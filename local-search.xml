<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>理解 C++ 内核</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<p>本节内容分为三部分：</p><ol><li>掌握进程虚拟地址空间区域划分</li><li>从指令角度掌握函数调用堆栈详细过程</li><li>从编译器角度理解C++代码的编译、链接</li></ol><p>通过了解底层基础，了解 C++ 的如何运行。</p><h2 id="1-掌握进程虚拟地址空间区域划分"><a href="#1-掌握进程虚拟地址空间区域划分" class="headerlink" title="1. 掌握进程虚拟地址空间区域划分"></a>1. 掌握进程虚拟地址空间区域划分</h2><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> gdata2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> gdata3;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata4 = <span class="hljs-number">11</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata5 = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata6;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">13</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> e = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> f;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上述代码，如何得知各个变量存储的位置？</p><h3 id="1-1-虚拟进程视图"><a href="#1-1-虚拟进程视图" class="headerlink" title="1.1 虚拟进程视图"></a>1.1 虚拟进程视图</h3><p>首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。</p><p>这里附上IBM公司关于<strong>虚拟</strong>的解释:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">它存在，你看得见，它是物理的<br>它存在，你看不见，它是透明的<br>它不存在，你看得见，它是虚拟的<br>它不存在，你看不见，它被删除<br></code></pre></td></tr></table></figure><p>这块空间的内容如下图所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png" alt="虚拟进程空间示例图 CN"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png" alt="虚拟进程空间示例图 EN"></p><blockquote><p>补充：<br>x86 32位体系下的4G虚拟地址空间：<br><strong>Linux默认3:1</strong>来分配 user space : kernal space；<br><strong>Windows默认2:2</strong>来分配 user space : kernal space。</p></blockquote><p>Linux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。</p><p>解释：<br>32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 <code>[0, 2^32]</code> ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。<br>64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 <code>[0, 2^64]</code> ，即 4GB * 4GB &#x3D; 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。</p><p><strong>为什么是 4G 内存：</strong></p><p>首先我们研究的体系是：<code>x86 32位Linux环境</code>：<br>Linux操作系统会给当前进程分配一个 <code>2^32</code> 大小的空间，那么，<code>2^32</code> 换算过来就是 4G 了。</p><h3 id="1-2-用户空间（User-Space）"><a href="#1-2-用户空间（User-Space）" class="headerlink" title="1.2 用户空间（User Space）"></a>1.2 用户空间（User Space）</h3><ol><li><p>保留区：<br> 128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 “NULL”，它便不会被引用了，从而避免了野指针。</p></li><li><p>指令段【.text】、只读数据段【.rodata】：<br> 指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。</p><blockquote><p>在C++中，不允许普通指针指向常量字符串，需要使用<code>const</code>：<br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png" alt="示例"></p></blockquote></li><li><p>数据段【.data】：<br> 存放程序中<strong>已初始化且不为0的全局变量或静态变量</strong>。</p></li><li><p>数据段【.bss】：<br> 存放程序中未初始化或者初始化为0的全局变量或静态变量。</p></li><li><p>堆【.heap】：<br> 存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。</p><ul><li>堆用于存放进程<code>运行时动态分配</code>的内存段，可动态扩张或缩减。</li><li>堆中内容是<code>匿名</code>的，无法通过名字进行访问，只能通过<code>指针</code>进行间接访问。</li><li>当进程调用<code>malloc(C)/new(C++)</code>等函数分配内存时，新分配的在堆上<code>动态扩张</code>；当调用<code>free(C)/delete(C++)</code>等函数释放内存时，被释放的内存从堆上<code>动态缩减</code></li><li>分配的堆内存时经过<code>字节对齐</code>的空间，以适合<code>原子操作</code>。</li><li><code>堆管理器</code>通过<code>链表</code>管理每个申请的内存块</li><li>由于堆内存块的申请与释放都是<code>无序</code>的，最终会产生许许多多<code>内存碎片</code>。</li><li>堆的末端由<code>break指针</code>标识，当堆管理器需要更多内存时，可通过<code>系统调用brk和sbrk</code>来<code>移动break指针</code>以扩张堆，一般情况下由系统自动调用。</li></ul></li><li><p>共享库【.dll、.so】：<br> 动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。</p></li><li><p>栈【.stack】：<br> 存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。</p><ul><li><p>栈中存放<code>非静态局部变量</code> <code>函数形参</code> <code>函数返回地址</code>等。</p></li><li><p>栈中内存空间由<code>编译器</code>（静态的）自动分配和释放，行为类似数据结构中的栈结构。</p><blockquote><p>主要用途：</p><ol><li>为函数内部声明的<strong>非静态局部变量</strong>提供存储空间</li><li>记录函数调用过程相关的维护性信息，称为栈帧（stack frame）</li><li>作为<code>临时存储区</code>，用于暂时存放<code>较长的算术表达式部分计算结果</code>，或者运行时调用alloca函数<code>动态分配</code>栈内内存</li></ol></blockquote></li><li><p>栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。</p></li><li><p>查看栈大小：<code>ulimit -s</code>可查看和设置<code>栈的最大值</code>，当程序使用的栈大小超过该值，会发生<code>segmentation fault</code>。</p></li><li><ul><li>栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。</li></ul></li></ul></li><li><p>命令行参数：<br> 保存传递给 main 函数的参数，比如 argc 和 argv。</p></li><li><p>环境变量：<br> 用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。</p></li></ol><h3 id="1-3-进程空间（Kernal-Space）"><a href="#1-3-进程空间（Kernal-Space）" class="headerlink" title="1.3 进程空间（Kernal Space）"></a>1.3 进程空间（Kernal Space）</h3><ol><li><p>内存直接访问区【ZONE_DMA】：<br> 16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。</p></li><li><p>常用区【ZONE_NORMAL】：<br> 892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。</p></li><li><p>高端内存区【ZONE_HIGHMEM】：<br> 128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。</p></li></ol><h3 id="1-4-最终解释"><a href="#1-4-最终解释" class="headerlink" title="1.4 最终解释"></a>1.4 最终解释</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png" alt="image.png"></p><blockquote><p>注意：<br>对于<code>a、b、c以及&#39;&#123;&#39;、&#39;&#125;&#39;</code>来说，是存储在<code>.text</code>指令段的，因为他们生成的都是&#x3D;&#x3D;指令&#x3D;&#x3D;。<br>例如：<br><code>int a = 12</code>：生成汇编指令如下：<code>mov dword ptr[a], 0Ch</code></p></blockquote><h3 id="1-5-好处"><a href="#1-5-好处" class="headerlink" title="1.5 好处"></a>1.5 好处</h3><p><code>数据</code>与<code>代码指令</code>分别开辟空间有以下好处：</p><ol><li>当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。<code>数据区</code>对于进程而言<code>可读可写</code>，<code>代码指令区</code>对于进程而言<code>只读</code>，</li><li>现代CPU一般<code>数据缓存</code>和<code>指令缓存</code>分离，故进程虚拟地址空间中数据与代码指令分离有助于提高<code>CPU缓存命中率</code>。</li><li>若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。</li></ol><p><strong>参考文章：</strong></p><blockquote><p>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1<br>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23<br>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09<br>【4】<a href="https://blog.csdn.net/m0_46308273/article/details/115818195">https://blog.csdn.net/m0_46308273/article/details/115818195</a><br>【5】<a href="https://blog.csdn.net/weixin_45437022/article/details/115409679">https://blog.csdn.net/weixin_45437022/article/details/115409679</a></p></blockquote><h2 id="2-从指令角度掌握函数调用堆栈详细过程"><a href="#2-从指令角度掌握函数调用堆栈详细过程" class="headerlink" title="2. 从指令角度掌握函数调用堆栈详细过程"></a>2. 从指令角度掌握函数调用堆栈详细过程</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png" alt="image.png"><br>栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。</p><p>堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：</p><ul><li>PUSH：将目标内存推入栈顶。</li><li>POP：从栈顶中移除目标。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png" alt="image.png"></p><p>当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 <strong>栈帧</strong> 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）</p><h3 id="2-1-ESP-和-EBP"><a href="#2-1-ESP-和-EBP" class="headerlink" title="2.1 ESP 和 EBP"></a>2.1 ESP 和 EBP</h3><p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p><p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：</p><ul><li>pop ebp;出栈 栈扩大4byte 因为ebp为32位</li><li>push ebp;入栈，栈减少4byte        </li><li>add esp, 0Ch；表示栈减小12byte</li><li>sub esp, 0Ch；表示栈扩大12byte</li></ul><p>ebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数</span><br><span class="hljs-comment">问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>temp = a + b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打断点，调试，查看反汇编：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 00007FF637EE23D0  push        rbp  </span><br><span class="hljs-comment">// 00007FF637EE23D2  push        rdi  </span><br><span class="hljs-comment">// 00007FF637EE23D3  sub         rsp,148h  </span><br><span class="hljs-comment">// 00007FF637EE23DA  lea         rbp,[rsp+20h]  </span><br><span class="hljs-comment">// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  </span><br><span class="hljs-comment">// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 00007FF637EE23EB  mov         dword ptr [a],0Ah  </span><br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 00007FF637EE23F2  mov         dword ptr [b],14h  </span><br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 00007FF637EE23F9  mov         edx,14h  </span><br><span class="hljs-comment">// 00007FF637EE23FE  mov         ecx,0Ah  </span><br><span class="hljs-comment">// 00007FF637EE2403  call        sum (07FF637EE11E5h)  </span><br><span class="hljs-comment">// 00007FF637EE2408  mov         dword ptr [ret],eax  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-comment">// 00007FF637EE240B  lea         rdx,[string &quot;ret:&quot; (07FF637EEAC24h)]  </span><br><span class="hljs-comment">// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  </span><br><span class="hljs-comment">// 00007FF637EE2419  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF637EE108Ch)  </span><br><span class="hljs-comment">// 00007FF637EE241E  mov         edx,dword ptr [ret]  </span><br><span class="hljs-comment">// 00007FF637EE2421  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1168h)]  </span><br><span class="hljs-comment">// 00007FF637EE242A  lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF637EE103Ch)]  </span><br><span class="hljs-comment">// 00007FF637EE2431  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1170h)]  </span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 00007FF637EE243A  xor         eax,eax  </span><br>&#125;<br><span class="hljs-comment">// 00007FF637EE243C  lea         rsp,[rbp+128h]  </span><br><span class="hljs-comment">// 00007FF637EE2443  pop         rdi  </span><br><span class="hljs-comment">// 00007FF637EE2444  pop         rbp  </span><br><span class="hljs-comment">// 00007FF637EE2445  ret </span><br></code></pre></td></tr></table></figure><h3 id="2-2-解析-main-函数"><a href="#2-2-解析-main-函数" class="headerlink" title="2.2  解析 main 函数"></a>2.2  解析 main 函数</h3><p><strong>1. <code>&#123;</code> 会进行入栈操作，<code>&#125;</code> 进行出栈操作</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png" alt="image.png"></p><p>上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。</p><p><strong>为什么这么做呢？</strong></p><p>因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。</p><p>在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</p><p><code>sub esp, 148h；</code>减去的值根据程序而定</p><p>之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</p><p>之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</p><p>在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png" alt="image.png"></p><p>所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数</p><p><strong>2. 函数内部：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png" alt="image.png"></p><ol><li><p><code>int a = 10;</code> 执行一条 mov 指令： </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [a],0Ah<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png" alt="image.png"></p></li><li><p> 同理 <code>int b = 20;</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [b],14h<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png" alt="image.png"></p></li><li><p><code>int ret = sum(a,b);</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Assmbly">00F81896 8B 45 EC             mov         eax,dword ptr [b] <br>00F81899 50                   push        eax     #压栈 b的值<br>00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  <br>00F8189D 51                   push        ecx     #压栈 a的值<br>00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call<br>00F818A3 83 C4 08             add         esp,8  <br>00F818A6 89 45 E0             mov         dword ptr [ret],eax <br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-sum-函数调用后"><a href="#2-3-sum-函数调用后" class="headerlink" title="2.3 sum 函数调用后"></a>2.3 sum 函数调用后</h3><p><strong>函数调用参数的压栈顺序:参数由右向左压入堆栈。</strong></p><p><strong>因此上面对应的是：</strong></p><p>先将b的值压入堆栈，再将a的值压入堆栈</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png" alt="image.png"><br><strong>执行call        sum (0F8108Ch)：</strong></p><p><strong>call函数首先会将下一行执行的地址入栈</strong>：假设下一行指令的地址位0x08124458</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png" alt="image.png"></p><p> <strong>第二步进入函数调用：sum</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png" alt="image.png"></p><p>函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈</p><p>第二步：将新的栈底ebp指向原来的栈顶esp</p><p>第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png" alt="image.png"></p><p>接着执行 <code>int temp = 0;</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         dword ptr [temp],0<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png" alt="image.png"></p><p>temp &#x3D; a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png" alt="image.png"></p><p>接着运行<code>return temp;</code>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         eax,dword ptr [temp]<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png" alt="image.png"></p><p>接着是<code>函数的右括号“&#125;”</code>：</p><p>（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。<br>（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。<br>（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png" alt="image.png"></p><h3 id="2-4-返回-main-函数后"><a href="#2-4-返回-main-函数后" class="headerlink" title="2.4 返回 main 函数后"></a>2.4 返回 main 函数后</h3><p>接着调用函数完毕，回到主函数：<br>利用了<code>PC寄存器</code>，使得程序知道退出sum后运行哪一条指令：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png" alt="image.png"></p><p><code>add         esp,8</code> ,将压栈的a b 形参空间回收</p><p><code>mov         dword ptr [ret],eax</code> 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png" alt="image.png"><br>最后<code>return 0</code>，程序结束</p><h3 id="2-5-栈溢出问题"><a href="#2-5-栈溢出问题" class="headerlink" title="2.5 栈溢出问题"></a>2.5 栈溢出问题</h3><p>出现栈内存溢出的常见原因有2个：</p><ol><li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li><li>局部静态变量体积太大。</li></ol><blockquote><p>第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。<br>检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。</p></blockquote><blockquote><p>   第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"> 即如果函数这样写：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span>* chdata = <span class="hljs-keyword">new</span>[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>   <span class="hljs-keyword">delete</span> []chdata;<br> &#125;<br>是不会出现这个错误的，而这样写则不行：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span> chdata[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br> &#125;<br>大多数情况下都会出现内存溢出的错误,<br></code></pre></td></tr></table></figure><p>解决办法大致说来也有两种：  </p><ol><li>增加栈内存的数目  </li><li>使用堆内存</li></ol><h2 id="3-从编译器角度理解-C-代码的编译、链接"><a href="#3-从编译器角度理解-C-代码的编译、链接" class="headerlink" title="3. 从编译器角度理解 C++ 代码的编译、链接"></a>3. 从编译器角度理解 C++ 代码的编译、链接</h2><p>整个编译过程分为两大步：</p><p>1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件</p><p>2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序</p><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><p>细分为3个阶段：</p><p><strong>1.1）编译预处理</strong></p><p>预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 <code>#include</code>），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 <code>#include</code> 包含的文件代码，进行 <code>#define</code> 宏定义的替换 ， 处理条件编译指令 （<code>#ifndef</code>、 <code>#ifdef</code>、 <code>#endif</code>）等。</p><p>预编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E main.c -o main.i<br></code></pre></td></tr></table></figure><p>主要规则如下：</p><ol><li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义；</li><li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>;</li><li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；</li><li>删除所有的注释：<code>//</code> 和 <code>/**/</code>；</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；</li><li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要使用它们。</li></ol><blockquote><p>注：<br><code>#pragma lib</code>、<code>pragma link</code><br>等命令是在链接过程处理的。</p></blockquote><p>预编译后得到的文件为：<code>.i</code>文件。</p><p><strong>1.2）编译</strong></p><p>通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</p><p>编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -S main.i -o main.s<br></code></pre></td></tr></table></figure><p>编译后得到的文件为：<code>.s</code>文件。</p><p><strong>1.3) 汇编</strong></p><p>汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。</p><p>目标文件由段组成，通常至少有两个段：</p><ol><li>.text：包换主要程序的指令。该段是可读和可执行的，一般不可写</li><li>.data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。</li></ol><p>汇编过程我们可以调用汇编器<code>as</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">as main.s -o main.o  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span>  <br>gcc -c main.s -o mian.o<br></code></pre></td></tr></table></figure><p>这个过程将.s文件转化成.o文件。</p><h3 id="3-2-链接过程"><a href="#3-2-链接过程" class="headerlink" title="3.2 链接过程"></a>3.2 链接过程</h3><p>链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。</p><p><strong>链接的时机</strong>：</p><ul><li>编译时，也就是在源代码被翻译成机器代码时</li><li>加载时，也就是在程序被加载器加载到存储器并执行时</li><li>运行时，由应用程序执行</li></ul><h4 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h4><p><strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p>为了构造可执行文件，<strong>链接器必须完成两个任务：符号解析，重定位</strong></p><ol><li><strong>符号解析：</strong> 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li><li><strong>重定位：</strong> 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li></ol><p>链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png" alt="image.png"></p><p>目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p><h4 id="2-目标文件"><a href="#2-目标文件" class="headerlink" title="2. 目标文件"></a>2. 目标文件</h4><p><strong>三种形式：</strong></p><ol><li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li><li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。</li></ol><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。</p><h4 id="3-可重定位目标文件"><a href="#3-可重定位目标文件" class="headerlink" title="3.  可重定位目标文件"></a>3.  可重定位目标文件</h4><p>一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png" alt="ELF可重定位目标文件"></p><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong> 已编译程序的机器代码。</li><li><strong>.rodata：</strong> 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li><li><strong>.data：</strong> 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li><li><strong>.bss：</strong> 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li><li><strong>.symtab：</strong> 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li><li><strong>.rel.text：</strong> 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li><li><strong>.rel.data：</strong> 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li><strong>.debug：</strong> 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li><li><strong>.line：</strong> 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li><li><strong>.strtab：</strong> 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li></ul><h4 id="4-符号和符号表"><a href="#4-符号和符号表" class="headerlink" title="4. 符号和符号表"></a>4. 符号和符号表</h4><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段</p><p>在链接器的上下文中，有三种不同的符号：</p><p>由m定义并能被其他模块引用的全局符号<br>由其他模块定义并被模块m引用的全局符号<br>只被模块m引用的本地符号</p><p>例如：</p><p><code>main.cpp</code> 内容 和 <code>sum.cpp</code> 内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> gdata;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-type">int</span> data = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = gdata;<br><span class="hljs-type">int</span> b = data;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>g++ -c</strong> 只编译不链接，只生成目标文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png" alt="image.png"></p><p> <strong>objdump -t main.o &#x2F;&#x2F; 输出目标文件的符号表：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png" alt="image.png"></p><ul><li>第一列：段内偏移；</li><li>第二列：符号作用域  : local &#x2F;global；</li><li>第三列：符号类型；</li><li>第四列：符号所在段（<em>UND</em>外部链接符号，未在本目标文件定义）；</li><li>第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；</li><li>第六列：符号名；</li></ul><p>其中 <code>main</code> 定义在 <code>.text</code></p><p>data 是全局变量，且初始化定义在 <code>.data</code> ,也就是 m 定义并能被其他模块引用的全局符号。<br>gdata 和 sum 函数是声明，因此是<em>UNG</em>，也就是由其他模块定义并被模块 m 引用的全局符号。</p><p>第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配</p><p>在 <code>sum.o</code> 中：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png" alt="image.png"></p><p>gdata 是出刷的全局变量 在 <code>.data</code> 中；sum 函数在 <code>.text</code> 中</p><p><code>readelf -h</code> 查看 elf 文件的头文件信息<br>可见目标文件的elf文件，其类型为REL(可重定位文件)。 </p><p><code>objdump -s</code> 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png" alt="image.png"></p><p>有调试信息的：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png" alt="image.png"></p><p>可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。</p><h4 id="5-符号解析"><a href="#5-符号解析" class="headerlink" title="5. 符号解析"></a>5. 符号解析</h4><p>链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（<em>UNG</em>）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）</p><p> <strong>链接器如何解析多重定义的全局符号：</strong></p><p>在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。<br>       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：</p><p>规则1：不允许有多个强符号。<br>规则2：如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><p><strong>链接器如何使用静态库来解析引用：</strong></p><p>在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。</p><blockquote><ol><li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。</li><li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。</li><li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li></ol></blockquote><p>这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。</p><p>另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在命令行上重复库。</p><h4 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6. 重定向"></a>6. 重定向</h4><p>一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位有两步组成：</p><ol><li><strong>重定位节和符号定义</strong>。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用</strong>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<code>重定位条目</code>的可重定位目标模块中的数据结构。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png" alt="image.png"></p><p>链接后：所有的符号都有虚拟地址</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png" alt="image.png"></p><p>汇编中，全局变量和函数都有了地址。</p><h4 id="7-可执行目标文件"><a href="#7-可执行目标文件" class="headerlink" title="7. 可执行目标文件"></a>7. 可执行目标文件</h4><p>可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<code>.text</code> 、<code>.rodata</code> 和 <code>.data</code> 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。</p><p>ELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 面向对象</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>本节分为 7 大类：</p><ol><li>类和对象、this 指针</li><li>构造函数和析构函数</li><li>深拷贝和浅拷贝</li><li>类和对象代码应用实践</li><li>构造函数的初始化列表</li><li>类的各种成员方法及区别</li><li>指向类成员的指针</li></ol><h2 id="1-类和对象、this-指针"><a href="#1-类和对象、this-指针" class="headerlink" title="1. 类和对象、this 指针"></a>1. 类和对象、this 指针</h2><p>C 语言是<strong>面向过程</strong>的，关注的是过程。分析出求解问题的步骤，通过函数调用<strong>逐步</strong>解决问题。</p><p>C++ 是基于<strong>面向对象</strong>的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的<strong>交互</strong>完成。</p><h3 id="1-类的引入"><a href="#1-类的引入" class="headerlink" title="1. 类的引入"></a>1. 类的引入</h3><p>C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetStudentInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* gender, <span class="hljs-type">int</span> age)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">strcpy</span>(_name, name);<br><span class="hljs-built_in">strcpy</span>(_gender, gender);<br>_age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStudentInfo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; _name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;gender = &quot;</span> &lt;&lt; _gender &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> _name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> _gender[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student s;<br>s.<span class="hljs-built_in">SetStudentInfo</span>(<span class="hljs-string">&quot;Peter&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">18</span>);<br>s.<span class="hljs-built_in">PrintStudentInfo</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png" alt="image.png"></p><p>上面结构体的定义，在 C++ 中更喜欢用<code>class</code>来代替。</p><h3 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h3><p>语法结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">className</span> &#123;<br> <span class="hljs-comment">// 类体：由成员函数和成员变量组成</span><br><br>&#125;; <span class="hljs-comment">// 要注意后面的分号</span><br></code></pre></td></tr></table></figure><ul><li><code>class</code>为定义类的关键字</li><li><code>ClassName</code>为类的名字</li><li><code>&#123;&#125;</code>中为类的主体</li><li>注意类定义结束时后面分号。</li></ul><p>类中的元素称为<strong>类的成员</strong>，类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>。 类中的函数称为<strong>类的方法</strong>或者<strong>成员函数</strong>。</p><p>类的两种定义方式：</p><ol><li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</li><li>声明放在.h文件中，类的定义放在<code>cpp</code>文件中。推荐使用！</li></ol><h3 id="3-类的访问限定符及封装"><a href="#3-类的访问限定符及封装" class="headerlink" title="3. 类的访问限定符及封装"></a>3. 类的访问限定符及封装</h3><ol><li><strong>访问限定符：</strong></li></ol><p><code>C++</code>实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。</p><p>访问限定符说明：</p><ol><li><code>public</code> 修饰的成员在类外可以直接被访问</li><li><code>protected</code> 和 <code>private</code> 修饰的成员在类外不能直接被访问(此处 <code>protected</code> 和 <code>private</code> 是类似的)</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li><li><code>class</code> 的默认访问权限为 <code>private</code>，<code>struct</code> 为 <code>public</code> (因为 <code>struct</code> 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</li></ol><blockquote><ul><li>问：C++ 中 <code>struct</code> 和 <code>class</code> 的区别是什么？</li><li>答：C++ 需要兼容 C 语言，所以 C++ 中 <code>struct</code> 可以当成结构体去使用。另外 C++ 中 <code>struct</code> 还可以用来定义类。 和 <code>class</code> 是定义类是一样的，区别是 <code>struct</code> 的成员默认访问方式是 <code>public</code>，<code>class</code> 的成员默认访问方式是 <code>private</code>。</li></ul></blockquote><ol start="2"><li><strong>封装</strong></li></ol><p>面向对象的三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p><p>在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。</p><blockquote><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p></blockquote><p>封装本质上是一种管理：</p><p>使用类数据和方法都封装到一下。 不想给别人看到的，使用 <code>protected</code> &#x2F; <code>private</code> 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p><h3 id="4-类的作用域"><a href="#4-类的作用域" class="headerlink" title="4. 类的作用域"></a>4. 类的作用域</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用<code>::</code>作用域解析符指明成员属于哪个类域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPersonInfo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> _name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> _gender[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-comment">// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::PrintPersonInfo</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;_name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;_gender&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-类的实例化"><a href="#5-类的实例化" class="headerlink" title="5. 类的实例化"></a>5. 类的实例化</h3><p><strong>用类类型创建对象的过程</strong>，称为类的实例化。</p><ol><li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。</li><li>一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。</li><li>做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li></ol><h3 id="6-类对象模型"><a href="#6-类对象模型" class="headerlink" title="6. 类对象模型"></a>6. 类对象模型</h3><p><strong>如何计算类对象的大小</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> _a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-comment">// 类中仅有成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 类中什么都没有---空类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A3</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sizeof</span>(A1) :<span class="hljs-number">4</span><br><span class="hljs-built_in">sizeof</span>(A2) :<span class="hljs-number">1</span><br><span class="hljs-built_in">sizeof</span>(A3) :<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结论：</p><p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 <strong>一个字节</strong> 来唯一标识这个类。</p><h3 id="7-this-指针"><a href="#7-this-指针" class="headerlink" title="7. this 指针"></a>7. this 指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span> </span>&#123;<br>_year = year;<br>_month = month;<br>_day = day;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year; <span class="hljs-comment">// 年</span><br><span class="hljs-type">int</span> _month; <span class="hljs-comment">// 月</span><br><span class="hljs-type">int</span> _day; <span class="hljs-comment">// 日</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Date d1, d2;<br><br>d1.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>d2.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>);<br><br>d1.<span class="hljs-built_in">Display</span>();<br>d2.<span class="hljs-built_in">Display</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述类，有这样的一个问题： <code>Date</code> 类中有 <code>SetDate</code> 与 <code>Display</code> 两个成员函数，函数体中没有关于不同对象的区分，那当 <code>s1</code> 调用 <code>SetDate</code> 函数时，该函数是如何知道应该设置 <code>s1</code> 对象，而不是设置 <code>s2</code> 对象呢？</p><p>C++ 中通过引入 <code>this</code> 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p><h3 id="8-this-指针特性"><a href="#8-this-指针特性" class="headerlink" title="8. this 指针特性"></a>8. this 指针特性</h3><ul><li><code>this</code>指针的类型：<code>类类型* const</code>。</li><li>只能在“成员函数”的内部使用。</li><li><code>this</code>指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给<code>this</code>形参。所以对象中不存储<code>this</code>指针。</li><li><code>this</code>指针是成员函数第一个隐含的指针形参，一般情况由编译器通过<code>ecx</code>寄存器自动传递，不需要用户传递。</li></ul><h2 id="2-构造函数和析构函数"><a href="#2-构造函数和析构函数" class="headerlink" title="2. 构造函数和析构函数"></a>2. 构造函数和析构函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h3><ul><li>因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。</li><li>C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。</li><li>构造函数没有返回值，名字与类名相同。</li></ul><p><strong>注意事项：</strong></p><ol><li>类的构造函数支持函数重载。</li><li>类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。</li><li>类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。</li><li>使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。</li><li>构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 <code>int a = 10;</code> 这是初始化 )，赋值是数据成员定义之后进行的( 像 <code>int b; b = 12;</code> 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> nn, <span class="hljs-type">double</span> dd, <span class="hljs-type">char</span> cc) <br>        : <span class="hljs-built_in">d</span>(dd), <span class="hljs-built_in">n</span>(nn), <span class="hljs-built_in">c</span>(cc) <br>    &#123;<br>        n = <span class="hljs-number">10</span>;<br>        d = <span class="hljs-number">3.4</span>;<br>        c = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>test.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// 运行结果：10 3.4 b</span><br><span class="hljs-comment">// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果</span><br></code></pre></td></tr></table></figure><ol start="6"><li>初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致</li><li>类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>&amp; nn, <span class="hljs-type">const</span> <span class="hljs-type">double</span> dd) <br>        : <span class="hljs-built_in">d</span>(dd), <span class="hljs-built_in">n</span>(nn)<br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>&amp; n;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> d;<br>&#125;;<br><br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(n, <span class="hljs-number">3.5</span>)</span></span>;<br>test.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// 运行结果：5 3.5</span><br></code></pre></td></tr></table></figure><h3 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2. 析构函数"></a>2. 析构函数</h3><ul><li>形式是构造函数名字前面加一个 “~”</li><li>析构函数只有一个没有重载</li><li>析构函数也没有形参</li><li>析构函数是在对象生命周期结束时自动调用的，它负责清理工作</li><li>与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用</li></ul><h2 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3. 深拷贝和浅拷贝"></a>3. 深拷贝和浅拷贝</h2><p>在了解拷贝前，我们需要先知道 <strong>拷贝构造函数</strong> 的本质</p><ul><li>拷贝构造本质上也是构造函数</li><li>参数是所在类的常引用的构造函数</li><li>类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ====== 浅拷贝示例代码 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> nn, <span class="hljs-type">double</span> dd) <br>        : <span class="hljs-built_in">n</span>(nn), <span class="hljs-built_in">d</span>(dd)<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <span class="hljs-comment">// 定义拷贝构造函数</span><br>        : <span class="hljs-built_in">n</span>(t.n), <span class="hljs-built_in">d</span>(t.d)<br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br><br><span class="hljs-comment">// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数</span><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>)</span></span>; <span class="hljs-comment">// 实例化一个对象</span><br><span class="hljs-function">Test <span class="hljs-title">test1</span><span class="hljs-params">(t)</span></span>;  <span class="hljs-comment">// 用对象t初始化另一个对象，调用拷贝构造函数</span><br>Test test2 = t; <span class="hljs-comment">// 通过重载的 &quot;=&quot; 初始化对象，调用拷贝构造函数</span><br>Test* test3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(t);  <span class="hljs-comment">// 调用拷贝构造函数初始化对象</span><br><span class="hljs-keyword">delete</span> test3;<br></code></pre></td></tr></table></figure><ul><li>浅拷贝方式对于一般的数据成员是”OK”的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是”OK”的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题</li><li>针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ====== 浅拷贝 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> n) <br>    : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(n))<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <br>        : <span class="hljs-built_in">p</span>(t.p)<br>    &#123; &#125;<br><br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(t)</span></span>;<br><span class="hljs-comment">// 程序运行出错，重复释放内存</span><br><br><span class="hljs-comment">// ====== 深拷贝 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(n))<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <br>        : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*t.p))<br>    &#123; &#125;<br><br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(t)</span></span>;<br><span class="hljs-comment">// 程序正常运行</span><br></code></pre></td></tr></table></figure><h3 id="1-浅拷贝和深拷贝原理"><a href="#1-浅拷贝和深拷贝原理" class="headerlink" title="1. 浅拷贝和深拷贝原理"></a>1. 浅拷贝和深拷贝原理</h3><p>拷贝就是 <strong>复制</strong>，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。</p><p>对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：</p><ul><li>第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。</li><li>第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。</li></ul><p>拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。</p><p><strong>总结</strong>：</p><ul><li><p><strong>浅拷贝</strong>：位拷贝，拷贝构造函数，赋值重载<br>  多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏</p></li><li><p><strong>深拷贝</strong>：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。</p></li></ul><p>简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><h3 id="2-浅拷贝和深拷贝实现"><a href="#2-浅拷贝和深拷贝实现" class="headerlink" title="2. 浅拷贝和深拷贝实现"></a>2. 浅拷贝和深拷贝实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// --- 浅拷贝实现 ---</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">Light</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br><span class="hljs-built_in">Light</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) : <span class="hljs-built_in">a</span>(A), <span class="hljs-built_in">b</span>(B) &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;b &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-function">Light <span class="hljs-title">obj1</span><span class="hljs-params">(a, b)</span></span>;<br>Light obj2 = obj1;<br><br>obj2.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png" alt="image.png"></p><p><strong>实现 String 类来了解 深拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// --- 深拷贝实现 ---</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-literal">nullptr</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; 默认构造函数:&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (str)<br>&#123;<br><span class="hljs-comment">// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，</span><br><span class="hljs-comment">// 直到碰到第一个字符串结束符&#x27;\0&#x27;为止，然后返回计数器值(长度不包含&#x27;\0&#x27;)</span><br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// strcpy把含有&#x27;\0&#x27;结束符的字符串复制到另一个地址空间</span><br><span class="hljs-built_in">strcpy</span>(data_, str);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">//new 数组类型 与delete []对应</span><br>*data_ = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造：&quot;</span> &lt;&lt; endl;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.data_) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(data_, str.data_);<br>&#125;<br><br><span class="hljs-comment">// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左</span><br>    <span class="hljs-comment">// 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败</span><br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;赋值重载：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">delete</span>[] data_;<br><br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.data_) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(data_, str.data_);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br><span class="hljs-comment">// 释放内存</span><br>~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] data_;<br>data_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* data_ = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>String s1;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;123&quot;</span>)</span></span>;<span class="hljs-comment">//默认构造函数</span><br>String s3 = s2;<span class="hljs-comment">//拷贝构造函数</span><br>String s4 = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-function">String <span class="hljs-title">s5</span><span class="hljs-params">(s4)</span></span>;<span class="hljs-comment">//拷贝构造函数   是构造过程发生</span><br>String s6;<br>s6 = s5;<span class="hljs-comment">//=重载  是赋值，左右两边的对象都已经存在</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类和对象代码应用实践"><a href="#4-类和对象代码应用实践" class="headerlink" title="4. 类和对象代码应用实践"></a>4. 类和对象代码应用实践</h2><p><strong>实现：循环队列</strong></p><p>当队列空时，条件就是 <code>front = rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png" alt="image.png"></p><p>由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 <code>(rear+1) %QueueSize == front</code> (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。</p><p>比如：QueueSize &#x3D; 5，当 front&#x3D;0，而 rear&#x3D;4, (4+1) %5 &#x3D; 0，所以此时队列满。再比如，front &#x3D; 2而rear &#x3D;1。(1 + 1) %5 &#x3D; 2，所以此时 队列也是满的。而对于下图, front &#x3D; 2而rear&#x3D; 0, (0+1) %5 &#x3D; 1，1!&#x3D;2,所以此时队列并没有满。</p><p>另外，当 <code>rear &gt; front</code> 时，此时队列的长度为 <code>rear—front</code>。但当rear &lt; front时，队列长度分为两段，一段是 <code>QueueSize-front</code>，另一段是0 + rear，加在一起，队列长度为 <code>rear-front + QueueSize</code></p><p>因此通用的计算队列长度公式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">(rear — front + QueueSize) % QueueSize<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>队空条件：front &#x3D;&#x3D; rear</li><li>队满条件：(rear+1) %QueueSize &#x3D;&#x3D; front</li><li>队列长度：(rear—front + QueueSize) % QueueSize</li></ul><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 初始化构造</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">20</span>) &#123;<br><span class="hljs-comment">// 创建队列</span><br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><span class="hljs-comment">// 初始化值</span><br>front_ = <span class="hljs-number">0</span>;<br>rear_ = <span class="hljs-number">0</span>;<br>size_ = size;<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">const</span> Queue* queue) &#123;<br><span class="hljs-comment">// 传值</span><br>size_ = queue-&gt;size_;<br>front_ = queue-&gt;front_;<br>rear_ = queue-&gt;rear_;<br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>queue_[i] = queue_[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 复制重构</span><br>Queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Queue&amp; q) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;q)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span> queue_;<br><span class="hljs-comment">// 重新赋值</span><br>size_ = q.size_;<br>front_ = q.front_;<br>rear_ = q.rear_;<br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>queue_[i] = q.queue_[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">Queue</span>() &#123;<br><span class="hljs-keyword">delete</span>[] queue_;<br>queue_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 队列方法：</span><br><span class="hljs-comment">// 1. push：放入元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">resize</span>();<br>&#125;<br><br><span class="hljs-comment">// 从队尾放置</span><br>queue_[rear_] = val;<br><span class="hljs-comment">// 计算下一个位置</span><br>rear_ = (rear_ + <span class="hljs-number">1</span>) % size_;<br>&#125;<br><br><span class="hljs-comment">// 2. 出队方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>front_ = (front_ + <span class="hljs-number">1</span>) % size_;<br>&#125;<br><br><span class="hljs-comment">// 4. 获取对头</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> queue_[front_];<br>&#125;<br><br><span class="hljs-comment">// 3. 判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> rear_ == front_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 私密方法：</span><br><span class="hljs-comment">// 1. 扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 扩容 2 倍</span><br><span class="hljs-type">int</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_ * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 拷贝值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>tmp[index] = queue_[i];<br>index++;<br>&#125;<br><br><span class="hljs-comment">// 清除原先数值</span><br><span class="hljs-keyword">delete</span> queue_;<br><span class="hljs-comment">// 重新赋值</span><br>queue_ = tmp;<br>front_ = <span class="hljs-number">0</span>;<br>rear_ = index++;<br>size_ *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (rear_ + <span class="hljs-number">1</span>) % size_ == front_;<br>&#125;<br><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 队列</span><br><span class="hljs-type">int</span>* queue_;<br><span class="hljs-comment">// 对头</span><br><span class="hljs-type">int</span> front_;<br><span class="hljs-comment">// 队尾</span><br><span class="hljs-type">int</span> rear_;<br><span class="hljs-comment">// 队列扩列大小</span><br><span class="hljs-type">int</span> size_;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建对象</span><br>Queue q1;<br>Queue q2;<br><br><span class="hljs-comment">// 放入元素</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>q1.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">20</span>; i &lt; <span class="hljs-number">40</span>; i++)<br>&#123;<br>q2.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>q1 = q2;<br><br><br><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">while</span> (!q1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q1.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q1.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-构造函数的初始化列表"><a href="#5-构造函数的初始化列表" class="headerlink" title="5. 构造函数的初始化列表"></a>5. 构造函数的初始化列表</h2><p>构造函数初始化列表的情况有三种：</p><ol><li>需要初始化的类的成员变量是对象的情况；</li><li>需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；</li><li>子类初始化父类的成员；</li></ol><p><strong>情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数</strong></p><p>如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyTest</span>() : <span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &#123;       <span class="hljs-comment">// 初始化值</span><br>cout &lt;&lt; <span class="hljs-string">&quot;MyTest&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Test test;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyTest t1;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。</p><p><strong>情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() :<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>) &#123;&#125;           <span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a;             <span class="hljs-comment">//const成员声明</span><br>&#125;;<br><br><span class="hljs-comment">// 或</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> _a) :<span class="hljs-built_in">a</span>(_a) &#123;&#125;      <span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>&amp; a;                 <span class="hljs-comment">//声明</span><br>&#125;<br></code></pre></td></tr></table></figure><p>**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Test</span> (<span class="hljs-type">int</span> x)&#123; int_x = x;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> int_x;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<span class="hljs-keyword">public</span> Test<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mytest</span>() ：<span class="hljs-built_in">Test</span>(<span class="hljs-number">110</span>) <span class="hljs-comment">//调用父类的构造函数</span><br>    &#123;<br>      <span class="hljs-comment">//Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用</span><br>    &#125;;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Mytest</span>();<br> p-&gt;<span class="hljs-built_in">show</span>();<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行顺序：</p><p>在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。</p><h2 id="6-类的各种成员方法及区别"><a href="#6-类的各种成员方法及区别" class="headerlink" title="6. 类的各种成员方法及区别"></a>6. 类的各种成员方法及区别</h2><p>C++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)<br>: <span class="hljs-built_in">year_</span>(year)<br>, <span class="hljs-built_in">month_</span>(month)<br>, <span class="hljs-built_in">day_</span>(day)<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;year：&quot;</span> &lt;&lt; year_ &lt;&lt; <span class="hljs-string">&quot; month：&quot;</span> &lt;&lt; month_ &lt;&lt; <span class="hljs-string">&quot; day：&quot;</span> &lt;&lt; day_ &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> year_;<br><span class="hljs-type">int</span> month_;<br><span class="hljs-type">int</span> day_;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">继承：a kind of，一种</span><br><span class="hljs-comment">组合：a part of，一部分</span><br><span class="hljs-comment">商品日期更像是商品的一部分，应该用组合的方式</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goods</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Goods</span>(<span class="hljs-type">int</span> id, string name, <span class="hljs-type">int</span> price, <span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)<br>: <span class="hljs-built_in">date_</span>(year, month, day)<br>, <span class="hljs-built_in">id_</span>(id)<br>, <span class="hljs-built_in">name_</span>(name)<br>, <span class="hljs-built_in">price_</span>(price)<br>&#123;<br>count_++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>date_.<span class="hljs-built_in">show</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;id：&quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; name：&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; price：&quot;</span> &lt;&lt; price_ &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span><span class="hljs-comment">//静态成员函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> count_;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>Date date_;<br><span class="hljs-type">int</span> id_;<br>string name_;<br><span class="hljs-type">int</span> price_;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count_;<span class="hljs-comment">//静态成员变量的声明</span><br>&#125;;<br><br><span class="hljs-type">int</span> Goods::count_ = <span class="hljs-number">0</span>;<span class="hljs-comment">//静态成员变量的初始化</span><br></code></pre></td></tr></table></figure><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h3><p>静态成员变量在类内声明，在类外定义初始化<br>静态成员变量可以用类引用，也可以通过对象引用</p><h3 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2.静态成员函数"></a>2.静态成员函数</h3><p>静态成员函数不能使用普通成员变量，能使用静态成员变量<br>静态成员函数可以通过类调用，也可以通过对象调用</p><h3 id="3-const-成员函数"><a href="#3-const-成员函数" class="headerlink" title="3. const 成员函数"></a>3. const 成员函数</h3><p>一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。<br>const 成员函数既能够被普通对象调用，也能被 const 对象调用</p><h2 id="7-指向类成员的指针"><a href="#7-指向类成员的指针" class="headerlink" title="7. 指向类成员的指针"></a>7. 指向类成员的指针</h2><p>成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。</p><h3 id="1-成员函数指针"><a href="#1-成员函数指针" class="headerlink" title="1. 成员函数指针"></a>1. 成员函数指针</h3><p>在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">成员函数返回类型 （类名::*指针名）（形参）= &amp;类名::成员函数名<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(string s) &#123;<br>name = s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string name;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;lisa&quot;</span>)</span></span>;<br><span class="hljs-comment">// 定义类长远函数指针并赋初始值</span><br><span class="hljs-built_in">void</span>(A::*memp)() = &amp;A::print;<br>(a.*memp)();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png" alt="image.png"></p><p>使用成员函数指着注意两点：</p><p>（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；<br>（2）为成员函数指针赋值时，需要显示使用 <code>&amp;</code> 运算符，不能直接将 “类名 <code>::</code> 成员函数名”赋给成员函数指针。</p><h3 id="2-数据成员指针"><a href="#2-数据成员指针" class="headerlink" title="2. 数据成员指针"></a>2. 数据成员指针</h3><p>一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：</p><ul><li>对象的首地址和该成员变量在对象之内的偏移量。</li><li>数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。</li></ul><p>数据成员指针的定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">成员类型 类名::*指针名=&amp;类名::成员名;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">average</span><span class="hljs-params">(Student* objs, <span class="hljs-type">int</span> Student::*pm, <span class="hljs-type">int</span> count)</span> </span>&#123;<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>result += objs[i].*pm;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(result) / count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student my[<span class="hljs-number">3</span>] = &#123; &#123;<span class="hljs-number">16</span>, <span class="hljs-number">86</span>&#125;, &#123;<span class="hljs-number">17</span>, <span class="hljs-number">80</span>&#125;, &#123;<span class="hljs-number">18</span>, <span class="hljs-number">58</span>&#125; &#125;;<br><br><span class="hljs-type">double</span> ageAver = <span class="hljs-built_in">average</span>(my, &amp;Student::age, <span class="hljs-number">3</span>);<br><span class="hljs-type">double</span> scoreAver = <span class="hljs-built_in">average</span>(my, &amp;Student::score, <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ageAver = &quot;</span> &lt;&lt; ageAver &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;scoreAver = &quot;</span> &lt;&lt; scoreAver &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png" alt="image.png"></p><p>使用数据成员指针时，需要注意以下几点：</p><p>（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。<br>（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 <code>average()</code> 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的<code>obj.*pm</code> 等同于 <code>*(int*)((char*)(&amp;obj)+pm)</code>，显然，这样书写可读性差，可移植性低且容易出错。<br>（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayClass</span>  &#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ArrayClass</span>()  &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>arr[i]=i;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用数据成员指针作为形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(ArrayClass&amp; arrObj,<span class="hljs-type">int</span> (ArrayClass::* pm)[<span class="hljs-number">5</span>])</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i) &#123;<br>cout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ArrayClass arrObj;<br><span class="hljs-built_in">printArray</span>(arrObj,&amp;ArrayClass::arr);<span class="hljs-comment">//编译出错，提示成员ArrayClass::arr不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。</p><p>要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayClass</span> &#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ArrayClass</span>() &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>arr[i]=i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ArrayClass&amp; arrObj)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用数据成员指针作为形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(ArrayClass&amp; arrObj,<span class="hljs-type">int</span> (ArrayClass::* pm)[<span class="hljs-number">5</span>])</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>cout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ArrayClass&amp; arrObj)</span> </span>&#123;<br><span class="hljs-built_in">printArray</span>(arrObj,&amp;ArrayClass::arr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ArrayClass arrObj;<br><span class="hljs-comment">//printArray(arrObj,&amp;ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问</span><br><span class="hljs-built_in">print</span>(arrObj); <span class="hljs-comment">//通过友元函数调用打印数组函数printArray()来访问私有成员</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 函数模板</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/04.C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/04.C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>本节分为四个部分：</p><ol><li>理解函数模板</li><li>理解类模板</li><li>实现 C++ STL 向量容器 vector</li><li>理解容器控件配置器 allocator</li></ol><h2 id="1-理解函数模板"><a href="#1-理解函数模板" class="headerlink" title="1. 理解函数模板"></a>1. 理解函数模板</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</p><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h3><p>面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = x;<br>x = y;<br>y = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-type">double</span> &amp; xr <span class="hljs-type">double</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。</p><p>能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。</p><p>程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。</p><p><strong>模板函数、模板的特例化和非模板函数的重载关系</strong>：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。</p><p><strong>模板代码是不能声明在.h，实现在.cpp</strong>，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 <code>#include</code></p><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p><p>在 C++ 中，模板分为函数模板和类模板两种。</p><ul><li>函数模板是用于生成函数；</li><li>类模板则是用于生成类的。</li></ul><p>函数模板的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">1</span>, <span class="hljs-keyword">class</span>类型参数<span class="hljs-number">2</span>, ...&gt;<br>返回值类型  模板名(形参表)<br>&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中的 class 关键字也可以用 typename 关键字替换</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> 类型参数<span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> 类型参数<span class="hljs-number">2</span>, ...&gt;<br></code></pre></td></tr></table></figure><p>函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp = x; <br>x = y; <br>y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>T 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp = x;<br>x = y;<br>y = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>, m = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 编译器自动生成 void Swap (int &amp;, int &amp;)函数</span><br><span class="hljs-built_in">Swap</span>(n, m);<br><br><span class="hljs-type">double</span> f = <span class="hljs-number">1.2</span>, g = <span class="hljs-number">3.4</span>;<br><span class="hljs-comment">// 编译器自动生成 void Swap (double &amp;, double &amp;)函数</span><br><span class="hljs-built_in">Swap</span>(f, g);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器在编译到 <code>Swap(n, m);</code> 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-type">int</span> &amp; x, <span class="hljs-type">int</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数可以匹配 <code>Swap(n, m);</code> 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 <code>Swap(n, m);</code> 编译成对自动生成的 Swap 函数的调用。</p><p>同理，编译器在编译到 <code>Swap(f, g);</code> 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp; x, <span class="hljs-type">double</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再将 <code>Swap(f, g);</code> 编译成对该 Swap 函数的调用。</p><p>编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。</p><p>编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">模板名&lt;实际类型参数<span class="hljs-number">1</span>, 实际类型参数<span class="hljs-number">2</span>, ...&gt;<br></code></pre></td></tr></table></figure><h2 id="2-理解类模板"><a href="#2-理解类模板" class="headerlink" title="2. 理解类模板"></a>2. 理解类模板</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>为了多快好省地定义出一批<strong>相似的类</strong>,可以定义「类模板」，然后<strong>由类模板生成不同的类</strong>。</p><p>类模板的定义形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">1</span>，<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">2</span>，...&gt; <span class="hljs-comment">//类型参数表</span><br><span class="hljs-keyword">class</span> 类模板名<br>&#123;<br>   成员函数和成员变量<br>&#125;;<br></code></pre></td></tr></table></figure><p>用类模板定义对象的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实参表);<br></code></pre></td></tr></table></figure><ul><li>类模板用于实现类所需数据的类型参数化</li><li>类模板在表示如数组、表、图等数据结构显得特别重要</li><li>这些数据结构的表示和算法不受所包含的元素类型的影响</li></ul><h3 id="2-类模板实现顺序栈"><a href="#2-类模板实现顺序栈" class="headerlink" title="2. 类模板实现顺序栈"></a>2. 类模板实现顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqStack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 构造函数初始化</span><br><span class="hljs-comment">// 构造和析构函数名不加&lt;T&gt; 其他出现模板的地方都加上类型参数列表</span><br><span class="hljs-built_in">SeqStack</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">PStack</span>(<span class="hljs-keyword">new</span> T[size])<br>, <span class="hljs-built_in">Top</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">Size</span>(size) &#123;<br><span class="hljs-comment">// 初始化生成的指令更少，效率更高。</span><br><span class="hljs-comment">// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符</span><br>&#125;;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-comment">// 初始化列表的方式初始化 size 和 top</span><br><span class="hljs-built_in">SeqStack</span>(<span class="hljs-type">const</span> SeqStack&lt;T&gt;&amp; stack)<br>: <span class="hljs-built_in">Top</span>(stack.Top)<br>, <span class="hljs-built_in">Size</span>(stack.Size) &#123;<br><span class="hljs-comment">// 重新设置栈</span><br>PStack = <span class="hljs-keyword">new</span> T[stack.Size];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>PStack[i] = stack.PStack[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 析构函数 释放内存</span><br>~<span class="hljs-built_in">SeqStack</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (PStack)<br>&#123;<br><span class="hljs-keyword">delete</span>[] PStack;<br>PStack = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 复制重载</span><br>SeqStack&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SeqStack&lt;T&gt;&amp; stack)<br>&#123;<br><span class="hljs-comment">// 判断是否相等</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;stack)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span>[] PStack;<br><br><span class="hljs-comment">// 重新赋值</span><br>Top = stack.Top;<br>Size = stack.Size;<br>PStack = <span class="hljs-keyword">new</span> T[stack.Size];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>PStack[i] = stack.PStack[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 共有方法</span><br><span class="hljs-comment">// 1. push 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">resize</span>();<br>&#125;<br>PStack[Top] = val;<br>Top++;<br>&#125;<br><br><span class="hljs-comment">// 2. pop 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Top--;<br>&#125;<br><br><span class="hljs-comment">// 3. top 方法</span><br><span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Stack is empty!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> PStack[Top - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> Top == Size;<br>&#125;<br><br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> Top == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 私有方法和数据</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>T* p = <span class="hljs-keyword">new</span> T[Size * <span class="hljs-number">2</span>];<br><span class="hljs-comment">// 将值赋值过去</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>p[i] = PStack[i];<br>&#125;<br><span class="hljs-comment">// 扩大</span><br>Size *= <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span> PStack;<br><span class="hljs-comment">// 重新赋值</span><br>PStack = p;<br>&#125;<br><br>T* PStack;<br><span class="hljs-type">int</span> Top;<br><span class="hljs-type">int</span> Size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SeqStack&lt;<span class="hljs-type">int</span>&gt; stack;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>stack.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; stack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>stack.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-实现-C-STL-向量容器-vector"><a href="#3-实现-C-STL-向量容器-vector" class="headerlink" title="3. 实现 C++ STL 向量容器 vector"></a>3. 实现 C++ STL 向量容器 vector</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png" alt="image.png"></p><p>vector 的本质是一个数组，在vector 中需要有三个指针：</p><ul><li><code>First</code>：指向数组的起始位置</li><li><code>Last</code>：指向已经存放的最后一个元素的下一个位置</li><li><code>End</code>：指向数组长度的末尾元素的下一个位置。</li></ul><p>vector 方法：</p><ul><li>数组的容量：<code>End-First</code></li><li>数组中存放的元素个数：<code>Last-First</code></li><li>数组是否为空：<code>First == Last</code></li><li>数组是否已满：<code>Last == End</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(<span class="hljs-keyword">new</span> T[size])<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 使用初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 获取容器长度</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 创建新容器</span><br>First = <span class="hljs-keyword">new</span> T[size];<br><span class="hljs-comment">// 获取数据长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>First[i] = rhs.First[i];<br>&#125;<br><span class="hljs-comment">// 重置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] First;<br>First = End = Last = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 清除</span><br><span class="hljs-keyword">delete</span>[] First;<br><br><span class="hljs-comment">// 重新计算并赋值</span><br><span class="hljs-comment">// 获取容器长度</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 创建新容器</span><br>First = <span class="hljs-keyword">new</span> T[size];<br><span class="hljs-comment">// 获取数据长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>First[i] = rhs.First[i];<br>&#125;<br><span class="hljs-comment">// 重置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 共有方法</span><br><span class="hljs-comment">// push_back 方法：容器添加内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">extend</span>();<br>&#125;<br><span class="hljs-comment">// 先给之以后，下次 push 则会递增内存</span><br>*Last++ = val;<br>&#125;<br><span class="hljs-comment">// pop_back 方法：容器删除内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>--Last;<br>&#125;<br><span class="hljs-comment">// back 方法：输出删除内容</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// full 方法：容器是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last == End;<br>&#125;<br><span class="hljs-comment">// empty 方法：容器是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last == First;<br>&#125;<br><span class="hljs-comment">// size 方法：获取内容厂区</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last - First;<br>&#125;<br><br><span class="hljs-comment">// 私有方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// vector 容器扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> size = End - First;<br>T* ptmp = <span class="hljs-keyword">new</span> T[size * <span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 遍历并转移</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>ptmp[i] = First[i];<br>&#125;<br><span class="hljs-comment">// 删除原先的</span><br><span class="hljs-keyword">delete</span>[] First;<br><br><span class="hljs-comment">// 重新覆盖</span><br>First = ptmp;<br>Last = First + size;<br>End = First + <span class="hljs-number">2</span> * size;<br>&#125;<br><br><span class="hljs-comment">// 私有数据</span><br><span class="hljs-keyword">private</span>:<br>T* First;<br>T* Last;<br>T* End;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t) <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl; <br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1;<br>Test t2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; std::endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png" alt="image.png"></p><p>问题：在我们实现的 <code>vector</code> 构造函数中，使用 <code>new T[size]</code>  ：它做了两件事情：</p><p>（1）开辟内存空间<br>（2）调用 T 类型的默认构造函数构造对象</p><p>其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。</p><p>同时：在实现 <code>pop_back(）</code> 时，存在内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> <span class="hljs-comment">// 从容器末尾删除元素</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>  --Last;<br>&#125;<br></code></pre></td></tr></table></figure><p> 仅仅将 Last 指针 –，并没有释放 Test 申请的资源。<strong>需要调用对象的析构函数</strong></p><h2 id="4-理解容器控件配置器-allocator"><a href="#4-理解容器控件配置器-allocator" class="headerlink" title="4. 理解容器控件配置器 allocator"></a>4. 理解容器控件配置器 allocator</h2><p><strong>通过 Win msvc 编译器的实现：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>: <span class="hljs-keyword">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;<span class="hljs-comment">// varying size array of values</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">using</span> _Mybase = _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;;<br><span class="hljs-keyword">using</span> _Alty = <span class="hljs-keyword">typename</span> _Mybase::_Alty;<br><span class="hljs-keyword">using</span> _Alty_traits = <span class="hljs-keyword">typename</span> _Mybase::_Alty_traits;<br>......<br></code></pre></td></tr></table></figure><p>系统的实现，除了数据类型外，还有一个<code>allocator</code>,它将开辟空间和构造对象分离开。  </p><p>而这，也就是空间配置器做的工作；</p><h3 id="1-容器的空间配置器"><a href="#1-容器的空间配置器" class="headerlink" title="1. 容器的空间配置器"></a>1. 容器的空间配置器</h3><p>空间配置器主要有四个功能：</p><ol><li>内存开辟 allocate（底层调用<code>malloc</code>）；</li><li>内存释放 deallocate（底层调用<code>free</code>）；</li><li>对象构造 construct（调用<code>构造函数</code>）；</li><li>对象析构 destroy（调用<code>析构函数</code>）；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-comment">// 负责内存的开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存的释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p) <span class="hljs-built_in">T</span>(val);<br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">(T* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ~T() 代表了 T 类型的析构函数</span><br> p-&gt;~<span class="hljs-built_in">T</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重新实现 vector：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 负责内存开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p)<span class="hljs-built_in">T</span>(val); <span class="hljs-comment">// 定位new</span><br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(T* p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p-&gt;~<span class="hljs-built_in">T</span>(); <span class="hljs-comment">// ~T()代表了T类型的析构函数</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 allocator 适配器重写 vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-comment">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 需要把内存开辟和对象构造分开处理</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(_allocator.<span class="hljs-built_in">allocate</span>(size))<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 通过初始化列表的方式，初始化数据</span><br>&#125;<br><br><span class="hljs-comment">// 拷贝函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~vector&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != Last; p++)<br>&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><span class="hljs-comment">// 重置 指针</span><br>First = Last = End = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 1. 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 3. 重新计算</span><br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 1. push_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">expand</span>();<br>&#125;<br><span class="hljs-comment">// 通过适配器添加内容</span><br>_allocator.<span class="hljs-built_in">construct</span>(Last, val);<br>Last++;<br>&#125;<br><span class="hljs-comment">// 2. pop_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>--Last;<br>_allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br><span class="hljs-comment">// 3. back 方法</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last == End; &#125;<br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> First == Last; &#125;<br><span class="hljs-comment">// 6. size 方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last - First; &#125;<br><br><span class="hljs-comment">// 私有属性和方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向数组起始的位置</span><br>T* First;<br><span class="hljs-comment">// 指向数组中有效元素的后继位置</span><br>T* Last;<br><span class="hljs-comment">// 指向数组空间的后继位置</span><br>T* End;<br><span class="hljs-comment">// 定义容器的空间配置器对象</span><br>Alloc _allocator;<br><br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取大小</span><br><span class="hljs-type">int</span> size = End - First;<br><span class="hljs-comment">// 配置 2 倍适配器空间</span><br>T* ptmp = _allocator.<span class="hljs-built_in">allocate</span>(size * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>_allocator.<span class="hljs-built_in">construct</span>(ptmp + i, First[i]);<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 重新赋值</span><br>First = ptmp;<br>Last = First + size;<br>End = First + size * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;)<br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1, t2;<br>cout &lt;&lt; <span class="hljs-string">&quot;1.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png" alt="image.png"></p><p>现在的效果就和 msvc 实现的 vector 相同了</p><h3 id="2-运算符重载与迭代器实现"><a href="#2-运算符重载与迭代器实现" class="headerlink" title="2. 运算符重载与迭代器实现"></a>2. 运算符重载与迭代器实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代器一般是现成容器的嵌套类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">iterator</span>(T* p = <span class="hljs-literal">nullptr</span>)<br>: _ptr(p)<br>&#123;<br><span class="hljs-comment">// 初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter)<br>: _ptr(iter._ptr)<br>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 重载函数合集</span><br><span class="hljs-comment">// 1. 前置 ++</span><br>iterator&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_ptr++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 后置 ++</span><br>iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>_ptr++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// 3. 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br><span class="hljs-comment">// 4. !=</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; iter) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _ptr != iter._ptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* _ptr;<br>&#125;;<br><br><br><span class="hljs-comment">//迭代器方法</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(First); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(Last); &#125;<br><br><span class="hljs-comment">//运算符重载[]</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;OutofRangeException&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> First[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-最终-vector-实现"><a href="#3-最终-vector-实现" class="headerlink" title="3. 最终 vector 实现"></a>3. 最终 vector 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 负责内存开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p)<span class="hljs-built_in">T</span>(val); <span class="hljs-comment">// 定位new</span><br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(T* p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p-&gt;~<span class="hljs-built_in">T</span>(); <span class="hljs-comment">// ~T()代表了T类型的析构函数</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 allocator 适配器重写 vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-comment">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 需要把内存开辟和对象构造分开处理</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(_allocator.<span class="hljs-built_in">allocate</span>(size))<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 通过初始化列表的方式，初始化数据</span><br>&#125;<br><br><span class="hljs-comment">// 拷贝函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~vector&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != Last; p++)<br>&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><span class="hljs-comment">// 重置 指针</span><br>First = Last = End = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 1. 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 3. 重新计算</span><br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//运算符重载[]</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>&#123;<br><span class="hljs-comment">// 判断索引位置</span><br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;OutofRangeException&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 返回索引值</span><br><span class="hljs-keyword">return</span> First[index];<br>&#125;<br><br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 1. push_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">expand</span>();<br>&#125;<br><span class="hljs-comment">// 通过适配器添加内容</span><br>_allocator.<span class="hljs-built_in">construct</span>(Last, val);<br>Last++;<br>&#125;<br><span class="hljs-comment">// 2. pop_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>--Last;<br>_allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br><span class="hljs-comment">// 3. back 方法</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last == End; &#125;<br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> First == Last; &#125;<br><span class="hljs-comment">// 6. size 方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last - First; &#125;<br><br><span class="hljs-comment">// 迭代器一般是现成容器的嵌套类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">iterator</span>(T* p = <span class="hljs-literal">nullptr</span>)<br>: _ptr(p)<br>&#123;<br><span class="hljs-comment">// 初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter)<br>: _ptr(iter._ptr)<br>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 重载函数合集</span><br><span class="hljs-comment">// 1. 前置 ++</span><br>iterator&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_ptr++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 后置 ++</span><br>iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>_ptr++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// 3. 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br><span class="hljs-comment">// 4. !=</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; iter) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _ptr != iter._ptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* _ptr;<br>&#125;;<br><span class="hljs-comment">//迭代器方法</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(First); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(Last); &#125;<br><br><br><span class="hljs-comment">// 私有属性和方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向数组起始的位置</span><br>T* First;<br><span class="hljs-comment">// 指向数组中有效元素的后继位置</span><br>T* Last;<br><span class="hljs-comment">// 指向数组空间的后继位置</span><br>T* End;<br><span class="hljs-comment">// 定义容器的空间配置器对象</span><br>Alloc _allocator;<br><br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取大小</span><br><span class="hljs-type">int</span> size = End - First;<br><span class="hljs-comment">// 配置 2 倍适配器空间</span><br>T* ptmp = _allocator.<span class="hljs-built_in">allocate</span>(size * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>_allocator.<span class="hljs-built_in">construct</span>(ptmp + i, First[i]);<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 重新赋值</span><br>First = ptmp;<br>Last = First + size;<br>End = First + size * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;)<br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1, t2;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-------------------------------&quot;</span> &lt;&lt; endl;<br>vector&lt;Test&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;it = &quot;</span> &lt;&lt; &amp;(*it) &lt;&lt; endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;iterator&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 基础精讲</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>本节分为 5 大类：</p><ol><li>形参带默认值的函数</li><li>内联函数inline</li><li>详解函数重载</li><li>const 深入应用</li><li>深入理解 C++ 的 new 和 delete</li></ol><h2 id="1-形参带默认值的函数"><a href="#1-形参带默认值的函数" class="headerlink" title="1. 形参带默认值的函数"></a>1. 形参带默认值的函数</h2><p>在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。</p><p><strong>注意事项：</strong></p><ol><li>在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span></span>; <span class="hljs-comment">//函数声明</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f)</span>  <span class="hljs-comment">//函数定义</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// ....  </span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>没有函数（原型）时，默认参数在函数定义时指定。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有 函数声明</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span>  <span class="hljs-comment">//函数定义</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</li></ol><p>就是说，<strong>函数声明时，必须按照从右向左的顺序，依次给与默认值。</strong></p><p>原因：</p><p>函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 <strong>从指令角度掌握函数调用堆栈详细过程。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3)</span></span>;         <span class="hljs-comment">// 错误, i3未指定默认值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">h</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 错误, i2未指定默认值</span><br></code></pre></td></tr></table></figure><p><strong>普通函数和形参带默认值函数对比：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b  = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>  temp = a + b;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br> <br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br> <br>  ret = <span class="hljs-built_in">sum</span>(a);<span class="hljs-comment">//b 使用默认值</span><br> <br>  ret = <span class="hljs-built_in">sum</span>();<span class="hljs-comment">//都使用默认值</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png" alt="image.png"></p><p>对比1，2 发现：</p><p>2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；</p><p>同理有3，使用默认值是：调用函数减少了 mov 指令。</p><h2 id="2-内联函数-inline"><a href="#2-内联函数-inline" class="headerlink" title="2. 内联函数 inline"></a>2. 内联函数 inline</h2><p><strong>特征：</strong></p><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明1（加 inline，建议使用）</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 声明2（不加 inline）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span> </span>&#123;<span class="hljs-comment">/****/</span>&#125;;<br><br><span class="hljs-comment">// 类内定义，隐式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;         <span class="hljs-comment">// 隐式内联</span><br>&#125;<br><br><span class="hljs-comment">// 类外定义，需要显式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;   <span class="hljs-comment">// 需要显式内联</span><br></code></pre></td></tr></table></figure><p><strong>编译器对 inline 函数的处理步骤：</strong></p><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><p><strong>内联函数与普通函数的区别？</strong></p><ol><li>内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理</li></ol><p>[[01.理解 C++ 内核]] 中的 <strong>从指令角度掌握函数调用堆栈详细过程</strong> 知道，在调用函数的过程中：</p><p>（1）将函数实数从右向左压栈<br>（2）call指令：<br>        将下一行要执行的代码地址入栈<br>        跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。</p><p>在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令</p><ol start="2"><li><p>内联函数不在生成相应的函数符号</p></li><li><p>inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。</p></li></ol><p>注意：</p><p>（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。</p><p><strong>优缺点：</strong></p><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="3-详解函数重载"><a href="#3-详解函数重载" class="headerlink" title="3. 详解函数重载"></a>3. 详解函数重载</h2><p><strong>函数重载</strong>：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。</p><p>（1）函数重载与函数返回值无关，因为在产生符号时没有返回值<br>（2） 函数重载需要在同一个作用域<br>（3）const 或者 volatile 的时候，是如何影响形参的</p><p><strong>C++ 支持函数重载，而 C 则不支持：</strong></p><p>编译器产生的函数符号规则不同：</p><ul><li>C++ 代码：函数符号包含了函数名和参数列表</li><li>C 代码：函数符号只包含了函数名。</li></ul><p><strong>注意事项：</strong></p><p>** <strong>函数重载需要在同一个作用域下</strong>。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;adf&quot;</span>, <span class="hljs-string">&quot;wew&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png" alt="image.png"></p><p>由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。</p><p><strong>const int 和 int 的重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png" alt="image.png"></p><p>原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png" alt="image.png"></p><p>const int 和 int 在编译器看来都是 int 类型 ，无法完成重载。</p><h3 id="3-1-C-和-C-语言如何相互调用"><a href="#3-1-C-和-C-语言如何相互调用" class="headerlink" title="3.1 C++ 和 C 语言如何相互调用"></a>3.1 C++ 和 C 语言如何相互调用</h3><p>由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten “C”{};</p><h4 id="1-C-调用-C"><a href="#1-C-调用-C" class="headerlink" title="1. C++ 调用 C"></a>1. C++ 调用 C</h4><p>对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字<code>extern &quot;C&quot;</code>，表示采用类c语言的方式解析函数符号。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// add.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ADD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ADD_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// add.c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 + 1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在例子中，<code>main.cpp</code> 为<code>c++</code> 代码，<code>add.c</code> 为 c 语言代码，当 c++ 编译器识别到<code>extern &quot;C&quot;</code> 关键字时，会去寻找 <code>_add_</code> 函数的实现而不是寻找类似<code>_int_add_int_int_</code> 这样带参数信息的函数实现。</p><h4 id="2-C-调用-C"><a href="#2-C-调用-C" class="headerlink" title="2. C 调用 C++"></a>2. C 调用 C++</h4><p>c 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：</p><ol><li>将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；</li><li>对外提供遵循类 c 语言规约的接口函数。例子如下所示：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// printNum.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// printNum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printNum.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; &lt;&lt; <span class="hljs-string">&quot;num is &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-built_in">printNum</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>通过将 <code>_cout_</code>函数封装为类 c 语言规约的接口函数，使得 <code>main.c</code> 中可以成功调用 c++ 函数 <code>_printNum_</code> 。值得注意的是，<code>main.c</code> 不可以直接引入 <code>printNum.h</code>，因为 c 语言不能识别 <code>extern &quot;C&quot;</code> 关键字。可以利用 c++ 预定义宏实现头文件的改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><ol><li>c 语言与 c++ 的相互调用可以通过 <code>extern &quot;C&quot;</code> 关键字实现</li><li>c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 <code>extern &quot;C&quot;</code></li><li>c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 <code>extern &quot;C&quot;</code> 声明的类 c 封装函数</li></ol><h2 id="4-const-深入应用"><a href="#4-const-深入应用" class="headerlink" title="4. const 深入应用"></a>4. const 深入应用</h2><p><strong>const 作用：</strong></p><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><p><strong>const 的指针与引用：</strong></p><ul><li>指针<ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul></li><li>引用<ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;                <span class="hljs-comment">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123; &#125;;        <span class="hljs-comment">// 初始化列表</span><br><br>    <span class="hljs-comment">// const可用于对重载函数的区分</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 普通成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对象</span><br>    A b;                        <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span><br>    <span class="hljs-type">const</span> A a;                  <span class="hljs-comment">// 常对象，只能调用常成员函数</span><br>    <span class="hljs-type">const</span> A *p = &amp;a;            <span class="hljs-comment">// 指针变量，指向常对象</span><br>    <span class="hljs-type">const</span> A &amp;q = a;             <span class="hljs-comment">// 指向常对象的引用</span><br><br>    <span class="hljs-comment">// 指针</span><br>    <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span>* p1 = greeting;                <span class="hljs-comment">// 指针变量，指向字符数组变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;          <span class="hljs-comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;          <span class="hljs-comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;    <span class="hljs-comment">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;           <span class="hljs-comment">// 传递过来的参数在函数内不可变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;         <span class="hljs-comment">// 参数指针所指内容为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;         <span class="hljs-comment">// 参数指针为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;          <span class="hljs-comment">// 引用参数在函数内为常量</span><br><br><span class="hljs-comment">// 函数返回值</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回一个常数</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure><p><strong>宏定义 <code>#define</code> 和 const 常量:</strong></p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h3 id="1-C-和-C-的-const-区别"><a href="#1-C-和-C-的-const-区别" class="headerlink" title="1. C++ 和 C 的 const 区别"></a>1. C++ 和 C 的 const 区别</h3><ul><li><strong>c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png" alt="image.png"></p><p>最终输出为：30、30、30</p><ul><li><strong>C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// const int b;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// a 常量，可以定义数组长度</span><br><span class="hljs-type">int</span> array[a] = &#123;&#125;;<br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png" alt="image.png"></p><p>原因：<strong>const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。</strong></p><h4 id="1-1-Debug-调试"><a href="#1-1-Debug-调试" class="headerlink" title="1.1 Debug 调试"></a>1.1 Debug 调试</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png" alt="image.png"></p><p>执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。</p><p><strong>如果不是立即数，则是常变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = b;<br><br><span class="hljs-comment">// 报错，a是常变量</span><br><span class="hljs-comment">//int array[a] = &#123;&#125;;</span><br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a); <span class="hljs-comment">// 30 30 30</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-const-与指针"><a href="#2-const-与指针" class="headerlink" title="2. const 与指针"></a>2. const 与指针</h3><p>const 修饰的量常出现的错误：</p><p><strong>（1）常量不能再作为左值</strong><br><strong>（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png" alt="image.png"></p><h4 id="2-1-const-和-一级指针"><a href="#2-1-const-和-一级指针" class="headerlink" title="2.1 const 和 一级指针"></a>2.1 const 和 一级指针</h4><p><strong>const 如果右边没有指针*，则const 是不参与类型的</strong></p><p><strong>C++的语言规范：就近原则 const 修饰的是离它最近的类型</strong></p><ol><li><code>const int* p</code>；离 const 最近的类型是 int，所以 const 修饰的是 <code>*p</code> ，所以 <code>*p</code> 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。</li><li><code>int const* p</code>；<code>*</code> 不是类型，离 const 最近的类型为 int，<code>*p</code> 无法修改，同（1）</li><li><code>int* const p</code>；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。</li><li><code>const int* const p</code>；不能修改 p 指向的地址和值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span> ;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<span class="hljs-comment">//p指向的地址的内容不能修改</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>重点：</p><p><strong>const 如果右边没有指针 <code>*</code>，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。</strong></p><p><strong>const 类型转化公式：</strong></p><ul><li><code>const int*</code>  &lt;&#x3D; <code>int*</code> 可以转换</li><li><code>int*</code> &lt;&#x3D; <code>const int*</code> 错误</li></ul></blockquote><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = <span class="hljs-literal">nullptr</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png"></p><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1= &amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;a;<span class="hljs-comment">// const int * &lt;= int *</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = &amp;a;<span class="hljs-comment">// int * &lt;= int *</span><br><span class="hljs-type">int</span> *p4 = p3;<span class="hljs-comment">//p3是int * 类型，因此没有问题</span><br></code></pre></td></tr></table></figure><h4 id="2-2-const-和-二级指针"><a href="#2-2-const-和-二级指针" class="headerlink" title="2.2 const 和 二级指针"></a>2.2 const 和 二级指针</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png" alt="image.png"></p><ul><li><code>const int** q</code>；离 const 最近的类型为 int，修饰的是 <code>**q</code>。</li><li><code>int* const* q</code>；离 const 最近的类型为 <code>int*</code>，修饰的是 <code>*q</code>。</li><li><code>int** const q</code>；离 const 最近的类型为 <code>int**</code>，修饰的是 <code>q</code>，同时 const 右侧没有 <code>*</code> ，q 是 <code>int**</code> 类型。</li></ul><p><strong>转化公式：</strong></p><ul><li><code>int**</code> &lt;&#x3D; <code>const int**</code> 错误</li><li><code>const int **</code> &lt;&#x3D; <code>int **</code> 错误</li></ul><p>const 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；</p><ul><li><code>int**</code> &lt;&#x3D; <code>int* const*</code> 是 const 和一级指针的结合，const 右边修饰的<code>*</code>  （等同于 <code>int *</code>  &lt;&#x3D; <code>const int *</code>  ）错误的</li><li><code>int* const*</code> &lt;&#x3D;<code>int**</code> （等同于<code>const int *</code> &lt;&#x3D; <code>int</code> ）可以的</li></ul><p><strong>要看 const 右边的 * 决定 const 修饰的是类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> ** q = &amp;p;<span class="hljs-comment">//error  </span><br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  const int * *q = &amp;p; 相当于（*）q 即 p的地址，赋值了一个const int * </span><br><span class="hljs-comment">  而p 是int *类型,把常量的地址泄露给普通的指针（p）</span><br><span class="hljs-comment">  修改 const int * p = &amp;a;</span><br><span class="hljs-comment">  */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h3><ol><li>引用是必须初始化的，指针可以不初始化。</li><li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。</li><li>定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。</li></ol><p>引用的错误用法  <code>int &amp;a = 10;</code> 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">int</span> &amp;b = a;<br> <br>  std::cout  &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br>  *p = <span class="hljs-number">20</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br> <br>  b = <span class="hljs-number">30</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png" alt="image.png"></p><p> <strong>反汇编：指针和引用没有区别</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png" alt="image.png"></p><p><code>lea eax,[a]</code>：将 a 的地址拷贝到寄存器 eax 中</p><p><code>mov dword ptr [p],eax</code>：将 eax 中的值拷贝到 p 中。</p><p><strong>反汇编中指针和引用拷贝也是没有区别。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png" alt="指针拷贝 - 1"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png" alt="指针拷贝 - 2"></p><p>对指针和引用赋值，都是一样的：获取地址，然后赋值。</p><h4 id="3-1-引用别名"><a href="#3-1-引用别名" class="headerlink" title="3.1 引用别名"></a>3.1 引用别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> array[<span class="hljs-number">5</span>] = &#123;&#125;;<br>  <span class="hljs-type">int</span> * p = array;<br>  <span class="hljs-built_in">int</span>(&amp;q)[<span class="hljs-number">5</span>] = array;<span class="hljs-comment">//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) </span><br> <br>  std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(array) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(q) &lt;&lt; std::endl;<span class="hljs-comment">//20 5 20</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png" alt="image.png"></p><p>关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 </p><p>站在宏观角度，引用也就是别名，所以不开辟看空间。</p><p>站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。</p><h3 id="4-左值引用"><a href="#4-左值引用" class="headerlink" title="4. 左值引用"></a>4. 左值引用</h3><p>左值：有内存地址，有名字，值可以修改；</p><p>如 <code>int a = 10;</code> <code>int &amp;b =a;</code></p><p><code>int &amp;c =10;</code> &#x2F;&#x2F;错误 20 是右值，20 &#x3D; 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；</p><p>上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = temp;<br></code></pre></td></tr></table></figure><p>根据上述分析，得出如下结论：</p><p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。</p><p>那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p><h3 id="5-右值引用"><a href="#5-右值引用" class="headerlink" title="5. 右值引用"></a>5. 右值引用</h3><p>C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p><ul><li>可以取地址的，有名字的，非临时的就是左值；</li><li>不能取地址的，没有名字的，临时的就是右值；</li></ul><p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。</p><p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。</p><ol><li><strong><code>int &amp;&amp;c = 10;</code>专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c &#x3D; 1;</strong></li></ol><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png" alt="image.png"></p><ol start="2"><li><strong>一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;e = a;<br></code></pre></td></tr></table></figure><h2 id="5-深入理解-C-的-new-和-delete"><a href="#5-深入理解-C-的-new-和-delete" class="headerlink" title="5. 深入理解 C++ 的 new 和 delete"></a>5. 深入理解 C++ 的 new 和 delete</h2><p><strong>New 的不同使用方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1 抛异常new</span><br>    <span class="hljs-type">int</span>* p1;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//分配内存并初始化</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e)<span class="hljs-comment">//判断是否抛异常</span><br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//2 不抛异常new</span><br>    <span class="hljs-type">int</span>* p2 = <span class="hljs-built_in">new</span> (std::nothrow)<span class="hljs-built_in">int</span>();<span class="hljs-comment">//不抛异常</span><br>    <span class="hljs-comment">//3 开辟常量内存</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">40</span>);<span class="hljs-comment">//开辟一个常量</span><br><br>    <span class="hljs-comment">//4 定位new</span><br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* p4 = <span class="hljs-built_in">new</span>(&amp;data) <span class="hljs-built_in">int</span>(<span class="hljs-number">50</span>);<span class="hljs-comment">//在指定地址内存初始化，本身并不开辟内存，只负责初始化</span><br>    <span class="hljs-keyword">delete</span> p1;<br>    <span class="hljs-keyword">delete</span> p2;<br>    <span class="hljs-keyword">delete</span> p3;<br>    <span class="hljs-keyword">delete</span> p4;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-malloc-与-new-的区别"><a href="#1-malloc-与-new-的区别" class="headerlink" title="1. malloc 与 new 的区别"></a>1. malloc 与 new 的区别</h4><ol><li>malloc 按字节开辟内存的；new 开辟内存时需要指定类型；</li><li>malloc 开辟内存返回的都是 <code>void *</code> ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。</li><li>malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。</li><li>malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。</li><li>malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要<code>[]</code>，而数组需要 <code>[]</code>并给上元素个数。</li></ol><h4 id="2-free-和-delete-的区别："><a href="#2-free-和-delete-的区别：" class="headerlink" title="2. free 和 delete 的区别："></a>2. free 和 delete 的区别：</h4><ol><li>free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  </li><li>delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  </li><li>delete 执行其实有两步，先调用析构，再释放；free 只有一步。</li></ol><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png" alt="image.png"></p><p><strong>new 与 delete 其本质也是函数的调用：运算符重载 new  delete</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span><br><span class="hljs-keyword">delete</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// new：</span><br><span class="hljs-comment">// 先调用 operator 开辟内存空间</span><br><span class="hljs-comment">// 然后调用对象的构造函数</span><br><span class="hljs-comment">// operator new 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// operator new[] 实现</span><br><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size)<br>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new[] addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// delete：</span><br><span class="hljs-comment">// 调用 p 指向对象的析构函数</span><br><span class="hljs-comment">// 再调用 operator delete 释放空间</span><br><span class="hljs-comment">// operator delete 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// operator delete[] 实现</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* ptr)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete[] addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">delete</span>[] p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png" alt="image.png"></p><h4 id="5-new-和delete-能够混用吗？"><a href="#5-new-和delete-能够混用吗？" class="headerlink" title="5. new 和delete 能够混用吗？"></a>5. new 和delete 能够混用吗？</h4><p><strong>C++为什么区分单个元素和数组的内存分配和释放呢？</strong></p><p><strong>情况1：int类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span>[]p;<br> <br><span class="hljs-type">int</span> *q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> q;<br></code></pre></td></tr></table></figure><p>能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。</p><p><strong>情况2：类类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>):<span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> ptr;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>单个元素与 <code>delete[]</code> 混用：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-keyword">delete</span>[]p1;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png" alt="报错程序"></p><p>程序崩溃。</p><ul><li><strong>数组与 delete 进行混用</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p2 = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">delete</span> p2;<br></code></pre></td></tr></table></figure><p>程序崩溃。</p><p><strong>分析：</strong></p><p>正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 <code>[]</code> 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 <code>0x100</code>；但是 new 完之后 p2 返回的地址是 <code>0x104</code> 地址，当我们执行 <code>delete[]</code> 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 <code>0x100</code> 开始的 4 字节也释放。</p><p>而 p2 出错是给用户返回的存对象开始的起始地址，<code>delete p2</code> 认为 p2 只是指向了一个对象，只将 <code>Test[0]</code> 对象析构，直接从 <code>0x104 free(p2)</code>，但底层实际是从 <code>0x100</code> 开辟的，因此崩溃。</p><p>而 p1 出错：p1 只是单个元素，从 <code>0x104</code> 开始开辟内存，但是 <code>delete[] p1</code>，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 <code>0x100</code> 释放)因此崩溃。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署流程</title>
    <link href="/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>主要使用技术合集：</strong></p><ol><li>Hexo 博客系统</li><li>Fluid 博客模板</li><li>Obsidian + Github Pages 部署。</li></ol><h2 id="1-Hexo-博客系统"><a href="#1-Hexo-博客系统" class="headerlink" title="1. Hexo 博客系统"></a>1. Hexo 博客系统</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <strong>Markdown</strong>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-1-安装需求"><a href="#1-1-安装需求" class="headerlink" title="1.1 安装需求"></a>1.1 安装需求</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li>Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li><li>Git</li></ul><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>全局安装后即可随时使用</p><h3 id="1-3-创建博客"><a href="#1-3-创建博客" class="headerlink" title="1.3 创建博客"></a>1.3 创建博客</h3><p>安装完成后，就可以在终端使用 <code>hexo</code> 指令了，可以使用以下指令创建一个 hexo 项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo init hexo-blog  <br><span class="hljs-built_in">cd</span> hexo-blog  <br>yarn install<br></code></pre></td></tr></table></figure><p>完成后项目目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.  <br>├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  <br>├── package.json  <br>├── scaffolds # 文章模板  <br>├── source  <br>|   ├── _drafts  <br>|   └── _posts # 你的 markdown 文章就需要存放在此目录下  <br>└── themes # 存放主题源码<br></code></pre></td></tr></table></figure><h2 id="2-配置-Fluid-主题"><a href="#2-配置-Fluid-主题" class="headerlink" title="2. 配置 Fluid 主题"></a>2. 配置 Fluid 主题</h2><ol><li>NPM 安装</li><li>源码安装</li></ol><h3 id="2-1-NPM-安装"><a href="#2-1-NPM-安装" class="headerlink" title="2.1 NPM 安装"></a>2.1 NPM 安装</h3><p>以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，使用 npm 安装只需要执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">yarn add hexo-theme-fluid  <br># 或者  <br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p><h3 id="2-2-源码安装"><a href="#2-2-源码安装" class="headerlink" title="2.2 源码安装"></a>2.2 源码安装</h3><p>源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。</p><p>仍然以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，在项目的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Releases</a> 页面中下载源码文件：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png"></p><p>下载解压后，在 <code>themes</code> 目录下创建一个 <code>fluid</code> 目录，将源码复制到该目录下，如下：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png" alt="image.png"></p><h3 id="2-3-应用主题"><a href="#2-3-应用主题" class="headerlink" title="2.3 应用主题"></a>2.3 应用主题</h3><p>当你安装成功后，需要在 <code>_config.yml</code> 中将使用的主题设置为你下载好的主题，找到 <code>theme</code> 配置项，将其修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions  </span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/  </span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/  </span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="2-4-配置第三方主题"><a href="#2-4-配置第三方主题" class="headerlink" title="2.4 配置第三方主题"></a>2.4 配置第三方主题</h3><p>如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 <code>_config.fluid.yml</code> 文件修改相关配置；</p><p>如果你是以源码方式安装的主题，就不需要创建 <code>_config.fluid.yml</code> 文件了，只需要修改 <code>/themes/fluid/_config.yml</code> 文件中的配置就可以了。</p><blockquote><p>注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档</p></blockquote><h2 id="3-部署-Github-Pages"><a href="#3-部署-Github-Pages" class="headerlink" title="3. 部署 Github Pages"></a>3. 部署 Github Pages</h2><p>然后在 Github 中创建一个新项目仓库，名称必须为 <code>&lt;你的github用户名&gt;.github.io</code>，创建完成后按照指引将你的博客代码上传到 github。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png" alt="image.png"></p><h3 id="3-1-开启-Github-Pages"><a href="#3-1-开启-Github-Pages" class="headerlink" title="3.1 开启 Github Pages"></a>3.1 开启 Github Pages</h3><p>在执行这一步之前，先创建一个没有任何代码的新分支，命名为 <code>gh-pages</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b gh-pages  <br>rm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  <br>git push --set-upstream origin release # 上传 release 分支<br></code></pre></td></tr></table></figure><p>在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 <code>gh-pages</code> 分支：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png" alt="image.png"></p><p>这就意为这你在 <code>gh-pages</code> 上传的任何 html 都可以使用 <code>&lt;你的github用户名&gt;.github.io</code> 这个域名来访问了。</p><p>我们切回 <code>master</code> 分支，之后执行 <code>yarn build</code> 将生成的 <code>public</code> 目录下的文件复制一份，然后重新切回 <code>gh-pages</code> 分支，将刚才复制的内容粘贴到 <code>gh-pages</code> 分支下，并上传代码。如果没有操作失误的话，访问 <code>&lt;你的github用户名&gt;.github.io</code> 即可看到你的博客了。</p><h3 id="3-2-Github-Action-自动部署"><a href="#3-2-Github-Action-自动部署" class="headerlink" title="3.2 Github Action 自动部署"></a>3.2 Github Action 自动部署</h3><p>使用 Github Action 来帮我们做自动化部署。</p><p>Github Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。</p><p>关于 Github Action，详细教程可以查看 <a href="https://docs.github.com/cn/actions">官方文档</a>。按照文档中所描述的，只要我们在代码中添加一层 <code>.github/workflows</code> 目录，并且在目录下创建一个 <code>yml</code> 文件来描述具体的行为，就可以实现开启 Github Action。</p><p>如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 <code>.github/workflows/blog-deploy.yml</code> 文件中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">16.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;16&quot;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br></code></pre></td></tr></table></figure><p>保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png" alt="image.png"></p><p>但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 <a href="https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context">secrets 上下文</a>，即 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code> 这里。</p><p><code>$&#123;&#123; xxx &#125;&#125;</code> 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 <code>secrets.ACCESS_TOKEN</code> 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。</p><p>首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 <code>Setting</code>，进入设置后选择 <code>Developer settings</code>，再选择 <code>Persona access token</code> 就可以看到它了：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png" alt="image.png"></p><p>点击右上角的 <code>Generate new token</code> 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 <code>repo</code> 和 <code>workflow</code> 权限，并将 <code>Expiration</code> 过期时间选为 <code>No expiration</code>：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png" alt="image.png"></p><blockquote><p>这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！</p></blockquote><p>点击 <code>Generate token</code> 按钮后，就会生成一个 <code>ghp</code> 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png" alt="image.png"></p><p>复制该 token 后，进入到博客仓库的设置中，选择 <code>Secrets - Actions</code>，点击 <code>New repository secret</code> 按钮生成一个密钥信息：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png" alt="image.png"></p><p>我们将密钥名称写为 <code>ACCESS_TOKEN</code>，值填入刚才复制的 Github token。</p><blockquote><p>这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 <code>secret</code> 上下文对象所获取到。</p></blockquote><p>至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>Blog</tag>
      
      <tag>Obdidian</tag>
      
      <tag>Github Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
