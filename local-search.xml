<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>11.C++ 多线程编程</title>
    <link href="/2023/08/22/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/11.C++%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/08/22/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/11.C++%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本节分为五部分：</p><ul><li>C++ 11 的 thread 多线程类</li><li>线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁</li><li>线程间同步通信 - 生产者消费者模型</li><li>再谈 lock_guard 和 unique_lock</li><li>基于 CAS 操作的 atomic 原子类型</li></ul><p><strong>什么是多线程？</strong></p><p><strong>多线程（multithreading）</strong>：是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p><p>在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。</p><p><strong>进程与线程：</strong></p><p>进程是正在运行的程序的实例，而线程是是进程中的实际运作单位。</p><p>线程是操作系统能够进行<strong>运算调度的最小单位</strong>。被包含在进程之中，是<strong>进程的实际运作单位</strong>。一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发执行多个线程，每个线程会执行不同的任务。</p><p><strong>区别：</strong></p><ul><li>一个程序有且只有一个进程，但可以拥有至少一个的线程。</li><li>不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221613179.png" alt="image.png"></p><h2 id="1-C-11-的-thread-多线程类"><a href="#1-C-11-的-thread-多线程类" class="headerlink" title="1. C++ 11 的 thread 多线程类"></a>1. C++ 11 的 thread 多线程类</h2><p>C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是<code>&lt;atomic&gt;</code> ,<code>&lt;thread&gt;</code>,<code>&lt;mutex&gt;</code>,<code>&lt;condition_variable&gt;</code> 和 <code>&lt;future&gt;</code>。</p><ol><li><code>&lt;atomic&gt;</code>：该头文件主要声明两个类：<ul><li><code>std::atomic</code></li><li><code>std::atomic_flag</code><br> 另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li></ul></li><li><code>&lt;thread&gt;</code>：该头文件主要声明一个类：<ul><li><code>std::thread</code></li><li>另外 <code>std::this_thread</code> 命名空间也在该头文件中。</li></ul></li><li><code>&lt;mutex&gt;</code>：该头文件主要声明了与互斥量（mutex）相关的类：<ul><li><code>std::mutex</code></li><li><code>std::lock_guard</code></li><li><code>std::unique_lock</code><br> 以及其他的类型和函数。</li></ul></li><li><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类：<ul><li><code>std::condition_variable</code></li><li><code>std::condition_varible_any</code></li></ul></li><li><code>&lt;future&gt;</code>：该头文件主要声明了两个 Provider 类和 两个 Futrue 类：<ul><li><code>std::promise</code>：Provider 类</li><li><code>std::package_task</code>：Provider 类</li><li><code>std::future</code>：Futrue 类</li><li><code>std::shared_futrue</code>：Futrue 类<br> 另外还有一些与之相关的类型和函数：</li><li><code>std::async()</code> 函数声明在该文件中。</li></ul></li></ol><h3 id="1-开启和关闭线程"><a href="#1-开启和关闭线程" class="headerlink" title="1. 开启和关闭线程"></a>1. 开启和关闭线程</h3><p>在<strong>语言级别</strong>，一般调用 std 名称空间的 thread 类来启动一个线程。 </p><p>其对应操作系统层次的一下系统调用：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">windows： createThread<br>linux：   pthread_create<br></code></pre></td></tr></table></figure><p>以下是 thread 类的一个构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread</span> <span class="hljs-params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>可以看到，其需要一个<strong>线程函数（也可以是类对象和 lambda 表达式）以及这个函数所需要传入的参数</strong>。</p><ol><li><strong>引入头文件：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>创建线程对象：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle1</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle2</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread2!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">3</span>)</span></span>;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;main thread done&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><p>主线程运行完成后，查看如果当前进程还有未运行完成的子线程，进程就会异常终止。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221632970.png" alt="image.png"></p><p>线程除了站在我们角度上的以名字区分，它还有一个属于自己的 id！通过 <code>std::thread::get_id()</code> 便可以获取到该成员对象线程的 id。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;t1 thread: ID = &quot;</span> &lt;&lt; t1.<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>而在线程函数中通过 <code>std::this_thread::get_id()</code> 获取线程 id。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;Inside t2 thread: ID = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221643499.png" alt="image.png"></p><ol start="3"><li><strong>终止子线程：</strong></li></ol><p>**t.join()**：创建线程执行线程函数，调用该函数会阻塞当前线程，直到线程执行完 join 才返回；等待t线程结束，当前线程继续往下运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle1</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle2</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread2!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">3</span>)</span></span>;<br><br><span class="hljs-comment">// 终止</span><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;main thread done&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221638021.png" alt="image.png"></p><p>**t.detach()**：detach 调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的 <code>std::thread</code> 对象失去对目标线程的关联，无法再通过 <code>std::thread</code> 对象取得该线程的控制权，由操作系统负责回收资源；主线程结束，整个进程结束，所有子线程都自动结束了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle1</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle2</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread2!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">3</span>)</span></span>;<br><br><span class="hljs-comment">// 终止</span><br>t1.<span class="hljs-built_in">detach</span>();<br>t2.<span class="hljs-built_in">detach</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;main thread done&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221639317.png" alt="image.png"></p><p><strong>线程如何结束：</strong></p><ol><li>线程函数返回（推荐）</li><li>调用 ExitThread 函数，线程自行撤销</li><li>同一进程或者另一个进程中调用 TerminateThread 函数</li><li>ExitProcess 和 TerminateProcess 函数可以终止线程进行</li></ol><h2 id="2-线程间互斥-mutex-互斥锁和-lock-guard-自动释放锁"><a href="#2-线程间互斥-mutex-互斥锁和-lock-guard-自动释放锁" class="headerlink" title="2. 线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁"></a>2. 线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁</h2><p>Mutex 又称互斥量，C++ 11 中与 Mutex 相关的类（包括锁类型）和函数都声明在 <code>&lt;mutex&gt;</code> 头文件中，所以使用 <code>std::mutex</code>，就必须包含 <code>&lt;mutex&gt;</code> 头文件。</p><h3 id="1-头文件介绍"><a href="#1-头文件介绍" class="headerlink" title="1. &lt;mutex&gt; 头文件介绍"></a>1. <code>&lt;mutex&gt;</code> 头文件介绍</h3><ul><li><p><strong>Mutex 系列类（四种）：</strong></p><ol><li><code>std::mutex</code>：最基本的 Mutex 类</li><li><code>std::recursive_mutex</code>：递归 Mutex 类</li><li><code>std::time_mutex</code>：定时 Mutex 类</li><li><code>std::recursive_timed_mutex</code>：定时递归 Mutex 类</li></ol></li><li><p><strong>Lock 类（两种）：</strong></p><ol><li><code>std::lock_guard</code>：与 Mutex RAII 相关，方便线程对互斥量上锁。</li><li><code>std::unique_lock</code>：与 Mutex RAII 相关，方便线程对互斥量上锁，但是提供了更好的上锁和解锁控制。</li></ol></li><li><p><strong>其他类型：</strong></p><ol><li><code>std::once_flag</code></li><li><code>std::adopt_lock_t</code></li><li><code>std::defer_lock_t</code></li><li><code>std::try_to_lock_t</code></li></ol></li><li><p><strong>函数：</strong></p><ol><li><code>std::try_lock</code>：尝试同时对多个互斥量上锁</li><li><code>std::lock</code>：可以同时对多个互斥量上锁</li><li><code>std::call_once</code>：如果多个线程需要同时调用某个函数，<code>call_once</code> 可以保证多个线程对该函数只调用一次。</li></ol></li></ul><h3 id="2-std-mutex-介绍"><a href="#2-std-mutex-介绍" class="headerlink" title="2. std::mutex 介绍"></a>2. <code>std::mutex</code> 介绍</h3><p>下面以 <code>std::mutex</code> 为例介绍 C++ 11 中的互斥量用法。</p><p><code>std::mutex</code> 是 C++ 11 中最基本的互斥量，<code>std::mutex</code> 对象提供了独占所有权的特性——即不支持递归地对 <code>std::mutex</code> 对象上锁，而 <code>std::recursive_lock</code> 则可以递归地对互斥量对象上锁。</p><p><code>std::mutex</code> 成员函数：</p><ul><li><strong>构造函数</strong>：<code>std::mutex</code> 不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 <strong>unlocked 状态</strong>的</li><li>**lock()**：调用线程将锁住该互斥量。线程调用该函数会发生一下三种情况：<ol><li>如果该互斥里昂当前没有被锁住，则调用线程将该互斥量舵主，知道调用了 unlock 志强，该线程一直拥有该锁。</li><li>如果当前互斥被其他线程锁住，则当前的调用线程被阻塞。</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(<strong>deadlock</strong>)。</li></ol></li><li>**unlock()**：解锁，释放互斥量的所有权。</li><li>**try_lock()**：尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面三种情况：<ol><li>如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</li><li>如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(<strong>deadlock</strong>)。</li></ol></li></ul><p>为了保证 <code>lock()</code> 和 <code>unlock()</code> 对应使用，一般不直接使用 mutex，而是和 <code>lock_guard</code>、<code>unique_lock</code> 一起使用。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>在多线程环境中运行的代码段，需要考虑是否存在竞态条件，如果存在竞态条件，就是说该代码段不是线程安全的，不能直接运行在多线程环境当中，对于这样的代码段，被称之为：临界区资源，对于临界区资源，多线程环境下需要保证它以原子操作执行，要保证临界区的原子操作，就需要用到线程间的互斥操作-锁机制，thread 类库还提供了更轻量级的基于 CAS 操作的原子操作类。</p><ul><li><strong>无锁时：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span><span class="hljs-comment">//C++11线程库提供的原子类</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span><span class="hljs-comment">//C++线程类库的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br> <br><span class="hljs-type">int</span> ticketCount = <span class="hljs-number">1</span>;<br> <br><span class="hljs-comment">//线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sumTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//每个线程给count加10次</span><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">40</span>; ++i)<br>  &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;窗口:&quot;</span> &lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;卖出第:&quot;</span> &lt;&lt; ticketCount &lt;&lt; <span class="hljs-string">&quot; 张票!&quot;</span> &lt;&lt; endl;<br>ticketCount++;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>  &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 开启线程</span><br>list&lt;std::thread&gt; tlist;<br><span class="hljs-comment">// 开启三个窗口</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>&#123;<br>tlist.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(sellTickets, i));<br>&#125;<br><br><span class="hljs-comment">// foreach 遍历终止线程</span><br><span class="hljs-keyword">for</span> (std::thread&amp; t : tlist)<br>&#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br> <br>​<br></code></pre></td></tr></table></figure><p>多线程同时对 ticketCount 进行操作，并不能保证同时只有一个线程对 ticketCount 执行 <code>++</code> 操作。最后的的结果不一定是100；</p><ul><li><strong>有锁操作：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 全局的一把互斥锁</span><br>std::mutex mtx; <br><br><span class="hljs-comment">// 数量</span><br><span class="hljs-type">int</span> ticketCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 模拟买票的线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sellTickets</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">40</span> ; i++)<br>&#123;<br>&#123;<br><span class="hljs-comment">// 保证所有线程都能释放锁，防止死锁问题的发生 scoped_ptr</span><br><span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-comment">// 临界区代码段  =&gt;  原子操作 =&gt; 线程间互斥操作了 =&gt; mutex</span><br>cout &lt;&lt; <span class="hljs-string">&quot;窗口:&quot;</span> &lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;卖出第:&quot;</span> &lt;&lt; ticketCount &lt;&lt; <span class="hljs-string">&quot; 张票!&quot;</span> &lt;&lt; endl;<br>ticketCount++;<br>&#125;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 开启线程</span><br>list&lt;std::thread&gt; tlist;<br><span class="hljs-comment">// 开启三个窗口</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>&#123;<br>tlist.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(sellTickets, i));<br>&#125;<br><br><span class="hljs-comment">// foreach 遍历终止线程</span><br><span class="hljs-keyword">for</span> (std::thread&amp; t : tlist)<br>&#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对 <code>count++</code> 操作上锁，保证一次只有一个线程能对其操作，结果是 120。</p><h2 id="3-线程间同步通信-生产者消费者模型"><a href="#3-线程间同步通信-生产者消费者模型" class="headerlink" title="3. 线程间同步通信 - 生产者消费者模型"></a>3. 线程间同步通信 - 生产者消费者模型</h2><p>多线程在运行过程中，各个线程都是随着 OS 的调度算法，占用 CPU 时间片来执行指令做事情，每个线程的运行完全没有顺序可言。但是在某些应用场景下，一个线程需要等待另外一个线程的运行结果，才能继续往下执行，这就需要涉及线程之间的同步通信机制。</p><p>线程间同步通信最典型的例子就是<strong>生产者-消费者模型</strong>，生产者线程生产出产品以后，会通知消费者线程去消费产品；如果消费者线程去消费产品，发现还没有产品生产出来，它需要通知生产者线程赶快生产产品，等生产者线程生产出产品以后，消费者线程才能继续往下执行。</p><p>C++ 11 线程库提供的条件变量 <code>condition_variable</code>，就是 Linux 平台下的 Condition Variable 机制，用于解决线程间的同步通信问题，下面通过代码演示一个生产者-消费者线程模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>           <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>             <span class="hljs-comment">//std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>              <span class="hljs-comment">//std::mutex, std::unique_lock</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span> <span class="hljs-comment">//std::condition_variable</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义互斥锁(条件变量需要和互斥锁一起使用)</span><br>std::mutex mtx;<br><span class="hljs-comment">//定义条件变量(用来做线程间的同步通信)</span><br>std::condition_variable cv;<br><br><span class="hljs-comment">// 定义：</span><br><span class="hljs-comment">// 生产者生产一个物品，通知消费者消费一个；</span><br><span class="hljs-comment">// 消费完成后通知生产者继续生产物品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 生产物品</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// lock_guard&lt;std::mutex&gt; guard(mtx); // scoped_ptr</span><br><span class="hljs-comment">// 设置锁</span><br><span class="hljs-function">unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-comment">// 遍历生产物品队列中是否存有商品</span><br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// que不为空，生产者应该通知消费者去消费，消费完了，再继续生产</span><br><span class="hljs-comment">// 生产者线程进入等待状态，并且把mtx互斥锁释放掉</span><br>cv.<span class="hljs-built_in">wait</span>(lck);<br>&#125;<br><span class="hljs-comment">// 存放货物</span><br>que.<span class="hljs-built_in">push</span>(val);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">notify_one：通知另外的一个线程</span><br><span class="hljs-comment">notify_all：通知其他所有线程</span><br><span class="hljs-comment">通知其它所有的线程，我生产了一个物品，你们赶紧消费吧</span><br><span class="hljs-comment">其它线程得到该通知，就会从等待状态 =&gt; 阻塞状态 =&gt; 获取互斥锁才能继续执行</span><br><span class="hljs-comment">*/</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;生产者正在生产：&quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; 号物品。&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 消费物品</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// lock_guard&lt;std::mutex&gt; guard(mtx); // scoped_ptr</span><br><span class="hljs-function">unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 消费者线程发现que是空的，通知生产者线程先生产物品</span><br><span class="hljs-comment">// 进入等待状态 # 把互斥锁mutex释放</span><br>cv.<span class="hljs-built_in">wait</span>(lck);<br>&#125;<br><span class="hljs-type">int</span> val = que.<span class="hljs-built_in">front</span>();<br>que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 通知其它线程我消费完了，赶紧生产吧</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;消费者 消费:&quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; 号物品。&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>queue&lt;<span class="hljs-type">int</span>&gt; que;<br>&#125;;<br><br><span class="hljs-comment">// 生产者线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(Queue* que)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>que-&gt;<span class="hljs-built_in">put</span>(i);<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 消费者线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(Queue* que)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>que-&gt;<span class="hljs-built_in">get</span>();<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建队列</span><br>Queue que;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(producer, &amp;que)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(consumer, &amp;que)</span></span>;<br><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241033564.png" alt="image.png"></p><h2 id="4-再谈-lock-guard-和-unique-lock"><a href="#4-再谈-lock-guard-和-unique-lock" class="headerlink" title="4. 再谈 lock_guard 和 unique_lock"></a>4. 再谈 lock_guard 和 unique_lock</h2><p>这两个其实可以类比智能指针来记：<br><code>lock_gurad</code> 类比于 <code>scoped_ptr</code>，它的拷贝构造和复制构造都被删除了，<strong>不可用在函数参数传递或者返回过程中</strong>，只能用在简单的临界区代码段的互斥操作中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lock_ <span class="hljs-title">guard</span><span class="hljs-params">(<span class="hljs-type">const</span> lock_ guard&amp;)</span></span>=<span class="hljs-keyword">delete</span>;<br>lock_ guard&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> lock_ guard&amp;)=<span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><p>而 <code>unique_lock</code> 可以类比于 <code>unique_ptr</code>，它不仅可以用在简单的临界代码段的互斥操作中，还能用在函数调用过程中。</p><p>总的来说，建议使用<code>unique_lock</code>.</p><h3 id="1-std-lock-gurad"><a href="#1-std-lock-gurad" class="headerlink" title="1. std::lock_gurad"></a>1. <code>std::lock_gurad</code></h3><p><code>std::lock_guard</code> 是 <code>RAII 模板类</code> 的简单实现，功能简单。</p><blockquote><ol><li>std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE lock_guard</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<br><span class="hljs-comment">// class with destructor that unlocks a mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> mutex_type = _Mutex;<br> <br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _MyMutex(_Mtx)</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock</span><br>_MyMutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br> <br><span class="hljs-built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _MyMutex(_Mtx)<br>&#123;<br><span class="hljs-comment">// construct but don&#x27;t lock</span><br>&#125;<br><br>~<span class="hljs-built_in">lock_guard</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-comment">// unlock</span><br>_MyMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>_Mutex&amp; _MyMutex;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>lock_gurad</code> 源码中看出，它在构造时进行上锁，在出作用域执行析构函数时释放锁；同时不允许拷贝构造和赋值运算符操作；</p><p>比较简单，不能用在函数参数传递或者返回过程中，因为它的拷贝构造和赋值运算符被禁用了；只能用在简单的临界区代码的互斥操作。</p><h3 id="2-std-unique-lock"><a href="#2-std-unique-lock" class="headerlink" title="2. std::unique_lock"></a>2. <code>std::unique_lock</code></h3><p>类 <code>unique_lock</code> 是通用互斥包装器，<strong>允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</strong>。</p><p><code>unique_lock</code> 比 <code>lock_guard</code> 使用更加灵活，功能更加强大。使用 <code>unique_lock</code> 需要付出更多的时间、性能成本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span><br>&#123;<br><span class="hljs-comment">// whizzy class with destructor that unlocks mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> _Mutex mutex_type;<br> <br><span class="hljs-comment">// CONSTRUCT, ASSIGN, AND DESTROY</span><br><span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span><br>: _Pmtx(<span class="hljs-literal">nullptr</span>), _Owns(<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">// default construct</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx))</span><br><span class="hljs-function">, _Owns(false)</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock</span><br>_Pmtx-&gt;<span class="hljs-built_in">lock</span>();<br>_Owns = <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx))<br>, _Owns(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// construct and assume already locked</span><br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">defer_lock_t</span>) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx))<br>, _Owns(<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">// construct but don&#x27;t lock</span><br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">try_to_lock_t</span>)<br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx))<br>, _Owns(_Pmtx-&gt;<span class="hljs-built_in">try_lock</span>())<br>&#123;<br><span class="hljs-comment">// construct and try to lock</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Rep, <span class="hljs-keyword">class</span> _Period&gt;</span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx))</span><br><span class="hljs-function">, _Owns(_Pmtx-&gt;try_lock_for(_Rel_time))</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock with timeout</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Clock, <span class="hljs-keyword">class</span> _Duration&gt;</span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx))</span><br><span class="hljs-function">, _Owns(_Pmtx-&gt;try_lock_until(_Abs_time))</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock with timeout</span><br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">const</span> xtime *_Abs_time)<br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx)), _Owns(<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">// try to lock until _Abs_time</span><br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_until</span>(_Abs_time);<br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; _Other) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_Other._Pmtx)<br>, _Owns(_Other._Owns)<br>&#123;<br><span class="hljs-comment">// destructive copy</span><br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br> <br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; _Other)<br>&#123;<br><span class="hljs-comment">// destructive copy</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Other))<br>&#123;<br><span class="hljs-comment">// different, move contents</span><br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br><br>_Pmtx = _Other._Pmtx;<br>_Owns = _Other._Owns;<br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br> <br>~<span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-comment">// clean up</span><br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// lock the mutex</span><br>_Validate();<br>_Pmtx-&gt;<span class="hljs-built_in">lock</span>();<br>_Owns = <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock the mutex</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock</span>();<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Rep, <span class="hljs-keyword">class</span> _Period&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock mutex for _Rel_time</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_for</span>(_Rel_time);<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Clock, <span class="hljs-keyword">class</span> _Duration&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock mutex until _Abs_time</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_until</span>(_Abs_time);<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> xtime *_Abs_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock the mutex until _Abs_time</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_until</span>(_Abs_time);<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to unlock the mutex</span><br><span class="hljs-keyword">if</span> (!_Pmtx || !_Owns)<br>_THROW(<span class="hljs-built_in">system_error</span>(<br>_STD <span class="hljs-built_in">make_error_code</span>(errc::operation_not_permitted)));<br> <br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>_Owns = <span class="hljs-literal">false</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_lock&amp; _Other)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// swap with _Other</span><br><span class="hljs-function">_STD <span class="hljs-title">swap</span><span class="hljs-params">(_Pmtx, _Other._Pmtx)</span></span>;<br><span class="hljs-function">_STD <span class="hljs-title">swap</span><span class="hljs-params">(_Owns, _Other._Owns)</span></span>;<br>&#125;<br> <br><span class="hljs-function">_Mutex *<span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// disconnect</span><br>_Mutex *_Res = _Pmtx;<br>_Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Owns = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> (_Res);<br>&#125;<br> <br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">owns_lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return true if this object owns the lock</span><br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return true if this object owns the lock</span><br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function">_NODISCARD _Mutex *<span class="hljs-title">mutex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return pointer to managed mutex</span><br><span class="hljs-keyword">return</span> (_Pmtx);<br>&#125;<br> <br><span class="hljs-keyword">private</span>:<br>_Mutex *_Pmtx;<br><span class="hljs-type">bool</span> _Owns;<br> <br><span class="hljs-type">void</span> _Validate() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-comment">// check if the mutex can be locked</span><br><span class="hljs-keyword">if</span> (!_Pmtx)<br>_THROW(<span class="hljs-built_in">system_error</span>(<br>_STD <span class="hljs-built_in">make_error_code</span>(errc::operation_not_permitted)));<br> <br><span class="hljs-keyword">if</span> (_Owns)<br>_THROW(<span class="hljs-built_in">system_error</span>(<br>_STD <span class="hljs-built_in">make_error_code</span>(errc::resource_deadlock_would_occur)));<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，有 <code>_Mutec* _Pmtx；</code> 只想一把锁的指针；不允许使用左值拷贝构造和赋值，但是可以使用右值拷贝构造和赋值，可以在函数调用过程中使用。</p><p>因此可以和条件变量一起使用：<code>cv.wait(lock);</code> 可以作为函数参数传入；</p><h2 id="5-基于-CAS-操作的-atomic-原子类型"><a href="#5-基于-CAS-操作的-atomic-原子类型" class="headerlink" title="5. 基于 CAS 操作的 atomic 原子类型"></a>5. 基于 CAS 操作的 atomic 原子类型</h2><p>因为锁的操作是比较重，对于系统消耗有些大，而且在临界区代码做的事情比较复杂，比较多。所以引入了 CAS 来保证上面的 <code>--操作</code> 的<strong>原子特性</strong>。同时这也是无锁操作。</p><p>C++ 11 的 thread 类库提供了针对简单类型的原子操作类，如： <code>std::atomic_int</code>，<code>atomic_long</code>，<code>atomic_bool</code> 等，它们值的增减都是基于 CAS 操作的，既保证了线程安全，效率还非常高。</p><blockquote><p>互斥锁用于比较复杂的场景，而简单的 ++，– 使用轻量的 atomic 原子类型即可。<br>一般也搭配 volatile使用，volatile 防止线程对变量进行缓存，操作的都是原始内存中的值。<br>不加 volatile 的话，每个线程都会拷贝一份自己的线程栈上的变量，带到 CPU 的寄存器，这样效率较高，但也可能出错。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span> <span class="hljs-comment">// C++11 线程库提供的原子类</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span> <span class="hljs-comment">// C++ 线程类库的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br> <br><span class="hljs-keyword">volatile</span> std::atomic_bool isReady = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">volatile</span> std::atomic_int mycount = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (!isReady)<br>&#123;<br><span class="hljs-comment">// 线程出让当前的CPU时间片，等待下一次调度</span><br>std::this_thread::<span class="hljs-built_in">yield</span>(); <br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)<br>&#123;<br>mycount++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;std::thread&gt; tlist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br>tlist.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(task));<br>&#125;<br><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>isReady = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span> (std::thread &amp;t : tlist)<br>&#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;mycount:&quot;</span> &lt;&lt; mycount &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="番外介绍：线程死锁"><a href="#番外介绍：线程死锁" class="headerlink" title="番外介绍：线程死锁"></a>番外介绍：线程死锁</h2><p><strong>概述死锁：</strong></p><p>线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于 <code>synchronized</code> 特性，一个线程池有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，而且会一直死等下去，因此便造成了死锁。</p><p><strong>死锁产生的条件：</strong></p><ul><li><strong>互斥条件</strong>：一个资源或者说一个锁只能被一个线程所占有，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其他线程均无法获取到这个锁。</li><li><strong>占有且等待</strong>：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。</li><li><strong>不可剥夺条件</strong>：任何一个线程都无法强制获取别的线程已经占有的锁。</li><li><strong>循环等待条件</strong>：线程A拿着线程B的锁，线程B拿着线程A的锁。</li></ul><h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h3><p>当一个程序的多个线程获取多个互斥锁资源的时候，就有可能发生死锁问题，比如线程 A 先获取了锁 1，线程 B 获取了锁 2，进而线程 A 还需要获取锁 2 才能继续执行，但是由于锁 2 被线程 B 持有还没有释放，线程 A 为了等待锁 2 资源就阻塞了；线程 B 这时候需要获取锁 1 才能往下执行，但是由于锁 1 被线程 A 持有，导致 A 也进入阻塞。</p><p>线程 A 和线程 B 都在等待对方释放锁资源，但是它们又不肯释放原来的锁资源，导致线程 A 和 B 一直互相等待，进程死锁了。下面代码示例演示这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>           <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>             <span class="hljs-comment">//std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>              <span class="hljs-comment">//std::mutex, std::unique_lock</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span> <span class="hljs-comment">//std::condition_variable</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br> <br><span class="hljs-comment">//锁资源1</span><br>std::mutex mtx1;<br><span class="hljs-comment">//锁资源2</span><br>std::mutex mtx2;<br> <br><span class="hljs-comment">//线程A的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//保证线程A先获取锁1</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockA</span><span class="hljs-params">(mtx1)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程A获取锁1&quot;</span> &lt;&lt; std::endl;<br> <br>  <span class="hljs-comment">//线程A睡眠2s再获取锁2，保证锁2先被线程B获取，模拟死锁问题的发生</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br> <br>  <span class="hljs-comment">//线程A先获取锁2</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockB</span><span class="hljs-params">(mtx2)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程A获取锁2&quot;</span> &lt;&lt; std::endl;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程A释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;<br>&#125;<br> <br><span class="hljs-comment">//线程B的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//线程B先睡眠1s保证线程A先获取锁1</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockB</span><span class="hljs-params">(mtx2)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程B获取锁2&quot;</span> &lt;&lt; std::endl;<br> <br>  <span class="hljs-comment">//线程B尝试获取锁1</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockA</span><span class="hljs-params">(mtx1)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程B获取锁1&quot;</span> &lt;&lt; std::endl;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程B释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//创建生产者和消费者线程</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(taskA)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(taskB)</span></span>;<br> <br>  <span class="hljs-comment">//main主线程等待所有子线程执行完</span><br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241112703.png" alt="image.png"></p><p>可以看到，线程 A 获取锁 1、线程 B 获取锁 2 以后，进程就不往下继续执行了，一直等待在这里，如果这就碰到的一个问题场景，<strong>如何判断出这是由于线程间死锁引起的呢？</strong></p><p>打开 process Explorer。找到该进程，查看线程状态，发现线程的 cpu 利用率为 0，那么应该不是死循环，应该是死锁了：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241113352.png" alt="image.png"></p><p>断：查看每一个线程的函数执行的位置</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241115303.png" alt="image.png"></p><p>发现当前线程正在申请锁的位置,判断出应该是锁了。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241118313.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241119893.png" alt="image.png"></p><p>同时主线程走了等待子线程结束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00.C++ 设计模式概述</title>
    <link href="/2023/08/21/04.C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/21/04.C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.C++ bind 绑定器和 function 函数对象</title>
    <link href="/2023/08/18/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/10.C++%20bind%20%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%20function%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/18/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/10.C++%20bind%20%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%20function%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>本节分为四部分：</p><ol><li>C++ STL 中的绑定器</li><li>function 示例和实现</li><li>bind 和 function 实现线程池</li><li>lambda 表达式</li></ol><h2 id="1-C-STL-中的绑定器"><a href="#1-C-STL-中的绑定器" class="headerlink" title="1. C++ STL 中的绑定器"></a>1. C++ STL 中的绑定器</h2><h3 id="1-介绍绑定器"><a href="#1-介绍绑定器" class="headerlink" title="1. 介绍绑定器"></a>1. 介绍绑定器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bind1st<br><span class="hljs-comment">// 和</span><br>std::bind2nd<br></code></pre></td></tr></table></figure><p>以上两个函数用于将一个 <strong>二元函数对象</strong> 转换为 <strong>一元函数对象</strong> 。</p><p>bind 意思为：<strong>绑定</strong>，1st 代表 first；2nd 代表 second，说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::binder1st&lt;F&gt; <span class="hljs-title">bind1st</span><span class="hljs-params">(<span class="hljs-type">const</span> F&amp; f, <span class="hljs-type">const</span> T&amp; x)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T &gt;</span><br><span class="hljs-function">std::binder2nd&lt;F&gt; <span class="hljs-title">bind2nd</span><span class="hljs-params">( <span class="hljs-type">const</span> F&amp; f, <span class="hljs-type">const</span> T&amp; x )</span></span><br></code></pre></td></tr></table></figure><p>将给定的参数 x 绑定到 二元函数对象 F 的第一个或第二个形参。也就是说，将 x 存储在该包装器中，如果调用该包装器，则将 x 作为 F 的第一个或第二个形参传递。</p><p><code>bind1st</code>：相当于操作：<code>x Operation value</code> &#x3D;&#x3D; <code>operator()</code> 的第一个形参变量绑定成一个确定的值。<br><code>bind2nd</code>：相当于操作：<code>Operation value x</code> &#x3D;&#x3D; <code>operator()</code> 的第二个形参变量绑定成一个确定的值。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211548667.png" alt="image.png"></p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContainer</span><span class="hljs-params">(Container&amp; con)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量</span><br><span class="hljs-comment">// typename告知编译器后面类型的作用域后面是类型</span><br><span class="hljs-keyword">typename</span> Container::iterator it = con.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != con.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br><br><span class="hljs-comment">// 遍历添加</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">//随机出来的数字，并不是有序的 </span><br>&#125;<br><br><span class="hljs-comment">// 初始化状态</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Init：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">// 从大到小排序</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Sort：&quot;</span>;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">// 把 70 按照顺序插入到 vec 容器当中，找第一个小于 70 的数字</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(<br>vec.<span class="hljs-built_in">begin</span>(),<br>vec.<span class="hljs-built_in">end</span>(),<br><span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">70</span>)<br>);<br><span class="hljs-comment">// auto it1 = find_if(vec.begin(), vec.end(),bind2nd(less&lt;int&gt;(), 70));</span><br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br>vec.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">70</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Insert：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211600501.png" alt="image.png"></p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><ol><li><strong><code>find_if</code></strong> 源码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// FUNCTION TEMPLATE find_if</span><br>_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_InIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Pr</span>&gt;<br><span class="hljs-function">_NODISCARD _CONSTEXPR20 _InIt <span class="hljs-title">find_if</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">_InIt _First, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _InIt _Last, </span></span><br><span class="hljs-params"><span class="hljs-function">_Pr _Pred</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-comment">// find first satisfying _Pred</span><br>    _Adl_verify_range(_First, _Last);<br>    <span class="hljs-keyword">auto</span> _UFirst      = _Get_unwrapped(_First);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> _ULast = _Get_unwrapped(_Last);<br>    <span class="hljs-keyword">for</span> (; _UFirst != _ULast; ++_UFirst) &#123;<br>        <span class="hljs-keyword">if</span> (_Pred(*_UFirst)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    _Seek_wrapped(_First, _UFirst);<br>    <span class="hljs-keyword">return</span> _First;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中第三个参数 <code>_Pred</code> 是一个一元函数对象</p><ol start="2"><li><strong><code>bind1st</code></strong> 源码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// FUNCTION TEMPLATE bind1st</span><br>_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fn</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD binder1st&lt;_Fn&gt; <span class="hljs-title">bind1st</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _Fn&amp; _Func, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _Ty&amp; _Left</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return a binder1st functor adapter</span><br>    <span class="hljs-keyword">typename</span> _Fn::first_argument_type _Val(_Left);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binder1st</span>&lt;_Fn&gt;(_Func, _Val);<br>&#125;<br></code></pre></td></tr></table></figure><p>它是一个函数模板，返回一元函数对象 <code>binder1st</code></p><ol start="3"><li><strong><code>bind2nd</code></strong> 源码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE binder1st</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fn</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binder1st</span><br>: <span class="hljs-keyword">public</span> unary_function&lt;<br><span class="hljs-keyword">typename</span> _Fn::second_argument_type,<br><span class="hljs-keyword">typename</span> _Fn::result_type&gt;<br>&#123;<br><span class="hljs-comment">// functor adapter _Func(stored, right)</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> unary_function&lt;<br><span class="hljs-keyword">typename</span> _Fn::second_argument_type,<br><span class="hljs-keyword">typename</span> _Fn::result_type&gt; _Base;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Base::argument_type argument_type;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Base::result_type result_type;<br> <br><span class="hljs-built_in">binder1st</span>(<br><span class="hljs-type">const</span> _Fn&amp; _Func,<br><span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> _Fn::first_argument_type&amp; _Left)<br>: <span class="hljs-built_in">op</span>(_Func)<br>, <span class="hljs-built_in">value</span>(_Left)<br>&#123;<br><span class="hljs-comment">// construct from functor and left operand</span><br>&#125;<br> <br><span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> argument_type&amp; _Right)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// apply functor to operands</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">op</span>(value, _Right));<br>&#125;<br> <br><span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(argument_type&amp; _Right)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// apply functor to operands</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">op</span>(value, _Right));<br>&#125;<br> <br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// the functor to apply</span><br>_Fn op;<br><span class="hljs-comment">// the left operand</span><br><span class="hljs-keyword">typename</span> _Fn::first_argument_type value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一元函数对象默认构造函数接受两个参数， <code>op</code> 和 <code>value</code>。赋值运算符接收一个参数，并使用传入的 <code>op</code> 和 <code>vaule</code> 进行运算：<code>op(value, _Right)</code></p><h3 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// bind1st 实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContainer</span><span class="hljs-params">(Container&amp; con)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量</span><br><span class="hljs-comment">// typename告知编译器后面类型的作用域后面是类型</span><br><span class="hljs-keyword">typename</span> Container::iterator it = con.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != con.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 实现 find_if</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Compare&gt;</span><br><span class="hljs-function">Iterator <span class="hljs-title">my_find_if</span><span class="hljs-params">(Iterator first, Iterator last, Compare comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 遍历这2个迭代器之间的元素，如果满足函数对象的运算，就返回当前迭代器，如果都不满足，返回end()</span><br><span class="hljs-keyword">for</span> (; first != last; first++)<br>&#123;<br><span class="hljs-comment">// comp.operator()(*first)一元函数对象，因为要从容器拿1个元素和它指定的元素比较</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">comp</span>(*first))<br>&#123;<br><span class="hljs-comment">// my_find_if 需要 一元函数对象，而在库里面都是二元的</span><br><span class="hljs-keyword">return</span> first;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> last;<br>&#125;<br><br><span class="hljs-comment">// 实现 bind1st</span><br><span class="hljs-comment">// 绑定器是函数对象的一个应用</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_mybind1st</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>_mybind1st(Compare comp, T val)<br>: _comp(comp)<br>, _val(val)<br>&#123;<br><span class="hljs-comment">// 列表初始化</span><br>&#125;<br><br><span class="hljs-comment">// 函数对象</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; second)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _comp(_val, second);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Compare _comp;<br>T _val;<br>&#125;;<br><br><span class="hljs-comment">// mybind1st(greater&lt;int&gt;(), 70)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Compare, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">_mybind1st&lt;Compare, T&gt; <span class="hljs-title">mybind1st</span><span class="hljs-params">(Compare comp, <span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 直接使用函数模板，好处是，可以进行类型的推演</span><br><span class="hljs-keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Init：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">// greater 二元函数对象</span><br><span class="hljs-comment">// 大到小排序</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>cout &lt;&lt; <span class="hljs-string">&quot;Sort：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">把70按顺序插入到vec容器当中   找第一个小于70的数字</span><br><span class="hljs-comment">operator()(const T &amp;val)</span><br><span class="hljs-comment">greater   a &gt; b</span><br><span class="hljs-comment">less      a &lt; b</span><br><span class="hljs-comment">绑定器 + 二元函数对象 =&gt; 一元函数对象</span><br><span class="hljs-comment">bind1st: + greater bool operator()(70, const _Ty&amp; _Right)</span><br><span class="hljs-comment">bind2nd: + less bool operator()(const _Ty&amp; _Left, 70)</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it1 = <span class="hljs-built_in">my_find_if</span>(<br>vec.<span class="hljs-built_in">begin</span>(), <br>vec.<span class="hljs-built_in">end</span>(),<br><span class="hljs-built_in">mybind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">70</span>)<br>);<br><span class="hljs-comment">// auto it1 = my_find_if(vec.begin(), vec.end(),bind2nd(less&lt;int&gt;(), 70));</span><br><span class="hljs-keyword">if</span> (it1 != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br>vec.<span class="hljs-built_in">insert</span>(it1, <span class="hljs-number">70</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Insert：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211759070.png" alt="image.png"></p><h2 id="2-function-示例和实现"><a href="#2-function-示例和实现" class="headerlink" title="2. function 示例和实现"></a>2. function 示例和实现</h2><p>function 是一个函数包装器模板，最早来自 boost 库。在 c11 标准中将其纳入标准库。该函数包装器模板可以包装任何类型的可调用元素，<strong>例如普通函数和函数对象</strong>。  </p><p>function 最大的作用就是<strong>保留可调用元素的类型</strong>。</p><p>解决绑定器，函数对象，lambda 表达式只能使用在一条语句中的问题；</p><p>定义：传递一个  <code>_Fty  function type</code> 希望传递一个函数类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <br><span class="hljs-comment">// CLASS TEMPLATE function</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">function</span><br>: <span class="hljs-keyword">public</span> _Get_function_impl&lt;_Fty&gt;::type<br>&#123;<br><span class="hljs-comment">// wrapper for callable objects</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Get_function_impl&lt;_Fty&gt;::type _Mybase;<br> <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">function</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-comment">// construct empty function wrapper</span><br>&#125;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-function的应用"><a href="#1-function的应用" class="headerlink" title="1. function的应用"></a>1. function的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// void (*pfunc)(string)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Sum：&quot;</span>;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 必须依赖一个对象 void (Test::*pfunc)(string)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.用函数类型实例化 function</span><br><span class="hljs-comment">2.通过 function 调用 operator() 函数的时候，需要根据函数类型传入相应的参数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 从 function 的类模板定义出，看到希望用一个函数类型实例化 function</span><br>function&lt;<span class="hljs-type">void</span>()&gt; func1 = hello1;<br><span class="hljs-comment">// func1.operator()() =&gt; hello();</span><br><span class="hljs-built_in">func1</span>();<br><br>function&lt;<span class="hljs-type">void</span>(string)&gt; func2 = hello2;<br><span class="hljs-built_in">func2</span>(<span class="hljs-string">&quot;hello world2!&quot;</span>);<br><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func3 = sum;<br><span class="hljs-built_in">sum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// operator() 表达式</span><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func4 =<br>[](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;function::operator()：&quot;</span> &lt;&lt; <span class="hljs-built_in">func4</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// 成员函数变量</span><br>function&lt;<span class="hljs-type">void</span>(Test*, string)&gt; func5 = &amp;Test::hello;<br>Test* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-built_in">func5</span>(t, <span class="hljs-string">&quot;call Test::hello!&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类成员函数  </span><br><span class="hljs-comment">// 报错：&amp; 左值引用问题</span><br>function&lt;<span class="hljs-type">void</span>(Test*, string)&gt; func5 = &amp;Test::hello;<br>   <span class="hljs-built_in">func5</span>(&amp;<span class="hljs-built_in">Test</span>(), <span class="hljs-string">&quot;call Test::hello!&quot;</span>);<span class="hljs-comment">//临时对象调用</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>其实是可以实现取地址的，对象是在站内构造的，可以通过栈偏移指向；但是编译器不支持，无法实现兼容。</p><p>报左值引用错误是因为<strong>仿函数</strong>要用，上面初始化的仿函数是个 this call，要提供 this，而 this 是结构体的指针，无法通过取地址实现，而且临时构造不能允许取地址。</p><p><code>test()</code> 的声明周期就那一行，结束就被销毁了是个右值，只有左值能取址。</p><h3 id="2-模板的完全特例化和部分特例化"><a href="#2-模板的完全特例化和部分特例化" class="headerlink" title="2. 模板的完全特例化和部分特例化"></a>2. 模板的完全特例化和部分特例化</h3><p>对于下面的 compare，对于 char 类型的比较不能满足实际的需要，因此对 compare 特例化一个版本 <code>compare&lt;const char *&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;template compare&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">bool</span> <span class="hljs-built_in">compare</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)<span class="hljs-comment">//特例化 </span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;compare&lt;const char*&gt;&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a, b) &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">// </span><br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<span class="hljs-comment">//T const char*</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>匹配原则：有完全特例化则先匹配完全特例化，其次部分特例化，最后函数模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector template init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 下面这个是对char*类型提供的完全特例化版本（&lt;&gt;中T已知：即下面的char *）  #1 </span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">// 特例化的语法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-type">char</span>*&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;char*&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 下面这个是对指针类型提供的部分特例化版本  #2</span><br><span class="hljs-comment">// 仅知道是一个指针，类型需要提供</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;Ty*&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;Ty*&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 指针函数指针（有返回值，有两个形参变量）提供的部分特例化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-built_in">R</span>(*)(A1, A2)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;R(*)(A1, A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 针对函数（有一个返回值，有两个形参变量）类型提供的部分特例化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-built_in">R</span>(A1, A2)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;R(A1, A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Vector&lt;<span class="hljs-type">int</span>&gt; vec1;<br>Vector&lt;<span class="hljs-type">char</span>*&gt; vec2;<br>Vector&lt;<span class="hljs-type">int</span>*&gt; vec3;<br>Vector&lt;<span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; vec4;<br>Vector&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; vec5;<span class="hljs-comment">// function</span><br><br><span class="hljs-comment">// 注意区分一下函数类型和函数指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*PFUNC1)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>PFUNC1 pfunc1 = sum;<br>cout &lt;&lt; <span class="hljs-built_in">pfunc1</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title">PFUNC2</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>PFUNC2* pfunc2 = sum;<br>cout &lt;&lt; (*pfunc2)(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308220929678.png" alt="image.png"></p><p><strong>实参推演：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// T 包含了所有的大的类型  返回值，所有形参的类型都取出来</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//细化返回值类型和参数类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(R(*a)(A1, A2))</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(R).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-comment">//实参推演每一个类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(R(T::* a)(A1, A2))</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(R).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------func1\n&quot;</span>;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-built_in">func</span>(sum);<span class="hljs-comment">//T  int (*)(int,int)   int (int,int)</span><br><span class="hljs-built_in">func</span>(&amp;Test::sum);<span class="hljs-comment">//int (__thiscall Test::*)(int,int)</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------func2\n&quot;</span>;<br><span class="hljs-built_in">func2</span>(sum);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------func3\n&quot;</span>;<br><span class="hljs-built_in">func3</span>(&amp;Test::sum);<span class="hljs-comment">// int (__thiscall Test::*)(int,int)</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308220936036.png" alt="image.png"></p><h3 id="3-function-原理解析"><a href="#3-function-原理解析" class="headerlink" title="3. function 原理解析"></a>3. function 原理解析</h3><p><strong>源码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">function</span> : <span class="hljs-keyword">public</span> _Get_function_impl&lt;_Fty&gt;::type &#123; <span class="hljs-comment">// wrapper for callable objects</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> _Mybase = <span class="hljs-keyword">typename</span> _Get_function_impl&lt;_Fty&gt;::type;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">function</span>() <span class="hljs-keyword">noexcept</span> &#123;&#125;<br><br>    <span class="hljs-built_in">function</span>(<span class="hljs-type">nullptr_t</span>) <span class="hljs-keyword">noexcept</span> &#123;&#125;<br><br>    <span class="hljs-built_in">function</span>(<span class="hljs-type">const</span> function&amp; _Right) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_Reset_copy(_Right);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fx</span>, <span class="hljs-keyword">typename</span> _Mybase::<span class="hljs-keyword">template</span> _Enable_if_callable_t&lt;_Fx, function&gt; = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-built_in">function</span>(_Fx&amp;&amp; _Func) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_Reset(_STD forward&lt;_Fx&gt;(_Func));<br>    &#125;<br>    <br>function&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> function&amp; _Right) &#123;<br>        <span class="hljs-built_in">function</span>(_Right).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span>(function&amp;&amp; _Right) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_Reset_move(_STD <span class="hljs-built_in">move</span>(_Right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>function 底层是一个可变参的偏特化函数对象</p><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// function 函数对象类型的实现原理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// 定义函数模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&#123;&#125;;<br><br><span class="hljs-comment">// 部分偏特化版本 &lt;R(A1)&gt;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(A1)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(A1);<br><span class="hljs-built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) &#123;&#125;<br><br><span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A1 arg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// hello(arg);</span><br><span class="hljs-keyword">return</span> _pfunc(arg);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>PFUNC _pfunc;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//部分偏特化版本   R(*)(A1, A2);</span><br><span class="hljs-comment">template&lt;class R, class A1, class A2&gt;</span><br><span class="hljs-comment">class myfunction&lt;R(A1, A2)&gt;</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">using PFUNC = R(*)(A1, A2);</span><br><span class="hljs-comment">myfunction(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;</span><br><span class="hljs-comment">R operator()(A1 arg1, A2 arg2)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">return _pfunc(arg1, arg2);//hello(arg)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">private:</span><br><span class="hljs-comment">PFUNC _pfunc;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//通用版本</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... A&gt;<span class="hljs-comment">//一组可变参数个数：表示一组类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(A...)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(A...);<br><span class="hljs-built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;<br><span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A... arg)</span><span class="hljs-comment">//一组形参变量</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _pfunc(arg...);<span class="hljs-comment">//hello(arg) 表示一组形参变量</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br>PFUNC _pfunc;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">myfunction&lt;<span class="hljs-title">void</span><span class="hljs-params">(string)</span>&gt; <span class="hljs-title">func1</span><span class="hljs-params">(hello)</span></span>;<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<span class="hljs-comment">// func1.operator()(&quot;hello world!&quot;)</span><br><br><span class="hljs-function">myfunction&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">func2</span><span class="hljs-params">(sum)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-bind-和-function-实现线程池"><a href="#3-bind-和-function-实现线程池" class="headerlink" title="3. bind 和 function 实现线程池"></a>3. bind 和 function 实现线程池</h2><p><strong>C++11 bind 绑定器，是一个函数模板 ，可以自动推演模板类型参数&#x3D;&gt; 返回的结果还是一个函数对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-comment">// C++ 11 bind 绑定器 -&gt; 返回的结果是一个函数对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// bind 是函数模板，可以自动退盐模板类型参数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;----- bind -----&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">bind</span>(hello, <span class="hljs-string">&quot;hello bind 1!&quot;</span>)();<br>cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">bind</span>(&amp;Test::sum, <span class="hljs-built_in">Test</span>(), <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)() &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;----- placeholder -----&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 参数占位符 placeholder 绑定器除了语句，无法继续使用</span><br><span class="hljs-comment">// 只是占位的作用，调用的时候就要传递参数了</span><br><span class="hljs-comment">// 书写的时候使用多少个占位符，就是意味着用户调用的时候要传入几个参数</span><br><span class="hljs-built_in">bind</span>(hello, placeholders::_1)(<span class="hljs-string">&quot;hello bind 2!&quot;</span>);<br>cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, placeholders::_1, placeholders::_2)(<span class="hljs-number">200</span>, <span class="hljs-number">300</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// 此处把 bind 返回的绑定器 binder 复用</span><br>cout &lt;&lt; <span class="hljs-string">&quot;----- function -----&quot;</span> &lt;&lt; endl;<br>function&lt;<span class="hljs-type">void</span>(string)&gt; func1 = <span class="hljs-built_in">bind</span>(hello, _1);<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function 1!&quot;</span>);<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function 2!&quot;</span>);<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function 3!&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在语句 <code>bind(hello, &quot;hello bind!&quot;)();</code> 中，bind 将 “hello bind 1！” 绑定至 hello 的 string 类型参数，并返回一个函数对象，调用这个函数对象的<code>operator（）</code> 函数，完成打印字符串的过程。</p><p>在语句 <code>bind(hello, _1)(&quot;hello bind 2!&quot;);</code> 中的 <code>_1</code> 是名称空间  placeholders 中的，用法 <code>placeholder::_1</code>。此为<strong>参数占位符</strong>，代表 hello 的第一个参数等待用户输入。在本例中将参数 “hello bind 2!” 传递给 <code>operator（）</code> 函数完成调用。</p><p><strong>用 function 实现对 bind 绑定的函数对象的类型保留</strong></p><p>bind 有个缺点：<strong>bind 无法保存它所绑定过的函数对象！</strong></p><p>所以就需要 function 和它进行配合。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221040672.png" alt="image.png"></p><p>placeholders 占位符：最多支持20个</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221041770.png" alt="image.png"></p><h3 id="1-线程池模拟"><a href="#1-线程池模拟" class="headerlink" title="1. 线程池模拟"></a>1. 线程池模拟</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-comment">// 线程类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Thread</span>(function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt; func, <span class="hljs-type">int</span> no)<br>: _func(func)<br>, _no(no) &#123; &#125;<br><span class="hljs-comment">// 这里需要包含头文件 #include&lt;thread&gt;</span><br><span class="hljs-function">thread <span class="hljs-title">start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义线程 t 执行 func 函数</span><br><span class="hljs-comment">// _func(_no)</span><br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(_func, _no)</span></span>;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 接收绑定器返回的函数对象</span><br>function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; _func;<br><span class="hljs-comment">// 线程池编号</span><br><span class="hljs-type">int</span> _no;<br>&#125;;<br><br><span class="hljs-comment">// 线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ThreadPool</span>() &#123;&#125;<br>~<span class="hljs-built_in">ThreadPool</span>()<br>&#123;<br><span class="hljs-comment">// 这里是指针，所以不能依靠vector析构自动析构，得手动释放Thread对象占用的堆资源</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _pool.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-keyword">delete</span> _pool[i];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 开启线程池</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startPool</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 遍历线程大小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>&#123;<br><span class="hljs-comment">// 添加线程</span><br>_pool.<span class="hljs-built_in">push_back</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(<span class="hljs-built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="hljs-keyword">this</span>, _1), i)<br>);<br>&#125;<br><br><span class="hljs-comment">// 执行线程函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>&#123;<br><span class="hljs-comment">// 添加线程池</span><br>_handler.<span class="hljs-built_in">push_back</span>(_pool[i]-&gt;<span class="hljs-built_in">start</span>());<br>&#125;<br><br><span class="hljs-keyword">for</span> (thread&amp; t : _handler)<br>&#123;<br><span class="hljs-comment">// 等待线程执行完毕</span><br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>vector&lt;Thread*&gt; _pool;<br>vector&lt;thread&gt; _handler;<br><br><span class="hljs-comment">// 把runInThread这个成员方法充当线程函数  thread   pthread_create</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInThread</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call runInThread! id: &quot;</span> &lt;&lt; id &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ThreadPool pool;<br>pool.<span class="hljs-built_in">startPool</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-lambda-表达式"><a href="#4-lambda-表达式" class="headerlink" title="4. lambda 表达式"></a>4. lambda 表达式</h2><p>lambda这个词起源于数学上的λ，在C++中利用lambda表达式，可以方便的定义和创建匿名函数。lambda可以看做<strong>函数对象的升级版</strong>。改进了函数对象以下的缺点：</p><ul><li>使用在泛型算法中的参数传递 </li><li>比较性质&#x2F;自定义操作 </li><li>优先级队列 </li><li>智能指针</li></ul><h3 id="1-表达式语法"><a href="#1-表达式语法" class="headerlink" title="1. 表达式语法"></a>1. 表达式语法</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221059552.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[捕获外部变量]（形参列表）-&gt;返回值&#123;操作代码&#125;；<br></code></pre></td></tr></table></figure><p>如果 lambda 不需要返回值，那么返回值可以省略。也就是这样：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[捕获外部变量]（形参列表）&#123;操作代码&#125;；<br></code></pre></td></tr></table></figure><ul><li><strong>参数列表</strong>：与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略。</li><li><strong>mutable</strong>：<strong>默认情况下，lambda函数总是一个const函数</strong>，mutable可以取消其常量性。使用该修饰符时，参数列表不可省略</li><li>-&gt; <strong>返回值类型</strong>：与普通函数返回值一样表达函数的返回值类型，可以省略，译器会对返回值类型进行推导。</li><li><strong>函数体</strong>：可以使用参数以及捕获到的变量。</li></ul><p><strong>捕获外部变量方式：</strong></p><ul><li><code>[]</code>：表示不捕获任何外部变量</li><li><code>[=]</code>：捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li><code>[&amp;]</code>：捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li><code>[this]</code>：捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li><li><code>[=，&amp;a]</code>：以传值的方式捕获外部的所有变量，但是a变量以传引用的方式捕获</li><li><code>[a，b]</code>：以传值的方式捕获外部变量 a 和 b</li><li><code>[a,&amp;b]</code>：a 以传值方式捕获，b 以传引用的方式捕获</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 最简单的lamber表达式，没有任何意义</span><br>[] &#123;&#125;;<br><br><span class="hljs-comment">// 省略参数列表和返回值类型，由编译器推导</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br>[=] &#123; <span class="hljs-keyword">return</span> a + b; &#125;; <span class="hljs-comment">// 函数体被的分号不要忘</span><br><br><span class="hljs-comment">// 引用传递的方式可以改变变量的值</span><br><span class="hljs-keyword">auto</span> func1 = [&amp;](<span class="hljs-type">int</span> c) &#123; <span class="hljs-keyword">return</span> b = a + c; &#125;;<br><span class="hljs-built_in">func1</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 值传递捕获不能改变变量的值，除非使用 mutable</span><br><span class="hljs-keyword">auto</span> func2 = [=](<span class="hljs-type">int</span> c) <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> b = a + c; &#125;;<br><span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-lambda-底层原理-函数对象"><a href="#2-lambda-底层原理-函数对象" class="headerlink" title="2. lambda 底层原理 - 函数对象"></a>2. lambda 底层原理 - 函数对象</h3><ul><li><strong>无参无返回值的 lambda</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func1 = []()&#123;cout &lt;&lt; <span class="hljs-string">&quot;hello world!&quot;</span> &lt;&lt; endl; &#125;;<br><span class="hljs-built_in">func1</span>();<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda01<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestLambda01</span>() &#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()()<span class="hljs-type">const</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>参数为整型返回值为整型的</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func2 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda02<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestLambda02</span>() &#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-built_in">operator</span>()(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>以引用方式获取参数的lambda</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// “a”: 无法在非可变 lambda 中修改通过复制捕获</span><br><span class="hljs-keyword">auto</span> func3 = [&amp;]()<br>&#123;<br><span class="hljs-type">int</span> tmp = a;<br>a = b;<br>b = tmp;<br>&#125;;<br><span class="hljs-built_in">func3</span>();<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda03<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestLambda03</span>(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b):<span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b) &#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-type">int</span> tmp = ma;<br>ma = mb;<br>mb = tmp;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> &amp;ma;<br><span class="hljs-type">int</span> &amp;mb;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>以值方式获取参数的lambda</strong>:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func4 = [=]() <span class="hljs-keyword">mutable</span><span class="hljs-comment">//并没有改变外面的a b ，传值</span><br>&#123;<br>    <span class="hljs-type">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;;<br><span class="hljs-built_in">func4</span>();<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda04<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestLambda04</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) :<span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b) &#123; &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-type">int</span> tmp = ma;<br>        ma = mb;<br>        mb = tmp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> ma;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>lambda 中的捕获参数列表对应类中成员变量的类型，返回值和参数列表对应 <code>operator（）</code> 的返回值和参数列表。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221517145.png" alt="image.png"></p><p>lambda 表达式在编译期间被编译器自动转换成函数对象执行，调研 operator</p><h3 id="3-lambda-表达式代替-switch"><a href="#3-lambda-表达式代替-switch" class="headerlink" title="3. lambda 表达式代替 switch"></a>3. lambda 表达式代替 switch</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; caculateMap;<br>caculateMap[<span class="hljs-number">1</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b; &#125;;<br>caculateMap[<span class="hljs-number">2</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a - b; &#125;;<br>caculateMap[<span class="hljs-number">3</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a * b; &#125;;<br>caculateMap[<span class="hljs-number">4</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a / b; &#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;选择:&quot;</span>;<br><span class="hljs-type">int</span> choice;<br>cin &gt;&gt; choice;<br>cout &lt;&lt; <span class="hljs-string">&quot;10 op  15:&quot;</span> &lt;&lt; caculateMap[choice](<span class="hljs-number">10</span>, <span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="4-按值捕获-捕获时机"><a href="#4-按值捕获-捕获时机" class="headerlink" title="4. 按值捕获 &amp; 捕获时机"></a>4. 按值捕获 &amp; 捕获时机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-keyword">auto</span> localStr = [=](string&amp; s) &#123; s = str; &#125;;<br><br>    str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    string str1;<br>    <span class="hljs-built_in">localStr</span>(str1);<br><br>    cout &lt;&lt; str;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>str = &quot;abc&quot;</code> 当闭包生成的那一刻，被捕获的变量已经按值赋值的方式进行了捕获，后面那个<code>str</code>再怎么变化，已经和闭包对象里面的值没有关系了.</p><p>localStr 中 str 中的值在localStr 定义的时候就已经确定为abc了，不会再发生变化。</p><h3 id="5-按引用捕获-悬空引用"><a href="#5-按引用捕获-悬空引用" class="headerlink" title="5. 按引用捕获 &amp; 悬空引用"></a>5. 按引用捕获 &amp; 悬空引用</h3><p>在 C++ 编程中，程序员有责任保证 Lambda 调用的时候，保证被捕获的变量仍然有效~！是的，责任在你，而不在编译器。如果不能很好理解这点，就会遇到悬空引用的问题！</p><p><strong>悬空引用（ dangling references ）</strong>：就是说当创建了一个对象的引用类型的变量，但是被引用的对象被析构了、无效了。一般情况下，引用类型的变量必须在初始化的时候赋值，很少遇到这种情况，但是如果 lambda 被延迟调用，在调用时，已经脱离了当前的作用域，那么按引用捕获的对象就是悬空引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br>std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">void</span>)&gt; func;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>std::string str = <span class="hljs-string">&quot;abc&quot;</span>;<br>func = [&amp;]() &#123; std::string a = str; cout &lt;&lt; a; &#125;;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-built_in">func</span>();<br>  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221527791.png" alt="image.png"></p><p>发生 crash：func 引用的对象 str 在离开作用域 <code>test()</code> 后被析构了，在 main 函数中执行 <code>func()</code> 导致找到引用的对象 str,导致 crash。</p><h3 id="6-lambda-实现指针自定义删除器"><a href="#6-lambda-实现指针自定义删除器" class="headerlink" title="6. lambda 实现指针自定义删除器"></a>6. lambda 实现指针自定义删除器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 智能指针自定义删除器   delete p;  FILE*   fclose(FILE*)</span><br>unique_ptr&lt;FILE, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <br><span class="hljs-built_in">ptr1</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), [](FILE *pf) &#123;<span class="hljs-built_in">fclose</span>(pf); &#125;);<br></code></pre></td></tr></table></figure><h3 id="7-lambda实现多种比较操作"><a href="#7-lambda实现多种比较操作" class="headerlink" title="7. lambda实现多种比较操作"></a>7. lambda实现多种比较操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> val1 = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> val2 = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ma</span>(val1), <span class="hljs-built_in">mb</span>(val2) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Data &amp;data) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ma &gt; data.ma; &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Data &amp;data) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ma &lt; data.ma; &#125;<br>    <span class="hljs-type">int</span> ma;<br>    <span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 优先级队列</span><br>    <span class="hljs-comment">//priority_queue&lt;Data&gt; queue;</span><br>    <span class="hljs-keyword">using</span> FUNC = function&lt;<span class="hljs-built_in">bool</span>(Data&amp;, Data&amp;)&gt;;<br><br>    priority_queue&lt;<br>        Data, <br>        vector&lt;Data&gt;, <br>        FUNC<br>    &gt; <span class="hljs-built_in">maxHeap</span>([](Data&amp; d1, Data&amp; d2)-&gt;<span class="hljs-type">bool</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> d1.mb &gt; d2.mb;<br>        &#125;);<br><br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>));<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09.C++ 智能指针</title>
    <link href="/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/09.C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/09.C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>本节分为五部分：</p><ol><li>自己实现智能指针</li><li>不带引用计数的智能指针：<strong>auto_ptr</strong>、<strong>scoped_ptr</strong>、<strong>unique_ptr</strong></li><li>带引用计数的智能指针：<strong>shared_ptr</strong>、<strong>weak_ptr</strong></li><li>多线程访问共享对象问题</li><li>自定义删除器</li></ol><p>我们知道除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。</p><p>在 C++ 中，动态内存的管理是用一对运算符完成的：new 和 delete。</p><ul><li>new：在动态内存中为对象分配一块空间并返回一个指向该对象的指针;</li><li>delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。</li></ul><p>动态内存管理经常会出现以下几种问题：</p><ol><li>忘记释放资源，导致资源泄露（常发生内存泄漏问题）。</li><li>尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。</li><li>统一资源释放多次，导致释放野指针，程序崩溃。</li><li>代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间 return 掉了，导致释放资源的代码未被执行到。</li><li>代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到。</li></ol><p>为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。</p><p>主要体现在用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。</p><p>C++ 11 库中，提供了 <strong>带引用计数的智能指针和不带引用计数的智能指针</strong>，本章节主要以原理和应用场景。</p><h2 id="1-自己实现智能指针"><a href="#1-自己实现智能指针" class="headerlink" title="1. 自己实现智能指针"></a>1. 自己实现智能指针</h2><p>智能指针的基本原理：</p><p><strong>利用栈上的对象做出作用域会自动析构</strong> 的特点，把资源释放代码全部放在析构函数中执行，就达到了所谓的智能指针。</p><ol><li><strong>使用裸指针：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">/*其它的代码...*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果这里忘记写 delete，或者上面的代码段中程序 return 掉了，</span><br><span class="hljs-comment">没有执行到这里，都会导致这里没有释放内存，内存泄漏</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>使用智能指针</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">CSmartPtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-comment">// ....</span><br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">CSmartPtr</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* mptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">/*其它的代码...*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">由于 ptr 是栈上的智能指针对象，不管是函数正常执行完，</span><br><span class="hljs-comment">还是运行过程中出现异常，栈上的对象都会自动调用析构函数，</span><br><span class="hljs-comment">在析构函数中进行了 delete 操作，保证释放资源</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码实现了较为简单的智能指针，主要用到两点：</p><p>（1）<strong>智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源。</strong><br>（2）<strong>利用栈上的对象出作用域自动析构这一特点，在智能指针的析构函数中保证释放资源。</strong></p><p>所以，智能指针一般都是定义在栈上的。</p><p>面试题：<strong>能不能在堆上定义智能指针？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">CSmartPtr* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CSmartPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这里定义的 p 虽然是智能指针类型，但它实质上还是一个裸指针，因此 p 还是需要进行手动 delete，又回到了最开始裸指针的问题。</p><p>当然，智能指针要做到和裸指针相似，还得提供裸指针常见的 * <strong>和-&gt;两种运算符的重载函数</strong>，使用起来才真正的和裸指针一样，代码扩充如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">CSmartPtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-comment">// ....</span><br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">CSmartPtr</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>&#125;<br><br><span class="hljs-comment">// 重载函数</span><br><span class="hljs-comment">// 1. *</span><br>T&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-comment">// 2. -&gt;</span><br>T&amp; <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>T* mptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><br>*ptr = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;ptr = &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171446300.png" alt="image.png"></p><p>上面的这个智能指针，使用起来就和普通的裸指针非常相似了，但是它还存在很大的问题，看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 main 函数运行，代码直接崩溃，问题出在<strong>默认的拷贝构造函数做的浅拷贝，两个智能指针都持有一个 <code>new int</code> 资源，ptr2 仙溪沟释放了资源，到了 ptr1 析构的时候，就变成了 delete 野指针，造成程序的崩溃</strong>。所以这里引出来智能指针需要解决的两件事情：</p><ol><li>怎么解决智能指针的浅拷贝问题</li><li>多个智能指针指向同一个资源的时候，怎么保证资源只释放一次，而不是每个智能指针都释放一次，造成代码运行不可预期的严重后果</li></ol><p>查看 C++ 库中的智能指针如何解决的问题。</p><h2 id="2-不带引用计数的智能指针"><a href="#2-不带引用计数的智能指针" class="headerlink" title="2. 不带引用计数的智能指针"></a>2. 不带引用计数的智能指针</h2><p>C++ 库中提供的不带引用计数的智能指针主要包括：<strong>auto_ptr，scoped_ptr，unique_ptr</strong>，下面一一进行介绍。</p><h3 id="1-auto-ptr-源码"><a href="#1-auto-ptr-源码" class="headerlink" title="1. auto_ptr 源码"></a>1. <strong><code>auto_ptr</code></strong> 源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span><br>&#123;<span class="hljs-comment">// wrap an object pointer to ensure destruction</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> _Ty element_type;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">auto_ptr</span><span class="hljs-params">(_Ty * _Ptr = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">: _Myptr(_Ptr)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// construct from object pointer</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里是 auto_ptr 的拷贝构造函数，</span><br><span class="hljs-comment">_Right.release() 函数中，把 _Right 的 _Myptr</span><br><span class="hljs-comment">赋为 nullptr，也就是换成当前 auto_ptr 持有资源地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">auto_ptr</span>(auto_ptr&amp; _Right) <span class="hljs-keyword">noexcept</span><br>: _Myptr(_Right.<span class="hljs-built_in">release</span>())<br>&#123;<span class="hljs-comment">// construct by assuming pointer from _Right auto_ptr</span><br>&#125;<br><br><span class="hljs-function">_Ty * <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return wrapped pointer and give up ownership</span><br>_Ty * _Tmp = _Myptr;<br>_Myptr = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">return</span> (_Tmp);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>_Ty * _Myptr;<span class="hljs-comment">// the wrapped object pointer</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171454384.png" alt="image.png"></p><p>从 <code>auto_ptr</code> 的源码可以看到，只有最后一个 <code>auto_ptr</code> 智能指针持有资源，原来的 <code>auto_ptr</code> 都被赋 <code>nullptr</code> 了，考虑如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">经过拷贝构造，p2 指向了 new int 资源，</span><br><span class="hljs-comment">p1 现在为 nullptr 了，如果使用 p1，相当于</span><br><span class="hljs-comment">访问空指针了，很危险</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>*p1 = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171457368.png" alt="image.png"></p><p>上面的程序，如果用户不了解 <code>auto_ptr</code> 的实现，代码就会出现严重的问题。</p><p>面试题：<strong>auto_ptr 能不能使用在容器当中？</strong>，看下面的代码描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>)));<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>)));<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">30</span>)));<br><br><span class="hljs-comment">// 输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;vec[0] = &quot;</span> &lt;&lt; *vec[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><br><span class="hljs-comment">// 拷贝</span><br>vector&lt;auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec2 = vec;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">这里由于上面做了 vector 容器的拷贝，相当于容器中</span><br><span class="hljs-comment">的每一个元素都进行了拷贝构造，原来 vec 中的智能指针</span><br><span class="hljs-comment">全部为 nullptr了，再次访问就成访问空指针了，程序崩溃</span><br><span class="hljs-comment">*/</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec[0] = &quot;</span> &lt;&lt; *vec[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171502615.png" alt="image.png"></p><p>所以不要在容器中使用 <code>auto_ptr</code>，<strong>C++ 建议最好不要使用 auto_ptr</strong>，除非应用场景非常简单。</p><p>【总结】：<strong>auto_ptr 智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的 auto_ptr 都置为 nullptr，只让最后一个 auto_ptr 持有资源。</strong></p><h3 id="2-scoped-ptr-源码"><a href="#2-scoped-ptr-源码" class="headerlink" title="2. scoped_ptr 源码"></a>2. <strong><code>scoped_ptr</code></strong> 源码</h3><p><strong>源码展示：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_ptr</span> <span class="hljs-comment">// noncopyable</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T * px;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">私有化拷贝构造函数和赋值函数，这样scoped_ptr的智能指针</span><br><span class="hljs-comment">对象就不支持这两种操作，从根本上杜绝浅拷贝的发生</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-built_in">scoped_ptr</span>(scoped_ptr <span class="hljs-type">const</span> &amp;);<br>    scoped_ptr &amp; <span class="hljs-keyword">operator</span>=(scoped_ptr <span class="hljs-type">const</span> &amp;);<br> <br>    <span class="hljs-keyword">typedef</span> scoped_ptr&lt;T&gt; this_type;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">私有化逻辑比较运算符重载函数，不支持scoped_ptr的智能指针</span><br><span class="hljs-comment">对象的比较操作</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>==( scoped_ptr <span class="hljs-type">const</span>&amp; ) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>!=( scoped_ptr <span class="hljs-type">const</span>&amp; ) <span class="hljs-type">const</span>;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> T element_type;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_ptr</span><span class="hljs-params">( T * p = <span class="hljs-number">0</span> )</span>: px( p ) // never throws</span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span><br>        boost::<span class="hljs-built_in">sp_scalar_constructor_hook</span>( px );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BOOST_NO_AUTO_PTR</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">支持从 auto_ptr 构造一个 scoped_ptr 智能指针对象，</span><br><span class="hljs-comment">但是 auto_ptr 因为调用 release() 函数，导致其内部指</span><br><span class="hljs-comment">针为 nullptr</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_ptr</span><span class="hljs-params">( std::auto_ptr&lt;T&gt; p )</span> BOOST_NOEXCEPT : px( p.release() )</span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span><br>        boost::<span class="hljs-built_in">sp_scalar_constructor_hook</span>( px );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*析构函数，释放智能指针持有的资源*/</span><br>    ~<span class="hljs-built_in">scoped_ptr</span>() <span class="hljs-comment">// never throws</span><br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span><br>        boost::<span class="hljs-built_in">sp_scalar_destructor_hook</span>( px );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        boost::<span class="hljs-built_in">checked_delete</span>( px );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">scoped_ptr</span>(scoped_ptr <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>scoped_ptr &amp; <span class="hljs-keyword">operator</span>=(scoped_ptr <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><p>从 <code>scoped_ptr</code> 的源码中可以看到，该智能指针私有化了拷贝构造函数和<br><code>operator=</code> 重载赋值函数，因此<strong>从根本上杜绝了智能指针浅拷贝的发生，所以 scoped_ptr 也是不能用在容器当中的，如果容器互相进行拷贝或者赋值，就会引起 scoped_ptr 对象的拷贝构造和赋值，这是不允许的，代码会提示编译错误</strong>。</p><p><code>auto_ptr</code> 和 <code>scoped_ptr</code> 这一点上的区别，有些资料上用<strong>所有权</strong>的概念来描述，道理是相同的，<strong>auto_ptr 可以任意转移资源的所有权，而 scoped_ptr 不会转移所有权</strong>（因为拷贝构造和赋值被禁止了）。</p><h3 id="3-unique-ptr-源码"><a href="#3-unique-ptr-源码" class="headerlink" title="3. unique_ptr 源码"></a>3. <strong><code>unique_ptr</code></strong> 源码</h3><p>要深入了解 <code>unique_ptr</code>，需要先了解 C++ 的右值引用原理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>,<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Dx</span>&gt;<span class="hljs-comment">// = default_delete&lt;_Ty&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>: <span class="hljs-keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;<br>&#123;<span class="hljs-comment">// non-copyable pointer to an object</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> _Unique_ptr_base&lt;_Ty, _Dx&gt; _Mybase;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Mybase::pointer pointer;<br><span class="hljs-keyword">typedef</span> _Ty element_type;<br><span class="hljs-keyword">typedef</span> _Dx deleter_type;<br><br><span class="hljs-comment">/*提供了右值引用的拷贝构造函数*/</span><br><span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; _Right) <span class="hljs-keyword">noexcept</span><br>: _Mybase(_Right.<span class="hljs-built_in">release</span>(),<br>_STD forward&lt;_Dx&gt;(_Right.<span class="hljs-built_in">get_deleter</span>()))<br>&#123;<span class="hljs-comment">// construct by moving _Right</span><br>&#125;<br><br><span class="hljs-comment">/*提供了右值引用的operator=赋值重载函数*/</span><br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; _Right) <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// assign by moving _Right</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Right))<br>&#123;<span class="hljs-comment">// different, do the move</span><br><span class="hljs-built_in">reset</span>(_Right.<span class="hljs-built_in">release</span>());<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>() = _STD forward&lt;_Dx&gt;(_Right.<span class="hljs-built_in">get_deleter</span>());<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">交换两个unique_ptr智能指针对象的底层指针</span><br><span class="hljs-comment">和删除器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_ptr&amp; _Right)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// swap elements</span><br>_Swap_adl(<span class="hljs-keyword">this</span>-&gt;_Myptr(), _Right._Myptr());<br>_Swap_adl(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>(), _Right.<span class="hljs-built_in">get_deleter</span>());<br>&#125;<br><br><span class="hljs-comment">/*通过自定义删除器释放资源*/</span><br>~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// destroy the object</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">pointer</span>())<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>()(<span class="hljs-built_in">get</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*unique_ptr提供-&gt;运算符的重载函数*/</span><br>_NODISCARD pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// return pointer to class object</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;_Myptr());<br>&#125;<br><br><span class="hljs-comment">/*返回智能指针对象底层管理的指针*/</span><br><span class="hljs-function">_NODISCARD pointer <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return pointer to object</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;_Myptr());<br>&#125;<br><br><span class="hljs-comment">/*提供bool类型的重载，使unique_ptr对象可以</span><br><span class="hljs-comment">直接使用在逻辑语句当中，比如if,for,while等*/</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// test for non-null pointer</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">pointer</span>());<br>&#125;<br>    <br>    <span class="hljs-comment">/*功能和auto_ptr的release函数功能相同，最终也是只有一个unique_ptr指针指向资源*/</span><br><span class="hljs-function">pointer <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// yield ownership of pointer</span><br>pointer _Ans = <span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">this</span>-&gt;_Myptr() = <span class="hljs-built_in">pointer</span>();<br><span class="hljs-keyword">return</span> (_Ans);<br>&#125;<br><br><span class="hljs-comment">/*把unique_ptr原来的旧资源释放，重置新的资源_Ptr*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(pointer _Ptr = pointer())</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// establish new pointer</span><br>pointer _Old = <span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">this</span>-&gt;_Myptr() = _Ptr;<br><span class="hljs-keyword">if</span> (_Old != <span class="hljs-built_in">pointer</span>())<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>()(_Old);<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">删除了unique_ptr的拷贝构造和operator=赋值函数，</span><br><span class="hljs-comment">因此不能做unique_ptr智能指针对象的拷贝构造和</span><br><span class="hljs-comment">赋值，防止浅拷贝的发生</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从源码中可以看出，<code>unique_ptr</code> 有一点和 <code>scoped_ptr</code> 做的一样，就是<strong>去掉了拷贝构造函数和 <code>operator=</code> 赋值重载函数，静止了用于对 unique_ptr 进行显示的拷贝和赋值，放置智能指针浅拷贝问题的发生。</strong></p><p><strong>但是 unique_ptr 提供了带右值引用参数的拷贝构造和赋值</strong>，也就是说，<code>unique_ptr</code> 智能指针可以通过右值引用进行拷贝构造和赋值操作，或者在产生 <code>unique_ptr</code> 临时对象的地方，如把 <code>unique_ptr</code> 作为函数的返回值时，示例代码如下：</p><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// 转换为 优质引用</span><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br>ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">test_uniqueptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-keyword">return</span> ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">此处调用 test_uniqueptr 函数，在 return ptr1 代码处，</span><br><span class="hljs-comment">调用右值引用的拷贝构造函数，由 ptr1 拷贝构造 ptr</span><br><span class="hljs-comment">*/</span><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = <span class="hljs-built_in">test_uniqueptr</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unique_ptr</code> 还提供了 reset 重置资源，swap 交换资源等函数，也经常会使用到。</p><p><strong>可以看到，unique_ptr 从名字就可以看出来，最终也是只能有一个该智能指针引用资源，因此建议在使用不带引用计数的智能指针时，可以优先选择 unique_ptr 智能指针</strong>。</p><h2 id="3-带引用计数的智能指针"><a href="#3-带引用计数的智能指针" class="headerlink" title="3. 带引用计数的智能指针"></a>3. 带引用计数的智能指针</h2><p>带引用计数的智能指针可以实现<strong>多个智能指针管理同一个资源。</strong> 通过给每个被管理的资源匹配一个<strong>引用计数</strong>来实现。当新增一个智能指针指向该资源时，引用计数 +1，当减少一个智能指向该资源是，引用计数 -1，知道引用计数为 0 时，资源被释放掉。由最后一个智能指针的析构函数来处理资源的释放问题，这就是引用计数的概念。</p><ul><li>带引用计数：多个智能指针可以管理同一个资源</li><li>带引用计数：给每一个对象资源，匹配一个引用计数</li></ul><p><strong>智能指针 -&gt; 引用资源的时候 -&gt; 引用计数 +1</strong></p><p><strong>智能指针 -&gt; 不适用资源的时候 -&gt; 引用计数 -1 -&gt;  !&#x3D; 0 不释放资源，为 0 则释放资源</strong></p><p>库里面的 <code>shared_ptr</code> 和 <code>weak_ptr</code> 引用计数的加减是线程安全的，因为用 atomic 定义了引用计数。</p><p><strong>计数实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现计数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCnt</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数初始化</span><br><span class="hljs-built_in">RefCnt</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-keyword">if</span> (mptr != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>mcount = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现增加和减少引用方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRef</span><span class="hljs-params">()</span> </span>&#123; mcount++; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delRef</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> --mcount; &#125;<br><br><span class="hljs-keyword">private</span>:<br>T* mptr;<br><span class="hljs-type">int</span> mcount;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>智能指针类：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现智能指针</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数 - 初始化</span><br><span class="hljs-built_in">CSmartPtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-comment">// 调用引用计数</span><br>mpRefCnt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RefCnt</span>&lt;T&gt;(mptr);<br>&#125;<br><span class="hljs-comment">/*CSmartPtr(const Csmartptr&lt;T&gt; &amp;src) &#123; mptr = new T(*src .mptr) ; &#125;*/</span><br><span class="hljs-comment">// 析构函数 - 释放内存</span><br>~<span class="hljs-built_in">CSmartPtr</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (mpRefCnt-&gt;<span class="hljs-built_in">delRef</span>() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>mptr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 重载函数</span><br>T&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br>T* <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> mptr; &#125;<br><br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">CSmartPtr</span>(CSmartPtr&lt;T&gt;&amp; src)<br>: <span class="hljs-built_in">mptr</span>(src.mptr)<br>, <span class="hljs-built_in">mpRefCnt</span>(src.mpRefCnt)<br>&#123;<br><span class="hljs-keyword">if</span> (mptr != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>mpRefCnt-&gt;<span class="hljs-built_in">addRef</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 赋值重载函数</span><br>CSmartPtr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CSmartPtr&lt;T&gt;&amp; src)<br>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断计时器</span><br><span class="hljs-keyword">if</span> (mpRefCnt-&gt;<span class="hljs-built_in">delRef</span>() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>&#125;<br><br><span class="hljs-comment">// 重新赋值</span><br>mptr = src.mptr;<br>mpRefCnt = src.mpRefCnt;<br>mpRefCnt-&gt;<span class="hljs-built_in">addRef</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向资源的指针</span><br>T* mptr;<br><span class="hljs-comment">// 指向该资源引用计数对象的指针</span><br>RefCnt&lt;T&gt;* mpRefCnt;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>main 函数测试：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 普通初始化</span><br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// 拷贝构造函数初始化</span><br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br><span class="hljs-comment">// 初始化</span><br>CSmartPtr&lt;<span class="hljs-type">int</span>&gt; ptr3;<br><span class="hljs-comment">// 复制构造函数</span><br>ptr3 = ptr2;<br><br><span class="hljs-comment">// 赋值</span><br>*ptr1 = <span class="hljs-number">20</span>;<br><br>cout &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *ptr3 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171609802.png" alt="image.png"></p><h3 id="1-shared-ptr-实现"><a href="#1-shared-ptr-实现" class="headerlink" title="1. shared_ptr 实现"></a>1. <strong><code>shared_ptr</code></strong> 实现</h3><p>内部大概实现：每次复制，多一个共享同处资源的 <code>shared_ptr</code> 时，计数 +1。每次释放 <code>shared_ptr</code> 时，计数 -1。<br>当 shared 计数为 0 时，则证明所有指向同一处资源的 <code>shared_ptr</code> 们全都释放了，则随即释放该资源（还会释放 new 出来的 SharedPtrControlBlock）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//shared计数放在这个结构体里面，实际上结构体里还应该有另一个weak计数。下文介绍weak_ptr时会解释。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedPtrControlBlock</span><br>&#123;　　<br>  <span class="hljs-type">int</span> shared_count;<br>&#125;;<br><span class="hljs-comment">//大概长这个样子（简化版）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span><br>&#123;　　<br>  T* ptr;　　<br>  SharedPtrControlBlock* count;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>shared_ptr 是强智能指针，可以改变资源的引用计数</strong></p><p>循环引用问题，造成 new 出来的资源无法释放，资源泄露</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>shared_ptr&lt;B&gt; ptrb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>shared_ptr&lt;A&gt; ptra;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br><br>pa-&gt;ptrb = pb;<br>pb-&gt;ptra = pa;<br><br>cout &lt;&lt; pa.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">//打印引用计数</span><br>cout &lt;&lt; pb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171614731.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171614091.png" alt="image.png"></p><ol><li>首先，初始化时：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br></code></pre></td></tr></table></figure><p><code>shared_ptr</code> 创建后，栈上的指针指向了对应的对象上，时期计数 +1。</p><ol start="2"><li>其次，指向</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">pa-&gt;ptrb = pb;<br>pb-&gt;ptra = pa;<br></code></pre></td></tr></table></figure><p>指针互相指向，其计数器又 +1。</p><p><strong>这就是交叉引用问题。！！！！</strong></p><ol start="3"><li>最后，析构，无法释放对象中互相引用的内存。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171626154.png" alt="image.png"></p><p>如下表所示是 <code>shared_ptr</code> 特有的操作：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171627469.png" alt="image.png"></p><p>如何解决循环引用问题？</p><ul><li>定义对象的时候，用强智能指针；引用对象的地方，使用弱智能指针</li><li><code>weak_ptr</code> 之所以可以打破循环引用，是因为：将一个 <code>weak_ptr</code> 绑定到一个 <code>shared_ptr</code> 不会改变 <code>shared_ptr</code> 的引用计数</li></ul><h3 id="2-weak-ptr"><a href="#2-weak-ptr" class="headerlink" title="2. weak_ptr"></a>2. <strong><code>weak_ptr</code></strong></h3><p><code>weak_ptr</code> 是为了辅助 <code>shared_ptr</code> 的存在，它只提供了对管理对象的一个访问手段，同时也可以实时动态地知道指向的对象是否存活。</p><p>（只有某个对象的访问权，而没有它的生命控制权 即是 弱引用，所以 <code>weak_ptr</code> 是一种弱引用型指针）</p><p><strong>内部大概实现：</strong></p><ul><li>计数区域(SharedPtrControlBlock)结构体引进新的 int 变量 <code>weak_count</code>，来作为弱引用计数。</li><li>每个 <code>weak_ptr</code> 都占指针的两倍空间，一个装着原始指针，一个装着计数区域的指针（和 <code>shared_ptr</code> 一样的成员）。</li><li><code>weak_ptr</code> 可以由一个 <code>shared_ptr</code> 或者另一个 <code>weak_ptr</code> 构造。</li><li><code>weak_ptr</code> 的构造和析构不会引起 <code>shared_count</code> 的增加或减少，只会引起 <code>weak_count</code> 的增加或减少。</li></ul><p>被管理资源的释放只取决于 shared 计数，当 shared 计数为0，才会释放被管理资源，也就是说 <strong>weak_ptr 不控制资源的生命周期</strong>。</p><p>但是计数区域的释放却取决于 shared 计数和 weak 计数，当两者均为 0 时，才会释放计数区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//shared引用计数和weak引用计数</span><br><span class="hljs-comment">//之前的计数区域实际最终应该长这个样子</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedPtrControlBlock</span><br>&#123;　　<br>   <span class="hljs-type">int</span> shared_count;　　<br>   <span class="hljs-type">int</span> weak_count;<br>&#125;;<br><span class="hljs-comment">//大概长这个样子（简化版）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">weak_ptr</span><br>&#123;　　<br>   T* ptr;　　<br>   SharedPtrControlBlock* count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>弱智能指针 <code>weak_ptr</code> 区别于 <code>shared_ptr</code> 之处在于：</p><ol><li><code>weak_ptr</code> 不会改变资源的引用计数，只是一个观察者的角色，通过观察 <code>shared_ptr</code> 来判定资源是否存在</li><li><code>weak_ptr</code> 持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</li><li><code>weak_ptr</code> 没有提供常用的指针操作，无法直接访问资源，需要先通过 lock方法提升为 <code>shared_ptr</code> 强智能指针，才能访问资源</li></ol><p>解决问题方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>weak_ptr&lt;B&gt; _ptrb; <span class="hljs-comment">// 指向B对象的弱智能指针。引用对象时，用弱智能指针</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>weak_ptr&lt;A&gt; _ptra; <span class="hljs-comment">// 指向A对象的弱智能指针。引用对象时，用弱智能指针</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 定义对象时，用强智能指针</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptra</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<span class="hljs-comment">// ptra指向A对象，A的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">ptrb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<span class="hljs-comment">// ptrb指向B对象，B的引用计数为1</span><br><span class="hljs-comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变</span><br>ptra-&gt;_ptrb = ptrb;<br><span class="hljs-comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变</span><br>ptrb-&gt;_ptra = ptra;<br><br>cout &lt;&lt; ptra.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 打印结果:1</span><br>cout &lt;&lt; ptrb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 打印结果:1</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span><br><span class="hljs-comment">B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象</span><br><span class="hljs-comment">被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>weak_ptr</code> 是弱智能指针，不会改变资源的引用计数</p><p><code>weak_ptr</code> -&gt; (观察）<code>shared_ptr</code> -&gt;（管理） 资源（内存）</p><p><strong>注意：</strong></p><p><code>weak_ptr</code> 只是一个观察者，它并不能直接操纵资源，没有重载 <code>-&gt;</code> 和<code>*</code>  运算符，所以不能 <code>-&gt;</code> 这样输出，要用 lock 返回 <code>shared_ptr</code> 类型才能用 <code>-&gt;</code></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171631672.png" alt="image.png"></p><h2 id="4-多线程访问共享对象问题"><a href="#4-多线程访问共享对象问题" class="headerlink" title="4. 多线程访问共享对象问题"></a>4. 多线程访问共享对象问题</h2><p><strong>强弱智能指针解决的另一问题：多线程访问共享对象的线程安全问题</strong></p><p>有一个用 C++ 写的开源网络库，muduo 库，作者陈硕</p><p>该源码中对于智能指针的应用非常优秀，其中借助 <code>shared_ptr</code> 和 <code>weak_ptr</code> 解决了这样一个问题，多线程访问共享对象的线程安全问题。</p><p>解释如下：线程 A 和线程 B 访问一个共享的对象，如果线程 A 正在析构这个对象的时候，线程 B 又要调用该共享对象的成员方法，此时可能线程 A 已经把对象析构完了，线程 B 再去访问该对象，就会发生不可预期的错误。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span><br><span class="hljs-built_in">Test</span>() <br>:_ptr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 析构Test对象，释放_ptr指向的堆内存</span><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> _ptr;<br>_ptr = <span class="hljs-literal">nullptr</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 该show会在另外一个线程中被执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *_ptr &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* <span class="hljs-keyword">volatile</span> _ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadProc</span><span class="hljs-params">(Test* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 睡眠两秒，此时main主线程已经把Test对象给delete析构掉了</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">此时当前线程访问了main线程已经析构的共享对象，结果未知，隐含bug。</span><br><span class="hljs-comment">此时通过p指针想访问Test对象，需要判断Test对象是否存活，如果Test对象</span><br><span class="hljs-comment">存活，调用show方法没有问题；如果Test对象已经析构，调用show有问题！</span><br><span class="hljs-comment">*/</span><br>p-&gt;<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在堆上定义共享对象</span><br>Test* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-comment">// 使用C++11的线程类，开启一个新线程，并传入共享对象的地址p</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, p)</span></span>;<br><br><span class="hljs-comment">// 在main线程中析构Test共享对象</span><br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">// 等待子线程运行结束</span><br>t1.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，发现在 main 主线程已经 delete 析构 Test 对象以后，子线程 threadProc 再去访问 Test 对象的 show 方法，无法打印出 <code>*_ptr</code> 的值 20。可以用 <code>shared_ptr</code> 和 <code>weak_ptr</code> 来解决多线程访问共享对象的线程安全问题，上面代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span><br><span class="hljs-built_in">Test</span>() :_ptr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 析构Test对象，释放_ptr指向的堆内存</span><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> _ptr;<br>_ptr = <span class="hljs-literal">nullptr</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 该show会在另外一个线程中被执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *_ptr &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* <span class="hljs-keyword">volatile</span> _ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadProc</span><span class="hljs-params">(weak_ptr&lt;Test&gt; pw)</span> <span class="hljs-comment">// 通过弱智能指针观察强智能指针</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 睡眠两秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升</span><br><span class="hljs-comment">为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存</span><br><span class="hljs-comment">的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象</span><br><span class="hljs-comment">已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。</span><br><span class="hljs-comment">*/</span><br>shared_ptr&lt;Test&gt; ps = pw.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>ps-&gt;<span class="hljs-built_in">show</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在堆上定义共享对象</span><br><span class="hljs-function">shared_ptr&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;<br><span class="hljs-comment">// 在main线程中析构Test共享对象</span><br><span class="hljs-comment">// 等待子线程运行结束</span><br>t1.<span class="hljs-built_in">join</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，show 方法可以打印出 20，因为 main 线程调用了 <code>t1.join()</code> 方法等待子线程结束，此时 pw 通过 lock 提升为 ps 成功，见上面代码示例。</p><p>如果设置 t1 为分离线程，让 main 主线程结束，p 智能指针析构，进而把 Test 对象析构，此时 show 方法已经不会被调用，因为在 threadProc 方法中，pw 提升到 ps 时，lock 方法判定 Test 对象已经析构，提升失败！main 函数代码可以如下修改测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在堆上定义共享对象</span><br><span class="hljs-function">shared_ptr&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;<br><span class="hljs-comment">// 在main线程中析构Test共享对象</span><br><span class="hljs-comment">// 设置子线程分离</span><br>t1.<span class="hljs-built_in">detach</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该 main 函数运行后，最终的 threadProc 中，show 方法不会被执行到。<strong>以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用</strong>。</p><h2 id="5-自定义删除器"><a href="#5-自定义删除器" class="headerlink" title="5. 自定义删除器"></a>5. 自定义删除器</h2><p>在用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会 delete 释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如：打开的文件，此时对于文件指针的关闭，就不能用 delete 了，这时需要自定义智能指针释放资源的方式，先看看 <code>unique_ptr</code> 智能指针的析构函数代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// destroy the object</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">pointer</span>())<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>()(<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// 这里获取底层的删除器，进行函数对象的调用</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 <code>unique_ptr</code> 的析构函数可以看到，如果要实现一个自定义的删除器，实际上就是定义一个函数对象而已，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDeleter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 删除器负责删除资源的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE* pf)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fclose</span>(pf);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 由于用智能指针管理文件资源，因此传入自定义的删除器类型FileDeleter</span><br><span class="hljs-function">unique_ptr&lt;FILE, FileDeleter&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>))</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这种方式需要定义额外的函数对象类型，不推荐，可以用 C++11 提供的函数对象 function 和 lambda 表达式更好的处理自定义删除器，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 自定义智能指针删除器，关闭文件资源</span><br>unique_ptr&lt;FILE, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <br><span class="hljs-built_in">filePtr</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), [](FILE *pf)-&gt;<span class="hljs-type">void</span>&#123;<span class="hljs-built_in">fclose</span>(pf);&#125;);<br><br><span class="hljs-comment">// 自定义智能指针删除器，释放数组资源</span><br>unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt;<br><span class="hljs-built_in">arrayPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], [](<span class="hljs-type">int</span> *ptr)-&gt;<span class="hljs-type">void</span> &#123;<span class="hljs-keyword">delete</span>[]ptr; &#125;);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>想进一步了解智能指针，可以查看智能指针的源码实现，或者看 muduo 网络库的源码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08.C++ 优化</title>
    <link href="/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/08.C++%20%E4%BC%98%E5%8C%96/"/>
    <url>/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/08.C++%20%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>本节分为六部分：</p><ol><li>对象使用时调用了哪些方法</li><li>函数使用时调用了哪些方法</li><li>三条对象优化规则</li><li>右值引用</li><li>move 移动语义</li><li>forward 完美转义</li></ol><h3 id="1-对象使用时调用了哪些方法"><a href="#1-对象使用时调用了哪些方法" class="headerlink" title="1. 对象使用时调用了哪些方法"></a>1. 对象使用时调用了哪些方法</h3><p><strong>C++ 编译器对于对象构造的优化，用临时对象生成新对象的时候，临时对象不产生了，直接构建新对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ma</span>(a)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(int)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) :<span class="hljs-built_in">ma</span>(t.ma)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>        ma = t.ma;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;1.Test t1;&quot;</span> &lt;&lt; endl;<br>    Test t1;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n2.Test t2(t1)&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n3.Test t3 = t1;&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    Test t3 = t1;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n4.Test t4 = Test(20);&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    C++ 编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象</span><br><span class="hljs-comment">    就不产生了，直接构造新对象就可以了</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 和Test t4(20);没有区别的！ 仅调用一次默认构造函数</span><br>    Test t4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">20</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308170951985.png" alt="image.png"></p><p><strong>调用赋值函数，因为t4原本已存在</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n5. t4 = t2;&quot;</span> &lt;&lt; endl;<br>t4 = t2;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171001411.png" alt="image.png"></p><p><strong>显式生成临时对象，临时对象生成后，给 t4 赋值,出语句后，临时对象析构 (默认构造函数，赋值运算符，析构函数)</strong></p><p>用临时对象赋值给已存在的对象的时候，要产生临时对象，再调用 <code>operator=</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n6. t4 = Test(20);&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 显式生成临时对象,临时对象生成后</span><br><span class="hljs-comment">// 给t4赋值,出语句后，临时对象析构 (默认构造函数，赋值运算符，析构函数)</span><br>t4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171003567.png" alt="image.png"></p><p><strong>构造函数完成类型转换。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"> cout &lt;&lt; <span class="hljs-string">&quot;\n7.t4 = (Test)30;&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">/************************************************************************/</span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">把其他类型转成类类型的时候，编译器就看这个类的类型</span><br><span class="hljs-comment">有没有合适的构造函数 把整型转成 Test，就看这个类的类型有没有</span><br><span class="hljs-comment">    带 int 类型参数的构造函数 ，有，就可以显式生成临时对象，然后</span><br><span class="hljs-comment">    赋值给 t4 出语句后，临时对象析构</span><br><span class="hljs-comment">*/</span><span class="hljs-comment">/************************************************************************/</span><br><span class="hljs-comment">// 把 30 强转成 Test 类型 int-&gt;Test(int)  同 t4 = Test(20);</span><br>t4 = (Test)<span class="hljs-number">30</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;\n8.t4 = 40;&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 隐式生成临时对象,然后赋值给t4，出语句后，临时对象析构  同7</span><br>t4 = <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171006393.png" alt="image.png"></p><p><strong>临时对象生存周期：所在的语句</strong></p><p>而引用就是别名，相当于给这块内存又给了个名字，所以用引用来引用临时对象，临时对象的生命周期就变成引用变量的生命周期了。</p><p>所以用指针指向临时变量是不安全的，而用引用引用临时对象是安全的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n9. Test *p = &amp;Test(40);&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 指针指向临时对象，这个临时对象肯定是要生成的</span><br>Test* p = &amp;<span class="hljs-built_in">Test</span>(<span class="hljs-number">40</span>);<br><span class="hljs-comment">// 然后p指向这个临时对象的地址</span><br><span class="hljs-comment">// 出语句后，临时对象析构 </span><br><span class="hljs-comment">// 此时p指向的是一个已经析构的临时对象，p相当于野指针了</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n10. const Test &amp;ref = Test(50);&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 引用一个临时对象，这个临时对象也是要生成的</span><br><span class="hljs-type">const</span> Test&amp; ref = <span class="hljs-built_in">Test</span>(<span class="hljs-number">50</span>);<br><span class="hljs-comment">// 出语句后，临时对象不析构，因为引用相当于是别名，临时对象出语句析构是因为没有名字 </span><br><span class="hljs-comment">// 用引用变量引用临时对象是安全的，临时对象就是有名字了，临时对象的生存周期就变成引用变量的</span><br><span class="hljs-comment">// 生存周期了。引用变量是这个函数的局部变量，return完，这个临时对象才析构 </span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171011279.png" alt="image.png"></p><p><strong>程序运行，对象构造顺序以及背后调用总结</strong></p><ul><li>先全局</li><li>再进入 main</li></ul><p><strong>注意：</strong></p><ul><li>静态局部变量，内存分配是在程序运行之前就分配好的，因为有初值的静态局部变量存储在 <code>.data</code> 区，<code>.data</code> 区的内存是事先就分配好的；但是静态局部变量的初始化（对象的构造）是在运行到它的时候才初始化，<code>.data</code> 区析构的时候是程序结束（main 结束）的时候析构</li><li>new 比 malloc 多的：new 不仅分配内存，还构建对象；delete 比 free 多的：delete 不仅释放内存，释放之前先调用析构函数。</li></ul><p><strong>对象底层调用代码示例：（注释是构造顺序与底层调用的方法）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//因为a,b有默认值所以构造有3种方式：</span><br>    <span class="hljs-comment">//Test() Test(10) Test(10, 10)</span><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">5</span>)<span class="hljs-comment">//构造函数 </span><br>        :<span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(int, int)：&quot;</span> &lt;&lt; ma &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; mb &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<span class="hljs-comment">//析构函数 </span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Test()：&quot;</span> &lt;&lt; ma &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; mb &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; src)<span class="hljs-comment">//拷贝构造函数 </span><br>        :<span class="hljs-built_in">ma</span>(src.ma), <span class="hljs-built_in">mb</span>(src.mb)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; src)<span class="hljs-comment">//赋值函数 </span><br>    &#123;<br>        ma = src.ma;<br>        mb = src.mb;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ma;<br>    <span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-comment">// 在mian函数之前构造，在main函数结束后释放，存储在.data段</span><br><span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n---------------------------main()&quot;</span> &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 1.Test t2(20,20); &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 2.Test t3 = t2&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    Test t3 = t2;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 3.Test t3 = t2&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 第一次运行到它才初始化</span><br>    <span class="hljs-type">static</span> Test t4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 4 t2 = (Test)(50, 50);&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// (50,50)是逗号表达式，(表达式1，表达式2，表达式n)</span><br>    <span class="hljs-comment">// (50,50)的最后的结果是最后一个表达式n的结果 50</span><br>    <span class="hljs-comment">// (50, 50) =  (Test)50;</span><br>    t2 = (Test)(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);    <span class="hljs-comment">// Test(int,int) operator= 出语句调用~Test()</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 5  Test* p1 = new Test(70, 70);&quot;</span> &lt;&lt; endl;<br>    Test* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">70</span>, <span class="hljs-number">70</span>);    <span class="hljs-comment">// Test(int,int) 要调用delete才析构对象</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 6  Test* p2 = new Test[2];&quot;</span> &lt;&lt; endl;<br>    Test* p2 = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">2</span>];         <span class="hljs-comment">// Test(int,int) Test(int,int) 要调用delete才析构对象</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 7  Test* p3 = &amp;Test(80, 80);&quot;</span> &lt;&lt; endl;<br>    Test* p3 = &amp;<span class="hljs-built_in">Test</span>(<span class="hljs-number">80</span>, <span class="hljs-number">80</span>);       <span class="hljs-comment">// Test(int,int) 出语句调用~Test()</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 8  const Test&amp; p4 = Test(90, 90);&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">const</span> Test&amp; p4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">90</span>, <span class="hljs-number">90</span>);  <span class="hljs-comment">// Test(int,int)</span><br><br>    <span class="hljs-comment">// ~Test()</span><br>    <span class="hljs-keyword">delete</span> p1;<br>    <span class="hljs-comment">// ~Test() ~Test()</span><br>    <span class="hljs-keyword">delete</span>[]p2;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n---------------------------finish&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Test <span class="hljs-title">t5</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span></span>;<span class="hljs-comment">//Test(int, int)</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171023620.png" alt="image.png"></p><h2 id="2-函数使用时调用了哪些方法"><a href="#2-函数使用时调用了哪些方法" class="headerlink" title="2. 函数使用时调用了哪些方法"></a>2. 函数使用时调用了哪些方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//有默认值，可以有2种构造方式：Test()  Test(20)</span><br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ma</span>(data)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Test(int):&quot;</span> &lt;&lt;  ma &lt;&lt;  endl;<br>  &#125;<br>  ~<span class="hljs-built_in">Test</span>()<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; ma &lt;&lt;  endl;<br>  &#125;<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test &amp;t) :<span class="hljs-built_in">ma</span>(t.ma)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test &amp;t)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>    ma = t.ma;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ma; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> ma;<br>&#125;;<br> <br><span class="hljs-function">Test <span class="hljs-title">GetObject</span><span class="hljs-params">(Test t)</span></span><br><span class="hljs-function"></span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------GetObject1 \n&quot;</span>;<br>  <span class="hljs-type">int</span> val = t.<span class="hljs-built_in">getData</span>();<br>  <span class="hljs-function">Test <span class="hljs-title">tmp</span><span class="hljs-params">(val)</span></span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------GetObject2 \n&quot;</span>;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Test t1;<span class="hljs-comment">//1、调用带整型参数的构造函数 </span><br>  Test t2;<span class="hljs-comment">//2、调用带整型参数的构造函数</span><br>  <br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------main GetObject1 \n&quot;</span>;<br>  t2 = <span class="hljs-built_in">GetObject</span>(t1);<span class="hljs-comment">//函数调用</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------main GetObject2 \n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）实参传递给形参：调用 <code>Test(const Test&amp;)</code> 拿 t1 拷贝构造形参 t。<br>（2）调用 <code>Test(int)</code> 的构造，构造 tmp 对象。<br>（3）<code>return tmp;</code> tmp 和 t2 是两个不同函数栈帧上的对象，是不能直接进行赋值的 GetObject 函数完成调用时 tmp 对象作为局部对象就析构 ，为了把返回值带出来， 在 <code>return tmp;</code> 这里，首先要 在main 函数栈帧上构建一个临时对象，目的就是把 tmp 对象带出来。<br>（4）调用 <code>Test(const Test&amp;)</code>，tmp 拷贝构造 main 函数栈帧上的临时对象<br>（5）出 GetObject 作用域，tmp 析构。<br>（6）形参 t 对象析构。<br>（7）<code>operator =</code>，把 main 函数刚才构建的临时对象赋值给 t2，临时对象没名字，出了语句就要析构。<br>（8）把 main 函数刚才构建的临时对象析构。<br>（9）main 函数结束，t2 析构。<br>（10）t1 析构。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171025935.png" alt="image.png"></p><p>短短的代码调用了11个函数，可以优化。</p><h2 id="3-三条对象优化规则"><a href="#3-三条对象优化规则" class="headerlink" title="3. 三条对象优化规则"></a>3. 三条对象优化规则</h2><ol><li>函数参数传递过程中，对象优先按引用传递，这样可以省去一个形参t的拷贝构造调用，形参没有构建新的对象，出作用域也不用析构了，所以不要按值传！</li><li>函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象</li><li>接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收</li></ol><p>优化 1：<strong>没有 t1 的拷贝构造，形参 t 没有新的对象，出作用域也不用析构。</strong></p><p>省去了形参t的拷贝构造和形参t的析构</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171034781.png" alt="image.png"></p><p> 优化 2：<strong>函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171035711.png" alt="image.png"></p><p>优化 3：<strong>接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171036229.png" alt="image.png"></p><p>函数返回值临时对象给 t2 初始化！用这个临时对象拷贝构造同类型的新对象 t2。<strong>C++ 编译器会进行优化，这个 main 函数栈帧上的临时对象都不产生了，直接构造 t2 对象。也就是 <code>return Test(val);</code> 直接构造 t2 对象了</strong>。</p><p><code>Test t2= GetObject(t1);</code> 在汇编上，除了把 t1 的地址传进去，还把 t2 的地址也传进去了，也压到函数栈帧上，所以 <code>return Test(val);</code> 就可以取到 t2 的地址，就知道在哪块内存上构造一个名为 t2 的对象。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171039594.png" alt="image.png"></p><h2 id="4-右值引用"><a href="#4-右值引用" class="headerlink" title="4. 右值引用"></a>4. 右值引用</h2><p>如果有的应用场景必须返回的是定义过的对象，也必须按赋值的方式来接收函数调用，那优化的后两条规则就用不成了。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171044277.png" alt="image.png"></p><p>解决办法：</p><ul><li>给该类添加一个右值引用拷贝构造函数，函数内部不做资源的分配，而是资源的转移，每当有通过右值（临时对象）来构建对象的时候，就调用右值引用拷贝构造函数。</li></ul><h3 id="1-详解"><a href="#1-详解" class="headerlink" title="1. 详解"></a>1. 详解</h3><ul><li>左值：有名字或有内存</li><li>右值：没名字（临时量）或没内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;b = a;  <span class="hljs-comment">// ok</span><br>    <span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>;  <span class="hljs-comment">//error, 10是纯右值，不能拿普通引用引用它，可以拿常引用引用它</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>;  <span class="hljs-comment">//ok，因为const做了这两件事：int tmp = 10; const int &amp;c= 10;</span><br>    <br>    <span class="hljs-type">int</span> &amp;&amp; d = <span class="hljs-number">10</span>; <span class="hljs-comment">//ok，右值引用，可以把一个右值绑定到右值引用上，底层汇编指令类似于int tmp = 10; int &amp;&amp;d = tmp;</span><br>    <br>    <span class="hljs-comment">//通过const方式不能改右值的值，通过&amp;&amp;右值引用是可以改右值的值的</span><br>    <br>    <span class="hljs-comment">//一个右值引用的变量，本身是一个左值，如int &amp;&amp; d = 10; d本身 是左值，类型是int，变量值是10，所以不能int &amp;&amp;f =d;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>记住两句话：</p><ul><li>常量、数字、临时量、<strong>函数返回值</strong>都是右值，要引用它们就要用右值引用&amp;&amp;，将亡值也属于右值</li><li>一个右值引用的变量，本身是一个左值</li></ul><h3 id="2-提高效率"><a href="#2-提高效率" class="headerlink" title="2. 提高效率"></a>2. 提高效率</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171050183.png" alt="image.png"></p><p>我直接指向你的资源，再把你的指针置为空，你的资源相当于移动给我了</p><p>下图中 tmpStr 匹到的就是右值引用的拷贝构造，因为函数返回值属于右值。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171051588.png" alt="image.png"></p><p><strong>CMyString 的重载加号运算符函数</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171052705.png" alt="image.png"></p><h3 id="3-给容器里拷贝构造对象（笔试题）"><a href="#3-给容器里拷贝构造对象（笔试题）" class="headerlink" title="3. 给容器里拷贝构造对象（笔试题）"></a>3. 给容器里拷贝构造对象（笔试题）</h3><p>vector 提供了左值引用与右值引用的拷贝构造函数，传的是左值就调用左值引用的拷贝构造函数，传的是右值，就调用右值引用的拷贝构造函数。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171053392.png" alt="image.png"></p><h2 id="5-move-移动语义"><a href="#5-move-移动语义" class="headerlink" title="5.  move 移动语义"></a>5.  move 移动语义</h2><p>move：移动语义，<strong>将 val 的类型强转右值引用类型继而可以通过右值引用使用该值，以用于移动语义。</strong></p><p><code>std::move</code> 源码：<code>_Ty</code> 是未定的引用类型，<code>remove_reference_t</code> 用于移除<code>_Ty</code> 的引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data)) &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span> ptr; ptr = <span class="hljs-literal">nullptr</span>; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; src)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl;<br>        ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*src.ptr);<br>    &#125;<br>    <span class="hljs-built_in">A</span>(A&amp;&amp; src)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl;<br>        ptr = src.ptr;<br>        src.ptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* ptr;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;A&gt; vec;<br>    vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------begin&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(i)</span></span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里a是一个左值，因此vec.push_back(a)会调用左值的</span><br><span class="hljs-comment">        拷贝构造函数，用a拷贝构造vector底层数组中的对象</span><br><span class="hljs-comment">        */</span><br>        vec.<span class="hljs-built_in">push_back</span>(a);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------endl&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171105811.png"></p><p>每次循环都需要首先构造 A,调用 A 的默认构造函数，然后 调用左值引用的拷贝构造函数，看上面的代码，<code>A a(i)</code> 在 for 循环中其实算是局部对象，在 <code>vec.push_back(a)</code> 完成后，a 对象调用析构函数。</p><p>在 <code>vec.push_back(a)</code> 时，应该把对象 a 的资源直接移动给 vector 容器底层的对象，也就是调用右值引用参数的拷贝构造函数，怎么做到呢？这时候就用到了带移动语义的 <code>std::move</code> 函数，main 函数代码修改如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;--------------------begin&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i)&#123;<br>  <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(i)</span></span>;<br> <br>  vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(a));<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------endl&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171109450.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD _MSVC_INTRINSIC <span class="hljs-keyword">constexpr</span> <span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，函数参数 <code>T&amp;&amp;</code> 是一个指向模板类型参数的右值引用，通过引用折叠，此参数可以与任何类型的实参匹配（可以传递左值或右值，这是 <code>std::move</code> 主要使用的两种场景)。关于引用折叠如下：</p><p><strong>公式一. <code>X&amp; &amp;</code>、<code>X&amp;&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code> 都折叠成 <code>X&amp;</code>，用于处理左值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>std::<span class="hljs-built_in">move</span>(s) =&gt; std::<span class="hljs-built_in">move</span>(string&amp; &amp;&amp;) =&gt; 折叠后 std::<span class="hljs-built_in">move</span>(string&amp; )<br>此时：T的类型为string&amp;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type为string <br>整个std::move被实例化如下<br>string&amp;&amp; <span class="hljs-built_in">move</span>(string&amp; t) <span class="hljs-comment">//t为左值，移动后不能在使用t</span><br>&#123;<br>    <span class="hljs-comment">//通过static_cast将string&amp;强制转换为string&amp;&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;string&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>公式二、<code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code>，用于处理右值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)) =&gt; std::<span class="hljs-built_in">move</span>(string&amp;&amp;)<br><span class="hljs-comment">//此时：T的类型为string </span><br><span class="hljs-comment">//     remove_reference&lt;T&gt;::type为string </span><br><span class="hljs-comment">//整个std::move被实例如下</span><br>string&amp;&amp; <span class="hljs-built_in">move</span>(string&amp;&amp; t) <span class="hljs-comment">//t为右值</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;string&amp;&amp;&gt;(t);  <span class="hljs-comment">//返回一个右值引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用</p><p><code>remove_reference</code> 是通过类模板的部分特例化进行实现的，其实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//原始的，最通用的版本</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&#123;<br>    <span class="hljs-keyword">typedef</span> T type;  <span class="hljs-comment">//定义T的类型别名为type</span><br>&#125;;<br> <br><span class="hljs-comment">//部分版本特例化，将用于左值引用和右值引用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&gt; <span class="hljs-comment">//左值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&amp;&gt; <span class="hljs-comment">//右值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;   <br>  <br><span class="hljs-comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span><br><span class="hljs-type">int</span> i;<br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::type a;             <span class="hljs-comment">//使用原版本，</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(i)&gt;::type  b;             <span class="hljs-comment">//左值引用特例版本</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">move</span>(i))&gt;::type  b;  <span class="hljs-comment">//右值引用特例版本 </span><br></code></pre></td></tr></table></figure><blockquote><p><code>std::move</code>实现：</p><p>首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。然后我们通过 <code>static_cast&lt;&gt;</code> 进行强制类型转换返回 <code>T&amp;&amp;</code> 右值引用，而 <code>static_cast</code> 之所以能使用类型转换，是通过 <code>remove_refrence::type</code> 模板移除 <code>T&amp;&amp;</code>，<code>T&amp;</code> 的引用，获取具体类型 T。 </p></blockquote><p><code>std::move</code> 函数可以以非常简单的方式将左值引用转换为右值引用</p><ul><li>C++ 标准库使用比如 <code>vector::push_back</code> 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数 <code>push_back</code> 进去就行了,通 <code>std::move</code>，可以避免不必要的拷贝操作。</li><li><code>std::move</code> 是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。</li><li>对指针类型的标准库对象并不需要这么做.</li></ul><p>使用 <code>std::move</code> 后，左值的内容将会被转移，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//摘自https://zh.cppreference.com/w/cpp/utility/move</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::vector&lt;std::string&gt; v;<br>    <span class="hljs-comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span><br>    v.<span class="hljs-built_in">push_back</span>(str);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>    <span class="hljs-comment">//调用移动构造函数，掏空str，掏空后，最好不要使用str</span><br>    v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="hljs-number">0</span>]<br>                                         &lt;&lt; <span class="hljs-string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171158831.png" alt="image.png"></p><h2 id="6-forward-完美转义"><a href="#6-forward-完美转义" class="headerlink" title="6. forward 完美转义"></a>6. forward 完美转义</h2><p><code>std::forward</code> 通常是用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。一个经典的完美转发的场景是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的有 2 点：</p><ul><li>输入参数的类型是 <code>Args&amp;&amp;...</code> ， &amp;&amp; 的作用是引用折叠</li><li><code>std::forward</code> 的模板参数必须是 <code>&lt;Args&gt;</code>，而不能是 <code>&lt;Args...&gt;</code>，这是由于我们不能对 Args 进行解包之后传递给 <code>std::forward</code>，而解包的过程必须在调用 <code>std::forward</code> 之后.</li></ul><p>其实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// FUNCTION TEMPLATE forward</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Ty&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// forward an lvalue as either an lvalue or an rvalue</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg));<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Ty&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// forward an rvalue as an rvalue</span><br><span class="hljs-built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="hljs-string">&quot;bad forward call&quot;</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::remove_reference_t</code> 是一个模板类的类型别名，用于去掉 T 的引用属性。</p><p><strong>实例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> value=<span class="hljs-number">0</span>) : <span class="hljs-built_in">value</span>(value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;construct&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br> <br>   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;a) : <span class="hljs-built_in">value</span>(a.value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;A(const A&amp;a):&quot;</span> &lt;&lt; a.value  &lt;&lt; std::endl;<br>  &#125;<br> <br>   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;&amp;a) : <span class="hljs-built_in">value</span>(a.value) &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;A(const A&amp;&amp;a):&quot;</span> &lt;&lt; a.value &lt;&lt; std::endl;<br>   &#125;<br> <br>  ~<span class="hljs-built_in">A</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;deconstruct&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(A&amp;&amp; a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;完美转发 右值引用： &quot;</span> &lt;&lt; a.value &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(A&amp; a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;完美转发 左值引用： &quot;</span> &lt;&lt; a.value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_forward</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>  <span class="hljs-built_in">test</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-type">float</span> b = <span class="hljs-number">2.1</span>;<br>  <span class="hljs-built_in">test_forward</span>(a, b);<br> <br>  <span class="hljs-built_in">test_forward</span>(std::<span class="hljs-built_in">move</span>(a), b);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>test_forward</code> 第一个参数通过 forward 完美转发到 <code>void test(A&amp; a, double b)</code> 以及 <code>void test(A&amp;&amp; a, double b)；</code></p><p>首先传入左值 <code>test_forward(a,b)</code>  -&gt; 调用 <code>void test(A&amp; a, double b)</code>。</p><p>之后传入传入左值 <code>test_forward(std::move(a),b)</code>  -&gt;调用 <code>void test(A&amp;&amp; a, double b)</code>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171201247.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.C++ STL</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/07.C++%20STL/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/07.C++%20STL/</url>
    
    <content type="html"><![CDATA[<p>本节分为十部分：</p><ol><li>vector 容器</li><li>deque 容器</li><li>list 容器</li><li>vector、deque、list 对比分析</li><li>详解容器适配器</li><li>无序关联容器</li><li>有序关联容器</li><li>迭代器 iterator</li><li>函数对象</li><li>泛型算法和绑定器</li></ol><p><strong>STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。</strong></p><h2 id="1-vector-容器"><a href="#1-vector-容器" class="headerlink" title="1. vector 容器"></a>1. vector 容器</h2><p><strong>vector</strong>：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 </p><p>容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。</p><h3 id="1-使用方法合集"><a href="#1-使用方法合集" class="headerlink" title="1. 使用方法合集"></a>1. 使用方法合集</h3><p><strong>语法结构：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure><p><strong>使用方式：</strong> 使用前包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure><ol><li><strong>增加：</strong></li></ol><ul><li>**<code>push_back()</code>**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。</li><li>**<code>insert(迭代器，迭代器位置)</code>**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。</li></ul><ol start="2"><li><strong>删除：</strong></li></ol><ul><li>**<code>pop_back()</code>**：在容器末尾删除一个元素，时间复杂度O(1)。</li><li>**<code>erase()</code>**：删除it迭代器指向的元素，时间复杂度O(n)。</li></ul><ol start="3"><li><strong>查询：</strong></li></ol><ul><li>**<code>operator[]</code>**：数据下标的随机访问<code>vec[5]</code>，时间复杂度O(1)。</li><li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li><li>**<code>find()\for_each</code>**：泛型算法。</li><li>**<code>foreach</code>**：C++11提供的语法糖，通过迭代器iterator来实现的。</li></ul><ol start="4"><li><strong>常用方法：</strong></li></ol><ul><li>**<code>size()</code>**：返回容器底层有效元素的个数。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>reserve()</code>**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</li><li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li><li>**<code>swap()</code>**：两个容器进行元素交换。</li></ul><h3 id="2-容器使用"><a href="#2-容器使用" class="headerlink" title="2. 容器使用"></a>2. 容器使用</h3><ol><li><strong>对 vector 容器中元素遍历。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector </span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 1. 运算符重载遍历</span><br><span class="hljs-type">int</span> size = vec.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 2. 迭代器遍历</span><br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png" alt="image.png"></p><ol start="2"><li><strong>把 vec 容器中所有偶数全部删除</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector </span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">auto</span> it1 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it1 != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <br>&#123;<br>it1 = vec.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it1++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 2. 迭代器遍历</span><br><span class="hljs-keyword">auto</span> it2 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png" alt="image.png"></p><ol start="3"><li><strong>在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector </span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//vec的operator[]运算符重载函数进行vector遍历</span><br><span class="hljs-type">int</span> size = vec.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>&#123;<br>cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">auto</span> it1 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it1 != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <br>&#123;<br>it1 = vec.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it1++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 迭代器遍历</span><br><span class="hljs-keyword">auto</span> it2 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 添加</span><br><span class="hljs-keyword">for</span> (it2 = vec.<span class="hljs-built_in">begin</span>(); it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br><span class="hljs-keyword">if</span> (*it2 % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>&#123;<br>it2 = vec.<span class="hljs-built_in">insert</span>(it2, *it2<span class="hljs-number">-1</span>);<br>++it2;<br>&#125;<br>&#125;<br><br>it2 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png" alt="image.png"></p><ol start="4"><li><strong>reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</strong></li></ol><p>默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<span class="hljs-comment">// 默认定义的 vector 底层为 0</span><br>vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">// 给 vector 容器预留空间</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果: <code>empty()</code> 是 1 为空，0 为非空。刚开始为空，<code>reserve(20)</code> 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png" alt="image.png"></p><ol start="5"><li><strong>resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。</strong></li></ol><p><code>resize()</code> 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<span class="hljs-comment">//默认定义的vector底层为0</span><br>vec.<span class="hljs-built_in">resize</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png" alt="image.png"></p><h2 id="2-deque-容器"><a href="#2-deque-容器" class="headerlink" title="2. deque 容器"></a>2. deque 容器</h2><p><strong>deque：双端队列容器，底层为动态开辟的二维数组。</strong> **</p><p>一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 <code>oldsize/2</code> 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。</p><h3 id="1-容器结构"><a href="#1-容器结构" class="headerlink" title="1. 容器结构"></a>1. 容器结构</h3><p>其底层为：<strong>动态开辟的二维数组</strong>。</p><p>其有两个宏：<code>MAP_SIZE</code>，为2；<code>QUE_SIZE</code>，为 <code>4096/sizeof(T)</code>，T 为实际的类型。底层有 2 个维度，还有一个 mapper 指针，指向第一维的一维数组，默认大小为<code> MAP_SIZE 2</code>；第二维为动态开辟的 <code>QUE_SIZE</code> 的大小，例如：使用整型时会有1024个元素。</p><p>双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；</p><p>简易的画了一个方向，first 与 last 处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150854875.png" alt="image.png"></p><h3 id="2-扩容方式"><a href="#2-扩容方式" class="headerlink" title="2. 扩容方式"></a>2. 扩容方式</h3><p>当我们元素的不断增加，相应的指示位置向后移动。</p><ul><li>如图 2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150858867.png" alt="image.png"></p><ul><li>如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150902713.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150903312.png" alt="image.png"></p><ul><li>如图5，6；刚才的第二维移动到第一维中间部分(<code>oldsize/2</code>)，方便任何一边的元素改动。若需再次扩容，同理。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150906687.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150909908.png" alt="image.png"></p><h3 id="3-使用方法合集"><a href="#3-使用方法合集" class="headerlink" title="3. 使用方法合集"></a>3. 使用方法合集</h3><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure><ol><li><strong>增加：</strong></li></ol><ul><li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li><li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li><li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(n)。</li></ul><ol start="2"><li><strong>删除：</strong></li></ol><ul><li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li><li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li><li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li></ul><ol start="3"><li><strong>查询：</strong></li></ol><ul><li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li></ul><ol start="4"><li><strong>常用方法：</strong></li></ol><ul><li>**<code>size()</code>**：返回容器底层有效元素的个数。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li><li>**<code>swap()</code>**：两个容器进行元素交换。</li></ul><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>和 vector 实例类似，直接参考 vector 容器实例即可。</p><h2 id="3-list-容器"><a href="#3-list-容器" class="headerlink" title="3. list 容器"></a>3. list 容器</h2><p><strong>list：链表容器，底层数据结构为双向循环链表。</strong></p><h3 id="1-使用方法合集-1"><a href="#1-使用方法合集-1" class="headerlink" title="1. 使用方法合集"></a>1. 使用方法合集</h3><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure><ol><li><strong>增加：</strong></li></ol><ul><li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li><li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li><li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行 <code>insert()</code> 时，要先进行 <code>query()</code> 操作，效率就慢了。</li></ul><ol start="2"><li><strong>删除：</strong></li></ol><ul><li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li><li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li><li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li></ul><ol start="3"><li><strong>查询：</strong></li></ol><ul><li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li></ul><ol start="4"><li><strong>常用方法：</strong></li></ol><ul><li>**<code>size()</code>**：返回容器底层有效元素的个数。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li><li>**<code>swap()</code>**：两个容器进行元素交换。</li></ul><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>使用实例与vector类似。</p><h2 id="4-vector、deque、list-对比分析"><a href="#4-vector、deque、list-对比分析" class="headerlink" title="4. vector、deque、list 对比分析"></a>4. vector、deque、list 对比分析</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150924833.png" alt="image.png"></p><ol><li><strong>deque 底层内存是否是连续的？</strong></li></ol><p>不是，deque 底层是动态开辟的二维数组，第二维都是独立开辟的空间，每一个第二维是连续的，但是所有的二维不是连续的。</p><ol start="2"><li><strong>vector 与 deque 容器之间的区别：</strong></li></ol><ul><li><strong>vector 特点：</strong> 底层是一个动态开辟数组，内存是连续的，2 倍的方式进行扩容。当默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li><li><strong>deque 特点：</strong> 底层为动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容时候(第一维的数组进行 2 倍扩容，原来的第二维的数组放入新扩容的数组中间)，支持前后插入删除为 O(1) 的操作。</li></ul><p><strong>区别：</strong></p><ul><li><strong>底层数据结构不同</strong>：vector 底层为动态开辟的数组，内存是连续的；deque 底层是动态开辟的二维数组空间，内存不连续。</li><li><strong>前中后删除的时间复杂度不同</strong>：它们中间与末尾插入删除一样为 O(1)，但最前面进行元素添加时候 deque 为 O(1)，vector 为 O(n)。</li><li><strong>内存使用效率不同</strong>：vector 低，需要的内存空间必须是连续的；deque 第二维内存空间不一定连续，可以分块进行数据存储，对内存使用效率会更高。</li><li><strong>在中间进行 insert 或者 erase，vector 与 deque 的效率不同</strong>：它们时间复杂度都为 O(n)，但 vecto r内存完全连续，其他元素容易移动；但 deque 内存不连续，元素移动更加麻烦一些，效率不如 vector。</li></ul><ol start="3"><li><strong>vector 与 list 容器之间的区别：</strong></li></ol><ul><li><strong>vector 特点</strong>： 底层是一个动态开辟的数组，内存是连续的，2 倍的方式进行扩容。当我们默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li><li><strong>list 特点</strong>： 底层是一个双向循环链表。</li></ul><p><strong>区别：</strong></p><p><strong>数组与链表区别</strong>：数组增加删除为 O(n)，查询 O(n)，随机访问为 O(1)；链表增加删除一个结点本身为 O(1)，但搜索的时间为 O(n)。如果增加删除使用多，优先使用 list；随机访问使用多，优先使用 vector。</p><h2 id="5-详解容器适配器"><a href="#5-详解容器适配器" class="headerlink" title="5. 详解容器适配器"></a>5. 详解容器适配器</h2><p>容器适配器：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。</p><p><strong>使用容器适配器实现栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Container=deque&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> Stack<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">void</span> <span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; val)<br>&#123;<br>con.<span class="hljs-built_in">push_back</span>(val);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>con.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> con.<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Container con;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>s.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>s.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现成功，相当于栈将 deque 代理了一下，也成为代理模式。push 将底层容器的 <code>push_back</code> 代理了，pop 将底层 <code>pop_back</code> 代理了，栈的 top 将容器底层的 back 代理了。</p><h3 id="1-Stack-栈容器"><a href="#1-Stack-栈容器" class="headerlink" title="1. Stack 栈容器"></a>1. Stack 栈容器</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151017597.png" alt="image.png"></p><p><code>stack&lt;T&gt;</code> 容器适配器中的数据是以 LIFO（Last In First Out） 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。</p><p>上图：展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。</p><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li>**<code>push()</code>**：入栈  </li><li>**<code>pop()</code>**：  出栈 </li><li>**<code>top()</code>**：查看栈顶元素  </li><li>**<code>empty()</code>**：判断栈空  </li><li>**<code>size()</code>**：返回元素个数</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;栈中元素个数:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>s.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151023238.png" alt="image.png"></p><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>只能访问 <code>queue&lt;T&gt;</code> 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。  </p><p>许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO（First In First Out） 准则处理的序列来说，使用 queue 容器适配器都是好的选择。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151024083.png" alt="image.png"></p><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li>**<code>push()</code>**：入栈  </li><li>**<code>pop()</code>**：  出栈 </li><li>**<code>front()</code>**：查看对头元素</li><li>**<code>back()</code>**：查看队尾元素</li><li>**<code>empty()</code>**：判断空  </li><li>**<code>size()</code>**：返回元素个数</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;队列中元素个数:&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151027513.png" alt="image.png"></p><h3 id="3-优先级队列"><a href="#3-优先级队列" class="headerlink" title="3. 优先级队列"></a>3. 优先级队列</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151036304.png" alt="image.png"></p><p><strong>优先级队列：底层数据结构为大根堆。</strong> </p><p>使用库中的优先级队列，需要加上头文件<code>&lt;queue&gt;</code>；<strong>优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。</strong></p><p><strong>常用方法：</strong></p><ul><li>**<code>push()</code>**：入栈  </li><li>**<code>pop()</code>**：  出栈 </li><li>**<code>top()</code>**：查看栈顶元素  </li><li>**<code>empty()</code>**：判断栈空  </li><li>**<code>size()</code>**：返回元素个数</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;优先队列中元素个数:&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据从大到小依次出队，数据越大优先级越高。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151039915.png" alt="image.png"></p><p><strong>问题一：stack 与 queue 第二个模板类型参数依赖 deque，为什么不依赖 vector？</strong></p><ol><li>vector 的初始化内存使用效率太低了，没有 deque 好。</li><li>对于 queue 来说，需要支持尾部插入，头部删除，时间复杂度需要为 O(1)，deque 恰好符合条件，若用 vector 其底层效率太低。</li><li>vector 需要大片的连续内存，而 deque 只需要分段的内存，当存储大量数据时，显然 deuqe 对于内存的利用率更高更好一些。</li></ol><p><strong>问题二：优先级队列为什么底层依赖 vector？</strong></p><p>优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为 i，左孩子为 <code>2i+1</code>，右孩子为 <code>2i+2</code>；大根堆为堆顶，其元素最大，结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的，因此底层依赖 vector；而 deque 的第二维不是连续的，不能使用。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151042363.png" alt="image.png"></p><h2 id="6-无序关联容器"><a href="#6-无序关联容器" class="headerlink" title="6. 无序关联容器"></a>6. 无序关联容器</h2><p><strong>关联容器分为：无序关联容器与有序关联容器，简单对比下：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151043482.png" alt="image.png"></p><p><strong>无序关联容器：底层为哈希表，里面元素无顺序，增删查为O(1)。</strong></p><h3 id="1-单重集合与多重集合"><a href="#1-单重集合与多重集合" class="headerlink" title="1. 单重集合与多重集合"></a>1. 单重集合与多重集合</h3><ul><li><strong>set 集合</strong>：存储的是关键字。<code>[key]</code></li><li><strong>unordered_set</strong>：单重集合；不允许 key 重复。</li><li><strong>unordered_multiset</strong>：多重集合；允许 key 重复。</li></ul><p><strong>包含文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p><p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p><p><strong>使用1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 不允许存储key值重复的元素</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; ++i)<br>&#123;<br><span class="hljs-comment">// 与vector/deque/list插入不同</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 返回key为15的元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151117267.png" alt="image.png"></p><p><strong>使用2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 不允许存储key值重复的元素</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; ++i)<br>&#123;<br><span class="hljs-comment">// 与vector/deque/list插入不同</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 迭代器遍历容器</span><br><span class="hljs-keyword">auto</span> it1 = set1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it1 != set1.<span class="hljs-built_in">end</span>(); ++it1)<br>&#123;<br>cout &lt;&lt; *it1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 按key值删除元素</span><br>set1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> (it1 = set1.<span class="hljs-built_in">begin</span>(); it1 != set1.<span class="hljs-built_in">end</span>();)<br>&#123;<br><span class="hljs-keyword">if</span> (*it1 == <span class="hljs-number">30</span>)<br>&#123;<br><span class="hljs-comment">// 迭代器删除元素</span><br>it1 = set1.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>++it1;<br>&#125;<br>&#125;<br><br>it1 = set1.<span class="hljs-built_in">find</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">if</span> (it1 != set1.<span class="hljs-built_in">end</span>())<br>&#123;<br>set1.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set1)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151119097.png" alt="image.png"></p><p><strong>使用3：unordered_multiset</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 允许存储key值重复的元素</span><br>unordered_multiset&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; ++i)<br>&#123;<br><span class="hljs-comment">// 与vector/deque/list插入不同</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 返回key为15的元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151121798.png" alt="image.png"></p><h3 id="2-单重映射表与多重映射表"><a href="#2-单重映射表与多重映射表" class="headerlink" title="2. 单重映射表与多重映射表"></a>2. 单重映射表与多重映射表</h3><ul><li><strong>map 集合</strong>：存储的是键值对。<code>[key，value]</code></li><li><strong>unordered_map</strong>：单重映射表；不可重复。</li><li><strong>unordered_multimap</strong>：多重映射表；可重复。</li></ul><p><strong>包含文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p><p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p><p><strong>使用1：unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map1;<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;size: &quot;</span> &lt;&lt; map1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">//键值对个数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用2：unordered_multimap</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_multimap&lt;<span class="hljs-type">int</span>,string&gt; map1;<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;张三&quot;</span>));<span class="hljs-comment">//打包成键值对</span><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>,<span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>,<span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;王五&quot;</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;size: &quot;</span> &lt;&lt; map1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">// 键值对个数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用3：查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//map operator[](key) =&gt;value </span><br>cout &lt;&lt; map1[<span class="hljs-number">1000</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map1;<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1020</span>);<span class="hljs-comment">//删除</span><br>map1[<span class="hljs-number">2000</span>] = <span class="hljs-string">&quot;刘帅&quot;</span>;<span class="hljs-comment">//相当于插入</span><br>map1[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;张三2&quot;</span>;<span class="hljs-comment">//相当于修改操作</span><br><br>cout &lt;&lt; map1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">//键值对个数</span><br><span class="hljs-comment">// map operator[](key) =&gt;value 查询</span><br>cout &lt;&lt; map1[<span class="hljs-number">1000</span>] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用4：iterator 查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map1;<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1030</span>, <span class="hljs-string">&quot;赵六&quot;</span>));<br><br><span class="hljs-keyword">auto</span> it1 = map1.<span class="hljs-built_in">find</span>(<span class="hljs-number">1030</span>);<br><span class="hljs-keyword">if</span> (it1 != map1.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it1-&gt;first &lt;&lt; <span class="hljs-string">&quot; value:&quot;</span> &lt;&lt; it1-&gt;second &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-海量数据"><a href="#3-海量数据" class="headerlink" title="3. 海量数据"></a>3. 海量数据</h3><p><strong>案例1：处理海量数据数据查重，经常会使用map。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ARR_LEN = <span class="hljs-number">1000</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[ARR_LEN] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ARR_LEN; i++)<br>&#123;<br>arr[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数</span><br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : arr)<br>&#123;<br><span class="hljs-keyword">auto</span> it = map1.<span class="hljs-built_in">find</span>(k);<br><span class="hljs-keyword">if</span> (it == map1.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//数字没出现过</span><br>&#123;<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(k, <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it-&gt;second++;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">auto</span> it = map1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != map1.<span class="hljs-built_in">end</span>(); ++it)<br>&#123;<br><span class="hljs-keyword">if</span> (it-&gt;second &gt; <span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例2：海量数据去重。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ARR_LEN = <span class="hljs-number">1000</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[ARR_LEN] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ARR_LEN; i++)<br>&#123;<br>arr[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 上面的整数中，将数字进行去重打印</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr)<br>&#123;<br>set.<span class="hljs-built_in">insert</span>(v);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-有序关联容器"><a href="#7-有序关联容器" class="headerlink" title="7. 有序关联容器"></a>7. 有序关联容器</h2><p><strong>有序关联容器：底层为红黑树，里面元素有序，增删查 $O(log^{2n})$。</strong></p><p><strong>包含文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。</li><li>multiset：多重集合，可以存储重复的元素，从小到大元素有序排列。</li><li>map：单重映射表，重复的只出现一次，从小到大元素有序排列。</li><li>multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。</li></ul><p><strong>实例1：set 实例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)<br>&#123;<br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set1)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>实例2：set 存放自定义类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> id, string name)<br>: _id(id)<br>, _name(name)<br>&#123;<br><span class="hljs-comment">// 舒适化列表</span><br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Student&amp; stu) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _id &lt; stu._id;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _id;<br>string _name;<br><span class="hljs-comment">// 友元</span><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Student&amp; str);<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Student&amp; stu)<br>&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; stu._id &lt;&lt; endl;<br>out &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; stu._name;<br><br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;Student&gt; set1;<br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Student</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张文&quot;</span>));<br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Student</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;李广&quot;</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = set1.<span class="hljs-built_in">begin</span>(); it != set1.<span class="hljs-built_in">end</span>(); ++it)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例3：map 实例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>, string name = <span class="hljs-string">&quot;&quot;</span>)<br>:_id(id), _name(name)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _id;<br>string _name;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Student &amp;stu);<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Student &amp;stu)<br>&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class="hljs-string">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, Student&gt; stuMap;<br>stuMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>,<span class="hljs-built_in">Student</span>(<span class="hljs-number">1010</span>,<span class="hljs-string">&quot;张文&quot;</span>)));<br>stuMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>,<span class="hljs-built_in">Student</span>(<span class="hljs-number">1020</span>,<span class="hljs-string">&quot;李广&quot;</span>)));<br>stuMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1030</span>,<span class="hljs-built_in">Student</span>(<span class="hljs-number">1030</span>,<span class="hljs-string">&quot;高阳&quot;</span>)));<br><br><span class="hljs-comment">//stuMap.erase(it) stuMap.erase(1020)</span><br><span class="hljs-comment">//cout &lt;&lt; stuMap[1020] &lt;&lt; endl;</span><br><span class="hljs-keyword">auto</span> it = stuMap.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it!=stuMap.<span class="hljs-built_in">end</span>(); ++it)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-迭代器-iterator"><a href="#8-迭代器-iterator" class="headerlink" title="8. 迭代器 iterator"></a>8. 迭代器 iterator</h2><ol><li>正向迭代器 <code>iterator</code>：输出元素时从第一个到对后一个，既可以读也可修改。</li><li>常量的正向迭代器 <code>const_iterator</code>：输出元素时从第一个到对后一个，只可以读。</li><li>反向迭代器 <code>reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li><li>常量的反向迭代器 <code>const_reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li></ol><p><strong>顺序容器、关联容器，都支持正向迭代器与反向迭代器。</strong></p><h3 id="1-iterator"><a href="#1-iterator" class="headerlink" title="1. iterator"></a>1. iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>*it = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161445442.png" alt="image.png"></p><h3 id="2-const-iterator"><a href="#2-const-iterator" class="headerlink" title="2. const_iterator"></a>2. const_iterator</h3><p><strong>底层原理：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// const_iterator &lt;= iterator</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> : <span class="hljs-keyword">public</span> const_iterator<br>&#123;<br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br>&#125;<br><span class="hljs-comment">// class const_iterator&#123;&#125;基类</span><br><span class="hljs-comment">// class iterator : public const_iterator派生类</span><br></code></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// vector&lt;int&gt;::iterator it1 = vec.begin();//可以接受派生类对象</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it1 = vec.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure><p>将上面普通的正向迭代器换为常量的正向迭代器，编译器报错。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161447974.png" alt="image.png"></p><h3 id="3-reverse-iterator"><a href="#3-reverse-iterator" class="headerlink" title="3. reverse_iterator"></a>3. reverse_iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator it = vec.<span class="hljs-built_in">rbegin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">rend</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>*it = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161450170.png" alt="image.png"></p><h3 id="4-const-reverse-iterator"><a href="#4-const-reverse-iterator" class="headerlink" title="4. const_reverse_iterator"></a>4. const_reverse_iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//vector&lt;int&gt;::reverse_iterator rit = vec.rbegin();</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_reverse_iterator rit = vec.<span class="hljs-built_in">rbegin</span>();<br></code></pre></td></tr></table></figure><h2 id="9-函数对象"><a href="#9-函数对象" class="headerlink" title="9. 函数对象"></a>9. 函数对象</h2><p><strong>函数对象</strong>：拥有 <code>()operator</code> 重载函数的对象即函数对象，函数对象类似 C 语言里面的函数指针，但在 C++ 里为函数对象。</p><h3 id="1-函数对象解释"><a href="#1-函数对象解释" class="headerlink" title="1. 函数对象解释"></a>1. 函数对象解释</h3><p>下图为，C 语言进行函数调用与 C++ 中两个函数调用。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161453547.png" alt="image.png"></p><p>看起来它们好像一模一样，但是 C 语言中的 <code>sum()</code>，是函数名为一个地址；但 C++ 中的 <code>sum()</code> 为一个对象，sum 调用自己的 <code>( )</code> 重载函数将 10 与 20 传给 sum 调用的 <code>()</code> 运算符重载函数了，它接受两个实参，再执行 a+b。</p><p><strong>这里就把 <code>()</code> 运算符重载函数的对象，称作函数对象，或者称作仿函数。</strong></p><p><strong>好处：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了一个比较大于的函数模板，这里编译器会根据实参推导出 T 的类型，再从原模板实例化处理整型与 char 类型的 <code>compare()</code> 函数。  </p><p>但是它不够灵活，有时想比较小于，每次改动符号有些麻烦，C 语言中的函数指针刚好可以很好解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 使用C的函数指针解决</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myGreater</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myLess</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b;<br>&#125;<br><br><span class="hljs-comment">// compare是C++的库函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> Compare&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b, Compare comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;大于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, myGreater&lt;<span class="hljs-type">int</span>&gt;) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;小于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, myLess&lt;<span class="hljs-type">int</span>&gt;) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161516099.png" alt="image.png"></p><p>此时，就可以很好的解决这个问题了，当传入不同的函数指针来解决，想比较大就传入 myGreater，想比较小就传入 myLess，通过函数指针间接调用函数。</p><p>这里，使用函数指针虽然解决了问题，但函数指针无法进行内联，有函数的调用开销，效率很低；即使将其能够写为内联函数，编译的时候还是不知道调用时 myGreater，myLess。这里是通过函数指针间接调用的，编译器在编译过程中看到函数指针时候，不知道其调用的哪个函数，只有运行时候才知道。</p><p>因此，C++ 有一个专门的函数对象来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// C++ 对象实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myGreater</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myLess</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// compare 是 C++ 的库函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> Compare&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b, Compare comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 编译过程知道调用对象的函数 operator()(a, b);</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;大于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-built_in">myGreater</span>&lt;<span class="hljs-type">int</span>&gt;()) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;小于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-built_in">myLess</span>&lt;<span class="hljs-type">int</span>&gt;()) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过函数对象调用 <code>()</code> 运算符重载，可以省略函数的调用开销，比通过函数指针调用函数(不能内联调用)效率高。  </li><li>因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。</li></ol><h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h3><ol><li><strong>优先级队列</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 底层vector</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; que.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>que.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161525837.png" alt="image.png"></p><p><strong>如何使用小根堆：</strong></p><p>库中的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>,<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Container</span> = vector&lt;_Ty&gt;,<br><span class="hljs-keyword">class</span> _Pr = less&lt;<span class="hljs-keyword">typename</span> _Container::value_type&gt; &gt;<br></code></pre></td></tr></table></figure><p>将 less 改为 greater 即可变为小根堆即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> MinHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;;<br></code></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> MinHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 底层vector</span><br>MinHeap que;<br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; que.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>que.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161528812.png" alt="image.png"></p><ol start="2"><li><strong>set 集合</strong></li></ol><p>set 底层为红黑树，默认底层从小到大进行输出。底层为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Kty</span>,<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Pr</span> = less&lt;_Kty&gt;,<br><span class="hljs-keyword">class</span> _Alloc = allocator&lt;_Kty&gt; &gt;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; set;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i)<br>&#123;<br>set.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="10-泛型算法和绑定器"><a href="#10-泛型算法和绑定器" class="headerlink" title="10. 泛型算法和绑定器"></a>10. 泛型算法和绑定器</h2><h3 id="1-泛型算法"><a href="#1-泛型算法" class="headerlink" title="1. 泛型算法"></a>1. 泛型算法</h3><p>使用 STL 库中提供的泛型算法需要引入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br></code></pre></td></tr></table></figure><p>泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果。</p><p><strong>特点：</strong></p><ol><li>泛型算法的参数接受的都是迭代器。</li><li>泛型算法的参数还可以接受函数对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">78</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">43</span>, <span class="hljs-number">56</span>, <span class="hljs-number">52</span>, <span class="hljs-number">42</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(arr, arr+<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]))</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//begin——end之间元素默认小到大排序</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161543085.png" alt="image.png"></p><p><strong>在上面有序的容器进行二分查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">78</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">43</span>, <span class="hljs-number">56</span>, <span class="hljs-number">52</span>, <span class="hljs-number">42</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(arr, arr+<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]))</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//begin——end之间元素默认小到大排序</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">21</span>));<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;21存在&quot;</span> &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改变 sort 排序方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传入函数对象greater，改变容器元素比较方式</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>for_each 将容器中所有偶数打印出来。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// for_each可以遍历容器的所有元素，可以自行添加合适的函数对象</span><br><span class="hljs-comment">// 对容器的元素进行过滤。</span><br>for_each(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <br>[](<span class="hljs-type">int</span> val)-&gt;<span class="hljs-type">void</span>   <span class="hljs-comment">// 拉姆达表达式</span><br>&#123;<br><span class="hljs-keyword">if</span> (val %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-绑定器"><a href="#2-绑定器" class="headerlink" title="2. 绑定器"></a>2. 绑定器</h3><p><strong>包含头文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure><p>绑定器：绑定器 + 二元函数对象 &#x3D; 一元函数对象。</p><ul><li><strong>bind1st</strong>：把二元函数对象 <code>operator()(a,b)</code> 第一个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li><li><strong>bind2nd</strong>：把二元函数对象 <code>operator()(a,b)</code> 第二个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//78 56 52 43 42 31 21 12 9 4</span><br><span class="hljs-comment">//find_if</span><br><span class="hljs-comment">//将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象</span><br><span class="hljs-comment">//因此我们需要绑定器</span><br><span class="hljs-comment">//greater a &gt; b   less a &lt; b</span><br><span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <br><span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">48</span>));<br><span class="hljs-comment">//bind2nd(less&lt;int&gt;(),48);</span><br><span class="hljs-comment">//[](int val)-&gt;bool&#123;return val &lt; 48;&#125;); 拉姆达表达式</span><br>vec.<span class="hljs-built_in">insert</span>(it2, <span class="hljs-number">48</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06.C++ 继承与多态</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/06.C++%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/06.C++%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>本节分为十部分：</p><ol><li>继承的基本意义</li><li>派生类的构造过程</li><li>重载、覆盖、隐藏</li><li>虚函数、静态绑定和动态绑定</li><li>虚析构函数</li><li>理解多态是什么</li><li>理解抽象类</li><li>理解虚基类和虚继承</li><li>菱形继承问题</li><li>C++ 的 四种类型转换</li></ol><h2 id="1-继承的基本意义"><a href="#1-继承的基本意义" class="headerlink" title="1. 继承的基本意义"></a>1. 继承的基本意义</h2><p><strong>继承的本质：</strong></p><p>代码的复用，实现多态的基础。</p><p><strong>关系：</strong></p><ul><li>组合：a part of…  一部分的关系</li><li>继承：a kind of… 一种的关系</li></ul><p><strong>继承方式和访问限定罗列：</strong></p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>继承方式</td><td>基类的访问限定</td><td>派生类的访问限定</td><td>(main)外部的访问限定</td></tr><tr><td>public</td><td></td><td></td><td></td></tr><tr><td></td><td>public</td><td>public</td><td>Y</td></tr><tr><td></td><td>protected</td><td>protected</td><td>N</td></tr><tr><td></td><td>private</td><td>不可见的</td><td>N</td></tr><tr><td>protected</td><td></td><td></td><td></td></tr><tr><td></td><td>public</td><td>protected</td><td>N</td></tr><tr><td></td><td>protected</td><td>protected</td><td>N</td></tr><tr><td></td><td>private</td><td>不可见的</td><td>N</td></tr><tr><td>private</td><td></td><td></td><td></td></tr><tr><td></td><td>public</td><td>private</td><td>N</td></tr><tr><td></td><td>protected</td><td>private</td><td>N</td></tr><tr><td></td><td>private</td><td>不可见的</td><td>N</td></tr></tbody></table><p><strong>protected继承方式下：</strong> <strong>基类的成员的访问限定，在派生类里面是不可能超过继承方式的。public降为protected的。</strong></p><p><strong>private继承方式下：</strong> <strong>public与protected降为private。</strong></p><p><strong>总结：</strong></p><ol><li>外部只能看到并使用 public 成员，protected 和 private 成员无法直接访问。</li><li>在继承结构中，派生类从基类继承来的 private 成员，然是无法直接访问（派生类中不可见）。</li><li>基类成员访问限定，在派生类里面不能超过继承方式。</li></ol><p><strong>protected 和 private 区别：</strong></p><ol><li>如果只是单纯的一个类，没有继承结构，则二者没有区别，外部都是无法访问的。</li><li>若存在继承关系，在基类中定义的成员，想被派生类访问，但不想被外部访问，那么可以在基类中将该成员定义为保护型。</li><li>若存在继承关系，在基类中定义的成员，不想被派生类访问，也不想被外部访问，则可以在基类中将该成员定义为私有。</li></ol><p><strong>默认继承方式：</strong></p><ul><li>要看派生类是用 class 定义的，还是 struct 定义的：<ul><li>若 class 定义派生类，则默认继承方式是私有的。</li><li>若 struct 定义派生类，则默认继承方式是共有的。</li></ul></li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-type">int</span> ma;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mb;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mc;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> _md, <span class="hljs-type">int</span> _mba, <span class="hljs-type">int</span> _maa)<br>: <span class="hljs-built_in">md</span>(_md)<br>, <span class="hljs-built_in">ma</span>(_mba)<br>&#123;<br>A::ma = _maa;<br>&#125;<br><span class="hljs-type">int</span> md;<br><span class="hljs-comment">// 作用域不同：派生类可以定义与基类同名的成员数据</span><br><span class="hljs-type">int</span> ma;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; md &lt;&lt; endl;<br>cout &lt;&lt; A::ma &lt;&lt; endl;<br>cout &lt;&lt; B::ma &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 公有继承下 ：基类私有的成员在派生类中不可见</span><br><span class="hljs-comment">// cout &lt;&lt; mc &lt;&lt; endl; </span><br>cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> me;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mf;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)</span></span>;<br>A a;<br><br>b.<span class="hljs-built_in">func</span>();<br>b.<span class="hljs-built_in">func1</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(a) &lt;&lt; endl;<span class="hljs-comment">// 3 * int(4)</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(b) &lt;&lt; endl;<span class="hljs-comment">// (3 + 4) * int(4)</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-派生类的构造过程"><a href="#2-派生类的构造过程" class="headerlink" title="2. 派生类的构造过程"></a>2. 派生类的构造过程</h2><p>派生类从基类可以继承来所有的成员（成员变量和成员方法）。</p><p><strong>派生类如何初始化基类继承的成员变量：</strong></p><p>通过调用基类相应的构造函数来初始化</p><ul><li>派生类的构造函数和析构函数，负责初始化和清理派生类部分；</li><li>派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数来负责。</li></ul><p><strong>派生类对象构造和析构过程：</strong></p><ol><li>派生类调用基类的构造函数，初始化从基类继承来的成员。</li><li>培生类调用自己的构造函数，初始化自身的成员。</li><li>……….. 派生类对象的作用域到期。</li><li>派生类调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存、文件）。</li><li>系统自动调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件）。</li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data) <br>        : <span class="hljs-built_in">ma</span>(data) <br>    &#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;基类构造函数：Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br>    ~<span class="hljs-built_in">Base</span>() <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;基类析构函数：~Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data)<br>        : <span class="hljs-built_in">Base</span>(data), <span class="hljs-built_in">mb</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;派生类构造函数：Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Derive</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;派生类析构函数：~Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mb;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110913834.png" alt="image.png"></p><h2 id="3-重载、覆盖、隐藏"><a href="#3-重载、覆盖、隐藏" class="headerlink" title="3. 重载、覆盖、隐藏"></a>3. 重载、覆盖、隐藏</h2><p>继承结构中，名字相同的成员会产生关系，基类派生类里面相关的成员方法我们经常使用三种关系来描述它们，即：<strong>重载、隐藏、覆盖</strong>关系。</p><ul><li><strong>重载：</strong></li></ul><p>一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同。</p><ul><li><strong>隐藏：</strong></li></ul><p>在继承结构当中，派生类的同名成员，把基类的同盟成员给隐藏掉了，即作用域的隐藏。</p><ul><li><strong>覆盖：</strong></li></ul><p>父子类中的同名、同参数、同返回值的多个成员函数，从子到父形成的关系称为覆盖关系，在虚函数中会详谈它。</p><h3 id="1-隐藏关系"><a href="#1-隐藏关系" class="headerlink" title="1. 隐藏关系"></a>1. 隐藏关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">ma</span>(data) &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">20</span>) <br>:<span class="hljs-built_in">Base</span>(data), <span class="hljs-built_in">mb</span>(data) &#123; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Derive d;<br>d.<span class="hljs-built_in">show</span>();<br>d.<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类对象调用了不带参数的show方法，派生类本身没有这个方法。<br>执行结果：调用成功，而且<strong>1与2是函数重载关系</strong>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110931669.png" alt="image.png"></p><p>我们又给派生类添加了一个不带参数的show方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">20</span>):<span class="hljs-built_in">Base</span>(data), <span class="hljs-built_in">mb</span>(data)&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-comment">//3</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure><p>派生类调用 show 时优先调用自己的 <code>show()</code>，在自己的作用域下找相应的成员名字，若没有才去基类找；当我们调用带整数参数的 <code>show(int)</code>，自己并没有，从基类继承来一个带整型参数的 <code>show(int)</code>。</p><p>执行一下：第二个 <code>show(int)</code> 调用执行出错。1 与 3 属于隐藏关系；2 与 3 也属于隐藏关系。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110932089.png" alt="image.png"></p><p>第二个调用的是派生类的 <code>show()</code>，不接受参数。</p><p><strong>为什么不调用基类中的 <code>show(int)</code>？</strong></p><p>派生类对象调用派生类与基类同盟成员时，派生类已经有一个名字 show 了，派生类的 <code>show()</code> 将基类同盟 <code>show()</code>隐藏掉了。</p><p>如果想调用基类成员函数，必须指明基类的作用域来调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Derive d;<br>d.Base::<span class="hljs-built_in">show</span>();<br>d.Base::<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>指明作用域调用成功。  </p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110934024.png" alt="image.png"></p><h3 id="2-继承中的类型转换"><a href="#2-继承中的类型转换" class="headerlink" title="2. 继承中的类型转换"></a>2. 继承中的类型转换</h3><p>继承结构，我们也称为从上(基类)到下(派生类)的结构。</p><p><strong>类型转换是否可以？</strong></p><ol><li><strong>基类对象——&gt;派生类对象的转换：类型从上到下的转换(NO)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//基类对象——&gt;派生类对象</span><br>d = b;<br></code></pre></td></tr></table></figure><p>执行结果：执行失败。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110942832.png" alt="image.png"></p><ol start="2"><li><strong>派生类对象——&gt;基类对象的转换：类型从下到上的转换(YES)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//派生类对象——&gt;基类对象</span><br>b = d;<br></code></pre></td></tr></table></figure><p>执行结果：成功执行。</p><ol start="3"><li><strong>基类指针(引用)——&gt;指向派生类对象：类型从下到上的转换(YES)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//基类指针(引用)——&gt;派生类对象</span><br>Base *pb = &amp;d;<br>pb-&gt;<span class="hljs-built_in">show</span>();<br>pb-&gt;<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>执行结果：成功执行。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110953689.png" alt="image.png"></p><ol start="4"><li><strong>派生类指针(引用)——&gt;指向基类对象：类型从上到下的转换(NO)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//派生类指针(引用)——&gt;指向基类对象</span><br>Derive *pd = &amp;b;<br></code></pre></td></tr></table></figure><p>执行结果：执行失败。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110954145.png" alt="image.png"></p><p><strong>总结：</strong></p><p>在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转不安全会涉及内存的非法访问。</p><h2 id="4-虚函数、静态绑定和动态绑定"><a href="#4-虚函数、静态绑定和动态绑定" class="headerlink" title="4. 虚函数、静态绑定和动态绑定"></a>4. 虚函数、静态绑定和动态绑定</h2><p><strong>覆盖：</strong></p><p>如果派生类中的方法和基类继承的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 <strong>virtual 虚函数</strong> ，那么派生类的这个方法，自动被处理成虚函数，它们之间成为覆盖关系；也就是说派生类会在自己虚函数表中将从基类继承来的虚函数进行替换，替换成派生类自己的。</p><p><strong>静态绑定：</strong></p><p>编译时期的多态，通过函数的重载以及模板来实现，也就是说调用函数的地址在编译时期我们就可以确定，在汇编代码层次，呈现的就是 call 函数名。</p><p><strong>动态绑定：</strong></p><p>动态时期的多态，通过派生类重写基类的虚函数来实现。在汇编代码层次，呈现的就是 call 寄存器，寄存器的值只有运行起来才能确定。</p><h3 id="1-不存在的虚函数"><a href="#1-不存在的虚函数" class="headerlink" title="1. 不存在的虚函数"></a>1. 不存在的虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">ma</span>(data) &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) <br>:<span class="hljs-built_in">Base</span>(data)<br>, <span class="hljs-built_in">mb</span>(data) &#123; &#125;<br><br>~<span class="hljs-built_in">Derive</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br>Base* pb = &amp;d;<br><br><span class="hljs-comment">// 静态（编译时期）绑定(函数调用) Base::show (06F12E4h)</span><br>pb-&gt;<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// Base::show (06F12BCh)</span><br>pb-&gt;<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Base size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derive) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111036581.png" alt="image.png"></p><p><strong>反汇编查看：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111039623.png" alt="image.png"></p><p>可以看到调用的都是基类的 <code>show()</code>,在编译阶段已经生成指令调用 Base 下的 show。</p><p><strong>结果：</strong></p><ul><li>因为 pb 是 Base 类型的指针，所以调用的都是 Base 类的成员方法。  </li><li>基类 Base 只有一个数据成员 ma，所以大小只有 4 字节。  </li><li>派生类 Derive 继承了 ma，其次还有自己的 mb，所以有 8 字节。  </li><li>pb 的类型是一个 <code>class Base *</code>；  </li><li><code>*pb</code> 的类型是一个 <code>class Base</code>。</li></ul><p><strong>图示:</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111042657.png" alt="image.png"></p><p>为什么 <code>Base *</code> 类型的指针，Derive 类型的对象，调用方法的时候是 Base 而不是 Derive 呢？</p><p>原因如上图：</p><p>Derive 类继承了 Base 类，导致了派生类的大小要比基类大，而 pb 的类型是基类的指针，所以通过 pb 调用方法时只能访问到 Derive 中从 Base 继承而来的方法，访问不到自己重写的方法（指针的类型限制了指针解引用的能力）。</p><h3 id="2-基类定义虚函数"><a href="#2-基类定义虚函数" class="headerlink" title="2. 基类定义虚函数"></a>2. 基类定义虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">ma</span>(data) &#123; &#125;<br><br>~<span class="hljs-built_in">Base</span>() &#123;&#125;<br><br><span class="hljs-comment">// 虚基类</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) <br>:<span class="hljs-built_in">Base</span>(data)<br>, <span class="hljs-built_in">mb</span>(data) &#123; &#125;<br><br>~<span class="hljs-built_in">Derive</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br>Base* pb = &amp;d;<br><br>pb-&gt;<span class="hljs-built_in">show</span>();<br>pb-&gt;<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Base size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derive) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111047159.png" alt="image.png"></p><p><strong>反汇编：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111048405.png" alt="image.png"></p><p><code>pb-&gt;show();</code> 中 pb 指针是 base 类型，如果发现 Base 中的 show 是虚函数，就进行动态绑定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">|63..32|31..16|15-8|7-0| <br>               |AH.|AL.| <br>               |AX.....| <br>       |EAX............| <br>|RAX...................|<br></code></pre></td></tr></table></figure><ol><li><strong><code>mov   rax, qword ptr [pb]</code></strong></li></ol><p>将 pb 指向的内存前 4 个字节放入 rax 寄存器，pb指向derive对象，前四个字节即 <code>vfptr</code>，将虚函数表地址加载到 rax</p><ol start="2"><li><strong><code>mov   rax, qword ptr [rax]</code></strong></li></ol><p>将 rax 的前四个字节 即 <code>Derive::show</code> 加载到 rax 中。</p><ol start="3"><li><strong><code>call   qword ptr [rax]</code></strong></li></ol><p>虚函数的地址</p><p>可以看到这一次，汇编码 call 的就不是确切的函数地址了，而是寄存器 rax。</p><p>那么就很好理解了：rax 寄存器里存放的是什么内容，编译阶段根本无从知晓，只能在运行的时候确定； 故为，动态绑定。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111100188.png" alt="image.png"></p><p>pb的类型：Base类型，查看Base中有没有虚函数</p><p>（1）Base中没有虚函数 <code>*pb</code> 识别的就是编译时期的类型 <code>*pb</code> 就是 Base 类型。<br>（2） Base中有虚函数，<code>*pb</code> 识别的就是运行时期的类型 RTTI 类型为：Derive。</p><p>在添加了 virtual 关键字后，对应的函数就变成了虚函数。</p><p><strong>那么，一个类添加了虚函数，对这个类有什么影响呢？</strong></p><ul><li>如果类中定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的 <code>vftable</code> 虚函数表，虚函数表中主要存储的内容是：RTTI（Run-time Type Information）指针和虚函数的地址；当程序运行时，每一张虚函数表都会加载到内存的 <code>.rodata</code> 区（只读数据区）。</li><li>一个类中定义了虚函数，那么这个类定义的对象，在运行时，内存中会多存储一个 <code>vfptr</code> 虚函数的指针，指向对应类型的虚函数表 <code>vftable</code>。</li><li>一个类型定义的 n 个对象，它们的 <code>vfptr</code> 指向的都是同一张虚函数表。</li><li>一个类中的虚函数个数，不影响对象内存的大小（vfptr），影响的是虚函数表 <code>vftable</code> 的大小。</li><li>如果派生类中的方法和从基类继承的某个方法中返回值、函数名以及参数列表都相同，且基类方法为 virtual ，那么派生类的这个方法自动被处理为虚函数。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111110387.png" alt="image.png"></p><p><strong>虚函数表：</strong></p><ol><li>RTTI：存放的是类型信息，也就是（Base 或 Derive）。</li><li>偏移地址：虚函数指针相对于对象内存空间的便宜，一般 <code>vfptr</code> 都在 0 偏移位置。</li><li>之后是函数时虚函数入口地址。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111112719.png" alt="image.png"></p><p>在 Derive 类中，由于重写了 <code>show()</code>,因此在 Derive 的虚函数表中，是使用子类的 show() 方法代替了 Base 类的 <code>show()</code>。</p><h3 id="3-VS-工具查看虚函数表相关"><a href="#3-VS-工具查看虚函数表相关" class="headerlink" title="3. VS 工具查看虚函数表相关"></a>3. VS 工具查看虚函数表相关</h3><ol><li>找到</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111116949.png" alt="image.png"></p><p>打开后：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111117972.png" alt="image.png"></p><ol start="2"><li>在打开的窗口中切换到当前工程所在目录</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111119264.png" alt="image.png"></p><ol start="3"><li>输入指令</li></ol><p>可通过 dir 命令查看当前目录所有文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111120593.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cl XXX.cpp /d1reportSingleClassLayoutXX<br></code></pre></td></tr></table></figure><p>第一个XXX表示源文件的名字，第二个代表你想查看的类类型，我这里就是<code>Derive</code></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111123449.png" alt="image.png"></p><p>以看到 <code>class Derived</code> 的对象的内存布局，在派生类对象的开始包含了基类 Base 的对象，其中有一个虚表指针，指向的就是下面的<code>Derived::$vftable@ （virtual function table）</code>，表中包含了 Derived 类中所有的虚函数。</p><h2 id="5-虚析构函数"><a href="#5-虚析构函数" class="headerlink" title="5. 虚析构函数"></a>5. 虚析构函数</h2><p>析构函数：可以成为虚函数，调用时候对象存在。</p><p>虚析构函数：在析构函数前加上 virtual 关键字。</p><p>什么时候需要把基类的析构函数必须实现成虚函数？<br>       <br>基类的指针(引用)指向堆上 new 出来的派生类对象的时候，delete 调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data) <br>        : <span class="hljs-built_in">ma</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;call Base::show()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) <br>        : <span class="hljs-built_in">Base</span>(data)<br>        , <span class="hljs-built_in">mb</span>(data)<br>        , <span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Derive</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Derive() &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mb;<br>    <span class="hljs-type">int</span>* ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base* pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 静态绑定pb Base*   *pb Derive</span><br>    pb-&gt;<span class="hljs-built_in">show</span>();<br><br>    <span class="hljs-keyword">delete</span> pb;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111143308.png" alt="image.png"></p><p><strong>没有调用派生类的析构函数，造成内存泄漏。</strong></p><p><strong>问题：</strong></p><p>pb 的配型是 Base 类型，因此 delete 调用析构函数先去 Base 找 <code>Base::~Base()</code>，对于析构函数的第哦啊用就是静态绑定，之间编译，没有机会调用派生类的析构函数，最后发生内存泄漏。</p><p><strong>解决：</strong></p><p>将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb 的类型是 Base 类型，调用析构时去 Base 中找 <code>Base::~Base</code> 发现它为虚函数，发生动态绑定。派生类的虚函数表中：<code>&amp;Derive:: ~derive</code>，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。</p><p><strong>注意：</strong></p><p><strong>构造函数不能为虚函数！！！</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111146816.png" alt="image.png"></p><p>（1）从存储空间角度：</p><p>虚函数对应一个 <code>vftable</code> ，这个 <code>vftable</code> 其实是存储在内存空间的。问题来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找 <code>vtable</code> 呢？所以构造函数不能是虚函数。</p><p>（2）从使用角度：</p><p>虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。</p><p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p><p>（4）构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p><p>（5）从实现上看，<code>vbtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数</p><p>从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p><h2 id="6-理解多态是什么"><a href="#6-理解多态是什么" class="headerlink" title="6. 理解多态是什么"></a>6. 理解多态是什么</h2><p>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。</p><p>所谓“虚函数”，就是在声明时前面加了virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。  </p><p>包含虚函数的类称为“<strong>多态类</strong>”。  </p><p>多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。  </p><p>多态在面向对象的程序设计语言中如此重要，以至于有类和对象的概念，但是不支持多态的语言，只能被称作“基于对象的程序设计语言”，而不能被称为“面向对象的程序设计语言”。例如，Visual Basic 就是“基于对象的程序设计语言”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;E::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    B b;<br>    D d;<br>    E e;<br><br>    A* pa = &amp;a;<br>    B* pb = &amp;b;<br><br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = pb;<br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;d;<br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;e;<br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405480.png" alt="image.png"></p><p>程序中，四个类之间的派生关系如下所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405483.png" alt="image.png"></p><p>每个类都有同名、同参数表的虚函数 Print（每个 Print 函数声明时都加了 virtual 关键字）。根据多态的规则，对于语句<code>pa-&gt;Print()</code>，由于 Print 是虚函数，尽管 pa 是基类 A 的指针，编译时也不能确定调用的是哪个类的 Print 函数。当程序运行到该语句时，pa 指向的是哪个类的对象，调用的就是哪个类的 Print 函数。    </p><p>多态的语句调用哪个类的成员函数是在运行时才能确定的，编译时不能确定（具体原理后面会解释）。因此，多态的函数调用语句被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。</p><h3 id="1-多态起手式以及内存分布"><a href="#1-多态起手式以及内存分布" class="headerlink" title="1.多态起手式以及内存分布"></a>1.多态起手式以及内存分布</h3><p>假设有一个基类 ClassA，一个继承了该基类的派生类 ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。</p><p>在代码中运用多态这个特性时，通常以两种方式起手：<br>(1) <code>ClassA *a = new ClassB();</code><br>(2) <code>ClassB b; ClassA *a = &amp;b;</code></p><p>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第 1 个用了 new 关键字而分配在堆上，第 2 个分配在栈上：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111411592.png" alt="image.png"></p><p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，<code>ClassA *a</code> 是一个栈上的指针。</p><p>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向 <strong>该类的虚函数表(这里是类ClassB)</strong> 的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p><h3 id="2-类的虚函数表与类实例的虚函数指针"><a href="#2-类的虚函数表与类实例的虚函数指针" class="headerlink" title="2. 类的虚函数表与类实例的虚函数指针"></a>2. 类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况；如果一个类中有虚函数，那么该类就有一个虚函数表。</p><p>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。</p><p>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111417318.png" alt="image.png"></p><h3 id="3-多态代码及多重继承情况"><a href="#3-多态代码及多重继承情况" class="headerlink" title="3. 多态代码及多重继承情况"></a>3. 多态代码及多重继承情况</h3><p>讨论了在没有继承的情况下，虚函数表的逻辑结构。</p><p>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::~ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassA::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassA::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> aData;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> : <span class="hljs-keyword">public</span> ClassA<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassB::ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassB::~ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassB::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassB::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> bData;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassC</span> : <span class="hljs-keyword">public</span> ClassA<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassC::ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassC::~ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassC::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassC::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> aData;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ClassC c;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(1) ClassA 是基类, 有普通函数: <code>fn1()、fn2()</code> 。虚函数: <code>vfn1()、vfn2()、~ClassA()</code><br>(2) ClassB 继承 ClassA, 有普通函数: <code>fn1()</code>。虚函数: <code>vfn1()、~ClassB()</code><br>(3) ClassC 继承 ClassB, 有普通函数: <code>fn2()</code>。虚函数: <code>vfn2()、~ClassB()</code></p><p>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。</p><p>ClassB 继承与 ClassA，其虚函数表是在 ClassA 虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassA* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassB</span>();<br><br>a-&gt;<span class="hljs-built_in">fn1</span>();<br>a-&gt;<span class="hljs-built_in">fn2</span>();<br><br>a-&gt;<span class="hljs-built_in">vfn1</span>();<br>a-&gt;<span class="hljs-built_in">vfn2</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111430434.png" alt="image.png"></p><p><strong>使用 VS 开发者工具查看：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111432206.png" alt="image.png"></p><p>这个结果不难想象，看上图，ClassA 类型的指针 a 能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同</p><p>这个结果已经说明了 C++ 的隐藏、重写(覆盖)特性。</p><p>同理，也就不难推导出 ClassC 的逻辑结构图了</p><p>类的继承情况是: ClassC 继承 ClassB，ClassB 继承 ClassA；这是一个多次单继承的情况。(多重继承)。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111435576.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111436071.png" alt="image.png"></p><h3 id="4-多继承下的虚函数表-同时继承多个基类"><a href="#4-多继承下的虚函数表-同时继承多个基类" class="headerlink" title="4. 多继承下的虚函数表 (同时继承多个基类)"></a>4. 多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ClassA1</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassA1</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::~ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a1Data;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ClassA2</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassA2</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::~ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc4</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::vfunc4()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a2Data;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassC</span> : <span class="hljs-keyword">public</span> ClassA1, <span class="hljs-keyword">public</span> ClassA2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ClassC</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::ClassC()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassC</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::~ClassC()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::vfunc3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ClassC c;<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111445452.png" alt="image.png"></p><p>（1）ClassA1 是第一个基类，拥有普通函数 <code>func1()</code>，虚函数<code>vfunc1()、 vfunc2()</code>。<br>（2）ClassA2 是第二个基类，拥有普通函数 <code>func1()</code>，虚函数 <code>vfunc1()、 vfunc2()、vfunc4()</code>。<br>（3）ClassC 依次继承 ClassA1、ClassA2。普通函数 <code>func1()</code>,虚函数<code>vfunc1()、vfunc2()、vfunc3()</code>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111442375.png" alt="image.png"></p><p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。</p><p>如图，虚函数表指针 01 指向的虚函数表是以 ClassA1 的虚函数表为基础的，子类的 <code>ClassC::vfunc1()</code>,和 <code>vfunc2()</code> 的函数指针覆盖了虚函数表 01 中的虚函数指针 01 的位置、02 位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。注意：</p><ol><li>子类虚函数会覆盖每一个父类的每一个同名虚函数。</li><li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li><li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用</li></ol><p>最后给出代码和结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassA1 *a1 = <span class="hljs-keyword">new</span> ClassC;<br>a1-&gt;<span class="hljs-built_in">func1</span>();               <span class="hljs-comment">// &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span><br>a1-&gt;<span class="hljs-built_in">vfunc1</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span><br>a1-&gt;<span class="hljs-built_in">vfunc2</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span><br>没有a1-&gt;<span class="hljs-built_in">vfunc3</span>()，父类没有这个虚函数<br><br>ClassA2 *a2 = <span class="hljs-keyword">new</span> ClassC;<br>a2-&gt;<span class="hljs-built_in">func1</span>();               <span class="hljs-comment">// &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span><br>a2-&gt;<span class="hljs-built_in">vfunc1</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class="hljs-built_in">vfunc2</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class="hljs-built_in">vfunc4</span>();              <span class="hljs-comment">// &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span><br><br>ClassC *c = <span class="hljs-keyword">new</span> ClassC;<br>c-&gt;<span class="hljs-built_in">func1</span>();                <span class="hljs-comment">// &quot;ClassC::func1()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc1</span>();               <span class="hljs-comment">// &quot;ClassC::vfunc1()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc2</span>();               <span class="hljs-comment">// &quot;ClassC::vfunc2()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc3</span>();               <span class="hljs-comment">// &quot;ClassC::vfunc3()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc4</span>();               <span class="hljs-comment">// &quot;ClassA2::func4()&quot;</span><br></code></pre></td></tr></table></figure><h2 id="7-理解抽象类"><a href="#7-理解抽象类" class="headerlink" title="7. 理解抽象类"></a>7. 理解抽象类</h2><p>抽象类(接口)：接口描述了类的行为和功能,而无需完成类的特定实现</p><p>C++ 接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用</p><p><strong>注意:</strong></p><p>如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>因此，如果一个抽象类的派生类需要被实例化(建立对象)，则必须对每个继承来的纯虚函数进行函数体实现。<br>如果没有在派生类中重写所有纯虚函数，就尝试实例化派生类的对象，也会导致编译错误，这是因为如果派生类没有实现父类的纯虚函数，则派生类变为抽象类。</p><p>抽象类基类为派生自抽象基类的派生类提供了约束条件，即：派生类必须要实现继承自抽象基类中的纯虚函数，否则此派生类不可进行实例化，且派生类将继承为抽象派生类。</p><h3 id="1-抽象类与纯虚函数（抽象方法）"><a href="#1-抽象类与纯虚函数（抽象方法）" class="headerlink" title="1. 抽象类与纯虚函数（抽象方法）"></a>1. 抽象类与纯虚函数（抽象方法）</h3><p><strong>纯虚函数</strong>是一个在 <strong>基类中声明的虚函数</strong>，它在该基类中<strong>没有定义具体的函数体</strong>(操作内容),要求<strong>派生类根据实际需要定义自己的版本</strong>，设计多层次类继承关系时用到。把某个方法声明为一个抽象方法等于告诉编译器,这个方法<strong>必不可少</strong>，但目前在基类中还不能为它提供实现</p><p>纯虚函数的标准格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> 函数类型 函数名（参数表）= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明了一个纯虚函数 也就是在虚函数尾部加上&quot; = 0 &quot; 一个虚函数便被声明成为了一个纯虚函数</span><br><span class="hljs-comment">// 等于 0 表示该函数仅声明而没有函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>一旦类中有了纯虚函数，这个类便被称为：<strong>抽象类</strong>。</p><blockquote><p><strong>且此类不能被实例化！！！（不可建立类对象实例！！！）</strong></p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 报错！带有纯虚函数的类称为抽象类，不可实例化</span><br>Pet pet; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象类：</strong></p><p>只能作为积累使用，无法定义抽象类对象实例，这是因为 <strong>抽象类中包含了没有定义的纯虚函数</strong>，在 C++ 中，我们把 <strong>只能由于被继承而不能直接创建对象的类</strong> 称之为：<strong>抽象类</strong>，这种基类不能直接生成对象，而只有被继承后，并重写其虚函数后，才能使用。</p><p>当抽象类的派生类实现了继承而来的纯虚函数后，才能实例化对象。</p><p>之所以要存在抽象类，最主要是因为它具有不确定因素，我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为虚函数。虚函数是一种特殊的函数，在抽象类中只有声明，没有具体的定义。</p><p><strong>抽象类和纯虚函数的关系</strong></p><p>抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类，存在纯虚函数是成为抽象类的充要条件。</p><h3 id="2-为什么需要一个抽象类"><a href="#2-为什么需要一个抽象类" class="headerlink" title="2. 为什么需要一个抽象类"></a>2. 为什么需要一个抽象类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// todonew 与 delete 动态分配内存,与用指针调用对象 通过对象的不同调用不同的同名虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span> <span class="hljs-comment">// 声明纯虚函数 sound 后 Pet 类变为抽象类(接口)</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Pet</span>(string thename);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明纯虚函数 sound  (并未进行函数实现 函数实现放在派生类中)</span><br><br>    <span class="hljs-comment">//注意:   </span><br>    <span class="hljs-comment">//todo1.继承自抽象基类 Pet 的子类必须全部实现基类中的所有纯虚函数</span><br>    <span class="hljs-comment">//todo2.抽象基类 Pet 不可进行实例化</span><br><br><span class="hljs-keyword">protected</span>:<br>    string name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Pet<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(string thename);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">climb</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Pet<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Dog</span>(string thename);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jump</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br>Pet::<span class="hljs-built_in">Pet</span>(string thename) <span class="hljs-comment">// todo 基类构造器(抽象类也有构造函数)</span><br>&#123;<br>    name = thename;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pet::sleep</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;正在睡大觉\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pet::sound</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;动物发声\n&quot;</span>;<br>&#125;<br><br>Cat::<span class="hljs-built_in">Cat</span>(string thename) :<span class="hljs-built_in">Pet</span>(thename) <span class="hljs-comment">// 派生类 Cat 构造函数</span><br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cat::climb</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;正在爬树\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">Cat::sound</span><span class="hljs-params">()</span> <span class="hljs-comment">// 派生类虚函数</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//Pet::sound(); // todo 如果需要调用基类中的 play() 函数  在原本的play()函数的基础上加上覆盖上的子类play()函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;喵喵喵!\n&quot;</span>;<br>&#125;<br><br><br>Dog::<span class="hljs-built_in">Dog</span>(string thename) :<span class="hljs-built_in">Pet</span>(thename)<span class="hljs-comment">// 派生类 Dog 构造函数</span><br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::jump</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;跳过了栅栏\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::sound</span><span class="hljs-params">()</span> <span class="hljs-comment">// 派生类虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Pet::sound();</span><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;汪汪汪!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Pet* x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x-&gt;<span class="hljs-built_in">sound</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Pet pet; // todo 用带有抽象方法(纯虚函数)的抽象类 Pet 无法实例化对象</span><br><br>    <span class="hljs-comment">// todo 创建指向子类实例的基类指针和引用来调用纯虚函数</span><br>    Pet* cat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;猫&quot;</span>);<br>    Pet* dog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>(<span class="hljs-string">&quot;狗&quot;</span>);<br><br>    <span class="hljs-comment">// todo 创建对象实例来调用纯虚函数</span><br>    <span class="hljs-function">Cat <span class="hljs-title">cat2</span><span class="hljs-params">(<span class="hljs-string">&quot;对象实例调用 猫&quot;</span>)</span></span>;<br>    cat2.<span class="hljs-built_in">sound</span>();<br><br>    <span class="hljs-built_in">func</span>(cat);<br>    <span class="hljs-built_in">func</span>(dog);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中定义了三个类,它们的继承关系为：<code>Animal--&gt;Cat</code>和<code>Animal--&gt;Dog</code></p><p>Animal 是一个抽象类，也是最顶层的基类，在 Animal 类中定义了一个<strong>纯虚函数</strong><code>sound()</code>，在 <code>Cat</code> 类中，实现了<code>sound()</code>函数。所谓实现，就是定义了纯虚函数的函数体，抽象类 Animal 虽然不能实例化，但它为派生类提供了<strong>约束条件</strong>，派生类必须要实现这个函数，完成动物发声功能，否则就不能对派生类进行实例化。</p><p>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的，虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111557893.png" alt="image.png"></p><p><strong>总结：</strong></p><ol><li>任何具有纯虚函数的类都是抽象类。</li><li>抽象类基类不可建立实例。</li><li>抽象类派生出的子类需将继承的纯虚函数全部进行实例化，才能建立其实例。</li><li>抽象类可以有构造函数。</li><li>如果派生类没有实现父类的纯虚函数，则派生类变为抽象类，即不可建立其实例。</li><li>抽象基类除了约束派生类的功能，还可以实现多态，可以创建指向子类的实例的抽象基类的指针和引用。</li><li>只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。</li></ol><h2 id="8-理解虚基类和虚继承"><a href="#8-理解虚基类和虚继承" class="headerlink" title="8. 理解虚基类和虚继承"></a>8. 理解虚基类和虚继承</h2><p><strong>virtual作用：</strong></p><ol><li>virtual 修饰了成员方法是虚函数。  </li><li>可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。</li></ol><ul><li><strong>vfptr</strong>：一个类有虚函数，这个类生成的对象就有 vfptr，指向 vftable。  </li><li><strong>vbptr</strong>：在派生类中从基类虚继承而来。  </li><li><strong>vftable</strong>：第一行为向上偏移量，第二行为虚基类指针离虚基类内存的偏移量。  </li><li><strong>vbtable</strong>：存放的 RTTI 指针，指向运行时 RTTI 信息与虚函数地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-comment">//A a; 4个字节</span><br><span class="hljs-comment">//B b; 8个字节</span><br></code></pre></td></tr></table></figure><p>这里我们的对象 a 占 4 个字节，对象 8 占 8 个字节。但如果我们给 B 的继承方式访问限定符前面加了一个 virtual 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>类 A 被虚继承了，但内存布局没有变化：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111611448.png" alt="image.png"></p><p><strong>类 B 在继承普通基类的内存变化：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111612673.png"></p><p>再看一下类 B，不是之前的 8 个字节，变为 12 个字节，多了一个 vbptr 指针。原来最上面应该为 ma 与 mb，但是现在多了一个 <code>vbptr</code>(虚基类指针)，ma 跑到派生类最后面去了。<code>vbptr</code> 指向的是 <code>vbtable</code>，<code>vbtable</code> 第一行为 0，第二行为虚基类指针到虚基类数据的偏移量。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111614890.png" alt="image.png"></p><p>当遇到虚继承时候，要考虑派生类 B 的内存布局时；</p><p>首先，先不考虑虚继承，类 B 继承了基类的 ma，还有自己的mb；当基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个 <code>vbptr</code>。派生类的内存就由这几部分来构成。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111618147.png" alt="image.png"></p><p>虚基类指针(<code>vbptr</code>)指向虚基类表(<code>vbtable</code>)，<code>vbtable</code> 第一行为向上的偏移量，因为 <code>vbptr</code> 在该派生类内存起始部分，因此向上的偏移量为 0；第二行为向下的偏移量(<code>vbptr</code> 离虚基类数据的偏移量)，原来基类的数据放到最后，找 ma 的时候还是在最开始找，但 ma 被移动，根据偏移的字节就可以找到。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111619886.png" alt="image.png"></p><h3 id="1-虚基类和虚继承出错情况分析"><a href="#1-虚基类和虚继承出错情况分析" class="headerlink" title="1. 虚基类和虚继承出错情况分析"></a>1. 虚基类和虚继承出错情况分析</h3><p><strong>那么当我们虚基类指针与虚函数指针在一起出现的时候会发生什么呢？</strong></p><p>调用是没有问题的，但是 delete 会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</span><br>A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<span class="hljs-comment">// B::vftable</span><br>p-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图：调用成功，但delete时会出错。  </p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111623556.png" alt="image.png"></p><p><strong>分析：</strong></p><p>B 的内存布局：</p><p>B 首先从 A 中获取 <code>vfptr</code> 与 ma， B 中还有自身的 mb；<br>此时 A 被虚继承，A 中所有的东西都移动到派生类最后面，最上面补一个<code>vbptr</code>，<code>vbptr</code> 指向 <code>vbtable</code>，<code>vfptr</code> 指向 <code>vftable</code>；基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</p><p>普通情况下，派生类内存布局先是基类，在是派生类，基类指针指向派生类对象时，基类指针指向的就是派生类内存的起始部分。但是，虚继承下基类称为虚基类，虚基类的数据在派生类最后面，原地方补上 <code>vbptr</code>，此时再用基类指针指向派生类对象时候，基类指针永远指向派生类基类部分的起始地址。虚基类一开始就是 <code>vfptr</code>，能够用 p 指向的对象访问 <code>vfptr</code> 与 <code>vftable</code> 的原因。释放内存时候出错，因为对象开辟是在最上面即绿色部分，但是 p 所持有的是虚基类的地址，delete 时从虚基类起始地址 delete，因此出错。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111627334.png" alt="image.png"></p><p>命令验证如下：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111628141.png" alt="image.png"></p><p><strong>验证一下内存地址：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator delete p:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br><span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>cout &lt;&lt; <span class="hljs-string">&quot;operator new p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(); <span class="hljs-comment">// B::vftable</span><br>cout &lt;&lt; <span class="hljs-string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>p-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111629072.png" alt="image.png"></p><p><code>00000119E9411CB0</code> 为分配的内存的起始地址，我们用基类指针指向派生类对象一定是指向派生类内存基类的起始部分：<code>00000119E9411CC0</code> 刚好比 <code>00000119E9411CB0</code> 多了 16 个字节，是 <code>vbptr</code> 与 mb，但是 delete 时候从 <code>00000119E9411CC0</code> 开始释放，因此崩溃。</p><p>Windows 的 VS 下这样写会出错，但是 Linux 下的 <code>g++ delete</code> 时会自动偏移到 new 内存的起始部分，进行内存 <code>free()</code>，不会出错。</p><p>如果在栈上开辟内存，基类指针指向派生类对象，出了作用域自己进行析构，这样是没有问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">B b;<br>A *p = &amp;b; <span class="hljs-comment">// B::vftable</span><br>cout &lt;&lt; <span class="hljs-string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>p-&gt;<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></table></figure><h2 id="9-菱形继承问题"><a href="#9-菱形继承问题" class="headerlink" title="9. 菱形继承问题"></a>9. 菱形继承问题</h2><p><strong>多重继承：</strong> 一个<code>派生类</code>如果只继承一个<code>基类</code>，称作单继承； 一个<code>派生类</code>如果继承了多个<code>基类</code>，称作多继承。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111602992.png" alt="image.png"></p><p><strong>优点：</strong></p><ul><li>多重继承可以做更多的代码复用！</li><li>派生类通过多重继承，可以得到多个基类的数据和方法，更大程度的实现了代码复用。</li></ul><p><strong>问题：</strong></p><p>菱形继承的问题：在于继承时有重复利用的数据。</p><p><strong>会导致派生类有多份间接基类的数据，可以采用虚继承来解决。</strong> <strong>A 为 B、C 的基类，B 从 A 单继承而来，C 从 A 也是单继承而来；D 是 B 和 C 多继承而来，D 有两个基类分别为 B 和 C。A 称为 D 的间接基类，D 也有 A 的数据。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111637497.png" alt="image.png"></p><p>当然，多重继承还会出现别的问题：</p><p><strong>半圆形继承问题：</strong> <strong>B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111638517.png" alt="image.png"></p><p>多重继承虽然可以复用多个基类的代码到派生类中，但是会出现许多问题，因此 C++ 开源代码上很少见到多重继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">ma</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mb</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">B</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mc</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">C</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~C()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mc;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">B</span>(data), <span class="hljs-built_in">C</span>(data), <span class="hljs-built_in">md</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;D()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">D</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~D()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> md;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>画一下 d 对象的内存布局：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641312.png" alt="image.png"></p><p>D 能看见 B，C 与 md，所以 D 在构造时调用 B，C 的构造及 ma 的初始化。 ma 的初始化在 B 与 C 的构造函数中进行，因此 D 内存为 20 个字节。</p><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641957.png" alt="image.png"></p><p>先是 A 的构造，B 的构造，又是 A 的构造，C 的构造，最后是 D 的构造；析构顺序与其相反。就会发现，D 这个派生类中调用了两次 A 的构造，数据重复，浪费内存，这种情况必须被杜绝。</p><p><strong>如何处理？</strong></p><p><strong>虚继承来处理，所有从A继承而来的地方都采用虚继承，A 就为虚基类。</strong></p><p>此时：<br>B 从 A 虚继承而来，A 为虚基类，<code>A::ma</code> 移动到派生类最后面，在 <code>A::ma</code> 位置上补一个 <code>vbptr</code>；C 也是从 A 虚继承而来，<code>A::ma</code> 移动到派生类最后面，但发现已经有一份同样的虚基类的数据，那么 C 的 <code>A::ma</code> 丢弃，在 <code>A::ma</code> 位置存放 <code>vbptr</code>。此时派生类中只有一份基类 <code>A::ma</code> 的数据，以后访问都是同一个 ma；同时 ma 的初始化由 D 来负责。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111645047.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">ma</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mb</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">B</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mc</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">C</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~C()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mc;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">B</span>(data), <span class="hljs-built_in">C</span>(data), <span class="hljs-built_in">md</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;D()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">D</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~D()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> md;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：修改成功；A、B、C、D各初始化与析构一次。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111646462.png" alt="image.png"></p><h2 id="10-C-的-四种类型转换"><a href="#10-C-的-四种类型转换" class="headerlink" title="10. C++ 的 四种类型转换"></a>10. C++ 的 四种类型转换</h2><blockquote><ol><li>const_cast</li><li>static_cast</li><li>reinterpert_cast</li><li>dynamic_cast</li></ol></blockquote><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1. const_cast"></a>1. const_cast</h3><p><strong>const_cast：修改类型的const或volatile属性。</strong> 使用该运算方法可以返回一个指向非常量的指针（或引用）指向，就可以通过该指针（或引用）对它的数据成员任意改变。</p><p><strong>注意：</strong>  </p><p>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。  </p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span>&lt;里面必须是指针或引用类型&gt;<br></code></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1 = (<span class="hljs-type">int</span>*)&amp;a;<span class="hljs-comment">// C 中类型转换</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;a);<span class="hljs-comment">// C++ 中类型转换 const_cast</span><br></code></pre></td></tr></table></figure><p>转换为相同类型的时候，通过反汇编查看时候，发现 C 中的类型强转与 C++ 中 <code>const_cast</code> 所生成的汇编指令底层是一模一样的。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111757973.png" alt="image.png"></p><p>但是在转换成汇编指令之前，即编译阶段，就有所不同。</p><p><strong>注意：</strong></p><ol><li><strong>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// C 中类型转换，可以</span><br><span class="hljs-type">char</span> *p1 = (<span class="hljs-type">char</span>*)&amp;a;<br><span class="hljs-comment">// C++ 中类型转换 const_cast，不可以</span><br><span class="hljs-type">char</span> *p2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;a);<br></code></pre></td></tr></table></figure><p>通过 C中类型转换可以将 <code>int *</code> 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过 <code>const_cast</code> 将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。<code>const_cast</code>使用时，地址的类型是与左边类型以及转换的类型需要保持一致。防止了 C 中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。</p><p>编译出错：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111806390.png" alt="image.png"></p><ol start="2"><li><strong><code>const_cast&lt;里面必须是指针或引用类型&gt;</code>，否则出错</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);<br></code></pre></td></tr></table></figure><p>编译出错：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111807110.png" alt="image.png"></p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. static_cast</h3><p><strong><code>static_cast(静态)</code>：编译时期的类型转换，提供编译器认为安全的类型转换。</strong></p><p>是一个 c++ 运算符，功能是把一个表达式转换为某种类型，使用最多。</p><p><strong>注意：</strong></p><ol><li><strong>有联系的类型之间可以互相转换。</strong></li><li><strong>没有任何联系的类型之前转换会被否定。</strong></li><li><strong>基类类型与派生类类型进行转换，可以用 <code>static_cast</code>，它们类型之间有关系，但不一定安全。</strong></li></ol><p><strong>实例：</strong></p><ol><li>有联系的类型之间可以互相转换</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);<br></code></pre></td></tr></table></figure><p>编译成功，int 与 char 直之间有联系。</p><ol start="2"><li>有任何联系的类型之间的转换会被否定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// double* = (double*)p; C 可以转换</span><br><span class="hljs-type">double</span>* b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111811911.png" alt="image.png"></p><h3 id="3-reinterpert-cast"><a href="#3-reinterpert-cast" class="headerlink" title="3. reinterpert_cast"></a>3. reinterpert_cast</h3><p><strong><code>reinterpret_cast</code>：类似于 C 风格的强制类型转换，是 C++ 里的强制类型转换符，不安全。</strong></p><p><strong>注意：</strong></p><ol><li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li></ol><p><strong>实例：</strong> </p><ol><li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">double</span>* b = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure><p><code>reinterpret_cast</code> 与 C 中类型转换类似，转换成功，不安全。</p><h3 id="4-dynamic-cast"><a href="#4-dynamic-cast" class="headerlink" title="4. dynamic_cast"></a>4. dynamic_cast</h3><p><strong><code>dynamic_cast</code>(动态)：运行时期的类型转换，用于继承结构中，可以支持 RTTI 类型识别的上下转换及识别。</strong></p><p><strong>将一个基类对象指针（或引用）转换到继承类指针，<code>dynamic_cast</code> 会根据基类指针是否真正指向继承类指针来做相应处理。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive1</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call Derive1::func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive2</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showFunc</span><span class="hljs-params">(Base* p)</span></span><br><span class="hljs-function"></span>&#123;<br>p-&gt;<span class="hljs-built_in">func</span>();<span class="hljs-comment">//动态绑定</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Derive1 d1;<br>Derive1 d2;<br><br><span class="hljs-built_in">showFunc</span>(&amp;d1);<br><span class="hljs-built_in">showFunc</span>(&amp;d2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：执行成功。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111838785.png" alt="image.png"></p><p>需求改变了，<code>Derive</code> 实现了一个新功能的 API 接口函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive2</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//需求更改 Derive2实现新功能的API接口函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derive02func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call derive02func()::func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>void show()</code> 应该区分判断一下，如果 <code>Base* p</code> 指向了其他的派生类对象，调用 <code>p-&gt;func()</code> 方法就好。但如果指向 Derive2 对象，不调用 <code>func()</code> 方法，而调用 Derive2 的 <code>derive02 func()</code>方法。该如何做呢？</p><p>这里就要识别 <code>*p</code> 的类型，看它指向哪个对象。此时就需要<code>dynamic_cast()</code>了。dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象；<code>p-&gt;vfptr-&gt;vftable</code> RTTI 信息 如果是 <code>dynamic_cast</code>，转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showFunc</span><span class="hljs-params">(Base* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象</span><br><span class="hljs-comment">// p-&gt;vfptr-&gt;vftable RTTI 信息 如果是 dynamic_cast，</span><br><span class="hljs-comment">// 转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr</span><br>Derive2 *pd2 = <span class="hljs-built_in">dynamic_cast</span>&lt;Derive2*&gt;(p);<br><span class="hljs-keyword">if</span> (pd2 != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>pd2-&gt;<span class="hljs-built_in">derive02func</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>p-&gt;<span class="hljs-built_in">func</span>();<span class="hljs-comment">//动态绑定</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>指向结果：调用成功。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111845822.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05.C++ 运算符重载</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/05.C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/05.C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>本节分为七个部分：</p><ol><li>学习复数类 Complex</li><li>模拟实现 C++ 的 string 类</li><li>string 字符串对象的迭代器</li><li>vector 容器的迭代器 iterator 实现</li><li>什么是容器的迭代器失效问题</li><li>new 和 delete 重载实现的对象池</li><li>深入理解 new 和 delete 的原理</li></ol><p><strong>什么是运算符重载</strong></p><p>运算符重载实质还是一个 函数。<br>通过重载运算符，可以让类在一些场景下使用起来更加方便。</p><p><strong>语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">op</span> <span class="hljs-params">(参数)</span></span>;​​​​​​​<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassType&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> ClassType&amp; src); <span class="hljs-comment">// 重载 “=” 运算符</span><br></code></pre></td></tr></table></figure><h2 id="1-学习复数类-Complex"><a href="#1-学习复数类-Complex" class="headerlink" title="1. 学习复数类 Complex"></a>1. 学习复数类 Complex</h2><p>复数是形如 <code>a+b</code> 的数，复数由实部和虚部构成，在 C++ 的模板库中由 complex 类，可以直接调用，包含在complex头文件中，再使用时应该添加 <code>#include&lt;complex&gt;</code>。下面介绍一些基本操作</p><h3 id="1-生成复数对象"><a href="#1-生成复数对象" class="headerlink" title="1. 生成复数对象"></a>1. 生成复数对象</h3><p>complex 类型的构造函数接受两个参数，第一个参数是复数实部的值，第二个参数是虚部的值。要想生成一个复数对象，并且对其值进行修改，参考以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>complex&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">x1</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>complex&lt;<span class="hljs-type">double</span>&gt;x2;<br>complex&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">x3</span>(x1);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;<span class="hljs-comment">// x1 = (2, 3)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;x2 = &quot;</span> &lt;&lt; x2 &lt;&lt; endl;<span class="hljs-comment">// x2 = (0, 0)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;x3 = &quot;</span> &lt;&lt; x3 &lt;&lt; endl;<span class="hljs-comment">// x3 = (2, 3)</span><br><br>x1.<span class="hljs-built_in">real</span>(<span class="hljs-number">22</span>);<span class="hljs-comment">// 修改实数部</span><br>x1.<span class="hljs-built_in">imag</span>(<span class="hljs-number">33</span>);<span class="hljs-comment">// 修改虚数部</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;<span class="hljs-comment">// x1 = (22,33)</span><br><br>complex&lt;<span class="hljs-type">double</span>&gt;a, b, c;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入三个复数：&quot;</span>;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100912113.png" alt="image.png"></p><h3 id="2-复数的运算"><a href="#2-复数的运算" class="headerlink" title="2. 复数的运算"></a>2. 复数的运算</h3><p>复数和实数一样都有加减乘除四则运算，这些运算符号在 complex 模板中已经被重载过，能够直接使用，下面代码示例展示了其功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>complex&lt;<span class="hljs-type">double</span>&gt; z1 = z + <span class="hljs-number">5.0</span>;<br>cout &lt;&lt; z1 &lt;&lt; endl;<br>complex&lt;<span class="hljs-type">double</span>&gt; z2 = z - <span class="hljs-number">5.0</span>;<br>cout &lt;&lt; z2 &lt;&lt; endl;<br>complex&lt;<span class="hljs-type">double</span>&gt; z3 = z * <span class="hljs-number">2.0</span>;<br>cout &lt;&lt; z3 &lt;&lt; endl;<br>complex&lt;<span class="hljs-type">double</span>&gt;z4 = z / <span class="hljs-built_in">complex</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cout &lt;&lt; z4 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100914081.png" alt="image.png"></p><h3 id="3-复数的比较"><a href="#3-复数的比较" class="headerlink" title="3. 复数的比较"></a>3. 复数的比较</h3><p>复数的比较需要同时比较实部和虚部是否都相等，有其一不等两数就 不等，下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z3</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br><br>cout &lt;&lt; boolalpha &lt;&lt; (z1 == z3) &lt;&lt; endl;<br>cout &lt;&lt; boolalpha &lt;&lt; (z1 == z2) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100916498.png" alt="image.png"></p><h3 id="4-实现-Complex-类"><a href="#4-实现-Complex-类" class="headerlink" title="4. 实现 Complex 类"></a>4. 实现 Complex 类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//#include &lt;complex&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义Complex 类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 无参构造函数</span><br><span class="hljs-built_in">Complex</span>()<br>: <span class="hljs-built_in">real</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">imag</span>(<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 初始化列表</span><br>&#125;<br><span class="hljs-comment">// 有参构造函数</span><br><span class="hljs-built_in">Complex</span>(T re, T im)<br>: <span class="hljs-built_in">real</span>(re)<br>, <span class="hljs-built_in">imag</span>(im)<br>&#123;<br><span class="hljs-comment">// 初始化列表</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-built_in">Complex</span>(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>: <span class="hljs-built_in">real</span>(com.real)<br>, <span class="hljs-built_in">imag</span>(com.imag)<br>&#123;<br><span class="hljs-comment">// 初始化列表</span><br>&#125;<br><span class="hljs-comment">// 析构</span><br>~<span class="hljs-built_in">Complex</span>()<br>&#123;<br><span class="hljs-comment">// ......</span><br>&#125;<br><br><span class="hljs-comment">// 方法</span><br><span class="hljs-comment">// 1. printComplex 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printComplex</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 2. + 方法重载：复数的加法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real += com.real;<br><span class="hljs-keyword">this</span>-&gt;imag += com.imag;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 3. - 方法重载：复数的减法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real -= com.real;<br><span class="hljs-keyword">this</span>-&gt;imag -= com.imag;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 4. * 方法重载：复数的乘法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real = (real * com.real) - (imag * com.imag);<br><span class="hljs-keyword">this</span>-&gt;imag = (real * com.real) + (imag * com.imag);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 5. / 方法重载：复数的除法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>/(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real = (real * com.real + imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br><span class="hljs-keyword">this</span>-&gt;real = (real * com.real - imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T real;<span class="hljs-comment">// 实部</span><br>T imag;<span class="hljs-comment">// 虚部</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>)</span></span>;<br>c1.<span class="hljs-built_in">printComplex</span>();<br><span class="hljs-function">Complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>)</span></span>;<br>c2.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c1 = c1 + c2;<br>cout &lt;&lt; <span class="hljs-string">&quot;c1 加法后：&quot;</span>;<br>c1.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c2 = c2 - c1;<br>cout &lt;&lt; <span class="hljs-string">&quot;c2 减法后：&quot;</span>;<br>c2.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c1 = c2 * c1;<br>cout &lt;&lt; <span class="hljs-string">&quot;c1 乘法后：&quot;</span>;<br>c1.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c2 = c2 / c1;<br>cout &lt;&lt; <span class="hljs-string">&quot;c2 除法后：&quot;</span>;<br>c2.<span class="hljs-built_in">printComplex</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100954476.png" alt="image.png"></p><p>另一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CComplex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CComplex</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>)<br>:_mreal(r)<br>,_mimage(i)<br>&#123;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CComplex&amp;obj)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_mreal = obj._mreal;<br><span class="hljs-keyword">this</span>-&gt;_mimage = obj._mimage;<br>&#125;<br><span class="hljs-comment">//指导编译器怎么做CComplex类对象的加法操作</span><br><span class="hljs-comment">/*CComplex operator+(const CComplex&amp;com)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">return CComplex(this-&gt;_mreal + com._mreal,</span><br><span class="hljs-comment">this-&gt;_mimage + com._mimage);</span><br><span class="hljs-comment">&#125;*/</span><br>CComplex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CComplex</span>(<span class="hljs-keyword">this</span>-&gt;_mreal++, <span class="hljs-keyword">this</span>-&gt;_mimage++);<br><span class="hljs-comment">/*CComplex comp = *this;</span><br><span class="hljs-comment">this-&gt;_mimage++;</span><br><span class="hljs-comment">this-&gt;_mreal++;</span><br><span class="hljs-comment">return comp;*/</span><br>&#125;<br>CComplex&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_mreal += <span class="hljs-number">1</span>;<br>_mimage += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> CComplex&amp;rhs)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_mreal += rhs._mreal;<br><span class="hljs-keyword">this</span>-&gt;_mimage += rhs._mimage;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;real:&quot;</span> &lt;&lt; _mreal &lt;&lt; <span class="hljs-string">&quot;image:&quot;</span> &lt;&lt; _mimage &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _mreal;<br><span class="hljs-type">int</span> _mimage;<br><span class="hljs-keyword">friend</span> CComplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> CComplex &amp;lhs, <span class="hljs-type">const</span> CComplex &amp;rhs);<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;out, <span class="hljs-type">const</span> CComplex&amp;src);<br><span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src);<br>&#125;;<br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>in &gt;&gt; a &gt;&gt; b;<br>src._mreal = a;<br>src._mimage = b;<br><span class="hljs-keyword">return</span> in;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;out, <span class="hljs-type">const</span> CComplex&amp;src)<br>&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;real:&quot;</span> &lt;&lt; src._mreal &lt;&lt; <span class="hljs-string">&quot;image:&quot;</span> &lt;&lt; src._mimage &lt;&lt; endl;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br>CComplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> CComplex &amp;lhs, <span class="hljs-type">const</span> CComplex &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CComplex</span>(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CComplex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">CComplex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>CComplex c4;<br><br>c4 = c1+c2;<br>c4.<span class="hljs-built_in">show</span>();<br><br>c4 = c1 + <span class="hljs-number">20</span>;<br>c4.<span class="hljs-built_in">show</span>();<br><br>c4 = <span class="hljs-number">30</span> + c2;<br>c4.<span class="hljs-built_in">show</span>();<br><br>CComplex c5;<br>c5 = c4++;<br>c5.<span class="hljs-built_in">show</span>();<br> <br>c5 = ++c4;<br>c5.<span class="hljs-built_in">show</span>();<br> <br>c5 += c4;<br>c5.<span class="hljs-built_in">show</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;<br> <br>cout &lt;&lt; c5;<br> <br>CComplex c6;<br>cin &gt;&gt; c6;<br>cout &lt;&lt; c6;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-模拟实现-C-的-string-类"><a href="#2-模拟实现-C-的-string-类" class="headerlink" title="2. 模拟实现 C++ 的 string 类"></a>2. 模拟实现 C++ 的 string 类</h2><p>string 类中的基本方法有：</p><ol><li>构造函数</li><li><ul><li>运算符重载</li></ul></li><li><code>&lt;&lt;</code> 运算符重载</li><li><blockquote><p>运算符重载</p></blockquote></li><li>len 方法</li><li><code>[]</code> 运算符重载</li><li>迭代器实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//默认构造函数</span><br>    string str1;<br>    string str2 = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-comment">//+ 运算符重载</span><br>    string str4 = str2 + str3;<br>    string str5 = str2 + <span class="hljs-string">&quot;ccc&quot;</span>;<br>    string str6 = <span class="hljs-string">&quot;ddd&quot;</span> + str2;<br><br>    <span class="hljs-comment">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// &gt;  运算符重载</span><br>    <span class="hljs-keyword">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-type">int</span> len = str6.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-comment">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// c_str()</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">strcpy</span>(buff, str6.<span class="hljs-built_in">c_str</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 迭代器实现</span><br>    string::iterator it = str2.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (it = str2.<span class="hljs-built_in">begin</span>(); it != str2.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101003436.png" alt="image.png"></p><h3 id="1-实现-string"><a href="#1-实现-string" class="headerlink" title="1. 实现 string"></a>1. 实现 string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建 string 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 创建</span><br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 拷贝</span><br>            <span class="hljs-built_in">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *_pstr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br>        _pstr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 运算符重载</span><br>    <span class="hljs-comment">// 1. =</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br><br>        <span class="hljs-comment">// 创建</span><br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. &gt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3. &lt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4. ==</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5. []</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class="hljs-comment">// 公共方法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(_pstr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">return</span> _pstr; <br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _pstr;<br><br>    <span class="hljs-comment">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class="hljs-comment">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str);<br><span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  重载+；</span><br><span class="hljs-comment">  重载+ 有两种方式：</span><br><span class="hljs-comment">  (1)定义成成员函数</span><br><span class="hljs-comment">  String operator+(const String&amp; s)&#123;</span><br><span class="hljs-comment">    String tmp;</span><br><span class="hljs-comment">    .....</span><br><span class="hljs-comment">    return tmp;</span><br><span class="hljs-comment">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class="hljs-comment">  （2）重载为全局函数</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/************************************************************************/</span><br>    <span class="hljs-keyword">friend</span> String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class="hljs-comment">并以此开辟空间大小，</span><br><span class="hljs-comment">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class="hljs-comment">*/</span><br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">char</span>* _ptmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(lhs._pstr) + <span class="hljs-built_in">strlen</span>(rhs._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拷贝</span><br>    <span class="hljs-built_in">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(_ptmp)</span></span>;<br>    <span class="hljs-keyword">delete</span>[]_ptmp;<br>    <br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    String str3 = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-comment">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class="hljs-string">&quot;ccc&quot;</span>;<br>    String str6 = <span class="hljs-string">&quot;ddd&quot;</span> + str2;<br><br>    <span class="hljs-comment">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// &gt;  运算符重载</span><br>    <span class="hljs-keyword">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-type">int</span> len = str6.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-comment">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// c_str()</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">strcpy</span>(buff, str6.<span class="hljs-built_in">c_str</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//  string::iterator it = str2.begin();</span><br>    <span class="hljs-comment">// for (it = str2.begin(); it != str2.end(); ++it) &#123;</span><br>     <span class="hljs-comment">// cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">char</span>* _ptmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(lhs._pstr) + <span class="hljs-built_in">strlen</span>(rhs._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拷贝</span><br>    <span class="hljs-built_in">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(_ptmp)</span></span>;<br>    <span class="hljs-keyword">delete</span>[]_ptmp;<br>    <br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了将局部新开辟的内存空间 <code>_ptmp</code> 资源释放，我们后面又构造了一个临时对象 <code>String tmp(_ptmp)</code>，之后将局部变量资源释放 <code>delete[]_ptmp</code>，但是这样一来的效率非常低！</p><h2 id="3-string-字符串对象的迭代器"><a href="#3-string-字符串对象的迭代器" class="headerlink" title="3. string 字符串对象的迭代器"></a>3. string 字符串对象的迭代器</h2><p>容器的迭代器可以透明的访问容器内部的元素的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string::iterator it = str2.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (it = str2.<span class="hljs-built_in">begin</span>(); it != str2.<span class="hljs-built_in">end</span>(); ++it) &#123;<br> cout &lt;&lt; (*it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代器创建</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">iterator</span>(<span class="hljs-type">char</span> *p = <span class="hljs-literal">nullptr</span>) : _p(p) &#123; &#125;<br>    <span class="hljs-comment">// 拷贝函数</span><br>    <span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>    <br>    <span class="hljs-comment">// 重载运算符</span><br>     <span class="hljs-comment">// !=  如 it != s1.end()</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it) &#123;<br>        <span class="hljs-keyword">return</span> _p != it._p;<span class="hljs-comment">//比较地址</span><br>    &#125;<br>    <span class="hljs-comment">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>    iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++_p;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//后置++  返回临时量</span><br>    iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        _p++;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-comment">//解引用  *iter</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *_p; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _p;<br>&#125;;<br><br><span class="hljs-comment">// 创建迭代器的 begin 和 end</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr + <span class="hljs-built_in">length</span>()); &#125;<br></code></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建 string 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 迭代器创建</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-built_in">iterator</span>(<span class="hljs-type">char</span> *p = <span class="hljs-literal">nullptr</span>) : _p(p) &#123; &#125;<br>        <span class="hljs-comment">// 拷贝函数</span><br>        <span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>        <br>        <span class="hljs-comment">// 重载运算符</span><br>         <span class="hljs-comment">// !=  如 it != s1.end()</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it) &#123;<br>            <span class="hljs-keyword">return</span> _p != it._p;<span class="hljs-comment">//比较地址</span><br>        &#125;<br>        <span class="hljs-comment">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>        iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            ++_p;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-comment">//后置++  返回临时量</span><br>        iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            <span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>            _p++;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>        <span class="hljs-comment">//解引用  *iter</span><br>        <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *_p; &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span>* _p;<br>    &#125;;<br><br>    <span class="hljs-comment">// 创建迭代器的 begin 和 end</span><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr); &#125;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr + <span class="hljs-built_in">length</span>()); &#125;<br><br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 创建</span><br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 拷贝</span><br>            <span class="hljs-built_in">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *_pstr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br>        _pstr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 运算符重载</span><br>    <span class="hljs-comment">// 1. =</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br><br>        <span class="hljs-comment">// 创建</span><br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. &gt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3. &lt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4. ==</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5. []</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class="hljs-comment">// 公共方法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(_pstr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">return</span> _pstr; <br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _pstr;<br><br>    <span class="hljs-comment">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class="hljs-comment">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str);<br><span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  重载+；</span><br><span class="hljs-comment">  重载+ 有两种方式：</span><br><span class="hljs-comment">  (1)定义成成员函数</span><br><span class="hljs-comment">  String operator+(const String&amp; s)&#123;</span><br><span class="hljs-comment">    String tmp;</span><br><span class="hljs-comment">    .....</span><br><span class="hljs-comment">    return tmp;</span><br><span class="hljs-comment">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class="hljs-comment">  （2）重载为全局函数</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/************************************************************************/</span><br>    <span class="hljs-keyword">friend</span> String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class="hljs-comment">并以此开辟空间大小，</span><br><span class="hljs-comment">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class="hljs-comment">*/</span><br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">char</span>* _ptmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(lhs._pstr) + <span class="hljs-built_in">strlen</span>(rhs._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拷贝</span><br>    <span class="hljs-built_in">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(_ptmp)</span></span>;<br>    <span class="hljs-keyword">delete</span>[]_ptmp;<br>    <br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    String str3 = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-comment">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class="hljs-string">&quot;ccc&quot;</span>;<br>    String str6 = <span class="hljs-string">&quot;ddd&quot;</span> + str2;<br><br>    <span class="hljs-comment">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// &gt;  运算符重载</span><br>    <span class="hljs-keyword">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-type">int</span> len = str6.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-comment">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// c_str()</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">strcpy</span>(buff, str6.<span class="hljs-built_in">c_str</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br><br>    <span class="hljs-comment">// 迭代器</span><br>    String::iterator it = str2.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (it = str2.<span class="hljs-built_in">begin</span>(); it != str2.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// auto</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str2) &#123;<br>        cout &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-代码优化"><a href="#1-代码优化" class="headerlink" title="1. 代码优化"></a>1. 代码优化</h3><p><strong>带右值引用参数的拷贝构造与带右值引用参数的赋值重载函数</strong></p><p>考虑这样一个操作：</p><p><strong>由于问题场景的特殊，子函数调用时我们无法返回一个临时对象。<br>而且我们也只能用赋值的方式接收一个函数调用的返回值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">String <span class="hljs-title">GetString</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n  GetString() begin\n&quot;</span>;<br>  <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(str.c_str())</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n  GetString() end\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  String s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>  String s2;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n main call GetString() begin\n&quot;</span>;<br>  s2 = <span class="hljs-built_in">GetString</span>(s1);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n main call GetString() end\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101105643.png" alt="image.png"></p><p> 存在的问题：</p><p>（1）在调用 <code>return tmp;</code> 时 实际是使用构造一个临时对象，临时对象调用拷贝构造函数从 tmp 中复制数据，然后调用析构函数析构 tmp 对象，这样就白耗费资源了，tmpStr 资源不要就早说，直接给函数栈帧上临时对象就好了；<br>（2）s2 调用赋值运算符 ：临时量给 str2 赋值，str2 是原本已经存在的对象，它也有一个指针 mptr，原先也指向了一个空间。</p><p>对于赋值来说，排除自赋值，然后把原先指向的空间释放掉，然后按照 str 的尺寸开辟空间，然后拷贝数据进行来。即按照临时对象的字符串大小开辟空间，然后把数据一个一个拷贝进来。</p><p>然后出语句，把这个临时对象析构及它指向的堆内存空间释放掉。</p><p>过程过于复杂，为什么不能直接把临时对象的外部资源给 str2 不就完了吗？</p><h3 id="2-右值引用"><a href="#2-右值引用" class="headerlink" title="2. 右值引用"></a>2. 右值引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++11把临时量都当做右值处理 </span><br>String &amp;&amp;e = <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//可以！ </span><br>    <span class="hljs-type">const</span> String &amp;e = <span class="hljs-built_in">MyString</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//可以！</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-comment">/*拷贝构造函数   //String s2 = s1;*/</span><br>  <span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (str._pstr !=<span class="hljs-literal">nullptr</span>) &#123;<br>      _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>      <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 左值拷贝构造函数\n&quot;</span>;<br>  &#125;<br> <br>  <span class="hljs-comment">//带右值引用参数的拷贝构造</span><br>  <span class="hljs-built_in">String</span>(String &amp;&amp;str)<span class="hljs-comment">//str引用的就是一个临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 右值拷贝构造函数\n&quot;</span>;<br>      _pstr = str._pstr;<br>    str._pstr = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br> <br>  <span class="hljs-comment">/************************************************************************/</span><br><span class="hljs-comment">/*赋值运算符    //s2 = s1*/</span><br><span class="hljs-comment">/************************************************************************/</span><br>  String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; src)<br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 左值赋值运算符\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> <br>    <span class="hljs-keyword">if</span> (src._pstr == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (_pstr) &#123;<br>      <span class="hljs-keyword">delete</span>[]_pstr;<br>    &#125;<br> <br> <br>    _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(src._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(_pstr, src._pstr);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br> <br>  <span class="hljs-comment">//带右值引用参数的赋值重载函数</span><br>  String&amp; <span class="hljs-keyword">operator</span>=(String &amp;&amp;str)<span class="hljs-comment">//str引用的是临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 右值引用参数的赋值重载函数\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> <br>    <span class="hljs-keyword">if</span> (str._pstr == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">delete</span>[]_pstr;<br> <br>    <span class="hljs-type">char</span> * tmp=_pstr ;<br>    _pstr = str._pstr;<br>    str._pstr = tmp;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>通过右值引用，<strong>没有任何内存的开辟和释放和数据的拷贝</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101116493.png" alt="image.png"></p><p>右值引用前：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117001.png" alt="image.png"></p><p>右值引用后：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117760.png" alt="image.png"></p><h2 id="4-vector-容器的迭代器-iterator-实现"><a href="#4-vector-容器的迭代器-iterator-实现" class="headerlink" title="4. vector 容器的迭代器 iterator 实现"></a>4. vector 容器的迭代器 iterator 实现</h2><p><strong>问题 1：删除 vector 中所有的偶数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 删除偶数</span><br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it &lt; vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>vec.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101137035.png" alt="image.png"></p><p>运行导致程序崩溃！</p><p><strong>问题 2：vector 容器插入元素问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it &lt; vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>vec.<span class="hljs-built_in">insert</span>(it, *it - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101430280.png" alt="image.png"></p><p>运行导致程序崩溃！</p><p><strong>问题 3：push_back 触发扩容时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;容量：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;后push_back容量：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;添加后，it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101503945.png" alt="image.png"></p><p><strong>原因：iterator 失效</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101431915.png" alt="image.png"></p><p>当删除（获取增加）it 位置的元素时，导致 it 后面的迭代器全部失效。因此多次调用 <code>erase\insert</code>导致崩溃</p><h2 id="5-什么是容器的迭代器失效问题"><a href="#5-什么是容器的迭代器失效问题" class="headerlink" title="5. 什么是容器的迭代器失效问题"></a>5. 什么是容器的迭代器失效问题</h2><h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h3><p><strong>问题一：</strong></p><p>当容器调用 erase 时，当前位置到容器末尾元素的所有的迭代器全部失效</p><p><strong>问题二：</strong></p><p>当容器调用 insert 时，当前位置到容器末尾元素的所有的迭代器全部失效</p><p>当容器调用 insert 时，如果引起容器内存扩容，原来容器的所有的迭代器就全部失效</p><p><strong>问题三：</strong></p><p>当容器 push_back 时，如果当前容量不足，则会触发扩容，导致整个容器重新申请内存，并且将原有的数据复制到新内存中将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放。</p><h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h3><p>进行更新操作：<code>erase\insert</code> 后会返回指向下一个元素的迭代器</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101510112.png" alt="image.png"></p><ul><li>[vector::erase] <a href="https://cplusplus.com/reference/vector/vector/erase/">https://cplusplus.com/reference/vector/vector/erase/</a></li></ul><p>从向量中删除单个元素（位置）或一系列元素（<code>[第一、最后一个]</code>）。</p><p>这有效地减少了容器的大小，减少了被删除的元素的数量，这些元素会被销毁。</p><p>由于向量使用数组作为其底层存储，擦除向量端以外位置的元素会导致容器在段擦除后将所有元素重新定位到其新位置。与其他类型的序列容器对相同操作执行的操作相比，这通常是一种低效的操作（如列表或转发列表）。</p><p>同理，insert</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101512469.png" alt="image.png"></p><p>通过在指定位置的元素之前插入新元素来扩展向量，从而通过插入的元素数量有效地增加容器大小。</p><p>当且仅当新向量大小超过当前向量容量时，这会导致自动重新分配分配分配的存储空间。</p><p>因为向量使用数组作为其底层存储，所以在向量末端以外的位置插入元素会导致容器将位置之后的所有元素重新定位到它们的新位置。与其他类型的序列容器（如 list 或 forward_list）对相同操作执行的操作相比，这通常是一种低效的操作。</p><p>这些参数确定插入的元素数量及其初始化值：</p><p>也说明了进行插入操作会导致之后的迭代器失效。</p><p>修改代码：</p><p>erase 解决代码：**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 把 vec 容器中的所有偶数删除</span><br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 重新赋值</span><br>it = vec.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 输出查看</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : vec)<br>&#123;<br>cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101516128.png" alt="image.png"></p><p><strong>insert 解决代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    vec.<span class="hljs-built_in">push_back</span>(i);<br>  &#125;<br> <br>  <span class="hljs-comment">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>  <span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    <span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      it = vec.<span class="hljs-built_in">insert</span>(it, *it - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// it原来的位置插入了新的，需要++it两次，才能到该偶数的后一个元素</span><br>      it++;<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : vec) &#123;<br>    cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101520065.png" alt="image.png"></p><h3 id="3-vector-实现中的-insert-和-erase"><a href="#3-vector-实现中的-insert-和-erase" class="headerlink" title="3. vector 实现中的 insert 和 erase"></a>3. vector 实现中的 insert 和 erase</h3><p>头插法：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101522251.png" alt="image.png"></p><p>检查迭代器失效：</p><p>在进行删除或增加的时候，要检测该位置到 last 位置，使其迭代器失效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> <span class="hljs-comment">// 从容器末尾删除元素</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br> <br>  <span class="hljs-comment">//检查迭代器 从该位置到最后</span><br>  <span class="hljs-built_in">verify</span>(Last<span class="hljs-number">-1</span>,Last);<br> <br>  <span class="hljs-comment">// 不仅要把_last指针--，还需要析构删除的元素</span><br>  --Last;<br>  _allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>迭代器检查实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">verify</span><span class="hljs-params">(T* first, t* last)</span></span><br><span class="hljs-function"></span>&#123;<br>Iterator_Base* pre = &amp;<span class="hljs-keyword">this</span>-&gt;head;<br>Iterator_Base* it = &amp;<span class="hljs-keyword">this</span>-&gt;head._next;<br><br><span class="hljs-keyword">while</span> (it != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)<br>&#123;<br><span class="hljs-comment">// 迭代器失效，把 iterator 持有的容器指针置空</span><br>it-&gt;_cur-&gt;_pVec = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 删除当前迭代器节点，继续判断后面的迭代器是否失效</span><br>pre-&gt;_next = it-&gt;_next;<br><span class="hljs-keyword">delete</span> it;<br>it = pre-&gt;_next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pre = it;<br>it = it-&gt;_next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-new-和-delete-重载实现的对象池"><a href="#6-new-和-delete-重载实现的对象池" class="headerlink" title="6. new 和 delete 重载实现的对象池"></a>6. new 和 delete 重载实现的对象池</h2><p>在编程中，我们经常会涉及到对象的操作，而经常的操作模式如下图所示:<code>创建对象</code>-&gt;<code>使用对象</code>-&gt;<code>销毁对象</code>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101557430.png" alt="image.png"></p><p>而这个对象有可能创建的时候会需要构建很多资源，消耗比较大, 比如：在<code>hiredis</code>的SDK中每次都创建一个<code>redisContext</code>，如果需要查询，那就首先要进行网络连接。如果一直都是上图的工作方式，那将会频繁的创建连接，查询完毕后再释放连接。重新建立连接，让网络的查询效率降低。</p><p>这个时候就可以构建一个<code>对象池</code>来重复利用这个对象，并且一般要做到线程安全:</p><ol><li>从<code>对象池</code>中获取对象，如果没有对象，则创建一个，并返回</li><li>使用对象</li><li>使用完成对象后，将对象还回<code>对象池</code></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101559621.png" alt="image.png"></p><p>那么符合如下条件的，应该适合使用<code>对象池</code>技术:</p><ul><li>有一些对象虽然创建开销比较大，但是不一定能够重复使用。要使用<code>对象池</code>一定要确保对象能够重复使用。</li><li>这个对象构建的时候，有一些耗时的资源可以重复利用。比如<code>redisContext</code>的网络连接。又或者如果对象的频繁申请释放会带来一些其他的资源使用问题，比如<code>内存碎片</code>。重复利用能够提升程序的效率。</li><li><code>对象池</code>的数量应该控制在能够接受的范围内，并不会无限膨胀。</li></ul><h3 id="1-对象池实现原理"><a href="#1-对象池实现原理" class="headerlink" title="1. 对象池实现原理"></a>1. 对象池实现原理</h3><ol><li><strong>分配过程：</strong></li></ol><p><strong>我们首先申请比如 100000 块内存空间，用这个块类型的指针指向这个申请好内存的首地址。如图：这个块可以是一个链式队列的一个节点或者一个树的节点等。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101603100.png" alt="image.png"><br><strong>当我们要分配给用户一块空间的时候我们就可以，先将 <code>_itemPool</code> 的地址保存到临时指针 p，然后再 <code>_itemPool++</code> 的操作，然后再将 p 返回给用户即可。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101604537.png" alt="image.png"></p><ol start="2"><li><strong>释放过程：</strong></li></ol><p><strong>比如现在的内存分配状况如图所示：现在用户需要归还第 1 块内存。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101605266.png" alt="image.png"></p><p>我们首先要归还块的首地址指向 <code>_itemPool</code> 的下一个块，然后再将 <code>_itemPool</code> 指向归还的块的地址。即可</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101606815.png" alt="image.png"></p><h3 id="2-以队列实现一个简单对象池"><a href="#2-以队列实现一个简单对象池" class="headerlink" title="2. 以队列实现一个简单对象池"></a>2. 以队列实现一个简单对象池</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运算符的重载  :成员方法、全局方法</span><br><span class="hljs-comment">内存池 进程池 线程池 连接池 对象池</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">Queue</span>()<br>&#123;<br><span class="hljs-comment">// 初始化指针</span><br>_front = _rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueItem</span>();<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">Queue</span>()<br>&#123;<br><span class="hljs-comment">// 创建新对象</span><br>QueueItem* cur = _front;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>_front = cur-&gt;_next;<br><span class="hljs-keyword">delete</span> cur;<br>cur = _front;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 拷贝对象</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">const</span> Queue&amp; obj) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">// 赋值重载</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Queue&amp; obj) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">// 方法</span><br><span class="hljs-comment">// 1. push 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>QueueItem* item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueItem</span>(val);<br>_rear-&gt;_next = item;<br>_rear = item;<br>&#125;<br><span class="hljs-comment">// 2. pop 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>QueueItem* first = _front-&gt;_next;<br>_front-&gt;_next = first-&gt;_next;<br><span class="hljs-keyword">if</span> (_front-&gt;_next == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>_rear = _front;<br>&#125;<br><span class="hljs-keyword">delete</span> first;<br>&#125;<br><span class="hljs-comment">// 3. front 方法</span><br><span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _front-&gt;_next-&gt;_data;<br>&#125;<br><span class="hljs-comment">// 4. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _rear == _front; &#125;<br><br><span class="hljs-comment">// 产生一个 QueueItem 的对象池</span><br><span class="hljs-comment">// 创建一个对象池结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueItem</span><br>&#123;<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">QueueItem</span>(T data = <span class="hljs-built_in">T</span>()) :_data(data), _next(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br><span class="hljs-comment">// new 重载</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (_itemPool == <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-comment">//由于我们不知道QueueItem的具体大小(模板未进行实例化)所以我们这里用char 1字节作为new的基准</span><br>_itemPool = (QueueItem*)<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[POOL_ITEM_SIZE * <span class="hljs-built_in">sizeof</span>(QueueItem)];<br>QueueItem* p = _itemPool;<br><span class="hljs-comment">//把开辟的POOL_ITEM_SIZE个块关联起来</span><br><span class="hljs-keyword">for</span> (; p != _itemPool + POOL_ITEM_SIZE - <span class="hljs-number">1</span>; ++p)<br>&#123;<br>p-&gt;_next = p + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//最后一块的next置为空</span><br>p-&gt;_next = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">//将第一块可以分配的块分配给用户</span><br>QueueItem* p = _itemPool;<br>_itemPool = _itemPool-&gt;_next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">// delete 重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//进行归还操作</span><br>QueueItem* p = (QueueItem*)ptr;<br>p-&gt;_next = _itemPool;<br>_itemPool = p;<br>&#125;<br><br><span class="hljs-comment">// 静态数据</span><br><span class="hljs-type">static</span> QueueItem* _itemPool;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> POOL_ITEM_SIZE = <span class="hljs-number">1000000</span>;<br><br><span class="hljs-comment">// 对象池单个对象</span><br>T _data;<br>QueueItem* _next;<br>&#125;;<br><br><span class="hljs-keyword">private</span>:<br>QueueItem* _front;<span class="hljs-comment">//指向头节点</span><br>QueueItem* _rear;<span class="hljs-comment">//指向队尾</span><br>&#125;;<br><br><span class="hljs-comment">//typename 告诉编译器后面是类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> Queue&lt;T&gt;::QueueItem* Queue&lt;T&gt;::QueueItem::_itemPool = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; ++i)<span class="hljs-comment">//大量的new delete;不划算</span><br>&#123;<br>que.<span class="hljs-built_in">push</span>(i);<br>que.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br>cout &lt;&lt; que.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-深入理解-new-和-delete-的原理"><a href="#7-深入理解-new-和-delete-的原理" class="headerlink" title="7. 深入理解 new 和 delete 的原理"></a>7. 深入理解 new 和 delete 的原理</h2><p><strong>new和delete</strong>是用户进行<strong>动态内存申请和释放的操作符</strong>，<strong>operator new 和operator delete</strong>是系统提供的<strong>全局函数</strong>，<strong>new在底层调用operator new</strong>全局函数来申请空间，<strong>delete在底层通过operator delete</strong>全局函数来释放空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator new:该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span>* __CRTDECL <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> _<span class="hljs-title">THROW1</span><span class="hljs-params">(_STD bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// try to allocate size bytes</span><br>    <span class="hljs-type">void</span>* p;<br>    <span class="hljs-keyword">while</span> ((p = <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> (_callnewh(size) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// report no memory</span><br>            <span class="hljs-comment">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常 </span><br>            <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::bad_alloc nomem; <br>            _RAISE(nomem);<br>        &#125;<br>        <br>    <span class="hljs-keyword">return</span> (p);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator delete: 该函数最终是通过free来释放空间的 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pUserData)</span></span><br><span class="hljs-function"></span>&#123;<br>    _CrtMemBlockHeader* pHead;<br>    <br>    <span class="hljs-built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (pUserData == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    _mlock(_HEAP_LOCK);  <span class="hljs-comment">/* block other threads */</span><br>    __TRY<br>    <br>        <span class="hljs-comment">/* get a pointer to memory block header */</span><br>        pHead = <span class="hljs-built_in">pHdr</span>(pUserData);<br>        <br>    <span class="hljs-comment">/* verify block type */</span><br>    _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));<br>    <br>    _free_dbg(pUserData, pHead-&gt;nBlockUse);<br>    <br>    __FINALLY<br>        _munlock(_HEAP_LOCK);  <span class="hljs-comment">/* release other threads */</span><br>    __END_TRY_FINALLY<br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">free的实现</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> free(p) _free_dbg(p, _NORMAL_BLOCK)</span><br></code></pre></td></tr></table></figure><p><strong>1. 内置类型：</strong></p><p>如果申请的是内置类型的空间 <code>new</code> 和 <code>malloc</code>，<code>delete</code> 和 <code>free</code> 基本类似，不同的地方是：<code>new/delete</code> 申请和释放的是单个元素的空间，<code>new[]</code> 和 <code>delete[]</code> 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc会返回NULL。</p><p><strong>2. 自定义类型:</strong></p><p><strong>new的原理：</strong></p><ol><li>调用operator new函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ol><p><strong>delete的原理：</strong></p><p>在空间上执行析构函数，完成对象中资源的清理工作在空间上执行析构函数，完成对象中资源的清理工作</p><p><code>new T[N]</code> 的原理：</p><ol><li>调用 <code>operator new[]</code> 函数，在 <code>operator new[]</code> 中实际调用 <code>operator new</code> 函数完成 N 个对象空间的申请</li><li>在申请的空间上执行N次构造函数</li></ol><p><code>delete[ ]</code>的原理：</p><ol><li>在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理</li><li>调用 <code>operator delete[]</code> 释放空间，实际在 <code>operator delete[]</code> 中调用 <code>operator delete</code> 来释放空间</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04.C++ 函数模板</title>
    <link href="/2023/08/08/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/04.C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/08/08/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/04.C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>本节分为四个部分：</p><ol><li>理解函数模板</li><li>理解类模板</li><li>实现 C++ STL 向量容器 vector</li><li>理解容器控件配置器 allocator</li></ol><h2 id="1-理解函数模板"><a href="#1-理解函数模板" class="headerlink" title="1. 理解函数模板"></a>1. 理解函数模板</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</p><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h3><p>面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = x;<br>x = y;<br>y = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-type">double</span> &amp; xr <span class="hljs-type">double</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。</p><p>能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。</p><p>程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。</p><p><strong>模板函数、模板的特例化和非模板函数的重载关系</strong>：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。</p><p><strong>模板代码是不能声明在.h，实现在.cpp</strong>，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 <code>#include</code></p><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p><p>在 C++ 中，模板分为函数模板和类模板两种。</p><ul><li>函数模板是用于生成函数；</li><li>类模板则是用于生成类的。</li></ul><p>函数模板的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">1</span>, <span class="hljs-keyword">class</span>类型参数<span class="hljs-number">2</span>, ...&gt;<br>返回值类型  模板名(形参表)<br>&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中的 class 关键字也可以用 typename 关键字替换</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> 类型参数<span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> 类型参数<span class="hljs-number">2</span>, ...&gt;<br></code></pre></td></tr></table></figure><p>函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp = x; <br>x = y; <br>y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>T 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp = x;<br>x = y;<br>y = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>, m = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 编译器自动生成 void Swap (int &amp;, int &amp;)函数</span><br><span class="hljs-built_in">Swap</span>(n, m);<br><br><span class="hljs-type">double</span> f = <span class="hljs-number">1.2</span>, g = <span class="hljs-number">3.4</span>;<br><span class="hljs-comment">// 编译器自动生成 void Swap (double &amp;, double &amp;)函数</span><br><span class="hljs-built_in">Swap</span>(f, g);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器在编译到 <code>Swap(n, m);</code> 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-type">int</span> &amp; x, <span class="hljs-type">int</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数可以匹配 <code>Swap(n, m);</code> 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 <code>Swap(n, m);</code> 编译成对自动生成的 Swap 函数的调用。</p><p>同理，编译器在编译到 <code>Swap(f, g);</code> 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp; x, <span class="hljs-type">double</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再将 <code>Swap(f, g);</code> 编译成对该 Swap 函数的调用。</p><p>编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。</p><p>编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">模板名&lt;实际类型参数<span class="hljs-number">1</span>, 实际类型参数<span class="hljs-number">2</span>, ...&gt;<br></code></pre></td></tr></table></figure><h2 id="2-理解类模板"><a href="#2-理解类模板" class="headerlink" title="2. 理解类模板"></a>2. 理解类模板</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>为了多快好省地定义出一批<strong>相似的类</strong>,可以定义「类模板」，然后<strong>由类模板生成不同的类</strong>。</p><p>类模板的定义形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">1</span>，<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">2</span>，...&gt; <span class="hljs-comment">//类型参数表</span><br><span class="hljs-keyword">class</span> 类模板名<br>&#123;<br>   成员函数和成员变量<br>&#125;;<br></code></pre></td></tr></table></figure><p>用类模板定义对象的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实参表);<br></code></pre></td></tr></table></figure><ul><li>类模板用于实现类所需数据的类型参数化</li><li>类模板在表示如数组、表、图等数据结构显得特别重要</li><li>这些数据结构的表示和算法不受所包含的元素类型的影响</li></ul><h3 id="2-类模板实现顺序栈"><a href="#2-类模板实现顺序栈" class="headerlink" title="2. 类模板实现顺序栈"></a>2. 类模板实现顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqStack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 构造函数初始化</span><br><span class="hljs-comment">// 构造和析构函数名不加&lt;T&gt; 其他出现模板的地方都加上类型参数列表</span><br><span class="hljs-built_in">SeqStack</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">PStack</span>(<span class="hljs-keyword">new</span> T[size])<br>, <span class="hljs-built_in">Top</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">Size</span>(size) &#123;<br><span class="hljs-comment">// 初始化生成的指令更少，效率更高。</span><br><span class="hljs-comment">// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符</span><br>&#125;;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-comment">// 初始化列表的方式初始化 size 和 top</span><br><span class="hljs-built_in">SeqStack</span>(<span class="hljs-type">const</span> SeqStack&lt;T&gt;&amp; stack)<br>: <span class="hljs-built_in">Top</span>(stack.Top)<br>, <span class="hljs-built_in">Size</span>(stack.Size) &#123;<br><span class="hljs-comment">// 重新设置栈</span><br>PStack = <span class="hljs-keyword">new</span> T[stack.Size];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>PStack[i] = stack.PStack[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 析构函数 释放内存</span><br>~<span class="hljs-built_in">SeqStack</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (PStack)<br>&#123;<br><span class="hljs-keyword">delete</span>[] PStack;<br>PStack = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 复制重载</span><br>SeqStack&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SeqStack&lt;T&gt;&amp; stack)<br>&#123;<br><span class="hljs-comment">// 判断是否相等</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;stack)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span>[] PStack;<br><br><span class="hljs-comment">// 重新赋值</span><br>Top = stack.Top;<br>Size = stack.Size;<br>PStack = <span class="hljs-keyword">new</span> T[stack.Size];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>PStack[i] = stack.PStack[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 共有方法</span><br><span class="hljs-comment">// 1. push 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">resize</span>();<br>&#125;<br>PStack[Top] = val;<br>Top++;<br>&#125;<br><br><span class="hljs-comment">// 2. pop 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Top--;<br>&#125;<br><br><span class="hljs-comment">// 3. top 方法</span><br><span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Stack is empty!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> PStack[Top - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> Top == Size;<br>&#125;<br><br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> Top == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 私有方法和数据</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>T* p = <span class="hljs-keyword">new</span> T[Size * <span class="hljs-number">2</span>];<br><span class="hljs-comment">// 将值赋值过去</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>p[i] = PStack[i];<br>&#125;<br><span class="hljs-comment">// 扩大</span><br>Size *= <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span> PStack;<br><span class="hljs-comment">// 重新赋值</span><br>PStack = p;<br>&#125;<br><br>T* PStack;<br><span class="hljs-type">int</span> Top;<br><span class="hljs-type">int</span> Size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SeqStack&lt;<span class="hljs-type">int</span>&gt; stack;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>stack.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; stack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>stack.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-实现-C-STL-向量容器-vector"><a href="#3-实现-C-STL-向量容器-vector" class="headerlink" title="3. 实现 C++ STL 向量容器 vector"></a>3. 实现 C++ STL 向量容器 vector</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png" alt="image.png"></p><p>vector 的本质是一个数组，在vector 中需要有三个指针：</p><ul><li><code>First</code>：指向数组的起始位置</li><li><code>Last</code>：指向已经存放的最后一个元素的下一个位置</li><li><code>End</code>：指向数组长度的末尾元素的下一个位置。</li></ul><p>vector 方法：</p><ul><li>数组的容量：<code>End-First</code></li><li>数组中存放的元素个数：<code>Last-First</code></li><li>数组是否为空：<code>First == Last</code></li><li>数组是否已满：<code>Last == End</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(<span class="hljs-keyword">new</span> T[size])<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 使用初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 获取容器长度</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 创建新容器</span><br>First = <span class="hljs-keyword">new</span> T[size];<br><span class="hljs-comment">// 获取数据长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>First[i] = rhs.First[i];<br>&#125;<br><span class="hljs-comment">// 重置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] First;<br>First = End = Last = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 清除</span><br><span class="hljs-keyword">delete</span>[] First;<br><br><span class="hljs-comment">// 重新计算并赋值</span><br><span class="hljs-comment">// 获取容器长度</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 创建新容器</span><br>First = <span class="hljs-keyword">new</span> T[size];<br><span class="hljs-comment">// 获取数据长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>First[i] = rhs.First[i];<br>&#125;<br><span class="hljs-comment">// 重置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 共有方法</span><br><span class="hljs-comment">// push_back 方法：容器添加内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">extend</span>();<br>&#125;<br><span class="hljs-comment">// 先给之以后，下次 push 则会递增内存</span><br>*Last++ = val;<br>&#125;<br><span class="hljs-comment">// pop_back 方法：容器删除内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>--Last;<br>&#125;<br><span class="hljs-comment">// back 方法：输出删除内容</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// full 方法：容器是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last == End;<br>&#125;<br><span class="hljs-comment">// empty 方法：容器是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last == First;<br>&#125;<br><span class="hljs-comment">// size 方法：获取内容厂区</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last - First;<br>&#125;<br><br><span class="hljs-comment">// 私有方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// vector 容器扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> size = End - First;<br>T* ptmp = <span class="hljs-keyword">new</span> T[size * <span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 遍历并转移</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>ptmp[i] = First[i];<br>&#125;<br><span class="hljs-comment">// 删除原先的</span><br><span class="hljs-keyword">delete</span>[] First;<br><br><span class="hljs-comment">// 重新覆盖</span><br>First = ptmp;<br>Last = First + size;<br>End = First + <span class="hljs-number">2</span> * size;<br>&#125;<br><br><span class="hljs-comment">// 私有数据</span><br><span class="hljs-keyword">private</span>:<br>T* First;<br>T* Last;<br>T* End;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t) <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl; <br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1;<br>Test t2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; std::endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png" alt="image.png"></p><p>问题：在我们实现的 <code>vector</code> 构造函数中，使用 <code>new T[size]</code>  ：它做了两件事情：</p><p>（1）开辟内存空间<br>（2）调用 T 类型的默认构造函数构造对象</p><p>其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。</p><p>同时：在实现 <code>pop_back(）</code> 时，存在内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> <span class="hljs-comment">// 从容器末尾删除元素</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>  --Last;<br>&#125;<br></code></pre></td></tr></table></figure><p> 仅仅将 Last 指针 –，并没有释放 Test 申请的资源。<strong>需要调用对象的析构函数</strong></p><h2 id="4-理解容器控件配置器-allocator"><a href="#4-理解容器控件配置器-allocator" class="headerlink" title="4. 理解容器控件配置器 allocator"></a>4. 理解容器控件配置器 allocator</h2><p><strong>通过 Win msvc 编译器的实现：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>: <span class="hljs-keyword">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;<span class="hljs-comment">// varying size array of values</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">using</span> _Mybase = _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;;<br><span class="hljs-keyword">using</span> _Alty = <span class="hljs-keyword">typename</span> _Mybase::_Alty;<br><span class="hljs-keyword">using</span> _Alty_traits = <span class="hljs-keyword">typename</span> _Mybase::_Alty_traits;<br>......<br></code></pre></td></tr></table></figure><p>系统的实现，除了数据类型外，还有一个<code>allocator</code>,它将开辟空间和构造对象分离开。  </p><p>而这，也就是空间配置器做的工作；</p><h3 id="1-容器的空间配置器"><a href="#1-容器的空间配置器" class="headerlink" title="1. 容器的空间配置器"></a>1. 容器的空间配置器</h3><p>空间配置器主要有四个功能：</p><ol><li>内存开辟 allocate（底层调用<code>malloc</code>）；</li><li>内存释放 deallocate（底层调用<code>free</code>）；</li><li>对象构造 construct（调用<code>构造函数</code>）；</li><li>对象析构 destroy（调用<code>析构函数</code>）；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-comment">// 负责内存的开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存的释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p) <span class="hljs-built_in">T</span>(val);<br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">(T* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ~T() 代表了 T 类型的析构函数</span><br> p-&gt;~<span class="hljs-built_in">T</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重新实现 vector：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 负责内存开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p)<span class="hljs-built_in">T</span>(val); <span class="hljs-comment">// 定位new</span><br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(T* p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p-&gt;~<span class="hljs-built_in">T</span>(); <span class="hljs-comment">// ~T()代表了T类型的析构函数</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 allocator 适配器重写 vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-comment">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 需要把内存开辟和对象构造分开处理</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(_allocator.<span class="hljs-built_in">allocate</span>(size))<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 通过初始化列表的方式，初始化数据</span><br>&#125;<br><br><span class="hljs-comment">// 拷贝函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~vector&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != Last; p++)<br>&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><span class="hljs-comment">// 重置 指针</span><br>First = Last = End = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 1. 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 3. 重新计算</span><br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 1. push_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">expand</span>();<br>&#125;<br><span class="hljs-comment">// 通过适配器添加内容</span><br>_allocator.<span class="hljs-built_in">construct</span>(Last, val);<br>Last++;<br>&#125;<br><span class="hljs-comment">// 2. pop_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>--Last;<br>_allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br><span class="hljs-comment">// 3. back 方法</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last == End; &#125;<br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> First == Last; &#125;<br><span class="hljs-comment">// 6. size 方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last - First; &#125;<br><br><span class="hljs-comment">// 私有属性和方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向数组起始的位置</span><br>T* First;<br><span class="hljs-comment">// 指向数组中有效元素的后继位置</span><br>T* Last;<br><span class="hljs-comment">// 指向数组空间的后继位置</span><br>T* End;<br><span class="hljs-comment">// 定义容器的空间配置器对象</span><br>Alloc _allocator;<br><br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取大小</span><br><span class="hljs-type">int</span> size = End - First;<br><span class="hljs-comment">// 配置 2 倍适配器空间</span><br>T* ptmp = _allocator.<span class="hljs-built_in">allocate</span>(size * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>_allocator.<span class="hljs-built_in">construct</span>(ptmp + i, First[i]);<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 重新赋值</span><br>First = ptmp;<br>Last = First + size;<br>End = First + size * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;)<br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1, t2;<br>cout &lt;&lt; <span class="hljs-string">&quot;1.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png" alt="image.png"></p><p>现在的效果就和 msvc 实现的 vector 相同了</p><h3 id="2-运算符重载与迭代器实现"><a href="#2-运算符重载与迭代器实现" class="headerlink" title="2. 运算符重载与迭代器实现"></a>2. 运算符重载与迭代器实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代器一般是现成容器的嵌套类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">iterator</span>(T* p = <span class="hljs-literal">nullptr</span>)<br>: _ptr(p)<br>&#123;<br><span class="hljs-comment">// 初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter)<br>: _ptr(iter._ptr)<br>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 重载函数合集</span><br><span class="hljs-comment">// 1. 前置 ++</span><br>iterator&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_ptr++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 后置 ++</span><br>iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>_ptr++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// 3. 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br><span class="hljs-comment">// 4. !=</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; iter) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _ptr != iter._ptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* _ptr;<br>&#125;;<br><br><br><span class="hljs-comment">//迭代器方法</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(First); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(Last); &#125;<br><br><span class="hljs-comment">//运算符重载[]</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;OutofRangeException&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> First[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-最终-vector-实现"><a href="#3-最终-vector-实现" class="headerlink" title="3. 最终 vector 实现"></a>3. 最终 vector 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 负责内存开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p)<span class="hljs-built_in">T</span>(val); <span class="hljs-comment">// 定位new</span><br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(T* p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p-&gt;~<span class="hljs-built_in">T</span>(); <span class="hljs-comment">// ~T()代表了T类型的析构函数</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 allocator 适配器重写 vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-comment">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 需要把内存开辟和对象构造分开处理</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(_allocator.<span class="hljs-built_in">allocate</span>(size))<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 通过初始化列表的方式，初始化数据</span><br>&#125;<br><br><span class="hljs-comment">// 拷贝函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~vector&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != Last; p++)<br>&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><span class="hljs-comment">// 重置 指针</span><br>First = Last = End = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 1. 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 3. 重新计算</span><br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//运算符重载[]</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>&#123;<br><span class="hljs-comment">// 判断索引位置</span><br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;OutofRangeException&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 返回索引值</span><br><span class="hljs-keyword">return</span> First[index];<br>&#125;<br><br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 1. push_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">expand</span>();<br>&#125;<br><span class="hljs-comment">// 通过适配器添加内容</span><br>_allocator.<span class="hljs-built_in">construct</span>(Last, val);<br>Last++;<br>&#125;<br><span class="hljs-comment">// 2. pop_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>--Last;<br>_allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br><span class="hljs-comment">// 3. back 方法</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last == End; &#125;<br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> First == Last; &#125;<br><span class="hljs-comment">// 6. size 方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last - First; &#125;<br><br><span class="hljs-comment">// 迭代器一般是现成容器的嵌套类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">iterator</span>(T* p = <span class="hljs-literal">nullptr</span>)<br>: _ptr(p)<br>&#123;<br><span class="hljs-comment">// 初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter)<br>: _ptr(iter._ptr)<br>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 重载函数合集</span><br><span class="hljs-comment">// 1. 前置 ++</span><br>iterator&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_ptr++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 后置 ++</span><br>iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>_ptr++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// 3. 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br><span class="hljs-comment">// 4. !=</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; iter) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _ptr != iter._ptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* _ptr;<br>&#125;;<br><span class="hljs-comment">//迭代器方法</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(First); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(Last); &#125;<br><br><br><span class="hljs-comment">// 私有属性和方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向数组起始的位置</span><br>T* First;<br><span class="hljs-comment">// 指向数组中有效元素的后继位置</span><br>T* Last;<br><span class="hljs-comment">// 指向数组空间的后继位置</span><br>T* End;<br><span class="hljs-comment">// 定义容器的空间配置器对象</span><br>Alloc _allocator;<br><br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取大小</span><br><span class="hljs-type">int</span> size = End - First;<br><span class="hljs-comment">// 配置 2 倍适配器空间</span><br>T* ptmp = _allocator.<span class="hljs-built_in">allocate</span>(size * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>_allocator.<span class="hljs-built_in">construct</span>(ptmp + i, First[i]);<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 重新赋值</span><br>First = ptmp;<br>Last = First + size;<br>End = First + size * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;)<br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1, t2;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-------------------------------&quot;</span> &lt;&lt; endl;<br>vector&lt;Test&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;it = &quot;</span> &lt;&lt; &amp;(*it) &lt;&lt; endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;iterator&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03.C++ 面向对象</title>
    <link href="/2023/08/04/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/04/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>本节分为 7 大类：</p><ol><li>类和对象、this 指针</li><li>构造函数和析构函数</li><li>深拷贝和浅拷贝</li><li>类和对象代码应用实践</li><li>构造函数的初始化列表</li><li>类的各种成员方法及区别</li><li>指向类成员的指针</li></ol><h2 id="1-类和对象、this-指针"><a href="#1-类和对象、this-指针" class="headerlink" title="1. 类和对象、this 指针"></a>1. 类和对象、this 指针</h2><p>C 语言是<strong>面向过程</strong>的，关注的是过程。分析出求解问题的步骤，通过函数调用<strong>逐步</strong>解决问题。</p><p>C++ 是基于<strong>面向对象</strong>的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的<strong>交互</strong>完成。</p><h3 id="1-类的引入"><a href="#1-类的引入" class="headerlink" title="1. 类的引入"></a>1. 类的引入</h3><p>C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetStudentInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* gender, <span class="hljs-type">int</span> age)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">strcpy</span>(_name, name);<br><span class="hljs-built_in">strcpy</span>(_gender, gender);<br>_age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStudentInfo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; _name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;gender = &quot;</span> &lt;&lt; _gender &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> _name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> _gender[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student s;<br>s.<span class="hljs-built_in">SetStudentInfo</span>(<span class="hljs-string">&quot;Peter&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">18</span>);<br>s.<span class="hljs-built_in">PrintStudentInfo</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png" alt="image.png"></p><p>上面结构体的定义，在 C++ 中更喜欢用<code>class</code>来代替。</p><h3 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h3><p>语法结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">className</span> &#123;<br> <span class="hljs-comment">// 类体：由成员函数和成员变量组成</span><br><br>&#125;; <span class="hljs-comment">// 要注意后面的分号</span><br></code></pre></td></tr></table></figure><ul><li><code>class</code>为定义类的关键字</li><li><code>ClassName</code>为类的名字</li><li><code>&#123;&#125;</code>中为类的主体</li><li>注意类定义结束时后面分号。</li></ul><p>类中的元素称为<strong>类的成员</strong>，类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>。 类中的函数称为<strong>类的方法</strong>或者<strong>成员函数</strong>。</p><p>类的两种定义方式：</p><ol><li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</li><li>声明放在.h文件中，类的定义放在<code>cpp</code>文件中。推荐使用！</li></ol><h3 id="3-类的访问限定符及封装"><a href="#3-类的访问限定符及封装" class="headerlink" title="3. 类的访问限定符及封装"></a>3. 类的访问限定符及封装</h3><ol><li><strong>访问限定符：</strong></li></ol><p><code>C++</code>实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。</p><p>访问限定符说明：</p><ol><li><code>public</code> 修饰的成员在类外可以直接被访问</li><li><code>protected</code> 和 <code>private</code> 修饰的成员在类外不能直接被访问(此处 <code>protected</code> 和 <code>private</code> 是类似的)</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li><li><code>class</code> 的默认访问权限为 <code>private</code>，<code>struct</code> 为 <code>public</code> (因为 <code>struct</code> 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</li></ol><blockquote><ul><li>问：C++ 中 <code>struct</code> 和 <code>class</code> 的区别是什么？</li><li>答：C++ 需要兼容 C 语言，所以 C++ 中 <code>struct</code> 可以当成结构体去使用。另外 C++ 中 <code>struct</code> 还可以用来定义类。 和 <code>class</code> 是定义类是一样的，区别是 <code>struct</code> 的成员默认访问方式是 <code>public</code>，<code>class</code> 的成员默认访问方式是 <code>private</code>。</li></ul></blockquote><ol start="2"><li><strong>封装</strong></li></ol><p>面向对象的三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p><p>在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。</p><blockquote><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p></blockquote><p>封装本质上是一种管理：</p><p>使用类数据和方法都封装到一下。 不想给别人看到的，使用 <code>protected</code> &#x2F; <code>private</code> 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p><h3 id="4-类的作用域"><a href="#4-类的作用域" class="headerlink" title="4. 类的作用域"></a>4. 类的作用域</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用<code>::</code>作用域解析符指明成员属于哪个类域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPersonInfo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> _name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> _gender[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-comment">// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::PrintPersonInfo</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;_name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;_gender&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-类的实例化"><a href="#5-类的实例化" class="headerlink" title="5. 类的实例化"></a>5. 类的实例化</h3><p><strong>用类类型创建对象的过程</strong>，称为类的实例化。</p><ol><li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。</li><li>一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。</li><li>做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li></ol><h3 id="6-类对象模型"><a href="#6-类对象模型" class="headerlink" title="6. 类对象模型"></a>6. 类对象模型</h3><p><strong>如何计算类对象的大小</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> _a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-comment">// 类中仅有成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 类中什么都没有---空类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A3</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sizeof</span>(A1) :<span class="hljs-number">4</span><br><span class="hljs-built_in">sizeof</span>(A2) :<span class="hljs-number">1</span><br><span class="hljs-built_in">sizeof</span>(A3) :<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结论：</p><p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 <strong>一个字节</strong> 来唯一标识这个类。</p><h3 id="7-this-指针"><a href="#7-this-指针" class="headerlink" title="7. this 指针"></a>7. this 指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span> </span>&#123;<br>_year = year;<br>_month = month;<br>_day = day;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year; <span class="hljs-comment">// 年</span><br><span class="hljs-type">int</span> _month; <span class="hljs-comment">// 月</span><br><span class="hljs-type">int</span> _day; <span class="hljs-comment">// 日</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Date d1, d2;<br><br>d1.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>d2.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>);<br><br>d1.<span class="hljs-built_in">Display</span>();<br>d2.<span class="hljs-built_in">Display</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述类，有这样的一个问题： <code>Date</code> 类中有 <code>SetDate</code> 与 <code>Display</code> 两个成员函数，函数体中没有关于不同对象的区分，那当 <code>s1</code> 调用 <code>SetDate</code> 函数时，该函数是如何知道应该设置 <code>s1</code> 对象，而不是设置 <code>s2</code> 对象呢？</p><p>C++ 中通过引入 <code>this</code> 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p><h3 id="8-this-指针特性"><a href="#8-this-指针特性" class="headerlink" title="8. this 指针特性"></a>8. this 指针特性</h3><ul><li><code>this</code>指针的类型：<code>类类型* const</code>。</li><li>只能在“成员函数”的内部使用。</li><li><code>this</code>指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给<code>this</code>形参。所以对象中不存储<code>this</code>指针。</li><li><code>this</code>指针是成员函数第一个隐含的指针形参，一般情况由编译器通过<code>ecx</code>寄存器自动传递，不需要用户传递。</li></ul><h2 id="2-构造函数和析构函数"><a href="#2-构造函数和析构函数" class="headerlink" title="2. 构造函数和析构函数"></a>2. 构造函数和析构函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h3><ul><li>因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。</li><li>C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。</li><li>构造函数没有返回值，名字与类名相同。</li></ul><p><strong>注意事项：</strong></p><ol><li>类的构造函数支持函数重载。</li><li>类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。</li><li>类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。</li><li>使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。</li><li>构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 <code>int a = 10;</code> 这是初始化 )，赋值是数据成员定义之后进行的( 像 <code>int b; b = 12;</code> 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> nn, <span class="hljs-type">double</span> dd, <span class="hljs-type">char</span> cc) <br>        : <span class="hljs-built_in">d</span>(dd), <span class="hljs-built_in">n</span>(nn), <span class="hljs-built_in">c</span>(cc) <br>    &#123;<br>        n = <span class="hljs-number">10</span>;<br>        d = <span class="hljs-number">3.4</span>;<br>        c = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>test.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// 运行结果：10 3.4 b</span><br><span class="hljs-comment">// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果</span><br></code></pre></td></tr></table></figure><ol start="6"><li>初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致</li><li>类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>&amp; nn, <span class="hljs-type">const</span> <span class="hljs-type">double</span> dd) <br>        : <span class="hljs-built_in">d</span>(dd), <span class="hljs-built_in">n</span>(nn)<br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>&amp; n;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> d;<br>&#125;;<br><br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(n, <span class="hljs-number">3.5</span>)</span></span>;<br>test.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// 运行结果：5 3.5</span><br></code></pre></td></tr></table></figure><h3 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2. 析构函数"></a>2. 析构函数</h3><ul><li>形式是构造函数名字前面加一个 “~”</li><li>析构函数只有一个没有重载</li><li>析构函数也没有形参</li><li>析构函数是在对象生命周期结束时自动调用的，它负责清理工作</li><li>与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用</li></ul><h2 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3. 深拷贝和浅拷贝"></a>3. 深拷贝和浅拷贝</h2><p>在了解拷贝前，我们需要先知道 <strong>拷贝构造函数</strong> 的本质</p><ul><li>拷贝构造本质上也是构造函数</li><li>参数是所在类的常引用的构造函数</li><li>类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ====== 浅拷贝示例代码 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> nn, <span class="hljs-type">double</span> dd) <br>        : <span class="hljs-built_in">n</span>(nn), <span class="hljs-built_in">d</span>(dd)<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <span class="hljs-comment">// 定义拷贝构造函数</span><br>        : <span class="hljs-built_in">n</span>(t.n), <span class="hljs-built_in">d</span>(t.d)<br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br><br><span class="hljs-comment">// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数</span><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>)</span></span>; <span class="hljs-comment">// 实例化一个对象</span><br><span class="hljs-function">Test <span class="hljs-title">test1</span><span class="hljs-params">(t)</span></span>;  <span class="hljs-comment">// 用对象t初始化另一个对象，调用拷贝构造函数</span><br>Test test2 = t; <span class="hljs-comment">// 通过重载的 &quot;=&quot; 初始化对象，调用拷贝构造函数</span><br>Test* test3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(t);  <span class="hljs-comment">// 调用拷贝构造函数初始化对象</span><br><span class="hljs-keyword">delete</span> test3;<br></code></pre></td></tr></table></figure><ul><li>浅拷贝方式对于一般的数据成员是”OK”的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是”OK”的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题</li><li>针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ====== 浅拷贝 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> n) <br>    : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(n))<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <br>        : <span class="hljs-built_in">p</span>(t.p)<br>    &#123; &#125;<br><br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(t)</span></span>;<br><span class="hljs-comment">// 程序运行出错，重复释放内存</span><br><br><span class="hljs-comment">// ====== 深拷贝 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(n))<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <br>        : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*t.p))<br>    &#123; &#125;<br><br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(t)</span></span>;<br><span class="hljs-comment">// 程序正常运行</span><br></code></pre></td></tr></table></figure><h3 id="1-浅拷贝和深拷贝原理"><a href="#1-浅拷贝和深拷贝原理" class="headerlink" title="1. 浅拷贝和深拷贝原理"></a>1. 浅拷贝和深拷贝原理</h3><p>拷贝就是 <strong>复制</strong>，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。</p><p>对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：</p><ul><li>第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。</li><li>第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。</li></ul><p>拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。</p><p><strong>总结</strong>：</p><ul><li><p><strong>浅拷贝</strong>：位拷贝，拷贝构造函数，赋值重载<br>  多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏</p></li><li><p><strong>深拷贝</strong>：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。</p></li></ul><p>简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><h3 id="2-浅拷贝和深拷贝实现"><a href="#2-浅拷贝和深拷贝实现" class="headerlink" title="2. 浅拷贝和深拷贝实现"></a>2. 浅拷贝和深拷贝实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// --- 浅拷贝实现 ---</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">Light</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br><span class="hljs-built_in">Light</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) : <span class="hljs-built_in">a</span>(A), <span class="hljs-built_in">b</span>(B) &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;b &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-function">Light <span class="hljs-title">obj1</span><span class="hljs-params">(a, b)</span></span>;<br>Light obj2 = obj1;<br><br>obj2.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png" alt="image.png"></p><p><strong>实现 String 类来了解 深拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// --- 深拷贝实现 ---</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-literal">nullptr</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; 默认构造函数:&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (str)<br>&#123;<br><span class="hljs-comment">// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，</span><br><span class="hljs-comment">// 直到碰到第一个字符串结束符&#x27;\0&#x27;为止，然后返回计数器值(长度不包含&#x27;\0&#x27;)</span><br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// strcpy把含有&#x27;\0&#x27;结束符的字符串复制到另一个地址空间</span><br><span class="hljs-built_in">strcpy</span>(data_, str);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">//new 数组类型 与delete []对应</span><br>*data_ = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造：&quot;</span> &lt;&lt; endl;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.data_) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(data_, str.data_);<br>&#125;<br><br><span class="hljs-comment">// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左</span><br>    <span class="hljs-comment">// 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败</span><br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;赋值重载：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">delete</span>[] data_;<br><br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.data_) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(data_, str.data_);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br><span class="hljs-comment">// 释放内存</span><br>~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] data_;<br>data_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* data_ = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>String s1;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;123&quot;</span>)</span></span>;<span class="hljs-comment">//默认构造函数</span><br>String s3 = s2;<span class="hljs-comment">//拷贝构造函数</span><br>String s4 = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-function">String <span class="hljs-title">s5</span><span class="hljs-params">(s4)</span></span>;<span class="hljs-comment">//拷贝构造函数   是构造过程发生</span><br>String s6;<br>s6 = s5;<span class="hljs-comment">//=重载  是赋值，左右两边的对象都已经存在</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类和对象代码应用实践"><a href="#4-类和对象代码应用实践" class="headerlink" title="4. 类和对象代码应用实践"></a>4. 类和对象代码应用实践</h2><p><strong>实现：循环队列</strong></p><p>当队列空时，条件就是 <code>front = rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png" alt="image.png"></p><p>由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 <code>(rear+1) %QueueSize == front</code> (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。</p><p>比如：QueueSize &#x3D; 5，当 front&#x3D;0，而 rear&#x3D;4, (4+1) %5 &#x3D; 0，所以此时队列满。再比如，front &#x3D; 2而rear &#x3D;1。(1 + 1) %5 &#x3D; 2，所以此时 队列也是满的。而对于下图, front &#x3D; 2而rear&#x3D; 0, (0+1) %5 &#x3D; 1，1!&#x3D;2,所以此时队列并没有满。</p><p>另外，当 <code>rear &gt; front</code> 时，此时队列的长度为 <code>rear—front</code>。但当rear &lt; front时，队列长度分为两段，一段是 <code>QueueSize-front</code>，另一段是0 + rear，加在一起，队列长度为 <code>rear-front + QueueSize</code></p><p>因此通用的计算队列长度公式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">(rear — front + QueueSize) % QueueSize<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>队空条件：front &#x3D;&#x3D; rear</li><li>队满条件：(rear+1) %QueueSize &#x3D;&#x3D; front</li><li>队列长度：(rear—front + QueueSize) % QueueSize</li></ul><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 初始化构造</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">20</span>) &#123;<br><span class="hljs-comment">// 创建队列</span><br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><span class="hljs-comment">// 初始化值</span><br>front_ = <span class="hljs-number">0</span>;<br>rear_ = <span class="hljs-number">0</span>;<br>size_ = size;<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">const</span> Queue* queue) &#123;<br><span class="hljs-comment">// 传值</span><br>size_ = queue-&gt;size_;<br>front_ = queue-&gt;front_;<br>rear_ = queue-&gt;rear_;<br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>queue_[i] = queue_[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 复制重构</span><br>Queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Queue&amp; q) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;q)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span> queue_;<br><span class="hljs-comment">// 重新赋值</span><br>size_ = q.size_;<br>front_ = q.front_;<br>rear_ = q.rear_;<br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>queue_[i] = q.queue_[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">Queue</span>() &#123;<br><span class="hljs-keyword">delete</span>[] queue_;<br>queue_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 队列方法：</span><br><span class="hljs-comment">// 1. push：放入元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">resize</span>();<br>&#125;<br><br><span class="hljs-comment">// 从队尾放置</span><br>queue_[rear_] = val;<br><span class="hljs-comment">// 计算下一个位置</span><br>rear_ = (rear_ + <span class="hljs-number">1</span>) % size_;<br>&#125;<br><br><span class="hljs-comment">// 2. 出队方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>front_ = (front_ + <span class="hljs-number">1</span>) % size_;<br>&#125;<br><br><span class="hljs-comment">// 4. 获取对头</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> queue_[front_];<br>&#125;<br><br><span class="hljs-comment">// 3. 判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> rear_ == front_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 私密方法：</span><br><span class="hljs-comment">// 1. 扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 扩容 2 倍</span><br><span class="hljs-type">int</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_ * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 拷贝值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>tmp[index] = queue_[i];<br>index++;<br>&#125;<br><br><span class="hljs-comment">// 清除原先数值</span><br><span class="hljs-keyword">delete</span> queue_;<br><span class="hljs-comment">// 重新赋值</span><br>queue_ = tmp;<br>front_ = <span class="hljs-number">0</span>;<br>rear_ = index++;<br>size_ *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (rear_ + <span class="hljs-number">1</span>) % size_ == front_;<br>&#125;<br><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 队列</span><br><span class="hljs-type">int</span>* queue_;<br><span class="hljs-comment">// 对头</span><br><span class="hljs-type">int</span> front_;<br><span class="hljs-comment">// 队尾</span><br><span class="hljs-type">int</span> rear_;<br><span class="hljs-comment">// 队列扩列大小</span><br><span class="hljs-type">int</span> size_;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建对象</span><br>Queue q1;<br>Queue q2;<br><br><span class="hljs-comment">// 放入元素</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>q1.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">20</span>; i &lt; <span class="hljs-number">40</span>; i++)<br>&#123;<br>q2.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>q1 = q2;<br><br><br><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">while</span> (!q1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q1.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q1.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-构造函数的初始化列表"><a href="#5-构造函数的初始化列表" class="headerlink" title="5. 构造函数的初始化列表"></a>5. 构造函数的初始化列表</h2><p>构造函数初始化列表的情况有三种：</p><ol><li>需要初始化的类的成员变量是对象的情况；</li><li>需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；</li><li>子类初始化父类的成员；</li></ol><p><strong>情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数</strong></p><p>如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyTest</span>() : <span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &#123;       <span class="hljs-comment">// 初始化值</span><br>cout &lt;&lt; <span class="hljs-string">&quot;MyTest&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Test test;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyTest t1;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。</p><p><strong>情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() :<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>) &#123;&#125;           <span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a;             <span class="hljs-comment">//const成员声明</span><br>&#125;;<br><br><span class="hljs-comment">// 或</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> _a) :<span class="hljs-built_in">a</span>(_a) &#123;&#125;      <span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>&amp; a;                 <span class="hljs-comment">//声明</span><br>&#125;<br></code></pre></td></tr></table></figure><p>**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Test</span> (<span class="hljs-type">int</span> x)&#123; int_x = x;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> int_x;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<span class="hljs-keyword">public</span> Test<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mytest</span>() ：<span class="hljs-built_in">Test</span>(<span class="hljs-number">110</span>) <span class="hljs-comment">//调用父类的构造函数</span><br>    &#123;<br>      <span class="hljs-comment">//Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用</span><br>    &#125;;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Mytest</span>();<br> p-&gt;<span class="hljs-built_in">show</span>();<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行顺序：</p><p>在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。</p><h2 id="6-类的各种成员方法及区别"><a href="#6-类的各种成员方法及区别" class="headerlink" title="6. 类的各种成员方法及区别"></a>6. 类的各种成员方法及区别</h2><p>C++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)<br>: <span class="hljs-built_in">year_</span>(year)<br>, <span class="hljs-built_in">month_</span>(month)<br>, <span class="hljs-built_in">day_</span>(day)<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;year：&quot;</span> &lt;&lt; year_ &lt;&lt; <span class="hljs-string">&quot; month：&quot;</span> &lt;&lt; month_ &lt;&lt; <span class="hljs-string">&quot; day：&quot;</span> &lt;&lt; day_ &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> year_;<br><span class="hljs-type">int</span> month_;<br><span class="hljs-type">int</span> day_;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">继承：a kind of，一种</span><br><span class="hljs-comment">组合：a part of，一部分</span><br><span class="hljs-comment">商品日期更像是商品的一部分，应该用组合的方式</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goods</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Goods</span>(<span class="hljs-type">int</span> id, string name, <span class="hljs-type">int</span> price, <span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)<br>: <span class="hljs-built_in">date_</span>(year, month, day)<br>, <span class="hljs-built_in">id_</span>(id)<br>, <span class="hljs-built_in">name_</span>(name)<br>, <span class="hljs-built_in">price_</span>(price)<br>&#123;<br>count_++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>date_.<span class="hljs-built_in">show</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;id：&quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; name：&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; price：&quot;</span> &lt;&lt; price_ &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span><span class="hljs-comment">//静态成员函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> count_;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>Date date_;<br><span class="hljs-type">int</span> id_;<br>string name_;<br><span class="hljs-type">int</span> price_;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count_;<span class="hljs-comment">//静态成员变量的声明</span><br>&#125;;<br><br><span class="hljs-type">int</span> Goods::count_ = <span class="hljs-number">0</span>;<span class="hljs-comment">//静态成员变量的初始化</span><br></code></pre></td></tr></table></figure><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h3><p>静态成员变量在类内声明，在类外定义初始化<br>静态成员变量可以用类引用，也可以通过对象引用</p><h3 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2.静态成员函数"></a>2.静态成员函数</h3><p>静态成员函数不能使用普通成员变量，能使用静态成员变量<br>静态成员函数可以通过类调用，也可以通过对象调用</p><h3 id="3-const-成员函数"><a href="#3-const-成员函数" class="headerlink" title="3. const 成员函数"></a>3. const 成员函数</h3><p>一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。<br>const 成员函数既能够被普通对象调用，也能被 const 对象调用</p><h2 id="7-指向类成员的指针"><a href="#7-指向类成员的指针" class="headerlink" title="7. 指向类成员的指针"></a>7. 指向类成员的指针</h2><p>成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。</p><h3 id="1-成员函数指针"><a href="#1-成员函数指针" class="headerlink" title="1. 成员函数指针"></a>1. 成员函数指针</h3><p>在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">成员函数返回类型 （类名::*指针名）（形参）= &amp;类名::成员函数名<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(string s) &#123;<br>name = s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string name;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;lisa&quot;</span>)</span></span>;<br><span class="hljs-comment">// 定义类长远函数指针并赋初始值</span><br><span class="hljs-built_in">void</span>(A::*memp)() = &amp;A::print;<br>(a.*memp)();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png" alt="image.png"></p><p>使用成员函数指着注意两点：</p><p>（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；<br>（2）为成员函数指针赋值时，需要显示使用 <code>&amp;</code> 运算符，不能直接将 “类名 <code>::</code> 成员函数名”赋给成员函数指针。</p><h3 id="2-数据成员指针"><a href="#2-数据成员指针" class="headerlink" title="2. 数据成员指针"></a>2. 数据成员指针</h3><p>一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：</p><ul><li>对象的首地址和该成员变量在对象之内的偏移量。</li><li>数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。</li></ul><p>数据成员指针的定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">成员类型 类名::*指针名=&amp;类名::成员名;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">average</span><span class="hljs-params">(Student* objs, <span class="hljs-type">int</span> Student::*pm, <span class="hljs-type">int</span> count)</span> </span>&#123;<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>result += objs[i].*pm;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(result) / count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student my[<span class="hljs-number">3</span>] = &#123; &#123;<span class="hljs-number">16</span>, <span class="hljs-number">86</span>&#125;, &#123;<span class="hljs-number">17</span>, <span class="hljs-number">80</span>&#125;, &#123;<span class="hljs-number">18</span>, <span class="hljs-number">58</span>&#125; &#125;;<br><br><span class="hljs-type">double</span> ageAver = <span class="hljs-built_in">average</span>(my, &amp;Student::age, <span class="hljs-number">3</span>);<br><span class="hljs-type">double</span> scoreAver = <span class="hljs-built_in">average</span>(my, &amp;Student::score, <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ageAver = &quot;</span> &lt;&lt; ageAver &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;scoreAver = &quot;</span> &lt;&lt; scoreAver &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png" alt="image.png"></p><p>使用数据成员指针时，需要注意以下几点：</p><p>（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。<br>（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 <code>average()</code> 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的<code>obj.*pm</code> 等同于 <code>*(int*)((char*)(&amp;obj)+pm)</code>，显然，这样书写可读性差，可移植性低且容易出错。<br>（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayClass</span>  &#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ArrayClass</span>()  &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>arr[i]=i;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用数据成员指针作为形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(ArrayClass&amp; arrObj,<span class="hljs-type">int</span> (ArrayClass::* pm)[<span class="hljs-number">5</span>])</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i) &#123;<br>cout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ArrayClass arrObj;<br><span class="hljs-built_in">printArray</span>(arrObj,&amp;ArrayClass::arr);<span class="hljs-comment">//编译出错，提示成员ArrayClass::arr不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。</p><p>要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayClass</span> &#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ArrayClass</span>() &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>arr[i]=i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ArrayClass&amp; arrObj)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用数据成员指针作为形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(ArrayClass&amp; arrObj,<span class="hljs-type">int</span> (ArrayClass::* pm)[<span class="hljs-number">5</span>])</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>cout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ArrayClass&amp; arrObj)</span> </span>&#123;<br><span class="hljs-built_in">printArray</span>(arrObj,&amp;ArrayClass::arr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ArrayClass arrObj;<br><span class="hljs-comment">//printArray(arrObj,&amp;ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问</span><br><span class="hljs-built_in">print</span>(arrObj); <span class="hljs-comment">//通过友元函数调用打印数组函数printArray()来访问私有成员</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>02.C++ 基础精讲</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>本节分为 5 大类：</p><ol><li>形参带默认值的函数</li><li>内联函数inline</li><li>详解函数重载</li><li>const 深入应用</li><li>深入理解 C++ 的 new 和 delete</li></ol><h2 id="1-形参带默认值的函数"><a href="#1-形参带默认值的函数" class="headerlink" title="1. 形参带默认值的函数"></a>1. 形参带默认值的函数</h2><p>在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。</p><p><strong>注意事项：</strong></p><ol><li>在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span></span>; <span class="hljs-comment">//函数声明</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f)</span>  <span class="hljs-comment">//函数定义</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// ....  </span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>没有函数（原型）时，默认参数在函数定义时指定。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有 函数声明</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span>  <span class="hljs-comment">//函数定义</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</li></ol><p>就是说，<strong>函数声明时，必须按照从右向左的顺序，依次给与默认值。</strong></p><p>原因：</p><p>函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 <strong>从指令角度掌握函数调用堆栈详细过程。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3)</span></span>;         <span class="hljs-comment">// 错误, i3未指定默认值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">h</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 错误, i2未指定默认值</span><br></code></pre></td></tr></table></figure><p><strong>普通函数和形参带默认值函数对比：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b  = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>  temp = a + b;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br> <br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br> <br>  ret = <span class="hljs-built_in">sum</span>(a);<span class="hljs-comment">//b 使用默认值</span><br> <br>  ret = <span class="hljs-built_in">sum</span>();<span class="hljs-comment">//都使用默认值</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png" alt="image.png"></p><p>对比1，2 发现：</p><p>2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；</p><p>同理有3，使用默认值是：调用函数减少了 mov 指令。</p><h2 id="2-内联函数-inline"><a href="#2-内联函数-inline" class="headerlink" title="2. 内联函数 inline"></a>2. 内联函数 inline</h2><p><strong>特征：</strong></p><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明1（加 inline，建议使用）</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 声明2（不加 inline）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span> </span>&#123;<span class="hljs-comment">/****/</span>&#125;;<br><br><span class="hljs-comment">// 类内定义，隐式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;         <span class="hljs-comment">// 隐式内联</span><br>&#125;<br><br><span class="hljs-comment">// 类外定义，需要显式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;   <span class="hljs-comment">// 需要显式内联</span><br></code></pre></td></tr></table></figure><p><strong>编译器对 inline 函数的处理步骤：</strong></p><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><p><strong>内联函数与普通函数的区别？</strong></p><ol><li>内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理</li></ol><p>[[01.理解 C++ 内核]] 中的 <strong>从指令角度掌握函数调用堆栈详细过程</strong> 知道，在调用函数的过程中：</p><p>（1）将函数实数从右向左压栈<br>（2）call指令：<br>        将下一行要执行的代码地址入栈<br>        跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。</p><p>在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令</p><ol start="2"><li><p>内联函数不在生成相应的函数符号</p></li><li><p>inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。</p></li></ol><p>注意：</p><p>（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。</p><p><strong>优缺点：</strong></p><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="3-详解函数重载"><a href="#3-详解函数重载" class="headerlink" title="3. 详解函数重载"></a>3. 详解函数重载</h2><p><strong>函数重载</strong>：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。</p><p>（1）函数重载与函数返回值无关，因为在产生符号时没有返回值<br>（2） 函数重载需要在同一个作用域<br>（3）const 或者 volatile 的时候，是如何影响形参的</p><p><strong>C++ 支持函数重载，而 C 则不支持：</strong></p><p>编译器产生的函数符号规则不同：</p><ul><li>C++ 代码：函数符号包含了函数名和参数列表</li><li>C 代码：函数符号只包含了函数名。</li></ul><p><strong>注意事项：</strong></p><p>** <strong>函数重载需要在同一个作用域下</strong>。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;adf&quot;</span>, <span class="hljs-string">&quot;wew&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png" alt="image.png"></p><p>由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。</p><p><strong>const int 和 int 的重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png" alt="image.png"></p><p>原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png" alt="image.png"></p><p>const int 和 int 在编译器看来都是 int 类型 ，无法完成重载。</p><h3 id="3-1-C-和-C-语言如何相互调用"><a href="#3-1-C-和-C-语言如何相互调用" class="headerlink" title="3.1 C++ 和 C 语言如何相互调用"></a>3.1 C++ 和 C 语言如何相互调用</h3><p>由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten “C”{};</p><h4 id="1-C-调用-C"><a href="#1-C-调用-C" class="headerlink" title="1. C++ 调用 C"></a>1. C++ 调用 C</h4><p>对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字<code>extern &quot;C&quot;</code>，表示采用类c语言的方式解析函数符号。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// add.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ADD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ADD_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// add.c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 + 1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在例子中，<code>main.cpp</code> 为<code>c++</code> 代码，<code>add.c</code> 为 c 语言代码，当 c++ 编译器识别到<code>extern &quot;C&quot;</code> 关键字时，会去寻找 <code>_add_</code> 函数的实现而不是寻找类似<code>_int_add_int_int_</code> 这样带参数信息的函数实现。</p><h4 id="2-C-调用-C"><a href="#2-C-调用-C" class="headerlink" title="2. C 调用 C++"></a>2. C 调用 C++</h4><p>c 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：</p><ol><li>将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；</li><li>对外提供遵循类 c 语言规约的接口函数。例子如下所示：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// printNum.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// printNum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printNum.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; &lt;&lt; <span class="hljs-string">&quot;num is &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-built_in">printNum</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>通过将 <code>_cout_</code>函数封装为类 c 语言规约的接口函数，使得 <code>main.c</code> 中可以成功调用 c++ 函数 <code>_printNum_</code> 。值得注意的是，<code>main.c</code> 不可以直接引入 <code>printNum.h</code>，因为 c 语言不能识别 <code>extern &quot;C&quot;</code> 关键字。可以利用 c++ 预定义宏实现头文件的改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><ol><li>c 语言与 c++ 的相互调用可以通过 <code>extern &quot;C&quot;</code> 关键字实现</li><li>c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 <code>extern &quot;C&quot;</code></li><li>c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 <code>extern &quot;C&quot;</code> 声明的类 c 封装函数</li></ol><h2 id="4-const-深入应用"><a href="#4-const-深入应用" class="headerlink" title="4. const 深入应用"></a>4. const 深入应用</h2><p><strong>const 作用：</strong></p><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><p><strong>const 的指针与引用：</strong></p><ul><li>指针<ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul></li><li>引用<ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;                <span class="hljs-comment">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123; &#125;;        <span class="hljs-comment">// 初始化列表</span><br><br>    <span class="hljs-comment">// const可用于对重载函数的区分</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 普通成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对象</span><br>    A b;                        <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span><br>    <span class="hljs-type">const</span> A a;                  <span class="hljs-comment">// 常对象，只能调用常成员函数</span><br>    <span class="hljs-type">const</span> A *p = &amp;a;            <span class="hljs-comment">// 指针变量，指向常对象</span><br>    <span class="hljs-type">const</span> A &amp;q = a;             <span class="hljs-comment">// 指向常对象的引用</span><br><br>    <span class="hljs-comment">// 指针</span><br>    <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span>* p1 = greeting;                <span class="hljs-comment">// 指针变量，指向字符数组变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;          <span class="hljs-comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;          <span class="hljs-comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;    <span class="hljs-comment">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;           <span class="hljs-comment">// 传递过来的参数在函数内不可变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;         <span class="hljs-comment">// 参数指针所指内容为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;         <span class="hljs-comment">// 参数指针为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;          <span class="hljs-comment">// 引用参数在函数内为常量</span><br><br><span class="hljs-comment">// 函数返回值</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回一个常数</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure><p><strong>宏定义 <code>#define</code> 和 const 常量:</strong></p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h3 id="1-C-和-C-的-const-区别"><a href="#1-C-和-C-的-const-区别" class="headerlink" title="1. C++ 和 C 的 const 区别"></a>1. C++ 和 C 的 const 区别</h3><ul><li><strong>c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png" alt="image.png"></p><p>最终输出为：30、30、30</p><ul><li><strong>C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// const int b;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// a 常量，可以定义数组长度</span><br><span class="hljs-type">int</span> array[a] = &#123;&#125;;<br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png" alt="image.png"></p><p>原因：<strong>const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。</strong></p><h4 id="1-1-Debug-调试"><a href="#1-1-Debug-调试" class="headerlink" title="1.1 Debug 调试"></a>1.1 Debug 调试</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png" alt="image.png"></p><p>执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。</p><p><strong>如果不是立即数，则是常变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = b;<br><br><span class="hljs-comment">// 报错，a是常变量</span><br><span class="hljs-comment">//int array[a] = &#123;&#125;;</span><br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a); <span class="hljs-comment">// 30 30 30</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-const-与指针"><a href="#2-const-与指针" class="headerlink" title="2. const 与指针"></a>2. const 与指针</h3><p>const 修饰的量常出现的错误：</p><p><strong>（1）常量不能再作为左值</strong><br><strong>（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png" alt="image.png"></p><h4 id="2-1-const-和-一级指针"><a href="#2-1-const-和-一级指针" class="headerlink" title="2.1 const 和 一级指针"></a>2.1 const 和 一级指针</h4><p><strong>const 如果右边没有指针*，则const 是不参与类型的</strong></p><p><strong>C++的语言规范：就近原则 const 修饰的是离它最近的类型</strong></p><ol><li><code>const int* p</code>；离 const 最近的类型是 int，所以 const 修饰的是 <code>*p</code> ，所以 <code>*p</code> 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。</li><li><code>int const* p</code>；<code>*</code> 不是类型，离 const 最近的类型为 int，<code>*p</code> 无法修改，同（1）</li><li><code>int* const p</code>；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。</li><li><code>const int* const p</code>；不能修改 p 指向的地址和值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span> ;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<span class="hljs-comment">//p指向的地址的内容不能修改</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>重点：</p><p><strong>const 如果右边没有指针 <code>*</code>，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。</strong></p><p><strong>const 类型转化公式：</strong></p><ul><li><code>const int*</code>  &lt;&#x3D; <code>int*</code> 可以转换</li><li><code>int*</code> &lt;&#x3D; <code>const int*</code> 错误</li></ul></blockquote><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = <span class="hljs-literal">nullptr</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png"></p><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1= &amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;a;<span class="hljs-comment">// const int * &lt;= int *</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = &amp;a;<span class="hljs-comment">// int * &lt;= int *</span><br><span class="hljs-type">int</span> *p4 = p3;<span class="hljs-comment">//p3是int * 类型，因此没有问题</span><br></code></pre></td></tr></table></figure><h4 id="2-2-const-和-二级指针"><a href="#2-2-const-和-二级指针" class="headerlink" title="2.2 const 和 二级指针"></a>2.2 const 和 二级指针</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png" alt="image.png"></p><ul><li><code>const int** q</code>；离 const 最近的类型为 int，修饰的是 <code>**q</code>。</li><li><code>int* const* q</code>；离 const 最近的类型为 <code>int*</code>，修饰的是 <code>*q</code>。</li><li><code>int** const q</code>；离 const 最近的类型为 <code>int**</code>，修饰的是 <code>q</code>，同时 const 右侧没有 <code>*</code> ，q 是 <code>int**</code> 类型。</li></ul><p><strong>转化公式：</strong></p><ul><li><code>int**</code> &lt;&#x3D; <code>const int**</code> 错误</li><li><code>const int **</code> &lt;&#x3D; <code>int **</code> 错误</li></ul><p>const 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；</p><ul><li><code>int**</code> &lt;&#x3D; <code>int* const*</code> 是 const 和一级指针的结合，const 右边修饰的<code>*</code>  （等同于 <code>int *</code>  &lt;&#x3D; <code>const int *</code>  ）错误的</li><li><code>int* const*</code> &lt;&#x3D;<code>int**</code> （等同于<code>const int *</code> &lt;&#x3D; <code>int</code> ）可以的</li></ul><p><strong>要看 const 右边的 * 决定 const 修饰的是类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> ** q = &amp;p;<span class="hljs-comment">//error  </span><br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  const int * *q = &amp;p; 相当于（*）q 即 p的地址，赋值了一个const int * </span><br><span class="hljs-comment">  而p 是int *类型,把常量的地址泄露给普通的指针（p）</span><br><span class="hljs-comment">  修改 const int * p = &amp;a;</span><br><span class="hljs-comment">  */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h3><ol><li>引用是必须初始化的，指针可以不初始化。</li><li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。</li><li>定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。</li></ol><p>引用的错误用法  <code>int &amp;a = 10;</code> 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">int</span> &amp;b = a;<br> <br>  std::cout  &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br>  *p = <span class="hljs-number">20</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br> <br>  b = <span class="hljs-number">30</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png" alt="image.png"></p><p> <strong>反汇编：指针和引用没有区别</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png" alt="image.png"></p><p><code>lea eax,[a]</code>：将 a 的地址拷贝到寄存器 eax 中</p><p><code>mov dword ptr [p],eax</code>：将 eax 中的值拷贝到 p 中。</p><p><strong>反汇编中指针和引用拷贝也是没有区别。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png" alt="指针拷贝 - 1"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png" alt="指针拷贝 - 2"></p><p>对指针和引用赋值，都是一样的：获取地址，然后赋值。</p><h4 id="3-1-引用别名"><a href="#3-1-引用别名" class="headerlink" title="3.1 引用别名"></a>3.1 引用别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> array[<span class="hljs-number">5</span>] = &#123;&#125;;<br>  <span class="hljs-type">int</span> * p = array;<br>  <span class="hljs-built_in">int</span>(&amp;q)[<span class="hljs-number">5</span>] = array;<span class="hljs-comment">//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) </span><br> <br>  std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(array) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(q) &lt;&lt; std::endl;<span class="hljs-comment">//20 5 20</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png" alt="image.png"></p><p>关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 </p><p>站在宏观角度，引用也就是别名，所以不开辟看空间。</p><p>站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。</p><h3 id="4-左值引用"><a href="#4-左值引用" class="headerlink" title="4. 左值引用"></a>4. 左值引用</h3><p>左值：有内存地址，有名字，值可以修改；</p><p>如 <code>int a = 10;</code> <code>int &amp;b =a;</code></p><p><code>int &amp;c =10;</code> &#x2F;&#x2F;错误 20 是右值，20 &#x3D; 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；</p><p>上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = temp;<br></code></pre></td></tr></table></figure><p>根据上述分析，得出如下结论：</p><p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。</p><p>那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p><h3 id="5-右值引用"><a href="#5-右值引用" class="headerlink" title="5. 右值引用"></a>5. 右值引用</h3><p>C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p><ul><li>可以取地址的，有名字的，非临时的就是左值；</li><li>不能取地址的，没有名字的，临时的就是右值；</li></ul><p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。</p><p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。</p><ol><li><strong><code>int &amp;&amp;c = 10;</code>专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c &#x3D; 1;</strong></li></ol><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png" alt="image.png"></p><ol start="2"><li><strong>一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;e = a;<br></code></pre></td></tr></table></figure><h2 id="5-深入理解-C-的-new-和-delete"><a href="#5-深入理解-C-的-new-和-delete" class="headerlink" title="5. 深入理解 C++ 的 new 和 delete"></a>5. 深入理解 C++ 的 new 和 delete</h2><p><strong>New 的不同使用方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1 抛异常new</span><br>    <span class="hljs-type">int</span>* p1;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//分配内存并初始化</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e)<span class="hljs-comment">//判断是否抛异常</span><br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//2 不抛异常new</span><br>    <span class="hljs-type">int</span>* p2 = <span class="hljs-built_in">new</span> (std::nothrow)<span class="hljs-built_in">int</span>();<span class="hljs-comment">//不抛异常</span><br>    <span class="hljs-comment">//3 开辟常量内存</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">40</span>);<span class="hljs-comment">//开辟一个常量</span><br><br>    <span class="hljs-comment">//4 定位new</span><br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* p4 = <span class="hljs-built_in">new</span>(&amp;data) <span class="hljs-built_in">int</span>(<span class="hljs-number">50</span>);<span class="hljs-comment">//在指定地址内存初始化，本身并不开辟内存，只负责初始化</span><br>    <span class="hljs-keyword">delete</span> p1;<br>    <span class="hljs-keyword">delete</span> p2;<br>    <span class="hljs-keyword">delete</span> p3;<br>    <span class="hljs-keyword">delete</span> p4;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-malloc-与-new-的区别"><a href="#1-malloc-与-new-的区别" class="headerlink" title="1. malloc 与 new 的区别"></a>1. malloc 与 new 的区别</h4><ol><li>malloc 按字节开辟内存的；new 开辟内存时需要指定类型；</li><li>malloc 开辟内存返回的都是 <code>void *</code> ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。</li><li>malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。</li><li>malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。</li><li>malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要<code>[]</code>，而数组需要 <code>[]</code>并给上元素个数。</li></ol><h4 id="2-free-和-delete-的区别："><a href="#2-free-和-delete-的区别：" class="headerlink" title="2. free 和 delete 的区别："></a>2. free 和 delete 的区别：</h4><ol><li>free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  </li><li>delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  </li><li>delete 执行其实有两步，先调用析构，再释放；free 只有一步。</li></ol><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png" alt="image.png"></p><p><strong>new 与 delete 其本质也是函数的调用：运算符重载 new  delete</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span><br><span class="hljs-keyword">delete</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// new：</span><br><span class="hljs-comment">// 先调用 operator 开辟内存空间</span><br><span class="hljs-comment">// 然后调用对象的构造函数</span><br><span class="hljs-comment">// operator new 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// operator new[] 实现</span><br><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size)<br>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new[] addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// delete：</span><br><span class="hljs-comment">// 调用 p 指向对象的析构函数</span><br><span class="hljs-comment">// 再调用 operator delete 释放空间</span><br><span class="hljs-comment">// operator delete 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// operator delete[] 实现</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* ptr)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete[] addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">delete</span>[] p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png" alt="image.png"></p><h4 id="5-new-和delete-能够混用吗？"><a href="#5-new-和delete-能够混用吗？" class="headerlink" title="5. new 和delete 能够混用吗？"></a>5. new 和delete 能够混用吗？</h4><p><strong>C++为什么区分单个元素和数组的内存分配和释放呢？</strong></p><p><strong>情况1：int类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span>[]p;<br> <br><span class="hljs-type">int</span> *q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> q;<br></code></pre></td></tr></table></figure><p>能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。</p><p><strong>情况2：类类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>):<span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> ptr;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>单个元素与 <code>delete[]</code> 混用：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-keyword">delete</span>[]p1;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png" alt="报错程序"></p><p>程序崩溃。</p><ul><li><strong>数组与 delete 进行混用</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p2 = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">delete</span> p2;<br></code></pre></td></tr></table></figure><p>程序崩溃。</p><p><strong>分析：</strong></p><p>正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 <code>[]</code> 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 <code>0x100</code>；但是 new 完之后 p2 返回的地址是 <code>0x104</code> 地址，当我们执行 <code>delete[]</code> 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 <code>0x100</code> 开始的 4 字节也释放。</p><p>而 p2 出错是给用户返回的存对象开始的起始地址，<code>delete p2</code> 认为 p2 只是指向了一个对象，只将 <code>Test[0]</code> 对象析构，直接从 <code>0x104 free(p2)</code>，但底层实际是从 <code>0x100</code> 开辟的，因此崩溃。</p><p>而 p1 出错：p1 只是单个元素，从 <code>0x104</code> 开始开辟内存，但是 <code>delete[] p1</code>，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 <code>0x100</code> 释放)因此崩溃。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.理解 C++ 内核</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<p>本节内容分为三部分：</p><ol><li>掌握进程虚拟地址空间区域划分</li><li>从指令角度掌握函数调用堆栈详细过程</li><li>从编译器角度理解C++代码的编译、链接</li></ol><p>通过了解底层基础，了解 C++ 的如何运行。</p><h2 id="1-掌握进程虚拟地址空间区域划分"><a href="#1-掌握进程虚拟地址空间区域划分" class="headerlink" title="1. 掌握进程虚拟地址空间区域划分"></a>1. 掌握进程虚拟地址空间区域划分</h2><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> gdata2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> gdata3;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata4 = <span class="hljs-number">11</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata5 = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata6;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">13</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> e = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> f;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上述代码，如何得知各个变量存储的位置？</p><h3 id="1-1-虚拟进程视图"><a href="#1-1-虚拟进程视图" class="headerlink" title="1.1 虚拟进程视图"></a>1.1 虚拟进程视图</h3><p>首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。</p><p>这里附上IBM公司关于<strong>虚拟</strong>的解释:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">它存在，你看得见，它是物理的<br>它存在，你看不见，它是透明的<br>它不存在，你看得见，它是虚拟的<br>它不存在，你看不见，它被删除<br></code></pre></td></tr></table></figure><p>这块空间的内容如下图所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png" alt="虚拟进程空间示例图 CN"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png" alt="虚拟进程空间示例图 EN"></p><blockquote><p>补充：<br>x86 32位体系下的4G虚拟地址空间：<br><strong>Linux默认3:1</strong>来分配 user space : kernal space；<br><strong>Windows默认2:2</strong>来分配 user space : kernal space。</p></blockquote><p>Linux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。</p><p>解释：<br>32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 <code>[0, 2^32]</code> ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。<br>64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 <code>[0, 2^64]</code> ，即 4GB * 4GB &#x3D; 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。</p><p><strong>为什么是 4G 内存：</strong></p><p>首先我们研究的体系是：<code>x86 32位Linux环境</code>：<br>Linux操作系统会给当前进程分配一个 <code>2^32</code> 大小的空间，那么，<code>2^32</code> 换算过来就是 4G 了。</p><h3 id="1-2-用户空间（User-Space）"><a href="#1-2-用户空间（User-Space）" class="headerlink" title="1.2 用户空间（User Space）"></a>1.2 用户空间（User Space）</h3><ol><li><p>保留区：<br> 128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 “NULL”，它便不会被引用了，从而避免了野指针。</p></li><li><p>指令段【.text】、只读数据段【.rodata】：<br> 指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。</p><blockquote><p>在C++中，不允许普通指针指向常量字符串，需要使用<code>const</code>：<br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png" alt="示例"></p></blockquote></li><li><p>数据段【.data】：<br> 存放程序中<strong>已初始化且不为0的全局变量或静态变量</strong>。</p></li><li><p>数据段【.bss】：<br> 存放程序中未初始化或者初始化为0的全局变量或静态变量。</p></li><li><p>堆【.heap】：<br> 存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。</p><ul><li>堆用于存放进程<code>运行时动态分配</code>的内存段，可动态扩张或缩减。</li><li>堆中内容是<code>匿名</code>的，无法通过名字进行访问，只能通过<code>指针</code>进行间接访问。</li><li>当进程调用<code>malloc(C)/new(C++)</code>等函数分配内存时，新分配的在堆上<code>动态扩张</code>；当调用<code>free(C)/delete(C++)</code>等函数释放内存时，被释放的内存从堆上<code>动态缩减</code></li><li>分配的堆内存时经过<code>字节对齐</code>的空间，以适合<code>原子操作</code>。</li><li><code>堆管理器</code>通过<code>链表</code>管理每个申请的内存块</li><li>由于堆内存块的申请与释放都是<code>无序</code>的，最终会产生许许多多<code>内存碎片</code>。</li><li>堆的末端由<code>break指针</code>标识，当堆管理器需要更多内存时，可通过<code>系统调用brk和sbrk</code>来<code>移动break指针</code>以扩张堆，一般情况下由系统自动调用。</li></ul></li><li><p>共享库【.dll、.so】：<br> 动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。</p></li><li><p>栈【.stack】：<br> 存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。</p><ul><li><p>栈中存放<code>非静态局部变量</code> <code>函数形参</code> <code>函数返回地址</code>等。</p></li><li><p>栈中内存空间由<code>编译器</code>（静态的）自动分配和释放，行为类似数据结构中的栈结构。</p><blockquote><p>主要用途：</p><ol><li>为函数内部声明的<strong>非静态局部变量</strong>提供存储空间</li><li>记录函数调用过程相关的维护性信息，称为栈帧（stack frame）</li><li>作为<code>临时存储区</code>，用于暂时存放<code>较长的算术表达式部分计算结果</code>，或者运行时调用alloca函数<code>动态分配</code>栈内内存</li></ol></blockquote></li><li><p>栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。</p></li><li><p>查看栈大小：<code>ulimit -s</code>可查看和设置<code>栈的最大值</code>，当程序使用的栈大小超过该值，会发生<code>segmentation fault</code>。</p></li><li><ul><li>栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。</li></ul></li></ul></li><li><p>命令行参数：<br> 保存传递给 main 函数的参数，比如 argc 和 argv。</p></li><li><p>环境变量：<br> 用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。</p></li></ol><h3 id="1-3-进程空间（Kernal-Space）"><a href="#1-3-进程空间（Kernal-Space）" class="headerlink" title="1.3 进程空间（Kernal Space）"></a>1.3 进程空间（Kernal Space）</h3><ol><li><p>内存直接访问区【ZONE_DMA】：<br> 16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。</p></li><li><p>常用区【ZONE_NORMAL】：<br> 892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。</p></li><li><p>高端内存区【ZONE_HIGHMEM】：<br> 128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。</p></li></ol><h3 id="1-4-最终解释"><a href="#1-4-最终解释" class="headerlink" title="1.4 最终解释"></a>1.4 最终解释</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png" alt="image.png"></p><blockquote><p>注意：<br>对于<code>a、b、c以及&#39;&#123;&#39;、&#39;&#125;&#39;</code>来说，是存储在<code>.text</code>指令段的，因为他们生成的都是&#x3D;&#x3D;指令&#x3D;&#x3D;。<br>例如：<br><code>int a = 12</code>：生成汇编指令如下：<code>mov dword ptr[a], 0Ch</code></p></blockquote><h3 id="1-5-好处"><a href="#1-5-好处" class="headerlink" title="1.5 好处"></a>1.5 好处</h3><p><code>数据</code>与<code>代码指令</code>分别开辟空间有以下好处：</p><ol><li>当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。<code>数据区</code>对于进程而言<code>可读可写</code>，<code>代码指令区</code>对于进程而言<code>只读</code>，</li><li>现代CPU一般<code>数据缓存</code>和<code>指令缓存</code>分离，故进程虚拟地址空间中数据与代码指令分离有助于提高<code>CPU缓存命中率</code>。</li><li>若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。</li></ol><p><strong>参考文章：</strong></p><blockquote><p>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1<br>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23<br>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09<br>【4】<a href="https://blog.csdn.net/m0_46308273/article/details/115818195">https://blog.csdn.net/m0_46308273/article/details/115818195</a><br>【5】<a href="https://blog.csdn.net/weixin_45437022/article/details/115409679">https://blog.csdn.net/weixin_45437022/article/details/115409679</a></p></blockquote><h2 id="2-从指令角度掌握函数调用堆栈详细过程"><a href="#2-从指令角度掌握函数调用堆栈详细过程" class="headerlink" title="2. 从指令角度掌握函数调用堆栈详细过程"></a>2. 从指令角度掌握函数调用堆栈详细过程</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png" alt="image.png"><br>栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。</p><p>堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：</p><ul><li>PUSH：将目标内存推入栈顶。</li><li>POP：从栈顶中移除目标。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png" alt="image.png"></p><p>当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 <strong>栈帧</strong> 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）</p><h3 id="2-1-ESP-和-EBP"><a href="#2-1-ESP-和-EBP" class="headerlink" title="2.1 ESP 和 EBP"></a>2.1 ESP 和 EBP</h3><p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p><p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：</p><ul><li>pop ebp;出栈 栈扩大4byte 因为ebp为32位</li><li>push ebp;入栈，栈减少4byte        </li><li>add esp, 0Ch；表示栈减小12byte</li><li>sub esp, 0Ch；表示栈扩大12byte</li></ul><p>ebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数</span><br><span class="hljs-comment">问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>temp = a + b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打断点，调试，查看反汇编：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 00007FF637EE23D0  push        rbp  </span><br><span class="hljs-comment">// 00007FF637EE23D2  push        rdi  </span><br><span class="hljs-comment">// 00007FF637EE23D3  sub         rsp,148h  </span><br><span class="hljs-comment">// 00007FF637EE23DA  lea         rbp,[rsp+20h]  </span><br><span class="hljs-comment">// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  </span><br><span class="hljs-comment">// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 00007FF637EE23EB  mov         dword ptr [a],0Ah  </span><br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 00007FF637EE23F2  mov         dword ptr [b],14h  </span><br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 00007FF637EE23F9  mov         edx,14h  </span><br><span class="hljs-comment">// 00007FF637EE23FE  mov         ecx,0Ah  </span><br><span class="hljs-comment">// 00007FF637EE2403  call        sum (07FF637EE11E5h)  </span><br><span class="hljs-comment">// 00007FF637EE2408  mov         dword ptr [ret],eax  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-comment">// 00007FF637EE240B  lea         rdx,[string &quot;ret:&quot; (07FF637EEAC24h)]  </span><br><span class="hljs-comment">// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  </span><br><span class="hljs-comment">// 00007FF637EE2419  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF637EE108Ch)  </span><br><span class="hljs-comment">// 00007FF637EE241E  mov         edx,dword ptr [ret]  </span><br><span class="hljs-comment">// 00007FF637EE2421  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1168h)]  </span><br><span class="hljs-comment">// 00007FF637EE242A  lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF637EE103Ch)]  </span><br><span class="hljs-comment">// 00007FF637EE2431  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1170h)]  </span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 00007FF637EE243A  xor         eax,eax  </span><br>&#125;<br><span class="hljs-comment">// 00007FF637EE243C  lea         rsp,[rbp+128h]  </span><br><span class="hljs-comment">// 00007FF637EE2443  pop         rdi  </span><br><span class="hljs-comment">// 00007FF637EE2444  pop         rbp  </span><br><span class="hljs-comment">// 00007FF637EE2445  ret </span><br></code></pre></td></tr></table></figure><h3 id="2-2-解析-main-函数"><a href="#2-2-解析-main-函数" class="headerlink" title="2.2  解析 main 函数"></a>2.2  解析 main 函数</h3><p><strong>1. <code>&#123;</code> 会进行入栈操作，<code>&#125;</code> 进行出栈操作</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png" alt="image.png"></p><p>上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。</p><p><strong>为什么这么做呢？</strong></p><p>因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。</p><p>在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</p><p><code>sub esp, 148h；</code>减去的值根据程序而定</p><p>之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</p><p>之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</p><p>在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png" alt="image.png"></p><p>所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数</p><p><strong>2. 函数内部：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png" alt="image.png"></p><ol><li><p><code>int a = 10;</code> 执行一条 mov 指令： </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [a],0Ah<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png" alt="image.png"></p></li><li><p> 同理 <code>int b = 20;</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [b],14h<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png" alt="image.png"></p></li><li><p><code>int ret = sum(a,b);</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Assmbly">00F81896 8B 45 EC             mov         eax,dword ptr [b] <br>00F81899 50                   push        eax     #压栈 b的值<br>00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  <br>00F8189D 51                   push        ecx     #压栈 a的值<br>00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call<br>00F818A3 83 C4 08             add         esp,8  <br>00F818A6 89 45 E0             mov         dword ptr [ret],eax <br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-sum-函数调用后"><a href="#2-3-sum-函数调用后" class="headerlink" title="2.3 sum 函数调用后"></a>2.3 sum 函数调用后</h3><p><strong>函数调用参数的压栈顺序:参数由右向左压入堆栈。</strong></p><p><strong>因此上面对应的是：</strong></p><p>先将b的值压入堆栈，再将a的值压入堆栈</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png" alt="image.png"><br><strong>执行call        sum (0F8108Ch)：</strong></p><p><strong>call函数首先会将下一行执行的地址入栈</strong>：假设下一行指令的地址位0x08124458</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png" alt="image.png"></p><p> <strong>第二步进入函数调用：sum</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png" alt="image.png"></p><p>函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈</p><p>第二步：将新的栈底ebp指向原来的栈顶esp</p><p>第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png" alt="image.png"></p><p>接着执行 <code>int temp = 0;</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         dword ptr [temp],0<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png" alt="image.png"></p><p>temp &#x3D; a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png" alt="image.png"></p><p>接着运行<code>return temp;</code>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         eax,dword ptr [temp]<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png" alt="image.png"></p><p>接着是<code>函数的右括号“&#125;”</code>：</p><p>（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。<br>（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。<br>（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png" alt="image.png"></p><h3 id="2-4-返回-main-函数后"><a href="#2-4-返回-main-函数后" class="headerlink" title="2.4 返回 main 函数后"></a>2.4 返回 main 函数后</h3><p>接着调用函数完毕，回到主函数：<br>利用了<code>PC寄存器</code>，使得程序知道退出sum后运行哪一条指令：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png" alt="image.png"></p><p><code>add         esp,8</code> ,将压栈的a b 形参空间回收</p><p><code>mov         dword ptr [ret],eax</code> 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png" alt="image.png"><br>最后<code>return 0</code>，程序结束</p><h3 id="2-5-栈溢出问题"><a href="#2-5-栈溢出问题" class="headerlink" title="2.5 栈溢出问题"></a>2.5 栈溢出问题</h3><p>出现栈内存溢出的常见原因有2个：</p><ol><li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li><li>局部静态变量体积太大。</li></ol><blockquote><p>第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。<br>检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。</p></blockquote><blockquote><p>   第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"> 即如果函数这样写：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span>* chdata = <span class="hljs-keyword">new</span>[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>   <span class="hljs-keyword">delete</span> []chdata;<br> &#125;<br>是不会出现这个错误的，而这样写则不行：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span> chdata[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br> &#125;<br>大多数情况下都会出现内存溢出的错误,<br></code></pre></td></tr></table></figure><p>解决办法大致说来也有两种：  </p><ol><li>增加栈内存的数目  </li><li>使用堆内存</li></ol><h2 id="3-从编译器角度理解-C-代码的编译、链接"><a href="#3-从编译器角度理解-C-代码的编译、链接" class="headerlink" title="3. 从编译器角度理解 C++ 代码的编译、链接"></a>3. 从编译器角度理解 C++ 代码的编译、链接</h2><p>整个编译过程分为两大步：</p><p>1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件</p><p>2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序</p><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><p>细分为3个阶段：</p><p><strong>1.1）编译预处理</strong></p><p>预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 <code>#include</code>），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 <code>#include</code> 包含的文件代码，进行 <code>#define</code> 宏定义的替换 ， 处理条件编译指令 （<code>#ifndef</code>、 <code>#ifdef</code>、 <code>#endif</code>）等。</p><p>预编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E main.c -o main.i<br></code></pre></td></tr></table></figure><p>主要规则如下：</p><ol><li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义；</li><li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>;</li><li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；</li><li>删除所有的注释：<code>//</code> 和 <code>/**/</code>；</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；</li><li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要使用它们。</li></ol><blockquote><p>注：<br><code>#pragma lib</code>、<code>pragma link</code><br>等命令是在链接过程处理的。</p></blockquote><p>预编译后得到的文件为：<code>.i</code>文件。</p><p><strong>1.2）编译</strong></p><p>通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</p><p>编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -S main.i -o main.s<br></code></pre></td></tr></table></figure><p>编译后得到的文件为：<code>.s</code>文件。</p><p><strong>1.3) 汇编</strong></p><p>汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。</p><p>目标文件由段组成，通常至少有两个段：</p><ol><li>.text：包换主要程序的指令。该段是可读和可执行的，一般不可写</li><li>.data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。</li></ol><p>汇编过程我们可以调用汇编器<code>as</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">as main.s -o main.o  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span>  <br>gcc -c main.s -o mian.o<br></code></pre></td></tr></table></figure><p>这个过程将.s文件转化成.o文件。</p><h3 id="3-2-链接过程"><a href="#3-2-链接过程" class="headerlink" title="3.2 链接过程"></a>3.2 链接过程</h3><p>链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。</p><p><strong>链接的时机</strong>：</p><ul><li>编译时，也就是在源代码被翻译成机器代码时</li><li>加载时，也就是在程序被加载器加载到存储器并执行时</li><li>运行时，由应用程序执行</li></ul><h4 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h4><p><strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p>为了构造可执行文件，<strong>链接器必须完成两个任务：符号解析，重定位</strong></p><ol><li><strong>符号解析：</strong> 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li><li><strong>重定位：</strong> 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li></ol><p>链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png" alt="image.png"></p><p>目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p><h4 id="2-目标文件"><a href="#2-目标文件" class="headerlink" title="2. 目标文件"></a>2. 目标文件</h4><p><strong>三种形式：</strong></p><ol><li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li><li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。</li></ol><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。</p><h4 id="3-可重定位目标文件"><a href="#3-可重定位目标文件" class="headerlink" title="3.  可重定位目标文件"></a>3.  可重定位目标文件</h4><p>一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png" alt="ELF可重定位目标文件"></p><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong> 已编译程序的机器代码。</li><li><strong>.rodata：</strong> 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li><li><strong>.data：</strong> 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li><li><strong>.bss：</strong> 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li><li><strong>.symtab：</strong> 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li><li><strong>.rel.text：</strong> 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li><li><strong>.rel.data：</strong> 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li><strong>.debug：</strong> 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li><li><strong>.line：</strong> 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li><li><strong>.strtab：</strong> 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li></ul><h4 id="4-符号和符号表"><a href="#4-符号和符号表" class="headerlink" title="4. 符号和符号表"></a>4. 符号和符号表</h4><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段</p><p>在链接器的上下文中，有三种不同的符号：</p><p>由m定义并能被其他模块引用的全局符号<br>由其他模块定义并被模块m引用的全局符号<br>只被模块m引用的本地符号</p><p>例如：</p><p><code>main.cpp</code> 内容 和 <code>sum.cpp</code> 内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> gdata;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-type">int</span> data = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = gdata;<br><span class="hljs-type">int</span> b = data;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>g++ -c</strong> 只编译不链接，只生成目标文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png" alt="image.png"></p><p> <strong>objdump -t main.o &#x2F;&#x2F; 输出目标文件的符号表：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png" alt="image.png"></p><ul><li>第一列：段内偏移；</li><li>第二列：符号作用域  : local &#x2F;global；</li><li>第三列：符号类型；</li><li>第四列：符号所在段（<em>UND</em>外部链接符号，未在本目标文件定义）；</li><li>第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；</li><li>第六列：符号名；</li></ul><p>其中 <code>main</code> 定义在 <code>.text</code></p><p>data 是全局变量，且初始化定义在 <code>.data</code> ,也就是 m 定义并能被其他模块引用的全局符号。<br>gdata 和 sum 函数是声明，因此是<em>UNG</em>，也就是由其他模块定义并被模块 m 引用的全局符号。</p><p>第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配</p><p>在 <code>sum.o</code> 中：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png" alt="image.png"></p><p>gdata 是出刷的全局变量 在 <code>.data</code> 中；sum 函数在 <code>.text</code> 中</p><p><code>readelf -h</code> 查看 elf 文件的头文件信息<br>可见目标文件的elf文件，其类型为REL(可重定位文件)。 </p><p><code>objdump -s</code> 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png" alt="image.png"></p><p>有调试信息的：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png" alt="image.png"></p><p>可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。</p><h4 id="5-符号解析"><a href="#5-符号解析" class="headerlink" title="5. 符号解析"></a>5. 符号解析</h4><p>链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（<em>UNG</em>）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）</p><p> <strong>链接器如何解析多重定义的全局符号：</strong></p><p>在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。<br>       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：</p><p>规则1：不允许有多个强符号。<br>规则2：如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><p><strong>链接器如何使用静态库来解析引用：</strong></p><p>在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。</p><blockquote><ol><li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。</li><li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。</li><li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li></ol></blockquote><p>这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。</p><p>另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在命令行上重复库。</p><h4 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6. 重定向"></a>6. 重定向</h4><p>一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位有两步组成：</p><ol><li><strong>重定位节和符号定义</strong>。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用</strong>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<code>重定位条目</code>的可重定位目标模块中的数据结构。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png" alt="image.png"></p><p>链接后：所有的符号都有虚拟地址</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png" alt="image.png"></p><p>汇编中，全局变量和函数都有了地址。</p><h4 id="7-可执行目标文件"><a href="#7-可执行目标文件" class="headerlink" title="7. 可执行目标文件"></a>7. 可执行目标文件</h4><p>可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<code>.text</code> 、<code>.rodata</code> 和 <code>.data</code> 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。</p><p>ELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署流程</title>
    <link href="/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>主要使用技术合集：</strong></p><ol><li>Hexo 博客系统</li><li>Fluid 博客模板</li><li>Obsidian + Github Pages 部署。</li></ol><h2 id="1-Hexo-博客系统"><a href="#1-Hexo-博客系统" class="headerlink" title="1. Hexo 博客系统"></a>1. Hexo 博客系统</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <strong>Markdown</strong>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-1-安装需求"><a href="#1-1-安装需求" class="headerlink" title="1.1 安装需求"></a>1.1 安装需求</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li>Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li><li>Git</li></ul><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>全局安装后即可随时使用</p><h3 id="1-3-创建博客"><a href="#1-3-创建博客" class="headerlink" title="1.3 创建博客"></a>1.3 创建博客</h3><p>安装完成后，就可以在终端使用 <code>hexo</code> 指令了，可以使用以下指令创建一个 hexo 项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo init hexo-blog  <br><span class="hljs-built_in">cd</span> hexo-blog  <br>yarn install<br></code></pre></td></tr></table></figure><p>完成后项目目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.  <br>├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  <br>├── package.json  <br>├── scaffolds # 文章模板  <br>├── source  <br>|   ├── _drafts  <br>|   └── _posts # 你的 markdown 文章就需要存放在此目录下  <br>└── themes # 存放主题源码<br></code></pre></td></tr></table></figure><h2 id="2-配置-Fluid-主题"><a href="#2-配置-Fluid-主题" class="headerlink" title="2. 配置 Fluid 主题"></a>2. 配置 Fluid 主题</h2><ol><li>NPM 安装</li><li>源码安装</li></ol><h3 id="2-1-NPM-安装"><a href="#2-1-NPM-安装" class="headerlink" title="2.1 NPM 安装"></a>2.1 NPM 安装</h3><p>以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，使用 npm 安装只需要执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">yarn add hexo-theme-fluid  <br># 或者  <br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p><h3 id="2-2-源码安装"><a href="#2-2-源码安装" class="headerlink" title="2.2 源码安装"></a>2.2 源码安装</h3><p>源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。</p><p>仍然以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，在项目的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Releases</a> 页面中下载源码文件：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png"></p><p>下载解压后，在 <code>themes</code> 目录下创建一个 <code>fluid</code> 目录，将源码复制到该目录下，如下：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png" alt="image.png"></p><h3 id="2-3-应用主题"><a href="#2-3-应用主题" class="headerlink" title="2.3 应用主题"></a>2.3 应用主题</h3><p>当你安装成功后，需要在 <code>_config.yml</code> 中将使用的主题设置为你下载好的主题，找到 <code>theme</code> 配置项，将其修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions  </span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/  </span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/  </span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="2-4-配置第三方主题"><a href="#2-4-配置第三方主题" class="headerlink" title="2.4 配置第三方主题"></a>2.4 配置第三方主题</h3><p>如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 <code>_config.fluid.yml</code> 文件修改相关配置；</p><p>如果你是以源码方式安装的主题，就不需要创建 <code>_config.fluid.yml</code> 文件了，只需要修改 <code>/themes/fluid/_config.yml</code> 文件中的配置就可以了。</p><blockquote><p>注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档</p></blockquote><h2 id="3-部署-Github-Pages"><a href="#3-部署-Github-Pages" class="headerlink" title="3. 部署 Github Pages"></a>3. 部署 Github Pages</h2><p>然后在 Github 中创建一个新项目仓库，名称必须为 <code>&lt;你的github用户名&gt;.github.io</code>，创建完成后按照指引将你的博客代码上传到 github。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png" alt="image.png"></p><h3 id="3-1-开启-Github-Pages"><a href="#3-1-开启-Github-Pages" class="headerlink" title="3.1 开启 Github Pages"></a>3.1 开启 Github Pages</h3><p>在执行这一步之前，先创建一个没有任何代码的新分支，命名为 <code>gh-pages</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b gh-pages  <br>rm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  <br>git push --set-upstream origin release # 上传 release 分支<br></code></pre></td></tr></table></figure><p>在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 <code>gh-pages</code> 分支：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png" alt="image.png"></p><p>这就意为这你在 <code>gh-pages</code> 上传的任何 html 都可以使用 <code>&lt;你的github用户名&gt;.github.io</code> 这个域名来访问了。</p><p>我们切回 <code>master</code> 分支，之后执行 <code>yarn build</code> 将生成的 <code>public</code> 目录下的文件复制一份，然后重新切回 <code>gh-pages</code> 分支，将刚才复制的内容粘贴到 <code>gh-pages</code> 分支下，并上传代码。如果没有操作失误的话，访问 <code>&lt;你的github用户名&gt;.github.io</code> 即可看到你的博客了。</p><h3 id="3-2-Github-Action-自动部署"><a href="#3-2-Github-Action-自动部署" class="headerlink" title="3.2 Github Action 自动部署"></a>3.2 Github Action 自动部署</h3><p>使用 Github Action 来帮我们做自动化部署。</p><p>Github Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。</p><p>关于 Github Action，详细教程可以查看 <a href="https://docs.github.com/cn/actions">官方文档</a>。按照文档中所描述的，只要我们在代码中添加一层 <code>.github/workflows</code> 目录，并且在目录下创建一个 <code>yml</code> 文件来描述具体的行为，就可以实现开启 Github Action。</p><p>如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 <code>.github/workflows/blog-deploy.yml</code> 文件中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">16.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;16&quot;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br></code></pre></td></tr></table></figure><p>保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png" alt="image.png"></p><p>但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 <a href="https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context">secrets 上下文</a>，即 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code> 这里。</p><p><code>$&#123;&#123; xxx &#125;&#125;</code> 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 <code>secrets.ACCESS_TOKEN</code> 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。</p><p>首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 <code>Setting</code>，进入设置后选择 <code>Developer settings</code>，再选择 <code>Persona access token</code> 就可以看到它了：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png" alt="image.png"></p><p>点击右上角的 <code>Generate new token</code> 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 <code>repo</code> 和 <code>workflow</code> 权限，并将 <code>Expiration</code> 过期时间选为 <code>No expiration</code>：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png" alt="image.png"></p><blockquote><p>这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！</p></blockquote><p>点击 <code>Generate token</code> 按钮后，就会生成一个 <code>ghp</code> 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png" alt="image.png"></p><p>复制该 token 后，进入到博客仓库的设置中，选择 <code>Secrets - Actions</code>，点击 <code>New repository secret</code> 按钮生成一个密钥信息：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png" alt="image.png"></p><p>我们将密钥名称写为 <code>ACCESS_TOKEN</code>，值填入刚才复制的 Github token。</p><blockquote><p>这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 <code>secret</code> 上下文对象所获取到。</p></blockquote><p>至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>Blog</tag>
      
      <tag>Obdidian</tag>
      
      <tag>Github Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
