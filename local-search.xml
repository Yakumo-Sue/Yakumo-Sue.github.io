<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>第一章 - 绪论</title>
    <link href="/2023/09/03/00.%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%20-%20%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/09/03/00.%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B8%80%E7%AB%A0%20-%20%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>本章主要讨论如下内容：</p><ul><li>计算机模型（图灵，冯诺依曼）</li><li>计算机发展史</li><li>计算机出现后所增加的社会和道德问题</li><li>计算机科学领域总览</li></ul><h2 id="1-图灵模型"><a href="#1-图灵模型" class="headerlink" title="1. 图灵模型"></a>1. 图灵模型</h2><p>Alan Turing（阿兰·图灵）在 1937 年提出的一个通用计算机设备的设想；其思想为：<strong>所有的计算都可能在一种特殊的机器上执行</strong>，也就是现在所说的<strong>图灵机</strong>。</p><h3 id="1-1-数据处理器"><a href="#1-1-数据处理器" class="headerlink" title="1.1 数据处理器"></a>1.1 数据处理器</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011534638.png" alt="image.png"></p><p>将计算机定义为：<strong>数据处理器</strong>，在这个模型的定义下，计算机根据外部输入得到输出。</p><p><strong>输入数据 –&gt; 计算机 –&gt; 输出数据</strong></p><p>由于定义过于宽泛，其仅仅是描述一类数据处理的设备工作方式，并不能规定计算机。而且其并没有区分其为专用计算模型还是通用计算模型，而显然计算机输入通用计算模型。</p><h3 id="1-2-可编程数据处理器"><a href="#1-2-可编程数据处理器" class="headerlink" title="1.2 可编程数据处理器"></a>1.2 可编程数据处理器</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011538125.png" alt="image.png"></p><p>在 <strong>数据处理器</strong> 的概念上新增了一个额外元素：<strong>程序</strong> - 用于告诉计算机对数据进行处理的指令合集。</p><p>改造后的图灵模型工作方式为：<strong>输入数据 + 程序 –&gt; 计算机 –&gt; 输出结果</strong>。</p><p>示例：</p><ol><li><strong>相同程序，不同输入数据</strong></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011541838.png" alt="image.png"></p><p>处理的输入数据不同，得到的结果也不同。</p><ol start="2"><li><strong>相同输入，不同程序</strong></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011542537.png" alt="image.png"></p><p>根据相同的输入，在计算机中拥有不同程序，得到的输出也不同。</p><ol start="3"><li><strong>相同输入，相同程序</strong></li></ol><p>输出相同。</p><blockquote><p>在图灵模型中，计算机根据程序来将输入数据处理成输出数据，这样也就做到了其通用性。</p></blockquote><h2 id="2-冯·诺依曼模型"><a href="#2-冯·诺依曼模型" class="headerlink" title="2. 冯·诺依曼模型"></a>2. 冯·诺依曼模型</h2><p>基于通用图灵机见到的计算机都是在存储器中储存数据。在 1944~1945 期间冯·诺依曼提出。</p><h3 id="2-1-4个子系统"><a href="#2-1-4个子系统" class="headerlink" title="2.1 4个子系统"></a>2.1 4个子系统</h3><p>基于存储器、算术逻辑单元、控制单元和输入&#x2F;输出单元这个理念设计的冯诺依曼模型如下所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011547349.png" alt="image.png"></p><p>主要的四个部分为：</p><ul><li><strong>存储器</strong>：用于存储 <strong>数据</strong> 和 <strong>程序</strong> 的区域。</li><li><strong>算术逻辑单元</strong>：用于计算的单元（包括算术运算和逻辑运算）。</li><li><strong>控制单元</strong>：控制存储器，算术逻辑单元，输入&#x2F;输出等子系统的单元。</li><li><strong>输入&#x2F;输出</strong>：包括接收输入的设备，传出输出结果的设备，输入输出缓存区等一系列与输入&#x2F;输出有关的系统。</li></ul><h3 id="2-2-存储器概念"><a href="#2-2-存储器概念" class="headerlink" title="2.2 存储器概念"></a>2.2 存储器概念</h3><p><strong>程序必须在内存中</strong>。现代计算器的存储单元用来存储程序及其响应数据。这意味着数据和程序有着相同格式，以：<strong>位模式（0 和 1 序列）</strong> 存储在内存中。</p><h3 id="2-3-指令的顺序执行"><a href="#2-3-指令的顺序执行" class="headerlink" title="2.3 指令的顺序执行"></a>2.3 指令的顺序执行</h3><p>一段程序由一组数量有限的<strong>指令</strong>组成。控制器按顺序从存储器中读入指令，解析指令，执行指令。</p><h2 id="3-计算机组成部分"><a href="#3-计算机组成部分" class="headerlink" title="3. 计算机组成部分"></a>3. 计算机组成部分</h2><p>计算机有三大部分组成：计算机硬件、数据和计算机软件。</p><h3 id="1-数据"><a href="#1-数据" class="headerlink" title="1. 数据"></a>1. 数据</h3>]]></content>
    
    
    
    <tags>
      
      <tag>‘computer</tag>
      
      <tag>Science’</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00-3.C++ STL 基础</title>
    <link href="/2023/09/01/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00-3.C++%20STL%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/01/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00-3.C++%20STL%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><ol><li>模板</li><li>STL 初识</li><li>STL - 常用容器</li><li>STL - 函数对象</li><li>STL - 常用算法</li></ol></blockquote><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><p>模板分类：</p><ul><li><p>C++另一种编程思想称为 &#x3D;&#x3D;泛型编程&#x3D;&#x3D; ，主要利用的技术就是模板</p></li><li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p></li></ul><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><strong>模板书写：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或定义<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>template  —  声明创建模板</li><li>typename  — 表面其后面的符号是一种数据类型，可以用class代替</li><li>T    —   通用的数据类型，名称可以替换，通常为大写字母</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 函数模板声明</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortFn01</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main_1_1_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义整形数据交换</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 利用模板实现交换</span><br><span class="hljs-comment">// 自动类型检测</span><br><span class="hljs-comment">// sortFn(a, b);</span><br><span class="hljs-comment">// 显示指定类型</span><br><span class="hljs-built_in">sortFn01</span>&lt;<span class="hljs-type">int</span>&gt;(a, b);<br><span class="hljs-comment">// 输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-comment">// 定义字符型数据交换</span><br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> d = <span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-comment">// 自动类型检测</span><br><span class="hljs-comment">// sortFn(c, d);</span><br><span class="hljs-comment">// 显示指定类型</span><br><span class="hljs-built_in">sortFn01</span>&lt;<span class="hljs-type">char</span>&gt;(c, d);<br><span class="hljs-comment">// 输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034143.png" alt="image-20230220141324694"></p><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型 T ,才可以使用</p></li><li><p>模板必须要确定出 T 的数据类型，才可以使用</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortFn02</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">// 1. 测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01_1_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 自动类型推导，必须推导出一致的数据类型T,才可以使用</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 自动转换</span><br><span class="hljs-built_in">sortFn02</span>(a, b);  <span class="hljs-comment">// 可以推导出一致的T</span><br><span class="hljs-comment">// sortFn02(a, c);      // T 类型不同，报错 </span><br>&#125;<br><br><span class="hljs-comment">// 2. 模板必须要确定出T的数据类型，才可以使用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fnc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;fnc 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">test01_1_2</span>();<br><br><span class="hljs-comment">// 直接调用模板函数</span><br><span class="hljs-comment">// fnc();  // 报错，不可以独立使用，必须确定 T 的类型</span><br><span class="hljs-built_in">fnc</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">// 利用显示指定类型的方式，给T一个类型，才可以使用该模板</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 利用函数模板封装一个排序的函数，可以对 不同数据类型数组 进行排序</span><br><span class="hljs-comment">// 排序规则从大到小，排序算法为选择排序</span><br><span class="hljs-comment">// 分别利用 char 数组和 int 数组进行测试</span><br><br><span class="hljs-comment">// 定义交换函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapTmplate</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">// 定义排序模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortTemplate</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-type">int</span> max = i;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; j++)<br>&#123;<br><span class="hljs-comment">// 判断数组内大小</span><br><span class="hljs-comment">// 降序排列</span><br><span class="hljs-keyword">if</span> (arr[max] &lt; arr[j])<br>&#123;<br>max = j;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果最大数的下标不是i，交换两者</span><br><span class="hljs-keyword">if</span> (max != i)<br>&#123;<br><span class="hljs-comment">// 交换函数模板</span><br><span class="hljs-built_in">swapTmplate</span>(arr[max], arr[i]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 定义输出模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTemplate</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 测试 int 类型数据交换</span><br><span class="hljs-type">int</span> intArr[] = &#123; <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">// 2. 获取数组长度</span><br><span class="hljs-type">int</span> lenInt = <span class="hljs-built_in">sizeof</span>(intArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-comment">// 调用函数模板</span><br><span class="hljs-built_in">sortTemplate</span>(intArr, lenInt);<br><span class="hljs-built_in">printTemplate</span>(intArr, lenInt);<br><br><span class="hljs-comment">// 2. 测试 char 类型数据交换</span><br><span class="hljs-type">char</span> charArr[] = <span class="hljs-string">&quot;bdcfeagh&quot;</span>;<br><span class="hljs-comment">// 2. 获取数组长度</span><br><span class="hljs-type">int</span> lenChar = <span class="hljs-built_in">sizeof</span>(charArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>);<br><span class="hljs-comment">// 调用函数模板</span><br><span class="hljs-built_in">sortTemplate</span>(charArr, lenChar);<br><span class="hljs-built_in">printTemplate</span>(charArr, lenChar);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>模板大幅度提高了代码的复用性</p></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAdd01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myAdd02</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01_1_4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="hljs-comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span><br><br><span class="hljs-comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span><br><br><span class="hljs-built_in">myAdd02</span>&lt;<span class="hljs-type">int</span>&gt;(a, c); <span class="hljs-comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01_1_4</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034629.png" alt="image-20230220141745016"></p><p>总结：</p><p>建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型 T</p><h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用的是函数模板&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用的是函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 定义函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1、如果函数模板和普通函数都可以实现，优先调用普通函数</span><br><span class="hljs-comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">printFn</span>(a); <span class="hljs-comment">// 调用普通函数</span><br><br><span class="hljs-comment">// 2、可以通过空模板参数列表来强制调用函数模板</span><br>printFn&lt;&gt;(a); <span class="hljs-comment">// 调用函数模板</span><br><br><span class="hljs-comment">//3、函数模板也可以发生重载</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">printFn</span>(a, b); <span class="hljs-comment">// 调用重载的函数模板</span><br><br><span class="hljs-comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span><br><span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-built_in">printFn</span>(c1); <span class="hljs-comment">// 调用函数模板</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034527.png" alt="image-20230220141900461"></p><p>总结：</p><p>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123; <br>   a = b;<br>   &#125;<br></code></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的 a 和 b 是一个数组，就无法实现了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123; <br>   <span class="hljs-keyword">if</span>(a &gt; b) &#123; ... &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是对象或类这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 1. 如果参数的类型为数组则无法进行赋值操作</span><br><span class="hljs-comment">//template&lt;typename T&gt;</span><br><span class="hljs-comment">//void f(T a, T b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//a = b;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person01</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person01</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Name = name;<br><span class="hljs-keyword">this</span>-&gt;Age = age;<br>&#125;<br><br>string Name;<br><span class="hljs-type">int</span> Age;<br>&#125;;<br><br><span class="hljs-comment">// 普通函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareTemplate</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a == b)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span><br><span class="hljs-comment">// 具体化优先于常规模板</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareTemplate</span><span class="hljs-params">(Person01&amp; p1, Person01&amp; p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (p1.Name == p2.Name)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br>Person01 p1 = <span class="hljs-built_in">Person01</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">12</span>);<br>Person01 p2 = <span class="hljs-built_in">Person01</span>(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">15</span>);<br><br><span class="hljs-comment">// 自定义数据类型，不会调用普通的函数模板</span><br><span class="hljs-comment">// 可以创建具体化的 Person01 数据类型的模板，用于特殊处理这个类型</span><br><span class="hljs-type">bool</span> result = <span class="hljs-built_in">compareTemplate</span>(p1, p2);<br><br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034287.png" alt="image-20230220142054017"></p><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>类<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>template  —  声明创建模板</li><li>class— 表面其后面的符号是一种数据类型</li><li>T    —   通用的数据类型，名称可以替换，通常为大写字母</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">useClassTemplate</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">useClassTemplate</span>(NameType name, AgeType age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Name = name;<br><span class="hljs-keyword">this</span>-&gt;Age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Age &lt;&lt; endl;<br>&#125;<br><br>NameType Name;<br>AgeType Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 使用时必须定义类型</span><br><span class="hljs-comment">// 指定NameType 为 string 类型，AgeType 为 int 类型</span><br><span class="hljs-function">useClassTemplate&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">23</span>)</span></span>;<br>p1.<span class="hljs-built_in">printFn</span>();<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034930.png" alt="image-20230220142328592"></p><p>总结：</p><p>类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span> = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> Person02<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person02</span>(NameType name, AgeType age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Name = name;<br><span class="hljs-keyword">this</span>-&gt;Age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Age &lt;&lt; endl;<br>&#125;<br><br>NameType Name;<br>AgeType Age;<br>&#125;;<br><br><span class="hljs-comment">// 1. 测试</span><br><span class="hljs-comment">// 1、类模板没有自动类型推导的使用方式</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01_2_2_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Person02 p(&quot;Tom&quot;, 123) // 错误、类模板使用时候，不可以用自动类型推导</span><br><span class="hljs-comment">// 必须使用显示指定类型的方式，使用类模板</span><br><span class="hljs-function">Person02&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">123</span>)</span></span>;<br>p.<span class="hljs-built_in">printFn</span>();<br>&#125;<br><span class="hljs-comment">// 2. 测试</span><br><span class="hljs-comment">// 2、类模板在模板参数列表中可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01_2_2_2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person02&lt;string&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-number">123</span>)</span></span>;<br>p.<span class="hljs-built_in">printFn</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test01_2_2_1</span>();<br><span class="hljs-built_in">test01_2_2_2</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034447.png" alt="image-20230220142424852"></p><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="创建时机"><a href="#创建时机" class="headerlink" title="创建时机"></a>创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">timeClass01</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Normal Class01 show!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">timeClass02</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Normal Class02 show!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">timeTmplate</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>T obj;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>obj.<span class="hljs-built_in">showInfo01</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>obj.<span class="hljs-built_in">showInfo02</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>timeTmplate&lt;timeClass01&gt; p1;<br>p1.<span class="hljs-built_in">fn01</span>();<br><span class="hljs-comment">// p1.fn02(); // 编译会出错，说明函数调用才会去创建成员函数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="做函数参数"><a href="#做函数参数" class="headerlink" title="做函数参数"></a>做函数参数</h4><p><strong>类模板实例化出的对象，向函数传参的方式</strong></p><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">NameType</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeType</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person03</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person03</span>(NameType name, AgeType age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Name = name;<br><span class="hljs-keyword">this</span>-&gt;Age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Age &lt;&lt; endl;<br>&#125;<br><br>NameType Name;<br>AgeType Age;<br>&#125;;<br><br><span class="hljs-comment">// 1. 指定传入的类型</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson01</span><span class="hljs-params">(Person03&lt;string, <span class="hljs-type">int</span>&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">printFn</span>();<br>&#125;<br><br><span class="hljs-comment">// 2. 参数模板化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson02</span><span class="hljs-params">(Person03&lt;T1, T2&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">printFn</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;T1 的类型为：&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;T1 的类型为：&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 3. 整体类模板话</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPerson03</span><span class="hljs-params">(T&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>p.<span class="hljs-built_in">printFn</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;T 的类型为：&quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person03&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-comment">// printPerson01(p01);</span><br><span class="hljs-comment">// printPerson02(p01);</span><br><span class="hljs-built_in">printPerson03</span>(p01);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义父类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fa</span><br>&#123;<br>T f;<br>&#125;;<br><br><span class="hljs-comment">// 定义子类模板</span><br><span class="hljs-comment">// class Son:public Base  // 错误，c++ 编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span><br><span class="hljs-comment">// 类模板继承类模板 ,可以用T2指定父类中的T类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Fa&lt;T2&gt; <span class="hljs-comment">// 必须指定一个类型</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main01_2_5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son&lt;<span class="hljs-type">int</span> ,<span class="hljs-type">char</span>&gt; s;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>如果父类是类模板，子类需要指定出父类中 T 的数据类型</p><h4 id="类外实现成员函数"><a href="#类外实现成员函数" class="headerlink" title="类外实现成员函数"></a>类外实现成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 类模板中成员函数类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OutTemplate</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-built_in">OutTemplate</span>(T1 person, T2 num);<br><span class="hljs-comment">// 定义成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showTemp</span><span class="hljs-params">()</span></span>;<br><br>T1 Person;<br>T2 Number;<br>&#125;;<br><span class="hljs-comment">// 构造函数-类外实现</span><br><span class="hljs-comment">// 直接写，报错</span><br><span class="hljs-comment">// 1. 无法知晓类模板的数据类型</span><br><span class="hljs-comment">// 2. 编译器无法识别 T1, T2 数据类型</span><br><span class="hljs-comment">// OutTemplate::OutTemplate(T1 person, T2 num);</span><br><span class="hljs-comment">// 正确写法：</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>OutTemplate&lt;T1, T2&gt;::<span class="hljs-built_in">OutTemplate</span>(T1 person, T2 num)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Person = person;<br><span class="hljs-keyword">this</span>-&gt;Number = num;<br>&#125;<br><br><span class="hljs-comment">// 成员函数-类外实现</span><br><span class="hljs-comment">// 同上</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> OutTemplate&lt;T1, T2&gt;::<span class="hljs-built_in">showTemp</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person：&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Person &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Number：&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;Number &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main01_2_6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 实例化类</span><br><span class="hljs-function">OutTemplate&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">otl</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">123</span>)</span></span>;<br>otl.<span class="hljs-built_in">showTemp</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="份文件编写"><a href="#份文件编写" class="headerlink" title="份文件编写"></a>份文件编写</h4><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><code>01-3-1.ArrayFn.hpp</code> 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">splitTemplate</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">splitTemplate</span>(T1 name, T2 age);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br>T1 m_Name;<br>T2 m_Age;<br>&#125;;<br><br><span class="hljs-comment">//构造函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>splitTemplate&lt;T1, T2&gt;::<span class="hljs-built_in">splitTemplate</span>(T1 name, T2 age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//成员函数 类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-type">void</span> splitTemplate&lt;T1, T2&gt;::<span class="hljs-built_in">showPerson</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;m_Age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.cpp</code> 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;split.hpp&quot;</span></span><br><br><span class="hljs-comment">// 解决方式1：直接包含.cpp源文件</span><br><span class="hljs-comment">// 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main01_2_7</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">splitTemplate&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">sptemp</span><span class="hljs-params">(<span class="hljs-string">&quot;Tim&quot;</span>, <span class="hljs-number">123</span>)</span></span>;<br>sptemp.<span class="hljs-built_in">showPerson</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">friendTemplate</span>;<br><span class="hljs-comment">// 如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span><br><span class="hljs-comment">// template&lt;class T1, class T2&gt; void printFriendTemplate(friendTemplate&lt;T1, T2&gt;&amp; p);</span><br><br><br><span class="hljs-comment">// 定义全局函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFriendTemplate</span><span class="hljs-params">(friendTemplate&lt;T1, T2&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person：&quot;</span> &lt;&lt; p.Person &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Number：&quot;</span> &lt;&lt; p.Number &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 创建类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">friendTemplate</span><br>&#123;<br><span class="hljs-comment">// 实现友元</span><br><span class="hljs-comment">// friend void printFriendTemplate&lt;T1, T2&gt;(friendTemplate&lt;T1, T2&gt;&amp; p);</span><br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> printFriendTemplate&lt;&gt;(friendTemplate&lt;T1, T2&gt;&amp; p);<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">friendTemplate</span>(T1 person, T2 num);<br><br>T1 Person;<br>T2 Number;<br>&#125;;<br><span class="hljs-comment">// 构造函数类外实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br>friendTemplate&lt;T1, T2&gt;::<span class="hljs-built_in">friendTemplate</span>(T1 person, T2 num)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Person = person;<br><span class="hljs-keyword">this</span>-&gt;Number = num;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main01_2_8</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br><span class="hljs-function">friendTemplate&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">fTemp</span><span class="hljs-params">(<span class="hljs-string">&quot;Jerry&quot;</span>, <span class="hljs-number">123123</span>)</span></span>;<br><span class="hljs-built_in">printFriendTemplate</span>(fTemp);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><code>ArrayFn.hpp</code> 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">arrFn</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-built_in">arrFn</span>(<span class="hljs-type">int</span> capacity);<br><br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">arrFn</span>(<span class="hljs-type">const</span> arrFn&amp; arr);<br><br><span class="hljs-comment">// operator 重载 = ；防止浅拷贝</span><br>arrFn&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> arrFn&amp; arr)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;重载区&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 先判断原堆区是否有数据</span><br><span class="hljs-comment">// 有释放</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Address != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;Address;<br><span class="hljs-keyword">this</span>-&gt;Address = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">this</span>-&gt;Capacity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;Size = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 无则重新开辟</span><br><span class="hljs-keyword">this</span>-&gt;Capacity = arr.Capacity;<br><span class="hljs-keyword">this</span>-&gt;Size = arr.Size;<br><span class="hljs-keyword">this</span>-&gt;Address = <span class="hljs-keyword">new</span> T[arr.Capacity];<br><br><span class="hljs-comment">// 将 arr 中的数据进行拷贝</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;Size; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Address[i] = arr.Address[i];<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// operator 重载 []；</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Address[index];<br>&#125;<br><br><span class="hljs-comment">// 尾插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>;<br><span class="hljs-comment">// 尾删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>;<br><span class="hljs-comment">//获取数组容量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//获取数组大小</span><br><span class="hljs-function"><span class="hljs-type">int</span><span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 析构函数释放</span><br>~<span class="hljs-built_in">arrFn</span>();<br><br><span class="hljs-keyword">private</span>:<br>T* Address;<span class="hljs-comment">// 指针指向堆区开辟的真实数组</span><br><span class="hljs-type">int</span> Capacity;<span class="hljs-comment">// 数组容量</span><br><span class="hljs-type">int</span> Size;<span class="hljs-comment">// 数组大小</span><br>&#125;;<br><br><span class="hljs-comment">// 类外声明类模板的构造函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>arrFn&lt;T&gt;::<span class="hljs-built_in">arrFn</span>(<span class="hljs-type">int</span> capacity)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;构造函数&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;Capacity = capacity;<br><span class="hljs-keyword">this</span>-&gt;Size = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;Address = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">this</span>-&gt;Capacity];<br>&#125;<br><br><span class="hljs-comment">// 类外声明类模板的拷贝构造函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>arrFn&lt;T&gt;::<span class="hljs-built_in">arrFn</span>(<span class="hljs-type">const</span> arrFn&amp; arr)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝函数&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">this</span>-&gt;Capacity = arr.Capacity;<br><span class="hljs-keyword">this</span>-&gt;Size = arr.Size;<br><span class="hljs-comment">// this-&gt;Address = arr.Address;</span><br><span class="hljs-comment">// 进行深拷贝</span><br><span class="hljs-keyword">this</span>-&gt;Address = <span class="hljs-keyword">new</span> T[arr.Capacity];<br><span class="hljs-comment">// 将 arr 中的数据进行拷贝</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;Size; i++)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;Address[i] = arr.Address[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 类外声明类模板的成员函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> arrFn&lt;T&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; value)<br>&#123;<br><span class="hljs-comment">// 判断容器大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Capacity == <span class="hljs-keyword">this</span>-&gt;Size)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 插入</span><br><span class="hljs-keyword">this</span>-&gt;Address[<span class="hljs-keyword">this</span>-&gt;Size] = value;<br><span class="hljs-keyword">this</span>-&gt;Size++;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> arrFn&lt;T&gt;::<span class="hljs-built_in">pop</span>(<span class="hljs-type">const</span> T&amp; value)<br>&#123;<br><span class="hljs-comment">// 判断容器大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Size == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">this</span>-&gt;Size--;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> arrFn&lt;T&gt;::<span class="hljs-built_in">getCapacity</span>()<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Capacity;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> arrFn&lt;T&gt;::<span class="hljs-built_in">getSize</span>()<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;Size;<br>&#125;<br><br><span class="hljs-comment">// 类外声明类模板的析构函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>arrFn&lt;T&gt;::~<span class="hljs-built_in">arrFn</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Address != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span>[] <span class="hljs-keyword">this</span>-&gt;Address;<br><span class="hljs-keyword">this</span>-&gt;Address = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">this</span>-&gt;Capacity = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">this</span>-&gt;Size = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main.cpp</code> 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;01-3-1.ArrayFn.hpp&quot;</span></span><br><br><span class="hljs-comment">//测试自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">testClass</span>() &#123;&#125;<br><span class="hljs-built_in">testClass</span>(string name, <span class="hljs-type">int</span> age) &#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPersonArray</span><span class="hljs-params">(arrFn&lt;testClass&gt;&amp; testArr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; testArr.<span class="hljs-built_in">getSize</span>(); i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; testArr[i].m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; testArr[i].m_Age &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printIntArray</span><span class="hljs-params">(arrFn&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">getSize</span>(); i++) &#123;<br>cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main01_3_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//arrFn&lt;int&gt; arr01(5);</span><br><span class="hljs-comment">//arrFn&lt;int&gt; arr02(arr01);</span><br><span class="hljs-comment">//arrFn&lt;int&gt; arr03(100);</span><br><br><span class="hljs-comment">//arr03 = arr01;</span><br><br><span class="hljs-comment">//创建数组</span><br><span class="hljs-function">arrFn&lt;testClass&gt; <span class="hljs-title">pArray</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">testClass <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">testClass <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;韩信&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">testClass <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;妲己&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">testClass <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;王昭君&quot;</span>, <span class="hljs-number">15</span>)</span></span>;<br><span class="hljs-function">testClass <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">24</span>)</span></span>;<br><br><span class="hljs-comment">//插入数据</span><br>pArray.<span class="hljs-built_in">push</span>(p1);<br>pArray.<span class="hljs-built_in">push</span>(p2);<br>pArray.<span class="hljs-built_in">push</span>(p3);<br>pArray.<span class="hljs-built_in">push</span>(p4);<br>pArray.<span class="hljs-built_in">push</span>(p5);<br><br><span class="hljs-built_in">printPersonArray</span>(pArray);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="hljs-built_in">getSize</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="hljs-built_in">getCapacity</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL-初识"><a href="#STL-初识" class="headerlink" title="STL 初识"></a>STL 初识</h2><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>STL（Standard Template Library）：<strong>标准模板库</strong></li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li><strong>容器：</strong>各种数据结构，如：vector、list、deque、set、map 等，用来存放数据。</li><li><strong>算法：</strong>各种常用的算法合集，如：sort、find、copy、for_each 等。</li><li><strong>迭代器：</strong>扮演了容器和算法之间的胶合剂。</li><li><strong>仿函数：</strong>行为类似函数，可作为算法的某种策略。</li><li><strong>适配器：</strong>一种用来修饰容器活着仿函数或迭代器接口的东西。</li><li><strong>空间适配器：</strong>负责空间的配置和管理。</li></ol><h3 id="容器、算法、迭代器"><a href="#容器、算法、迭代器" class="headerlink" title="容器、算法、迭代器"></a>容器、算法、迭代器</h3><ul><li><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><ul><li><strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。</li><li><strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</li></ul></li><li><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><ul><li>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</li><li>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</li></ul></li><li><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p></li></ul><h3 id="容器算法迭代器初识"><a href="#容器算法迭代器初识" class="headerlink" title="容器算法迭代器初识"></a>容器算法迭代器初识</h3><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 vector </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-comment">// 2. 引入 algorithm 使用 for_each</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 用于输出的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFn02</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 创建 vector 容器，并且通过模板参数指定容器中存放的数据的类型</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-comment">// 2. 从尾部插入数据</span><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-comment">// 每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span><br><span class="hljs-comment">// v.begin() 返回迭代器，这个迭代器指向容器中第一个数据</span><br><span class="hljs-comment">// v.end() 返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span><br><span class="hljs-comment">// vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span><br><br><span class="hljs-comment">// 第一种遍历方式：通过 while 循环遍历</span><br><span class="hljs-comment">// 首先定义返回迭代器</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator vBegin = v.<span class="hljs-built_in">begin</span>();<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator vEnd = v.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">// 其次循环</span><br><span class="hljs-keyword">while</span> (vBegin != vEnd)<br>&#123;<br><span class="hljs-comment">// 获取到的数据为地址 需要解引用</span><br>cout &lt;&lt; *vBegin &lt;&lt; endl;<br>vBegin++;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-------------隔离行--------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 第二种遍历方式：通过 for 循环遍历</span><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-------------隔离行--------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 第三种遍历方式：通过内置 for_each 语法遍历</span><br><span class="hljs-comment">// 第一个参数为容器的起始位置</span><br><span class="hljs-comment">// 第二个参数为容器的末尾位置</span><br><span class="hljs-comment">// 第三个参数为输出函数</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), printFn02);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034634.png" alt="image-20230222171206491"></p><h4 id="vector存放自定义数据类型"><a href="#vector存放自定义数据类型" class="headerlink" title="vector存放自定义数据类型"></a>vector存放自定义数据类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 vector </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-comment">// 2. 引入 algorithm 使用 for_each</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vectorClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">vectorClass</span>(string name, <span class="hljs-type">int</span> age) &#123;<br>mName = name;<br>mAge = age;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string mName;<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 创建容器</span><br>vector&lt;vectorClass&gt; VC;<br><span class="hljs-comment">// 2. 创建数据</span><br><span class="hljs-function">vectorClass <span class="hljs-title">VC1</span><span class="hljs-params">(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">vectorClass <span class="hljs-title">VC2</span><span class="hljs-params">(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">vectorClass <span class="hljs-title">VC3</span><span class="hljs-params">(<span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">vectorClass <span class="hljs-title">VC4</span><span class="hljs-params">(<span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">vectorClass <span class="hljs-title">VC5</span><span class="hljs-params">(<span class="hljs-string">&quot;eee&quot;</span>, <span class="hljs-number">50</span>)</span></span>;<br><br><span class="hljs-comment">// 3. 存放数据</span><br>VC.<span class="hljs-built_in">push_back</span>(VC1);<br>VC.<span class="hljs-built_in">push_back</span>(VC2);<br>VC.<span class="hljs-built_in">push_back</span>(VC3);<br>VC.<span class="hljs-built_in">push_back</span>(VC4);<br>VC.<span class="hljs-built_in">push_back</span>(VC5);<br><br><span class="hljs-comment">// 遍历输出</span><br>vector&lt;vectorClass&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = VC.<span class="hljs-built_in">begin</span>(); it != VC.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="hljs-string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011034087.png" alt="image-20230222172145507"></p><h4 id="vector容器嵌套容器"><a href="#vector容器嵌套容器" class="headerlink" title="vector容器嵌套容器"></a>vector容器嵌套容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 vector </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt;  v;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>vector&lt;<span class="hljs-type">int</span>&gt; v4;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>v2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">2</span>);<br>v3.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">3</span>);<br>v4.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-comment">//将容器元素插入到vector v中</span><br>v.<span class="hljs-built_in">push_back</span>(v1);<br>v.<span class="hljs-built_in">push_back</span>(v2);<br>v.<span class="hljs-built_in">push_back</span>(v3);<br>v.<span class="hljs-built_in">push_back</span>(v4);<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator vit;<br><span class="hljs-keyword">for</span> (vit = (*it).<span class="hljs-built_in">begin</span>(); vit != (*it).<span class="hljs-built_in">end</span>(); vit++) &#123;<br>cout &lt;&lt; *vit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035782.png" alt="image-20230222172829755"></p><h2 id="STL-常用容器"><a href="#STL-常用容器" class="headerlink" title="STL - 常用容器"></a>STL - 常用容器</h2><blockquote><ol><li>String 容器</li><li>Vector 容器</li><li>Deque 容器</li><li>Stack 容器</li><li>Queue 容器</li><li>List 容器</li><li>Set&#x2F;Multiset 容器</li><li>Map&#x2F;Multiset 容器</li></ol></blockquote><h3 id="String-容器"><a href="#String-容器" class="headerlink" title="String 容器"></a>String 容器</h3><p><strong>本质：</strong></p><p>string 是 C++ 风格的字符串，而 string 本质上是一个类。</p><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="string-构造函数"><a href="#string-构造函数" class="headerlink" title="string 构造函数"></a>string 构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>          &#x2F;&#x2F;创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code>        &#x2F;&#x2F;使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    &#x2F;&#x2F;使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           &#x2F;&#x2F;使用n个字符c初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 创建空字符串</span><br><span class="hljs-comment">// string()</span><br>string str1;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-comment">// string(const char* s)</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str2 = <span class="hljs-string">&quot;hello string&quot;</span>;<br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str2)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str2：&quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br><br><span class="hljs-comment">// 直接调用拷贝函数</span><br><span class="hljs-comment">// string(const string&amp; str);</span><br><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(s2)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str3：&quot;</span> &lt;&lt; s3 &lt;&lt; endl;<br><br><span class="hljs-comment">// string(int n, char c)</span><br><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;d&#x27;</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str4：&quot;</span> &lt;&lt; s4 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035877.png" alt="image-20230223160328970"></p><p>总结：</p><p>string 的多种构造方式没有可比性，灵活使用即可</p><h4 id="string-赋值操作"><a href="#string-赋值操作" class="headerlink" title="string 赋值操作"></a>string 赋值操作</h4><p><strong>给 string 字符串进行赋值</strong></p><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                            字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                    把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>                把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                    用n个字符c赋给当前字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// string&amp; operator=(const char* s);</span><br>string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>str1 = <span class="hljs-string">&quot;String, C++&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; operator=(const string &amp;s);</span><br>string str2;<br>str2 = str1;<br>cout &lt;&lt; <span class="hljs-string">&quot;str2：&quot;</span> &lt;&lt; str2 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; operator=(char c);</span><br>string str3;<br><span class="hljs-comment">// 只能输出第一个字符</span><br>str3 = <span class="hljs-string">&#x27;AB&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str3：&quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br><br><span class="hljs-comment">// tring&amp; assign(const char *s);</span><br>string str4;<br>str4.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello, C++&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str4：&quot;</span> &lt;&lt; str4 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; assign(const char *s, int n);</span><br>string str5;<br>str5.<span class="hljs-built_in">assign</span>(<span class="hljs-string">&quot;hello, C++&quot;</span>, <span class="hljs-number">5</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str5：&quot;</span> &lt;&lt; str5 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; assign(const string &amp;s);</span><br>string str6;<br>str6.<span class="hljs-built_in">assign</span>(str5);<br>cout &lt;&lt; <span class="hljs-string">&quot;str6：&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; assign(int n, char c);</span><br>string str7;<br><span class="hljs-comment">// 递增对有一个字符</span><br>str7.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;sw&#x27;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str7：&quot;</span> &lt;&lt; str7 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035596.png" alt="image-20230223161237567"></p><p>总结：</p><p>​string 的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="string-字符串拼接"><a href="#string-字符串拼接" class="headerlink" title="string 字符串拼接"></a>string 字符串拼接</h4><p><strong>实现在字符串末尾拼接字符串</strong></p><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                           重载+&#x3D;操作符</li><li><code>string&amp; operator+=(const char c);</code>                                 重载+&#x3D;操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                       重载+&#x3D;操作符</li><li><code>string&amp; append(const char *s); </code>                                        把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                         把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                                    同operator+&#x3D;(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n); </code>   字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// string&amp; operator+=(const char* str);</span><br>string str1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>str1 += <span class="hljs-string">&quot; world&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; operator+=(const char c);</span><br>str1 += <span class="hljs-string">&#x27;!!&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;str2：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; operator+=(const string&amp; str);</span><br>string str2 = <span class="hljs-string">&quot;, 123321&quot;</span>;<br>str1 += str2;<br>cout &lt;&lt; <span class="hljs-string">&quot;str2：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; append(const char *s);</span><br>string str3;<br>str3.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;append char&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str3：&quot;</span> &lt;&lt; str3 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; append(const char *s, int n);</span><br>string str4;<br>str4.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;hello, world&quot;</span>, <span class="hljs-number">5</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str4：&quot;</span> &lt;&lt; str4 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; append(const string &amp;s);</span><br>string str5;<br>str5.<span class="hljs-built_in">append</span>(str4);<br>cout &lt;&lt; <span class="hljs-string">&quot;str5：&quot;</span> &lt;&lt; str5 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; append(const string &amp;s, int pos, int n);</span><br>string str6;<br>str6.<span class="hljs-built_in">append</span>(str3, <span class="hljs-number">0</span>,<span class="hljs-number">6</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str6：&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035679.png" alt="image-20230223162434644"></p><p>总结：</p><p>字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="string-查找和替换"><a href="#string-查找和替换" class="headerlink" title="string 查找和替换"></a>string 查找和替换</h4><p>查找：查找指定字符串是否存在</p><p>替换：在指定的位置替换字符串</p><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                      查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>                从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                        查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>     查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>     替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                替换从pos开始的n个字符为字符串s</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// int find(const string&amp; str, int pos = 0) const;</span><br>string str1 = <span class="hljs-string">&quot;abcdefghijklmn&quot;</span>;<br><span class="hljs-type">int</span> pos = str1.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;f&quot;</span>);<br><span class="hljs-comment">// 判断是否存在</span><br><span class="hljs-keyword">if</span> (pos == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;position：&quot;</span> &lt;&lt; pos &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// int rfind(const string&amp; str, int pos = 0) const;</span><br><span class="hljs-comment">// rfind = right find</span><br>pos = str1.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;jk&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;position：&quot;</span> &lt;&lt; pos &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; replace(int pos, int n, const string&amp; str);</span><br>str1.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;1111&quot;</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035691.png" alt="image-20230223164123265"></p><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="string-字符串比较"><a href="#string-字符串比较" class="headerlink" title="string 字符串比较"></a>string 字符串比较</h4><p>字符串之间的比较</p><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>&#x3D; 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  &#x2F;&#x2F;与字符串s比较</li><li><code>int compare(const char *s) const;</code>      &#x2F;&#x2F;与字符串s比较</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1 = <span class="hljs-string">&quot;aello&quot;</span>;<br>string str2 = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-comment">// int compare(const string &amp;s) const;</span><br><span class="hljs-type">int</span> result = str1.<span class="hljs-built_in">compare</span>(str2);<br><br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 == str2&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 &gt; str2&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;str1 &lt; str2&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035456.png" alt="image-20230223164732415"></p><p>总结：</p><p>字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="string-字符存取"><a href="#string-字符存取" class="headerlink" title="string 字符存取"></a>string 字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                      通过at方法获取字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str1 = <span class="hljs-string">&quot;helol, wqeewq&quot;</span>;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; str1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; str1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; str1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; str1.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 修改</span><br>str1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>str1.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) = <span class="hljs-string">&#x27;B&#x27;</span>;<br><br>cout &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035404.png" alt="image-20230223165224934"></p><p>总结：</p><p>string 字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="string-插入和删除"><a href="#string-插入和删除" class="headerlink" title="string 插入和删除"></a>string 插入和删除</h4><p><strong>对string字符串进行插入和删除字符操作</strong></p><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    删除从Pos开始的n个字符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// string&amp; insert(int pos, const char* s);</span><br>string str1 = <span class="hljs-string">&quot;qweqweqwe&quot;</span>;<br>str1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-comment">// string&amp; erase(int pos, int n = npos);</span><br>str1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;str1：&quot;</span> &lt;&lt; str1 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035462.png" alt="image-20230223170323545"></p><p><strong>总结：</strong></p><p>插入和删除的起始下标都是从0开始</p><h4 id="string-子串"><a href="#string-子串" class="headerlink" title="string 子串"></a>string 子串</h4><p>从字符串中获取想要的子串</p><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   返回由pos开始的n个字符组成的字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 引入 string 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// string substr(int pos = 0, int n = npos) const;</span><br>string str1 = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>string subStr1 = str1.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subStr1：&quot;</span> &lt;&lt; subStr1 &lt;&lt; endl;<br><br><span class="hljs-comment">// 获取邮箱@前的数据</span><br>string email = <span class="hljs-string">&quot;heloWld@email.com&quot;</span>;<br><span class="hljs-type">int</span> pos = email.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;@&quot;</span>);<br>string username = email.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>cout &lt;&lt; <span class="hljs-string">&quot;Username：&quot;</span> &lt;&lt; username &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035195.png" alt="image-20230223170900699"></p><p><strong>总结：</strong></p><p>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="Vector-容器"><a href="#Vector-容器" class="headerlink" title="Vector 容器"></a>Vector 容器</h3><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组（栈）</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li><p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035504.png" alt="image-20230228154836150"></p></li><li><p>vector容器的迭代器是支持随机访问的迭代器</p></li></ul><h4 id="vector-构造函数"><a href="#vector-构造函数" class="headerlink" title="vector 构造函数"></a>vector 构造函数</h4><p><strong>创建vector容器</strong></p><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                                采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>        将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                               构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>          拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printVector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 输出方式通过迭代器</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// vector&lt;T&gt; v;</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><br><span class="hljs-comment">// 遍历传参</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-built_in">printVector</span>(v1);<br><br><span class="hljs-comment">// vector(v.begin(), v.end()); 拷贝</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1.begin(), v1.end())</span></span>;<br><span class="hljs-built_in">printVector</span>(v2);<br><br><span class="hljs-comment">// vector(n, elem);</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-built_in">printVector</span>(v3);<br><br><span class="hljs-comment">// vector(const vector &amp;vec);</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v3)</span></span>;<br><span class="hljs-built_in">printVector</span>(v4);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035785.png" alt="image-20230228155601418"></p><p><strong>总结：</strong></p><p>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="vector-赋值操作"><a href="#vector-赋值操作" class="headerlink" title="vector 赋值操作"></a>vector 赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>       重载等号操作符</p></li><li><p><code>assign(beg, end);</code>                                                 将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>                                                   将n个elem拷贝赋值给本身。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// vector&amp; operator=(const vector &amp;vec);</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>v2 = v1;<br><span class="hljs-keyword">for</span> (it = v2.<span class="hljs-built_in">begin</span>(); it != v2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// assign(beg, end);</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v3;<br>v3.<span class="hljs-built_in">assign</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (it = v3.<span class="hljs-built_in">begin</span>(); it != v3.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// assign(n, elem);</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v4;<br>v4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><span class="hljs-keyword">for</span> (it = v4.<span class="hljs-built_in">begin</span>(); it != v4.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011035434.png" alt="image-20230228161141420"></p><p><strong>总结：</strong></p><p> vector 赋值方式比较简单，使用 operator&#x3D;，或者 assign 都可以</p><h4 id="vector-容量和大小"><a href="#vector-容量和大小" class="headerlink" title="vector 容量和大小"></a>vector 容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                                   判断容器是否为空</p></li><li><p><code>capacity();</code>                             容器的容量</p></li><li><p><code>size();</code>                                     返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>                  重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                                 如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>      重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                                      如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// empty();</span><br><span class="hljs-keyword">if</span> (v1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1 内容为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;v1 不为空&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// capacity();</span><br>cout &lt;&lt; <span class="hljs-string">&quot;v1 的容量：&quot;</span> &lt;&lt; v1.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><span class="hljs-comment">// size()</span><br>cout &lt;&lt; <span class="hljs-string">&quot;v1 的大小：&quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span><br>v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">10</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span><br>v1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011036122.png" alt="image-20230228162220291"></p><p><strong>总结：</strong></p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="vector-插入和删除"><a href="#vector-插入和删除" class="headerlink" title="vector 插入和删除"></a>vector 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                                                             尾部插入元素ele</li><li><code> pop_back();</code>                                                                                     删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>                                         迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>                    迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                                                     删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end); </code>       删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                                                           删除容器中所有元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-comment">// push_back(ele);</span><br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">// pop_back();</span><br>v1.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// 定义迭代器</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-comment">// 循环 vector</span><br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// insert(const_iterator pos, ele);</span><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 循环 vector</span><br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// insert(const_iterator pos, int count,ele);</span><br>v1.<span class="hljs-built_in">insert</span>(v1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// erase(const_iterator pos);</span><br>v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>());<br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// erase(const_iterator start, const_iterator end);</span><br>v1.<span class="hljs-built_in">erase</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>());<br>v1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011036914.png" alt="image-20230228163036345"></p><p><strong>总结：</strong></p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear</li></ul><h4 id="vector-互换容器"><a href="#vector-互换容器" class="headerlink" title="vector 互换容器"></a>vector 互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>                         将vec与本身的元素互换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-comment">// push_back(ele);</span><br>v1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt;v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>&#123;<br>v2.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// swap(vec);</span><br>v1.<span class="hljs-built_in">swap</span>(v2);<br><br><span class="hljs-comment">// 定义迭代器</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-comment">// 循环 vector</span><br><span class="hljs-keyword">for</span> (it = v1.<span class="hljs-built_in">begin</span>(); it != v1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">// 循环 vector</span><br><span class="hljs-keyword">for</span> (it = v2.<span class="hljs-built_in">begin</span>(); it != v2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011036443.png" alt="image-20230228163533935"></p><p><strong>总结：</strong></p><p>swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="vector-预留空间"><a href="#vector-预留空间" class="headerlink" title="vector 预留空间"></a>vector 预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少 vector 在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>                 容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><br><span class="hljs-comment">// 预留空间</span><br>v1.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">if</span> (p != &amp;v1[<span class="hljs-number">0</span>]) &#123;<br>p = &amp;v1[<span class="hljs-number">0</span>];<br>num++;<br>&#125;<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011036220.png" alt="image-20230228164004650"></p><p><strong>总结：</strong></p><p>如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="Depue-容器"><a href="#Depue-容器" class="headerlink" title="Depue 容器"></a>Depue 容器</h3><p><strong>功能：</strong></p><ul><li><strong>双端数组（队列）</strong>，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011036435.png" alt="image-20230228164135885"></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011036299.png" alt="image-20230228164151449"></p><p>deque容器的迭代器也是支持随机访问的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 deque </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 函数用于输出 deque 中存的数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDeque</span><span class="hljs-params">(<span class="hljs-type">const</span> deque&lt;<span class="hljs-type">int</span>&gt;&amp; d)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义迭代器</span><br>deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator it;<br><span class="hljs-comment">// 循环遍历</span><br><span class="hljs-keyword">for</span> (it = d.<span class="hljs-built_in">begin</span>(); it != d.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="depue-构造函数"><a href="#depue-构造函数" class="headerlink" title="depue 构造函数"></a>depue 构造函数</h4><p><strong>deque容器构造</strong></p><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                       &#x2F;&#x2F;默认构造形式</li><li><code>deque(beg, end);</code>                  &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   &#x2F;&#x2F;拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-3.dequePrint.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 方法一：deque&lt;T&gt;</span><br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// 方法二：deque(beg, end);</span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d2</span><span class="hljs-params">(d1.begin(), d1.end())</span></span>;<br><span class="hljs-built_in">printDeque</span>(d2);<br><br><span class="hljs-comment">// 方法三：deque(n, elem);</span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-built_in">printDeque</span>(d3);<br><br><span class="hljs-comment">// 方法四：deque(const deque &amp;deq);</span><br><span class="hljs-function">deque&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d4</span><span class="hljs-params">(d3)</span></span>;<br><span class="hljs-built_in">printDeque</span>(d4);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037161.png" alt="image-20230309153916579"></p><p><strong>总结：</strong></p><p>deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可</p><h4 id="deque-赋值操作"><a href="#deque-赋值操作" class="headerlink" title="deque 赋值操作"></a>deque 赋值操作</h4><p><strong>给deque容器进行赋值</strong></p><p><strong>函数原型：</strong></p><ul><li><p><code>deque&amp; operator=(const deque &amp;deq); </code>         &#x2F;&#x2F;重载等号操作符</p></li><li><p><code>assign(beg, end);</code>                                           &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>                                             &#x2F;&#x2F;将n个elem拷贝赋值给本身。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-3.dequePrint.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// deque&amp; operator=(const deque &amp;deq);</span><br>deque&lt;<span class="hljs-type">int</span>&gt; d2;<br>d2 = d1;<br><span class="hljs-built_in">printDeque</span>(d2);<br><br><span class="hljs-comment">// assign(beg, end);</span><br>deque&lt;<span class="hljs-type">int</span>&gt; d3;<br>d3.<span class="hljs-built_in">assign</span>(d1.<span class="hljs-built_in">begin</span>(), d1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d3);<br><br><span class="hljs-comment">// assign(n, elem);</span><br>deque&lt;<span class="hljs-type">int</span>&gt; d4;<br>d4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">printDeque</span>(d4);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037440.png" alt="image-20230309154422560"></p><p><strong>总结：</strong></p><p>deque 赋值操作也与 vector 相同，需熟练掌握</p><h4 id="deque-大小操作"><a href="#deque-大小操作" class="headerlink" title="deque 大小操作"></a>deque 大小操作</h4><p><strong>对deque容器的大小进行操作</strong></p><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       &#x2F;&#x2F;判断容器是否为空</p></li><li><p><code>deque.size();</code>                         &#x2F;&#x2F;返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                             &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-3.dequePrint.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-keyword">if</span> (d1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;d1为空!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//统计大小</span><br>cout &lt;&lt; <span class="hljs-string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 重新指定大小</span><br>d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">15</span>, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br><br>d1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037368.png" alt="image-20230309155105073"></p><p><strong>总结：</strong></p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="deque-插入和删除"><a href="#deque-插入和删除" class="headerlink" title="deque 插入和删除"></a>deque 插入和删除</h4><p>向deque容器中插入和删除数据</p><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          &#x2F;&#x2F;在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        &#x2F;&#x2F;在容器头部插入一个数据</li><li><code>pop_back();</code>                   &#x2F;&#x2F;删除容器最后一个数据</li><li><code>pop_front();</code>                 &#x2F;&#x2F;删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><code>insert(pos,elem);</code>         &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>     &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li><code>insert(pos,beg,end);</code>    &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li><code>clear();</code>                           &#x2F;&#x2F;清空容器的所有数据</li><li><code>erase(beg,end);</code>             &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-3.dequePrint.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>d1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// 尾插、尾删</span><br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">11</span>);<br>d1.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// 头插、头删</span><br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">11</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">12</span>);<br>d1.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// 添加 insert(pos,elem);</span><br>d1.<span class="hljs-built_in">insert</span>(d1.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">20</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// insert(pos,n,elem);</span><br>d1.<span class="hljs-built_in">insert</span>(d1.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// insert(pos,beg,end);</span><br>deque&lt;<span class="hljs-type">int</span>&gt; d2;<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>d2.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">60</span>);<br><br>d1.<span class="hljs-built_in">insert</span>(d1.<span class="hljs-built_in">begin</span>(), d2.<span class="hljs-built_in">begin</span>(), d2.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-comment">// 删除 erase(beg,end);</span><br><span class="hljs-comment">// d1.erase(d1.begin(), d2.end());</span><br><span class="hljs-comment">// printDeque(d1);</span><br>d1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printDeque</span>(d1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037272.png" alt="image-20230309160124773"></p><p><strong>总结：</strong></p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="deque-数据存取"><a href="#deque-数据存取" class="headerlink" title="deque 数据存取"></a>deque 数据存取</h4><p>04.deque-插入和删除</p><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     &#x2F;&#x2F;返回索引idx所指的数据</li><li><code>operator[]; </code>      &#x2F;&#x2F;返回索引idx所指的数据</li><li><code>front(); </code>            &#x2F;&#x2F;返回容器中第一个数据元素</li><li><code>back();</code>              &#x2F;&#x2F;返回容器中最后一个数据元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-3.dequePrint.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d1;<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; d1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; d1[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; d1.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>cout &lt;&lt; d1.<span class="hljs-built_in">at</span>(i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;front:&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;back:&quot;</span> &lt;&lt; d1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037487.png" alt="image-20230309161424522"></p><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="deque-排序"><a href="#deque-排序" class="headerlink" title="deque 排序"></a>deque 排序</h4><p>利用算法实现对deque容器进行排序</p><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  &#x2F;&#x2F;对beg和end区间内元素进行排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-3.dequePrint.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>d.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>d.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br><span class="hljs-built_in">printDeque</span>(d);<br><br><span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printDeque</span>(d);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037763.png" alt="image-20230309161702805"></p><p><strong>总结：</strong></p><p>sort算法非常实用，使用时包含头文件 algorithm即可</p><h3 id="案例-打分"><a href="#案例-打分" class="headerlink" title="案例-打分"></a>案例-打分</h3><p>有5名选手：</p><p>选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 1. 定义选手类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Player</span>(string n, <span class="hljs-type">int</span> s)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;name = n;<br><span class="hljs-keyword">this</span>-&gt;score = s;<br>&#125;<br><br>string name;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-comment">// 2. 创建选手</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createPlayer</span><span class="hljs-params">(vector&lt;Player&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 选手编号</span><br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>string name = <span class="hljs-string">&quot;选手&quot;</span>;<br>name += nameSeed[i];<br><br><span class="hljs-comment">// 分数初始化</span><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><span class="hljs-function">Player <span class="hljs-title">p1</span><span class="hljs-params">(name, score)</span></span>;<br><span class="hljs-comment">// 输入到 vector 容器</span><br>p.<span class="hljs-built_in">push_back</span>(p1);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 3. 评委打分(随机)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setScore</span><span class="hljs-params">(vector&lt;Player&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 player 迭代器</span><br>vector&lt;Player&gt;::iterator itVec;<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> (itVec = p.<span class="hljs-built_in">begin</span>(); itVec != p.<span class="hljs-built_in">end</span>() ; itVec++)<br>&#123;<br><span class="hljs-comment">// 使用 deque 存放分数</span><br>deque&lt;<span class="hljs-type">int</span>&gt; d;<br><span class="hljs-comment">// 遍历并存入 10 位随机数</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-comment">// 60 ~ 100</span><br><span class="hljs-type">int</span> score = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">41</span> + <span class="hljs-number">60</span>;<br><span class="hljs-comment">// 存入 deque</span><br>d.<span class="hljs-built_in">push_back</span>(score);<br>&#125;<br><span class="hljs-comment">// 排序</span><br><span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// 去除最高和最低</span><br>d.<span class="hljs-built_in">pop_back</span>();<br>d.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-comment">// 用于合集所有分数</span><br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 定义 deque 迭代器</span><br>deque&lt;<span class="hljs-type">int</span>&gt;::const_iterator itDeq;<br><span class="hljs-keyword">for</span> (itDeq = d.<span class="hljs-built_in">begin</span>(); itDeq != d.<span class="hljs-built_in">end</span>(); itDeq++)<br>&#123;<br>sum += *itDeq;<br>&#125;<br><span class="hljs-comment">// 求平均分</span><br><span class="hljs-type">int</span> avg = sum / d.<span class="hljs-built_in">size</span>();<br><span class="hljs-comment">// 赋值过去</span><br>itVec-&gt;score = avg;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 展示分数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showScore</span><span class="hljs-params">(vector&lt;Player&gt;&amp; v)</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;Player&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;平均分： &quot;</span> &lt;&lt; it-&gt;score &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 随机数种子</span><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-comment">//1、创建5名选手</span><br>vector&lt;Player&gt;v;  <span class="hljs-comment">//存放选手容器</span><br><br><span class="hljs-comment">// 创建</span><br><span class="hljs-built_in">createPlayer</span>(v);<br><span class="hljs-comment">// 打分</span><br><span class="hljs-built_in">setScore</span>(v);<br><span class="hljs-comment">// 展示</span><br><span class="hljs-built_in">showScore</span>(v);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037075.png" alt="image-20230309165710603"></p><p><strong>总结：</strong> </p><p>选取不同的容器操作数据，可以提升代码的效率</p><h3 id="stack-容器"><a href="#stack-容器" class="headerlink" title="stack 容器"></a>stack 容器</h3><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037605.png" alt="image-20230309165744201"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><h4 id="stack-常用接口"><a href="#stack-常用接口" class="headerlink" title="stack 常用接口"></a>stack 常用接口</h4><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 &#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            &#x2F;&#x2F;拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           &#x2F;&#x2F;重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      &#x2F;&#x2F;向栈顶添加元素</li><li><code>pop();</code>                &#x2F;&#x2F;从栈顶移除第一个元素</li><li><code>top(); </code>                &#x2F;&#x2F;返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li><li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// stack&lt;T&gt; stk</span><br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-comment">// push(elem);</span><br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// empty();</span><br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 输出栈顶元素</span><br>cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 弹出栈顶元素</span><br>s.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037090.png" alt="image-20230309170752288"></p><p><strong>总结：</strong></p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul><h3 id="Queue-容器"><a href="#Queue-容器" class="headerlink" title="Queue 容器"></a>Queue 容器</h3><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037816.png" alt="image-20230309170930111"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><h4 id="queue-常用接口"><a href="#queue-常用接口" class="headerlink" title="queue 常用接口"></a>queue 常用接口</h4><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 &#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            &#x2F;&#x2F;拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           &#x2F;&#x2F;重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             &#x2F;&#x2F;往队尾添加元素</li><li><code>pop();</code>                                      &#x2F;&#x2F;从队头移除第一个元素</li><li><code>back();</code>                                    &#x2F;&#x2F;返回最后一个元素</li><li><code>front(); </code>                                  &#x2F;&#x2F;返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            &#x2F;&#x2F;判断堆栈是否为空</li><li><code>size(); </code>              &#x2F;&#x2F;返回栈的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//创建队列</span><br>queue&lt;Person&gt; q;<br><br><span class="hljs-comment">//准备数据</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;唐僧&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">1000</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;猪八戒&quot;</span>, <span class="hljs-number">900</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;沙僧&quot;</span>, <span class="hljs-number">800</span>)</span></span>;<br><br><span class="hljs-comment">//向队列中添加元素  入队操作</span><br>q.<span class="hljs-built_in">push</span>(p1);<br>q.<span class="hljs-built_in">push</span>(p2);<br>q.<span class="hljs-built_in">push</span>(p3);<br>q.<span class="hljs-built_in">push</span>(p4);<br>cout &lt;&lt; <span class="hljs-string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><br><span class="hljs-comment">//队列不提供迭代器，更不支持随机访问</span><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-comment">//输出队头元素</span><br>cout &lt;&lt; <span class="hljs-string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>().m_Name<br>&lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">front</span>().m_Age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().m_Name<br>&lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="hljs-built_in">back</span>().m_Age &lt;&lt; endl;<br><br>cout &lt;&lt; endl;<br><span class="hljs-comment">//弹出队头元素</span><br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037747.png" alt="image-20230309171037454"></p><p><strong>总结：</strong></p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul><h3 id="List-容器"><a href="#List-容器" class="headerlink" title="List 容器"></a>List 容器</h3><p><strong>功能：</strong></p><p>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037871.png" alt="image-20230315141442071"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p><strong>总结：</strong></p><p>STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 list 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;<span class="hljs-type">int</span>&gt;&amp; l)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义迭代器</span><br>list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it;<br><span class="hljs-keyword">for</span> (it = l.<span class="hljs-built_in">begin</span>(); it != l.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="list-构造函数"><a href="#list-构造函数" class="headerlink" title="list 构造函数"></a>list 构造函数</h4><p><strong>创建list容器</strong></p><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               &#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            &#x2F;&#x2F;拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-7.listPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. list&lt;T&gt; lst;</span><br>list&lt;<span class="hljs-type">int</span>&gt; lint1;<br>lint1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>lint1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>lint1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>lint1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 输出</span><br><span class="hljs-built_in">printList</span>(lint1);<br><br><span class="hljs-comment">// 2. list(beg,end);</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lint2</span><span class="hljs-params">(lint1.begin(), lint1.end())</span></span>;<br><span class="hljs-built_in">printList</span>(lint2);<br><br><span class="hljs-comment">// 3. list(n,elem);</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lint3</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-built_in">printList</span>(lint3);<br><br><span class="hljs-comment">// 4. list(const list &amp;lst);</span><br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lint4</span><span class="hljs-params">(lint3)</span></span>;<br><span class="hljs-built_in">printList</span>(lint4);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011037517.png" alt="image-20230315142543092"></p><h4 id="list-赋值和交换"><a href="#list-赋值和交换" class="headerlink" title="list 赋值和交换"></a>list 赋值和交换</h4><p><strong>给list容器进行赋值，以及交换list容器</strong></p><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         &#x2F;&#x2F;重载等号操作符</li><li><code>swap(lst);</code>                         &#x2F;&#x2F;将lst与本身的元素互换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-7.listPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建 list</span><br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printList</span>(L1);<br><br><span class="hljs-comment">// 1. 赋值</span><br><span class="hljs-comment">// list&amp; operator=(const list &amp;lst);</span><br>list&lt;<span class="hljs-type">int</span>&gt; L2;<br>L2 = L1;<br><span class="hljs-built_in">printList</span>(L2);<br><br><span class="hljs-comment">// assign(beg, end);</span><br>list&lt;<span class="hljs-type">int</span>&gt; L3;<br>L3.<span class="hljs-built_in">assign</span>(L1.<span class="hljs-built_in">begin</span>(), L1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">printList</span>(L3);<br><br><span class="hljs-comment">// assign(n, elem);</span><br>list&lt;<span class="hljs-type">int</span>&gt; L4;<br>L4.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">printList</span>(L4);<br><br><span class="hljs-comment">// 2. 交换</span><br><span class="hljs-comment">// swap(lst);</span><br>list&lt;<span class="hljs-type">int</span>&gt; L5;<br>L5.<span class="hljs-built_in">assign</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前： &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printList</span>(L1);<br><span class="hljs-built_in">printList</span>(L5);<br><br>L1.<span class="hljs-built_in">swap</span>(L5);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后： &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printList</span>(L1);<br><span class="hljs-built_in">printList</span>(L5);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038524.png" alt="image-20230315143233235"></p><h4 id="list-大小操作"><a href="#list-大小操作" class="headerlink" title="list 大小操作"></a>list 大小操作</h4><p><strong>对list容器的大小进行操作</strong></p><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             &#x2F;&#x2F;返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           &#x2F;&#x2F;判断容器是否为空</p></li><li><p><code>resize(num);</code>                   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​    &#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>&#x2F;&#x2F;如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-7.listPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">// 判断空</span><br><span class="hljs-keyword">if</span> (L1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;L1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;L1不为空&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 输出大小</span><br>cout &lt;&lt; <span class="hljs-string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 重新指定大小</span><br>L1.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">printList</span>(L1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038127.png" alt="image-20230315145053044"></p><h4 id="list-插入和删除"><a href="#list-插入和删除" class="headerlink" title="list 插入和删除"></a>list 插入和删除</h4><p><strong>list容器进行数据的插入和删除</strong></p><p><strong>函数原型：</strong></p><ul><li>push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素</li><li>pop_back();&#x2F;&#x2F;删除容器中最后一个元素</li><li>push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素</li><li>pop_front();&#x2F;&#x2F;从容器开头移除第一个元素</li><li>insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();&#x2F;&#x2F;移除容器的所有数据</li><li>erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-7.listPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; L;<br><span class="hljs-comment">// 尾插</span><br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br><span class="hljs-comment">// 头插</span><br>L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">100</span>);<br>L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">200</span>);<br>L.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">300</span>);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">// 尾删</span><br>L.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">// 头删</span><br>L.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">// 插入</span><br>list&lt;<span class="hljs-type">int</span>&gt;::iterator it = L.<span class="hljs-built_in">begin</span>();<br>L.<span class="hljs-built_in">insert</span>(++it, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">// 删除</span><br>it = L.<span class="hljs-built_in">begin</span>();<br>L.<span class="hljs-built_in">erase</span>(++it);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//移除</span><br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">printList</span>(L);<br>L.<span class="hljs-built_in">remove</span>(<span class="hljs-number">10000</span>);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">//清空</span><br>L.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038467.png" alt="image-20230315145810408"></p><h4 id="list-数据存取"><a href="#list-数据存取" class="headerlink" title="list 数据存取"></a>list 数据存取</h4><p><strong>对list容器中数据进行存取</strong></p><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        &#x2F;&#x2F;返回第一个元素。</li><li><code>back();</code>         &#x2F;&#x2F;返回最后一个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-7.listPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt;L1;<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">// cout &lt;&lt; L1.at(0) &lt;&lt; endl;// 错误 不支持at访问数据</span><br><span class="hljs-comment">// cout &lt;&lt; L1[0] &lt;&lt; endl;// 错误  不支持[]方式访问数据</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一个元素为：&quot;</span> &lt;&lt; L1.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;最后一个元素为：&quot;</span> &lt;&lt; L1.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// list容器的迭代器是双向迭代器，不支持随机访问</span><br>list&lt;<span class="hljs-type">int</span>&gt;::const_iterator it = L1.<span class="hljs-built_in">begin</span>();<br>cout &lt;&lt; *it++ &lt;&lt; endl;<br>cout &lt;&lt; *it++ &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038529.png" alt="image-20230315150131445"></p><h4 id="list-反转和排序"><a href="#list-反转和排序" class="headerlink" title="list 反转和排序"></a>list 反转和排序</h4><p><strong>将容器中的元素反转，以及将容器中的数据进行排序</strong></p><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   &#x2F;&#x2F;反转链表</li><li><code>sort();</code>        &#x2F;&#x2F;链表排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-7.listPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CompareList</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> n1 &gt; n2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;<span class="hljs-type">int</span>&gt; L;<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">90</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>L.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">70</span>);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">// 1. 反转</span><br>L.<span class="hljs-built_in">reverse</span>();<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-comment">// 2. 排序</span><br><span class="hljs-comment">// 默认从小到大</span><br>L.<span class="hljs-built_in">sort</span>();<br><span class="hljs-built_in">printList</span>(L);<br><span class="hljs-comment">// 自定义规则：从大到小</span><br>L.<span class="hljs-built_in">sort</span>(CompareList);<br><span class="hljs-built_in">printList</span>(L);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038461.png" alt="image-20230315150501754"></p><h4 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例"></a>排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">PersonClass</span>(string name, <span class="hljs-type">int</span> age, <span class="hljs-type">int</span> height) &#123;<br><span class="hljs-keyword">this</span>-&gt;p_Name = name;<br><span class="hljs-keyword">this</span>-&gt;p_Age = age;<br><span class="hljs-keyword">this</span>-&gt;p_Height = height;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string p_Name;<br><span class="hljs-type">int</span> p_Age;<br><span class="hljs-type">int</span> p_Height;<br>&#125;;<br><br><span class="hljs-comment">// 定义排序方式</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">comparePerson</span><span class="hljs-params">(PersonClass&amp; p1, PersonClass&amp; p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (p1.p_Age == p2.p_Age)<br>&#123;<br><span class="hljs-keyword">return</span> p1.p_Height &gt; p2.p_Height;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> p1.p_Age &gt; p2.p_Age;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历方法重写 - 排序前</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPersonList</span><span class="hljs-params">(<span class="hljs-type">const</span> list&lt;PersonClass&gt;&amp; p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义迭代器</span><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;<br>list&lt;PersonClass&gt;::const_iterator it;<br><span class="hljs-keyword">for</span> (it = p.<span class="hljs-built_in">begin</span>(); it != p.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; it-&gt;p_Name &lt;&lt; <span class="hljs-string">&quot; | &quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; it-&gt;p_Age &lt;&lt; <span class="hljs-string">&quot; | &quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;身高：&quot;</span> &lt;&lt; it-&gt;p_Height &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义以PersonClass的链表</span><br>list&lt;PersonClass&gt; L;<br><span class="hljs-comment">// 创建数据</span><br><span class="hljs-function">PersonClass <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-number">175</span>)</span></span>;<br><span class="hljs-function">PersonClass <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;曹操&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-number">180</span>)</span></span>;<br><span class="hljs-function">PersonClass <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;孙权&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">170</span>)</span></span>;<br><span class="hljs-function">PersonClass <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">190</span>)</span></span>;<br><span class="hljs-function">PersonClass <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-number">160</span>)</span></span>;<br><span class="hljs-function">PersonClass <span class="hljs-title">p6</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-number">200</span>)</span></span>;<br><span class="hljs-comment">// 插入数据</span><br>L.<span class="hljs-built_in">push_back</span>(p1);<br>L.<span class="hljs-built_in">push_back</span>(p2);<br>L.<span class="hljs-built_in">push_back</span>(p3);<br>L.<span class="hljs-built_in">push_back</span>(p4);<br>L.<span class="hljs-built_in">push_back</span>(p5);<br>L.<span class="hljs-built_in">push_back</span>(p6);<br><span class="hljs-comment">// 查看数据</span><br><span class="hljs-built_in">showPersonList</span>(L);<br>L.<span class="hljs-built_in">sort</span>(comparePerson);<br><span class="hljs-built_in">showPersonList</span>(L);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038719.png" alt="image-20230315151749786"></p><h3 id="Set-Multiset-容器"><a href="#Set-Multiset-容器" class="headerlink" title="Set&#x2F;Multiset 容器"></a>Set&#x2F;Multiset 容器</h3><p>所有元素都会在插入时自动被排序</p><p><strong>本质：</strong></p><ul><li>set&#x2F;multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 1. 引入 set 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printSet</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="set-构造和赋值"><a href="#set-构造和赋值" class="headerlink" title="set 构造和赋值"></a>set 构造和赋值</h4><p><strong>创建set容器以及赋值</strong></p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        &#x2F;&#x2F;默认构造函数：</li><li><code>set(const set &amp;st);</code>       &#x2F;&#x2F;拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    &#x2F;&#x2F;重载等号操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-8.setPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. set&lt;T&gt; st</span><br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">// 2. set(const set &amp;st);</span><br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br><span class="hljs-built_in">printSet</span>(s2);<br><br><span class="hljs-comment">// set&amp; operator=(const set &amp;st);</span><br>set&lt;<span class="hljs-type">int</span>&gt;s3;<br>s3 = s2;<br><span class="hljs-built_in">printSet</span>(s3);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038781.png" alt="image-20230315155022608"></p><h4 id="set-大小和交换"><a href="#set-大小和交换" class="headerlink" title="set 大小和交换"></a>set 大小和交换</h4><p><strong>统计set容器大小以及交换set容器</strong></p><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li><li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li><li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-8.setPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-keyword">if</span> (s1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 交换</span><br>set&lt;<span class="hljs-type">int</span>&gt;s2;<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">300</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">200</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">400</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br>s1.<span class="hljs-built_in">swap</span>(s2);<br><span class="hljs-built_in">printSet</span>(s1);<br><span class="hljs-built_in">printSet</span>(s2);<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038446.png" alt="image-20230315160748785"></p><h4 id="set-插入和删除"><a href="#set-插入和删除" class="headerlink" title="set 插入和删除"></a>set 插入和删除</h4><p>set容器进行插入数据和删除数据</p><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li><li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li><li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-8.setPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//插入</span><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//删除</span><br>s1.<span class="hljs-built_in">erase</span>(s1.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printSet</span>(s1);<br><br>s1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-comment">//清空</span><br><span class="hljs-comment">//s1.erase(s1.begin(), s1.end());</span><br>s1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printSet</span>(s1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011038108.png" alt="image-20230315160930987"></p><h4 id="set-查找和统计"><a href="#set-查找和统计" class="headerlink" title="set 查找和统计"></a>set 查找和统计</h4><p>对set容器进行查找数据以及统计数据</p><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-8.setPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//插入</span><br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">// 查找</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator pos = s1.<span class="hljs-built_in">find</span>(<span class="hljs-number">30</span>);<br><span class="hljs-keyword">if</span> (pos != s1.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到元素&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 统计</span><br><span class="hljs-type">int</span> num = s1.<span class="hljs-built_in">count</span>(<span class="hljs-number">30</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039642.png" alt="image-20230315161640686"></p><h4 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h4><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-8.setPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// set </span><br>set&lt;<span class="hljs-type">int</span>&gt; s;<br>pair&lt;set&lt;<span class="hljs-type">int</span>&gt;::iterator, <span class="hljs-type">bool</span>&gt; ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (ret.second)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次插入成功！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>ret = s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (ret.second) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// multiset</span><br>multiset&lt;<span class="hljs-type">int</span>&gt; ms;<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>ms.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br><br>multiset&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = ms.<span class="hljs-built_in">begin</span>(); it != ms.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039898.png" alt="image-20230315162403495"></p><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="pair-对组创建"><a href="#pair-对组创建" class="headerlink" title="pair 对组创建"></a>pair 对组创建</h4><p><strong>成对出现的数据，利用对组可以返回两个数据</strong></p><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. pair&lt;type, type&gt; p ( value1, value2 );</span><br><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(string(<span class="hljs-string">&quot;Tom&quot;</span>), <span class="hljs-number">20</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p1.first &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p1.second &lt;&lt; endl;<br><br><span class="hljs-comment">// 2. pair&lt;type, type&gt; p = make_pair( value1, value2 );</span><br>pair&lt;string, <span class="hljs-type">int</span>&gt; p2 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Jason&quot;</span>, <span class="hljs-number">30</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039723.png" alt="image-20230315163146227"></p><h4 id="set-容器排序"><a href="#set-容器排序" class="headerlink" title="set 容器排序"></a>set 容器排序</h4><p>set容器默认排序规则为从小到大</p><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-8.setPrintFn.h&quot;</span></span><br><br><span class="hljs-comment">// 示例一   set存放内置数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main03_7_6_1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;<span class="hljs-type">int</span>&gt; s1;<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-comment">//默认从小到大</span><br><span class="hljs-keyword">for</span> (it = s1.<span class="hljs-built_in">begin</span>(); it != s1.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//指定排序规则</span><br>set&lt;<span class="hljs-type">int</span>, MyCompare&gt; s2;<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);<br>s2.<span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>);<br>set&lt;<span class="hljs-type">int</span>, MyCompare&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = s2.<span class="hljs-built_in">begin</span>(); it != s2.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 示例二 set存放自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">People</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">comparePerson</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> People&amp; p1, <span class="hljs-type">const</span> People&amp; p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//按照年龄进行排序  降序</span><br><span class="hljs-keyword">return</span> p1.m_Age &gt; p2.m_Age;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;People, comparePerson&gt; s;<br><br><span class="hljs-function">People <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;刘备&quot;</span>, <span class="hljs-number">23</span>)</span></span>;<br><span class="hljs-function">People <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;关羽&quot;</span>, <span class="hljs-number">27</span>)</span></span>;<br><span class="hljs-function">People <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-string">&quot;张飞&quot;</span>, <span class="hljs-number">25</span>)</span></span>;<br><span class="hljs-function">People <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-string">&quot;赵云&quot;</span>, <span class="hljs-number">21</span>)</span></span>;<br><br>s.<span class="hljs-built_in">insert</span>(p1);<br>s.<span class="hljs-built_in">insert</span>(p2);<br>s.<span class="hljs-built_in">insert</span>(p3);<br>s.<span class="hljs-built_in">insert</span>(p4);<br>set&lt;People, comparePerson&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="map-multimap-容器"><a href="#map-multimap-容器" class="headerlink" title="map&#x2F;multimap 容器"></a>map&#x2F;multimap 容器</h3><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map&#x2F;multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map 和 multimap <strong>区别</strong>：</p><ul><li>map 不允许容器中有重复key值元素</li><li>multimap 允许容器中有重复key值元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMap</span><span class="hljs-params">(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义迭代器</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="map-构造和赋值"><a href="#map-构造和赋值" class="headerlink" title="map 构造和赋值"></a>map 构造和赋值</h4><p>对map容器进行构造和赋值操作</p><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     &#x2F;&#x2F;map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             &#x2F;&#x2F;拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    &#x2F;&#x2F;重载等号操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-9.mapPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 构造</span><br><span class="hljs-comment">// map&lt;T1, T2&gt; mp;</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br><span class="hljs-comment">// 添加</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><span class="hljs-comment">// 输出</span><br><span class="hljs-built_in">printMap</span>(m);<br><br><span class="hljs-comment">// map(const map &amp;mp);</span><br><span class="hljs-function">map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">m2</span><span class="hljs-params">(m)</span></span>;<br><span class="hljs-built_in">printMap</span>(m2);<br><br><span class="hljs-comment">// 2. 赋值</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m3;<br>m3 = m2;<br><span class="hljs-built_in">printMap</span>(m3);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039296.png" alt="image-20230317153538705"></p><p><strong>总结：</strong></p><p>map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="map-大小和交换"><a href="#map-大小和交换" class="headerlink" title="map 大小和交换"></a>map 大小和交换</h4><p>统计map容器大小以及交换map容器</p><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          &#x2F;&#x2F;返回容器中元素的数目</li><li><code>empty();</code>        &#x2F;&#x2F;判断容器是否为空</li><li><code>swap(st);</code>      &#x2F;&#x2F;交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-9.mapPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br><span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;m为空&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;m不为空&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m1;<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m2;<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">4</span>, <span class="hljs-number">100</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">200</span>));<br>m2.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">6</span>, <span class="hljs-number">300</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">printMap</span>(m1);<br><span class="hljs-built_in">printMap</span>(m2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后&quot;</span> &lt;&lt; endl;<br>m1.<span class="hljs-built_in">swap</span>(m2);<br><span class="hljs-built_in">printMap</span>(m1);<br><span class="hljs-built_in">printMap</span>(m2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039238.png" alt="image-20230317154344424"></p><h4 id="map-插入和删除"><a href="#map-插入和删除" class="headerlink" title="map 插入和删除"></a>map 插入和删除</h4><p><strong>map容器进行插入数据和删除数据</strong></p><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           &#x2F;&#x2F;在容器中插入元素。</li><li><code>clear();</code>                    &#x2F;&#x2F;清除所有元素</li><li><code>erase(pos);</code>              &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    &#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            &#x2F;&#x2F;删除容器中值为key的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-9.mapPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//插入</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br><span class="hljs-comment">//第一种插入方式</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br><span class="hljs-comment">//第二种插入方式</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br><span class="hljs-comment">//第三种插入方式</span><br>m.<span class="hljs-built_in">insert</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">value_type</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><span class="hljs-comment">//第四种插入方式</span><br>m[<span class="hljs-number">4</span>] = <span class="hljs-number">40</span>;<br><span class="hljs-built_in">printMap</span>(m);<br><br><span class="hljs-comment">//删除</span><br>m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>());<br><span class="hljs-built_in">printMap</span>(m);<br><br>m.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">printMap</span>(m);<br><br><span class="hljs-comment">//清空</span><br>m.<span class="hljs-built_in">erase</span>(m.<span class="hljs-built_in">begin</span>(), m.<span class="hljs-built_in">end</span>());<br>m.<span class="hljs-built_in">clear</span>();<br><span class="hljs-built_in">printMap</span>(m);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039529.png" alt="image-20230317154727090"></p><h4 id="map-查找和统计"><a href="#map-查找和统计" class="headerlink" title="map 查找和统计"></a>map 查找和统计</h4><p><strong>对map容器进行查找数据以及统计数据</strong></p><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  &#x2F;&#x2F;查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                &#x2F;&#x2F;统计key的元素个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;03-3-9.mapPrintFn.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;m;<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br><br><span class="hljs-comment">//查找</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">if</span> (pos != m.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="hljs-string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到元素&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//统计</span><br><span class="hljs-type">int</span> num = m.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039069.png" alt="image-20230317155108122"></p><h4 id="map-排序容器"><a href="#map-排序容器" class="headerlink" title="map 排序容器"></a>map 排序容器</h4><p>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</p><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//默认从小到大排序</span><br><span class="hljs-comment">//利用仿函数实现从大到小排序</span><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt; m;<br><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>, <span class="hljs-number">40</span>));<br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">5</span>, <span class="hljs-number">50</span>));<br><br><span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, MyCompare&gt;::iterator it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="案例-员工分组"><a href="#案例-员工分组" class="headerlink" title="案例 - 员工分组"></a>案例 - 员工分组</h3><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义部门ID</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CEHUA  0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEISHU 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> YANFA  2</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span><br><span class="hljs-comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span><br><span class="hljs-comment">- 随机给10名员工分配部门和工资</span><br><span class="hljs-comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span><br><span class="hljs-comment">- 分部门显示员工信息</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 定义员工类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>string w_name;<br><span class="hljs-type">int</span> w_salary;<br>&#125;;<br><br><span class="hljs-comment">// 创建员工函数，通过 vector 保存员工</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createWorker</span><span class="hljs-params">(vector&lt;Worker&gt;&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>string nameStr = <span class="hljs-string">&quot;ABCDEFGHIJ&quot;</span>;<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>Worker worker;<br>worker.w_name = <span class="hljs-string">&quot;员工&quot;</span>;<br>worker.w_name += nameStr[i];<br>worker.w_salary = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10000</span> + <span class="hljs-number">10000</span>; <span class="hljs-comment">// 10000 ~ 19999</span><br><br><span class="hljs-comment">// 将数据放入到 vector 容器中</span><br>w.<span class="hljs-built_in">push_back</span>(worker);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 员工分类函数通过 map 进行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setGroup</span><span class="hljs-params">(vector&lt;Worker&gt;&amp; v, multimap&lt;<span class="hljs-type">int</span>, Worker&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义迭代器</span><br>vector&lt;Worker&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-comment">//产生随机部门编号</span><br><span class="hljs-type">int</span> deptId = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>; <span class="hljs-comment">// 0 1 2 </span><br><span class="hljs-comment">// 员工分配编号</span><br>m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(deptId, *it));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 分类展示</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showGroup</span><span class="hljs-params">(multimap&lt;<span class="hljs-type">int</span>, Worker&gt;&amp; m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 0  A  B  C   1  D  E   2  F G ...</span><br>cout &lt;&lt; <span class="hljs-string">&quot;策划部门：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// find 函数查找</span><br>multimap&lt;<span class="hljs-type">int</span>, Worker&gt;::iterator pos = m.<span class="hljs-built_in">find</span>(CEHUA);<br><span class="hljs-type">int</span> count = m.<span class="hljs-built_in">count</span>(CEHUA);<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.w_name &lt;&lt; <span class="hljs-string">&quot; | &quot;</span> &lt;&lt; <span class="hljs-string">&quot;薪水：&quot;</span> &lt;&lt; pos-&gt;second.w_salary &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;美术部门：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// find 函数查找</span><br>pos = m.<span class="hljs-built_in">find</span>(MEISHU);<br>count = m.<span class="hljs-built_in">count</span>(MEISHU);<br>index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.w_name &lt;&lt; <span class="hljs-string">&quot; | &quot;</span> &lt;&lt; <span class="hljs-string">&quot;薪水：&quot;</span> &lt;&lt; pos-&gt;second.w_salary &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;研发部门：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// find 函数查找</span><br>pos = m.<span class="hljs-built_in">find</span>(YANFA);<br>count = m.<span class="hljs-built_in">count</span>(YANFA);<br>index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; pos != m.<span class="hljs-built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; pos-&gt;second.w_name &lt;&lt; <span class="hljs-string">&quot; | &quot;</span> &lt;&lt; <span class="hljs-string">&quot;薪水：&quot;</span> &lt;&lt; pos-&gt;second.w_salary &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-comment">// 创建员工</span><br>vector&lt;Worker&gt; worker;<br><span class="hljs-built_in">createWorker</span>(worker);<br><br><span class="hljs-comment">// 岗位分类</span><br>multimap&lt;<span class="hljs-type">int</span>, Worker&gt; deptId;<br><span class="hljs-built_in">setGroup</span>(worker, deptId);<br><br><span class="hljs-comment">// 展示分组</span><br><span class="hljs-built_in">showGroup</span>(deptId);<br><br><span class="hljs-comment">// 测试创建</span><br><span class="hljs-comment">//vector&lt;Worker&gt;::iterator it;</span><br><span class="hljs-comment">//for (it = worker.begin(); it != worker.end(); it++)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; it-&gt;w_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;w_salary &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039177.png" alt="image-20230320172300255"></p><h2 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL - 函数对象"></a>STL - 函数对象</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义仿函数</span><br><span class="hljs-comment">// 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTwoNum</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 重构 ()</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val1, <span class="hljs-type">int</span> val2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val1 + val2;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 函数对象可以有自己的状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">printStr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> count; <span class="hljs-comment">//内部自己的状态</span><br><span class="hljs-built_in">printStr</span>()<br>&#123;<br>count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; test &lt;&lt; endl;<br>count++;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 函数对象可以作为参数传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPrint</span><span class="hljs-params">(printStr&amp; ps, string test)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ps</span>(test);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>AddTwoNum atm;<br>cout &lt;&lt; <span class="hljs-string">&quot;两数之和：&quot;</span> &lt;&lt; <span class="hljs-built_in">atm</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br>printStr str1;<br><span class="hljs-built_in">str1</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">str1</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-built_in">str1</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;printStr 调用次数为： &quot;</span> &lt;&lt; str1.count &lt;&lt; endl;<br><br>printStr str2;<br><span class="hljs-built_in">doPrint</span>(str2, <span class="hljs-string">&quot;Hello, C++!!!&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义一元谓词</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二元谓词"><a href="#二元谓词" class="headerlink" title="二元谓词"></a>二元谓词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义仿函数：二元谓词</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareSort</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>  b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br><br><span class="hljs-comment">// 默认从小到大</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 修改方法</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">CompareSort</span>());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039966.png" alt="image-20230321161051277"></p><h3 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h3><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="算数仿函数"><a href="#算数仿函数" class="headerlink" title="算数仿函数"></a>算数仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                &#x2F;&#x2F;加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              &#x2F;&#x2F;减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    &#x2F;&#x2F;乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         &#x2F;&#x2F;除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         &#x2F;&#x2F;取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           &#x2F;&#x2F;取反仿函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// negate 取反</span><br>negate&lt;<span class="hljs-type">int</span>&gt; n;<br>cout &lt;&lt; <span class="hljs-built_in">n</span>(<span class="hljs-number">29</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// plus 加法</span><br>plus&lt;<span class="hljs-type">int</span>&gt; p;<br>cout &lt;&lt; <span class="hljs-built_in">p</span>(<span class="hljs-number">29</span>, <span class="hljs-number">31</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// minus 减法</span><br>minus&lt;<span class="hljs-type">int</span>&gt; mi;<br>cout &lt;&lt; <span class="hljs-built_in">mi</span>(<span class="hljs-number">29</span>, <span class="hljs-number">19</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// multiplies 乘法</span><br>multiplies&lt;<span class="hljs-type">int</span>&gt; mul;<br>cout &lt;&lt; <span class="hljs-built_in">mul</span>(<span class="hljs-number">29</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// divides 除法</span><br>divides&lt;<span class="hljs-type">int</span>&gt; d;<br>cout &lt;&lt; <span class="hljs-built_in">d</span>(<span class="hljs-number">21</span>,<span class="hljs-number">7</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// modulus 取模</span><br>modulus&lt;<span class="hljs-type">int</span>&gt; mod;<br>cout &lt;&lt; <span class="hljs-built_in">mod</span>(<span class="hljs-number">29</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039846.png" alt="image-20230321162217446"></p><h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    &#x2F;&#x2F;等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            &#x2F;&#x2F;不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      &#x2F;&#x2F;大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          &#x2F;&#x2F;大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           &#x2F;&#x2F;小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               &#x2F;&#x2F;小于等于</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//自己实现仿函数</span><br><span class="hljs-comment">//sort(v.begin(), v.end(), MyCompare());</span><br><span class="hljs-comment">//STL内建仿函数  大于仿函数</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++) &#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011039556.png" alt="image-20230321162338538"></p><h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              &#x2F;&#x2F;逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                &#x2F;&#x2F;逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              &#x2F;&#x2F;逻辑非</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>vector&lt;<span class="hljs-type">bool</span>&gt; v;<br><br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">true</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span><br>vector&lt;<span class="hljs-type">bool</span>&gt; v2;<br>v2.<span class="hljs-built_in">resize</span>(v.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">transform</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">logical_not</span>&lt;<span class="hljs-type">bool</span>&gt;());<br><span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">bool</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it != v2.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040509.png" alt="image-20230321162511853"></p><h2 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL - 常用算法"></a>STL - 常用算法</h2><p><strong>概述</strong>:</p><ul><li><p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p></li><li><p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li><li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li><li><p><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</p></li></ul><h3 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h3><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     &#x2F;&#x2F;遍历容器</li><li><code>transform</code>   &#x2F;&#x2F;搬运容器到另一个容器中</li></ul><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>&#x2F;&#x2F; 遍历算法 遍历容器元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _func 函数或者函数对象</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义输出函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forEachPrint</span><span class="hljs-params">(T val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义仿函数输出方式</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ForEachPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector 容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vi.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 遍历 1</span><br>for_each(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), forEachPrint&lt;<span class="hljs-type">int</span>&gt;);<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 遍历 2</span><br>for_each(vi.<span class="hljs-built_in">begin</span>(), vi.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ForEachPrint</span>&lt;<span class="hljs-type">int</span>&gt;());<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040567.png" alt="image-20230324142138704"></p><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></p><p>&#x2F;&#x2F; beg1 源容器开始迭代器</p><p>&#x2F;&#x2F;end1 源容器结束迭代器</p><p>&#x2F;&#x2F;beg2 目标容器开始迭代器</p><p>&#x2F;&#x2F;_func 函数或者函数对象</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 转移</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransForm</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">T <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义仿函数输出方式</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector 容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vi1;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vi1.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 定义转移容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vi2;<br>vi2.<span class="hljs-built_in">resize</span>(vi1.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-comment">// 使用转移算法</span><br><span class="hljs-built_in">transform</span>(vi1.<span class="hljs-built_in">begin</span>(), vi1.<span class="hljs-built_in">end</span>(), vi2.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">TransForm</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br><span class="hljs-comment">// 遍历 vi2</span><br>for_each(vi2.<span class="hljs-built_in">begin</span>(), vi2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">TransformPrint</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040822.png" alt="image-20230324142957286"></p><h3 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h3><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     &#x2F;&#x2F;查找元素</li><li><code>find_if</code>               &#x2F;&#x2F;按条件查找元素</li><li><code>adjacent_find</code>    &#x2F;&#x2F;查找相邻重复元素</li><li><code>binary_search</code>    &#x2F;&#x2F;二分查找法</li><li><code>count</code>                   &#x2F;&#x2F;统计元素个数</li><li><code>count_if</code>             &#x2F;&#x2F;按条件统计元素个数</li></ul><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 查找的元素</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义数据查找</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FindData</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FindData</span>(<span class="hljs-type">int</span> id)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;F_id = id;<br>&#125;<br><br><span class="hljs-comment">// 重构 ==</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> FindData&amp; f)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;F_id == f.F_id)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> F_id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义类组</span><br><span class="hljs-function">FindData <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">FindData <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">FindData <span class="hljs-title">f3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">FindData <span class="hljs-title">f4</span><span class="hljs-params">(<span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">FindData <span class="hljs-title">f5</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br><br><span class="hljs-comment">// 放入 vector 容器</span><br>vector&lt;FindData&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(f1);<br>v.<span class="hljs-built_in">push_back</span>(f2);<br>v.<span class="hljs-built_in">push_back</span>(f3);<br>v.<span class="hljs-built_in">push_back</span>(f4);<br>v.<span class="hljs-built_in">push_back</span>(f5);<br><br><span class="hljs-comment">// 查找</span><br>vector&lt;FindData&gt;::iterator it = <span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), f3);<br><span class="hljs-keyword">if</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了，ID为：&quot;</span> &lt;&lt; it-&gt;F_id &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040454.png" alt="image-20230324144515369"></p><h4 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a>find_if</h4><p>功能描述：**</p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//内置数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreaterFive</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt; <span class="hljs-number">5</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">GreaterFive</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;没有找到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040313.png" alt="image-20230324144753389"></p><h4 id="adjacent-find"><a href="#adjacent-find" class="headerlink" title="adjacent_find"></a>adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>&#x2F;&#x2F; 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//查找相邻重复元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">adjacent_find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">if</span> (it == v.<span class="hljs-built_in">end</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找不到!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040307.png" alt="image-20230324145526289"></p><h4 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>&#x2F;&#x2F; 查找指定的元素，查到 返回true  否则false</p><p>&#x2F;&#x2F; 注意: 在<strong>无序序列中不可用</strong></p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 查找的元素</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 二分查找</span><br><span class="hljs-type">bool</span> result = <span class="hljs-built_in">binary_search</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br><br><span class="hljs-keyword">if</span> (result)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;找到了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未找到&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040168.png" alt="image-20230324150002018"></p><p><strong>总结：</strong></p><p>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>&#x2F;&#x2F; 统计元素出现次数</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 统计的元素</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 自定义数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CountData</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CountData</span>(<span class="hljs-type">int</span> val)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;id = val;<br>&#125;<br><br><span class="hljs-comment">// 重构 == </span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> CountData&amp; c)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;id == c.id)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">int</span> id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;<br><br>vector&lt;CountData&gt; v2;<br><span class="hljs-comment">// 创建类数据</span><br><span class="hljs-function">CountData <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c4</span><span class="hljs-params">(<span class="hljs-number">40</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c5</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c6</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c7</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">CountData <span class="hljs-title">c8</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-comment">// 放入 容器</span><br>v2.<span class="hljs-built_in">push_back</span>(c1);<br>v2.<span class="hljs-built_in">push_back</span>(c2);<br>v2.<span class="hljs-built_in">push_back</span>(c3);<br>v2.<span class="hljs-built_in">push_back</span>(c4);<br>v2.<span class="hljs-built_in">push_back</span>(c5);<br>v2.<span class="hljs-built_in">push_back</span>(c6);<br>v2.<span class="hljs-built_in">push_back</span>(c7);<br>v2.<span class="hljs-built_in">push_back</span>(c8);<br><br><span class="hljs-function">CountData <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-type">int</span> countNum = <span class="hljs-built_in">count</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), c);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; countNum &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040294.png" alt="image-20230324150841999"></p><h4 id="count-if"><a href="#count-if" class="headerlink" title="count_if"></a>count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>&#x2F;&#x2F; 按条件统计元素出现次数</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _Pred 谓词</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greater4</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">4</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-type">int</span> num = <span class="hljs-built_in">count_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">Greater4</span>());<br><br>cout &lt;&lt; <span class="hljs-string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040783.png" alt="image-20230324150958367"></p><h3 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             &#x2F;&#x2F;对容器内元素进行排序</li><li><code>random_shuffle</code>   &#x2F;&#x2F;洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           &#x2F;&#x2F; 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       &#x2F;&#x2F; 反转指定范围的元素</li></ul><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F;  beg    开始迭代器</p><p>&#x2F;&#x2F;  end    结束迭代器</p><p>&#x2F;&#x2F; _Pred  谓词</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortPrint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br><span class="hljs-comment">//sort默认从小到大排序</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), sortPrint);<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//从大到小排序</span><br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), sortPrint);<br>cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040735.png" alt="image-20230324153738894"></p><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>&#x2F;&#x2F; 指定范围内的元素随机调整次序</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">RandomPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//打乱顺序</span><br><span class="hljs-built_in">random_shuffle</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">RandomPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040888.png" alt="image-20230324154321065"></p><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>&#x2F;&#x2F; 容器元素合并，并存储到另一容器中</p><p>&#x2F;&#x2F; 注意: 两个容器必须是<strong>有序的</strong></p><p>&#x2F;&#x2F; beg1   容器1开始迭代器<br>&#x2F;&#x2F; end1   容器1结束迭代器<br>&#x2F;&#x2F; beg2   容器2开始迭代器<br>&#x2F;&#x2F; end2   容器2结束迭代器<br>&#x2F;&#x2F; dest    目标容器开始迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MergePrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vtarget;<br><span class="hljs-comment">//目标容器需要提前开辟空间</span><br>vtarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());<br><span class="hljs-comment">//合并  需要两个有序序列</span><br><span class="hljs-built_in">merge</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vtarget.<span class="hljs-built_in">begin</span>());<br>for_each(vtarget.<span class="hljs-built_in">begin</span>(), vtarget.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">MergePrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040498.png" alt="image-20230324154555678"></p><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>&#x2F;&#x2F; 反转指定范围的元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReversePrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;反转前： &quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ReversePrint</span>());<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;反转后： &quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ReversePrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011040006.png" alt="image-20230324154947225"></p><h3 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h3><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      &#x2F;&#x2F; 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                &#x2F;&#x2F; 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          &#x2F;&#x2F; 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     &#x2F;&#x2F; 互换两个容器的元素</li></ul><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>&#x2F;&#x2F; 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>&#x2F;&#x2F; beg  开始迭代器</p><p>&#x2F;&#x2F; end  结束迭代器</p><p>&#x2F;&#x2F; dest 目标起始迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyPrint</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>v2.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>());<br><span class="hljs-built_in">copy</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>());<br><br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">CopyPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011041739.png" alt="image-20230324160826822"></p><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>&#x2F;&#x2F; 将区间内旧元素 替换成 新元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; oldvalue 旧元素</p><p>&#x2F;&#x2F; newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换前：&quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//将容器中的20 替换成 2000</span><br>cout &lt;&lt; <span class="hljs-string">&quot;替换后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">replace</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">20</span>,<span class="hljs-number">2000</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="replace-if"><a href="#replace-if" class="headerlink" title="replace_if"></a>replace_if</h4><p><strong>功能描述:</strong>  </p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>&#x2F;&#x2F; 按条件替换元素，满足条件的替换成指定元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; _pred 谓词</p><p>&#x2F;&#x2F; newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplaceGreater30</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> val &gt;= <span class="hljs-number">30</span>;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">30</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">40</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">50</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;替换前：&quot;</span> &lt;&lt; endl;<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//将容器中大于等于的30 替换成 3000</span><br>cout &lt;&lt; <span class="hljs-string">&quot;替换后：&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">ReplaceGreater30</span>(), <span class="hljs-number">3000</span>);<br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>&#x2F;&#x2F; 互换两个容器的元素</p><p>&#x2F;&#x2F; c1容器1</p><p>&#x2F;&#x2F; c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">100</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换前： &quot;</span> &lt;&lt; endl;<br>for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后： &quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">swap</span>(v1, v2);<br>for_each(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>for_each(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><h3 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h3><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      &#x2F;&#x2F; 计算容器元素累计总和</p></li><li><p><code>fill</code>                 &#x2F;&#x2F; 向容器中添加元素</p></li></ul><h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>&#x2F;&#x2F; 计算容器元素累计总和</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-type">int</span> total = <span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>&#x2F;&#x2F; 向容器中填充元素</p><p>&#x2F;&#x2F; beg 开始迭代器</p><p>&#x2F;&#x2F; end 结束迭代器</p><p>&#x2F;&#x2F; value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">//填充</span><br><span class="hljs-built_in">fill</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">100</span>);<br><br>for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h3><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          &#x2F;&#x2F; 求两个容器的交集</p></li><li><p><code>set_union</code>                       &#x2F;&#x2F; 求两个容器的并集</p></li><li><p><code>set_difference </code>              &#x2F;&#x2F; 求两个容器的差集</p></li></ul><h4 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>&#x2F;&#x2F; 求两个集合的交集</p><p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p><p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vTarget;<br><span class="hljs-comment">//取两个里面较小的值给目标容器开辟空间</span><br>vTarget.<span class="hljs-built_in">resize</span>(<span class="hljs-built_in">min</span>(v1.<span class="hljs-built_in">size</span>(), v2.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <br>        <span class="hljs-built_in">set_intersection</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>&#x2F;&#x2F; 求两个集合的并集</p><p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p><p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vTarget;<br><span class="hljs-comment">//取两个容器的和给目标容器开辟空间</span><br>vTarget.<span class="hljs-built_in">resize</span>(v1.<span class="hljs-built_in">size</span>() + v2.<span class="hljs-built_in">size</span>());<br><br><span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <br>        <span class="hljs-built_in">set_union</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br><br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>&#x2F;&#x2F; 求两个集合的差集</p><p>&#x2F;&#x2F; <strong>注意:两个集合必须是有序序列</strong></p><p>&#x2F;&#x2F; beg1 容器1开始迭代器<br>&#x2F;&#x2F; end1 容器1结束迭代器<br>&#x2F;&#x2F; beg2 容器2开始迭代器<br>&#x2F;&#x2F; end2 容器2结束迭代器<br>&#x2F;&#x2F; dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br>vector&lt;<span class="hljs-type">int</span>&gt; v2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>v1.<span class="hljs-built_in">push_back</span>(i);<br>v2.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">5</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vTarget;<br><span class="hljs-comment">//取两个里面较大的值给目标容器开辟空间</span><br>vTarget.<span class="hljs-built_in">resize</span>( <span class="hljs-built_in">max</span>(v1.<span class="hljs-built_in">size</span>() , v2.<span class="hljs-built_in">size</span>()));<br><br><span class="hljs-comment">//返回目标容器的最后一个元素的迭代器地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator itEnd = <br>        <span class="hljs-built_in">set_difference</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;<br>itEnd = <span class="hljs-built_in">set_difference</span>(v2.<span class="hljs-built_in">begin</span>(), v2.<span class="hljs-built_in">end</span>(), v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), vTarget.<span class="hljs-built_in">begin</span>());<br>for_each(vTarget.<span class="hljs-built_in">begin</span>(), itEnd, <span class="hljs-built_in">myPrint</span>());<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00-2.C++ 核心编程</title>
    <link href="/2023/09/01/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00-2.C++%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/09/01/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00-2.C++%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><ol><li>内存分区模型</li><li>引用</li><li>函数提高</li><li>类和对象</li><li>文件操作</li></ol></blockquote><h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011027836.jpeg" alt="C++内存分区模型_Julian_cather的博客-CSDN博客"></p><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>​在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​<strong>代码区：</strong></p><p>​存放 CPU 执行的机器指令</p><p>​代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​<strong>全局区：</strong></p><p>​全局变量和静态变量存放在此.</p><p>​全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//全局常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//局部变量</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//打印地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;g_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;g_b &lt;&lt; endl;<br><br><span class="hljs-comment">//静态变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_b = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world1&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_b &lt;&lt; endl;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_b = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011027119.png" alt="image-20221205094540332"></p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p><strong>栈区：</strong></p><p>​由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 局部变量存放在栈区，函数执行完会释放</span><br><span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span>* p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 编译器进行了保留会输出正确值</span><br>cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 指向了野指针位置</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011027085.png" alt="image-20221205095525929"></p><p><strong>堆区：</strong></p><p>​由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​在C++中主要利用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span>* p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028682.png" alt="image-20221205100035659"></p><p><strong>总结：</strong></p><ul><li>堆区数据由程序员管理开辟和释放</li><li>堆区数据利用new关键字进行开辟内存</li></ul><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;</p><p>语法：<code> new 数据类型</code></p><p>利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>基本使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-built_in">func3</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-comment">//利用delete释放堆区数据</span><br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028061.png" alt="image-20221205101239821"></p><p><strong>开辟数组：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// new 开辟int指针数组</span><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>arr[i] = i + <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 清除 new</span><br><span class="hljs-keyword">delete</span>[] arr;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028056.png" alt="image-20221205101525672"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>b = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028079.png" alt="image-20221206093835332"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//int &amp;c; //错误，引用必须初始化</span><br><span class="hljs-type">int</span> &amp;c = a; <span class="hljs-comment">//一旦初始化后，就不可以更改</span><br>c = b; <span class="hljs-comment">//这是赋值操作，不是更改引用</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="做函数参数"><a href="#做函数参数" class="headerlink" title="做函数参数"></a>做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//1. 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">//2. 地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = *a;<br>*a = *b;<br>*b = temp;<br>&#125;<br><br><span class="hljs-comment">//3. 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-built_in">mySwap01</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">mySwap02</span>(&amp;a, &amp;b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">mySwap03</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p><h3 id="做函数返回值"><a href="#做函数返回值" class="headerlink" title="做函数返回值"></a>做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//返回局部变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//局部变量</span><br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">//返回静态变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//不能返回局部变量的引用</span><br><span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">//如果函数做左值，那么必须返回引用</span><br><span class="hljs-type">int</span>&amp; ref2 = <span class="hljs-built_in">test02</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br><span class="hljs-built_in">test02</span>() = <span class="hljs-number">1000</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; ref)</span></span>&#123;<br>ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span><br><span class="hljs-type">int</span>&amp; ref = a; <br>ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span><br>    <br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>    <br><span class="hljs-built_in">func</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//引用使用的场景，通常用来修饰形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v)</span> </span>&#123;<br><span class="hljs-comment">//v += 10;</span><br>cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="hljs-comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//ref = 100;  //加入const后不可以修改变量</span><br>cout &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">//函数中利用常量引用防止误操作修改实参</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">showValue</span>(a);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><br><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><br><span class="hljs-comment">//int func(double a, int b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">func</span>();<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数重载注意事项</span><br><span class="hljs-comment">//1、引用作为重载条件</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//2、函数重载碰到函数默认参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//调用无const</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用有const</span><br><br><br><span class="hljs-comment">//func2(10); //碰到默认参数产生歧义，需要避免</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;</p><p>人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//圆周率</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-comment">//1、封装的意义</span><br><span class="hljs-comment">//将属性和行为作为一个整体，用来表现生活中的事物</span><br><br><span class="hljs-comment">//封装一个圆类，求圆的周长</span><br><span class="hljs-comment">//class代表设计一个类，后面跟着的是类名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//访问权限  公共的权限</span><br><br><span class="hljs-comment">//属性</span><br><span class="hljs-type">int</span> m_r;<span class="hljs-comment">//半径</span><br><br><span class="hljs-comment">//行为</span><br><span class="hljs-comment">//获取到圆的周长</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//2 * pi  * r</span><br><span class="hljs-comment">//获取圆的周长</span><br><span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * m_r;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//通过圆类，创建圆的对象</span><br><span class="hljs-comment">// c1就是一个具体的圆</span><br>Circle c1;<br>c1.m_r = <span class="hljs-number">10</span>; <span class="hljs-comment">//给圆对象的半径 进行赋值操作</span><br><br><span class="hljs-comment">//2 * pi * 10 = = 62.8</span><br>cout &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="hljs-built_in">calculateZC</span>() &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028727.png" alt="image-20221208104958937"></p><p><strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 属性</span><br>string stu_name;  <span class="hljs-comment">// 学生姓名</span><br><span class="hljs-type">int</span> ID;  <span class="hljs-comment">// 学生ID</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 方法</span><br><span class="hljs-comment">// 赋值姓名</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span></span><br><span class="hljs-function"></span>&#123;<br>stu_name = name;<br>&#125;<br><span class="hljs-comment">// 赋值ID</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>ID = id;<br>&#125;<br><span class="hljs-comment">// 展示</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showStu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名: &quot;</span> &lt;&lt; stu_name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ID:  &quot;</span> &lt;&lt; ID &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student s1;<br>s1.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;Jason&quot;</span>);<br>s1.<span class="hljs-built_in">setID</span>(<span class="hljs-number">114514</span>);<br>s1.<span class="hljs-built_in">showStu</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028327.png" alt="image-20221212091549716"></p><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//三种权限</span><br><span class="hljs-comment">//公共权限  public     类内可以访问  类外可以访问</span><br><span class="hljs-comment">//保护权限  protected  类内可以访问  类外不可以访问</span><br><span class="hljs-comment">//私有权限  private    类内可以访问  类外不可以访问</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-comment">//姓名  公共权限</span><br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><br><span class="hljs-comment">//汽车  保护权限</span><br><span class="hljs-keyword">protected</span>:<br>string m_Car;<br><br><span class="hljs-comment">//银行卡密码  私有权限</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_Password;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_Name = <span class="hljs-string">&quot;张三&quot;</span>;<br>m_Car = <span class="hljs-string">&quot;拖拉机&quot;</span>;<br>m_Password = <span class="hljs-number">123456</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Person p;<br>p.m_Name = <span class="hljs-string">&quot;李四&quot;</span>;<br><span class="hljs-comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span><br><span class="hljs-comment">//p.m_Password = 123; //私有权限类外访问不到</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028663.png" alt="image-20221212093431105"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028163.png" alt="image-20221212093439523"></p><h4 id="struct-和-class-区别"><a href="#struct-和-class-区别" class="headerlink" title="struct 和 class 区别"></a><code>struct</code> 和 <code>class</code> 区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// struct 默认为公共权限</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S1</span><br>&#123;<br><span class="hljs-type">int</span>  m_A; <span class="hljs-comment">// 默认是公共权限</span><br>&#125;;<br><span class="hljs-comment">// class 默认为私有权限</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span><br>&#123;<br><span class="hljs-type">int</span> m_A;  <span class="hljs-comment">// 默认是私有权限</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>C1 c1;<br><span class="hljs-comment">//c1.m_A = 10; //错误，访问权限是私有</span><br><br>S1 s1;<br>s1.m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//正确，访问权限是公共</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011028150.png" alt="image-20221212093719785"></p><h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 姓名设置可读可写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>m_Name = name;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Name;<br>&#125;<br><br><span class="hljs-comment">// 设置年龄并获取年龄 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>&#123;<br>m_Age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> m_Age;<br>&#125;<br><br><span class="hljs-comment">// 情人设置为只写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLover</span><span class="hljs-params">(string lover)</span> </span>&#123;<br>m_Lover = lover;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string m_Name;<span class="hljs-comment">// 可读可写  姓名</span><br><span class="hljs-type">int</span> m_Age;<span class="hljs-comment">// 只读  年龄</span><br>string m_Lover; <span class="hljs-comment">// 只写  情人</span><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Person p;<br><span class="hljs-comment">// 姓名设置</span><br>p.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;Su&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// 年龄设置</span><br>p.<span class="hljs-built_in">setAge</span>(<span class="hljs-number">23</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">// 情人设置</span><br>p.<span class="hljs-built_in">setLover</span>(<span class="hljs-string">&quot;风见幽香&quot;</span>);<br><span class="hljs-comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029053.png" alt="image-20221212100922456"></p><h4 id="案例一：求立方体"><a href="#案例一：求立方体" class="headerlink" title="案例一：求立方体"></a>案例一：求立方体</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029568.png" alt="image-20221213095418225"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cube</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 设置长并获取长</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLong</span><span class="hljs-params">(<span class="hljs-type">int</span> inputLong)</span></span><br><span class="hljs-function"></span>&#123;<br>Long = inputLong;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLong</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Long;<br>&#125;<br><span class="hljs-comment">// 设置宽并获取宽</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> inputWidth)</span></span><br><span class="hljs-function"></span>&#123;<br>Width = inputWidth;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Width;<br>&#125;<br><span class="hljs-comment">// 设置高并获取高</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> inputHeight)</span></span><br><span class="hljs-function"></span>&#123;<br>Height = inputHeight;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Height;<br>&#125;<br><span class="hljs-comment">// 获取面积和体积</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Acreage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Long == <span class="hljs-literal">NULL</span> || Width == <span class="hljs-literal">NULL</span> || Height == <span class="hljs-literal">NULL</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请设置长宽高后在进行面积计算！！！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br><span class="hljs-type">int</span> Area = <span class="hljs-number">2</span> * (Long * Width + Long * Height + Width * Height);<br><span class="hljs-keyword">return</span> Area;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Volume</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (Long == <span class="hljs-literal">NULL</span> || Width == <span class="hljs-literal">NULL</span> || Height == <span class="hljs-literal">NULL</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请设置长宽高后在进行体积计算！！！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> Long * Height * Width;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> Long;<span class="hljs-comment">// 长</span><br><span class="hljs-type">int</span> Width;<span class="hljs-comment">// 宽</span><br><span class="hljs-type">int</span> Height;<span class="hljs-comment">// 高</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">is_Same</span><span class="hljs-params">(Cube&amp; cu1, Cube cu2)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 生成实例</span><br>Cube c;<br><span class="hljs-comment">// 设置长宽高</span><br>c.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">10</span>);<br>c.<span class="hljs-built_in">setLong</span>(<span class="hljs-number">5</span>);<br>c.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">7</span>);<br><span class="hljs-comment">// 输出长宽高</span><br>cout &lt;&lt; <span class="hljs-string">&quot;长为：&quot;</span> &lt;&lt; c.<span class="hljs-built_in">getLong</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;宽为：&quot;</span> &lt;&lt; c.<span class="hljs-built_in">getWidth</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;高为：&quot;</span> &lt;&lt; c.<span class="hljs-built_in">getHeight</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 输出面积</span><br>cout &lt;&lt; <span class="hljs-string">&quot;面积为：&quot;</span> &lt;&lt; c.<span class="hljs-built_in">Acreage</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;体积为：&quot;</span> &lt;&lt; c.<span class="hljs-built_in">Volume</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">is_Same</span><span class="hljs-params">(Cube&amp; cu1, Cube cu2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (cu1.<span class="hljs-built_in">Acreage</span>() == cu2.<span class="hljs-built_in">Acreage</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;立方体面积相等&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;不相等&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029079.png" alt="image-20221213095402961"></p><h3 id="对象的而初始化和清理"><a href="#对象的而初始化和清理" class="headerlink" title="对象的而初始化和清理"></a>对象的而初始化和清理</h3><p>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</p><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029900.png" alt="image-20221213104933706"></p><h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p><p>​按参数分为： 有参构造和无参构造</p><p>​按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person4</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 无参构造函数（默认构造函数）</span><br><span class="hljs-built_in">Person4</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 有参构造函数</span><br><span class="hljs-built_in">Person4</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">Person4</span>(<span class="hljs-type">const</span> Person4&amp; p)<br>&#123;<br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">Person4</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 方法一：括号法</span><br><span class="hljs-comment">// 注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="hljs-comment">// Person4 peo1;// 默认构造</span><br><span class="hljs-comment">// Person4 peo2(10);// 有参构造</span><br><span class="hljs-comment">// Person4 peo3(peo2);  // 拷贝构造</span><br><br><span class="hljs-comment">// 方法二：显式法</span><br><span class="hljs-comment">// 注意2：Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="hljs-comment">// Person4 peo2 = Person4(10);// 有参构造</span><br><span class="hljs-comment">// Person4 peo3 = Person4(peo2);// 拷贝构造</span><br><br><span class="hljs-comment">// 方法三：隐式转换法</span><br>Person4 p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person4 p4 = Person(10); </span><br>Person4 p5 = p4; <span class="hljs-comment">// Person4 p5 = Person(p4); </span><br><br><span class="hljs-comment">// 注意3：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="hljs-comment">// Person p5(p4);</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person5</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person5</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">Person5</span>(<span class="hljs-type">int</span> age) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = age;<br>&#125;<br><span class="hljs-built_in">Person5</span>(<span class="hljs-type">const</span> Person5 &amp;p) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = p.mAge;<br>&#125;<br><span class="hljs-comment">//析构函数在释放内存之前调用</span><br>~<span class="hljs-built_in">Person5</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person5 <span class="hljs-title">man</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//p对象已经创建完毕</span><br><span class="hljs-function">Person5 <span class="hljs-title">newman</span><span class="hljs-params">(man)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br>Person5 newman2 = man; <span class="hljs-comment">//拷贝构造</span><br><br><span class="hljs-comment">//Person newman3;</span><br><span class="hljs-comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span><br>&#125;<br><br><span class="hljs-comment">//2. 值传递的方式给函数参数传值</span><br><span class="hljs-comment">//相当于Person p1 = p;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person5 p1)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>Person5 pe; <span class="hljs-comment">//无参构造函数</span><br><span class="hljs-built_in">doWork</span>(pe);<br>&#125;<br><br><span class="hljs-comment">//3. 以值方式返回局部对象</span><br><span class="hljs-function">Person5 <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person5 pe1;<br>cout &lt;&lt; (<span class="hljs-type">int</span>*)&amp;pe1 &lt;&lt; endl;<br><span class="hljs-keyword">return</span> pe1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person5 pe = <span class="hljs-built_in">doWork2</span>();<br>cout &lt;&lt; (<span class="hljs-type">int</span>*)&amp;pe &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test1();</span><br><span class="hljs-comment">//test2();</span><br><span class="hljs-built_in">test3</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下，C++ 编译器至少给一个类添加 3 个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，C++ 不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br>Person p1; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//用户提供的有参</span><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">//此时如果用户没有提供拷贝构造，编译器会提供</span><br><br><span class="hljs-comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br>Person p4; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//此时如果用户自己没有提供有参，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(p5)</span></span>; <span class="hljs-comment">//用户自己提供拷贝构造</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深拷贝-和-浅拷贝"><a href="#深拷贝-和-浅拷贝" class="headerlink" title="深拷贝 和 浅拷贝"></a><code>深拷贝</code> 和 <code>浅拷贝</code></h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>深拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 深拷贝</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">DeepCopy</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;DeepCopy(深拷贝)的默认构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br><span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> ark)<br>&#123;<br>Num = num;<br><span class="hljs-comment">// 通过 new 关键字 将ark存放到堆区域</span><br>Ark =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(ark);<br>cout &lt;&lt; <span class="hljs-string">&quot;DeepCopy(深拷贝)的默认构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br><span class="hljs-comment">// 实现拷贝构造函数</span><br><span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> DeepCopy&amp; dp)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;DeepCopy(深拷贝)的拷贝构造函数调用&quot;</span> &lt;&lt; endl;<br>Num = dp.Num;<br><span class="hljs-comment">// 编译器默认实现</span><br><span class="hljs-comment">// Ark = dp.Ark;</span><br><span class="hljs-comment">// 实现深拷贝</span><br>Ark = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*dp.Ark);<br>&#125;<br><span class="hljs-comment">// 析构函数通常用来销毁，开发人员创建的数据</span><br>~<span class="hljs-built_in">DeepCopy</span>()<br>&#123;<br><span class="hljs-comment">// 释放数据</span><br><span class="hljs-keyword">if</span> (Ark != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> Ark;<br>Ark = <span class="hljs-literal">NULL</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;DeepCopy(深拷贝)的析构函数调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> Num;<br><span class="hljs-type">int</span> *Ark;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DP01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">DeepCopy <span class="hljs-title">DC1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">123</span>)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;DP01 的 num：&quot;</span> &lt;&lt; DC1.Num &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;DC1 的 Ark：&quot;</span> &lt;&lt; *DC1.Ark &lt;&lt; endl;<br><br><span class="hljs-comment">// 拷贝函数会做 浅拷贝操作</span><br><span class="hljs-function">DeepCopy <span class="hljs-title">DC2</span><span class="hljs-params">(DC1)</span></span>; <br><br>cout &lt;&lt; <span class="hljs-string">&quot;DP02 的 num：&quot;</span> &lt;&lt; DC2.Num &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;DC2 的 Ark：&quot;</span> &lt;&lt; *DC2.Ark &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 深拷贝调用</span><br><span class="hljs-built_in">DP01</span>();<br><span class="hljs-comment">// 浅拷贝调用</span><br><span class="hljs-comment">//SP01();</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>浅拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShallowCopy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ShallowCopy</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ShallowCopy(浅拷贝)的默认构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br><span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> ark)<br>&#123;<br>Num = num;<br>cout &lt;&lt; <span class="hljs-string">&quot;ShallowCopy(浅拷贝)的默认构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br>~<span class="hljs-built_in">ShallowCopy</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;ShallowCopy(浅拷贝)的析构函数调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> Num;<br><span class="hljs-type">int</span> *Ark;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SP01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ShallowCopy <span class="hljs-title">SP1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">123</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;SP1 的 num：&quot;</span> &lt;&lt; DC1.Num &lt;&lt; endl;<br><br><span class="hljs-function">ShallowCopy <span class="hljs-title">SP2</span><span class="hljs-params">(DC1)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;SP2 的 num：&quot;</span> &lt;&lt; DC2.Num &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">SP01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029614.png" alt="image-20221215095119628"></p><blockquote><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 初始化列表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitList</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> A;<br><span class="hljs-type">int</span> B;<br><span class="hljs-type">int</span> C;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 传统方式</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">InitList(int a, int b, int c)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">A = a;</span><br><span class="hljs-comment">B = b;</span><br><span class="hljs-comment">C = c;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 初始化列表方式</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">InitList() :A(10), B(20), C(30)</span><br><span class="hljs-comment">&#123;&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 初始化列表方式初始化</span><br><span class="hljs-built_in">InitList</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)<br>:<span class="hljs-built_in">A</span>(a), <span class="hljs-built_in">B</span>(b), <span class="hljs-built_in">C</span>(c)<br>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A：&quot;</span> &lt;&lt; A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;B：&quot;</span> &lt;&lt; B &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;C：&quot;</span> &lt;&lt; C &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initList</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 方法一：初始化列表方式使用</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">InitList il1;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;il1 的 A：&quot; &lt;&lt; il1.A &lt;&lt; endl;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;il1 的 B：&quot; &lt;&lt; il1.B &lt;&lt; endl;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;il1 的 C：&quot; &lt;&lt; il1.C &lt;&lt; endl;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 方法二：初始化列表方式初始化使用</span><br><span class="hljs-function">InitList <span class="hljs-title">IL1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>IL1.<span class="hljs-built_in">PrintList</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">initList</span>();<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    A a；<br>&#125;<br></code></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Phone</span>(string name)<br>&#123;<br>m_PhoneName = name;<br>cout &lt;&lt; <span class="hljs-string">&quot;Phone构造&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Phone</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Phone析构&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>string m_PhoneName;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//初始化列表可以告诉编译器调用哪一个构造函数</span><br><span class="hljs-built_in">BClass</span>(string name, string pName) :<span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Phone</span>(pName)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person构造&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">BClass</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person析构&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; m_Name &lt;&lt; <span class="hljs-string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="hljs-string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>string m_Name;<br>Phone m_Phone; <span class="hljs-comment">// 类成员</span><br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span><br><span class="hljs-comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br><span class="hljs-comment">//析构顺序与构造相反</span><br><span class="hljs-function">BClass <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span> , <span class="hljs-string">&quot;苹果X&quot;</span>)</span></span>;<br>B.<span class="hljs-built_in">playGame</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>静态成员变量：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SC1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 静态成员变量特点：</span><br><span class="hljs-comment">// 1 在编译阶段分配内存</span><br><span class="hljs-comment">// 2 类内声明，类外初始化</span><br><span class="hljs-comment">// 3 所有对象共享同一份数据</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> SC_A;<span class="hljs-comment">// 静态成员变量</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> SC_B;<span class="hljs-comment">// 静态变量私有属性</span><br>&#125;;<br><br><span class="hljs-comment">// 初始化静态变量</span><br><span class="hljs-type">int</span> SC1::SC_A = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> SC1::SC_B = <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 1. 访问</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SCTest01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 通过对象进行访问</span><br>SC1 sc1;<br>sc1.SC_A = <span class="hljs-number">200</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;sc1.SC_A = &quot;</span> &lt;&lt; sc1.SC_A &lt;&lt; endl;<br><br><span class="hljs-comment">// 2. 通过类名直接访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;sc1.SC_A = &quot;</span> &lt;&lt; SC1::SC_A &lt;&lt; endl;<br><br><span class="hljs-comment">// 3. 私人属性无法访问</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;SC1.SC_B = &quot; &lt;&lt; SC1::SC_B &lt;&lt; endl;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">SCTest01</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态成员函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SC2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;fn1调用&quot;</span> &lt;&lt; endl;<br>m_A = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//m_B = 100; //错误，不可以访问非静态成员变量</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><span class="hljs-type">int</span> m_B; <span class="hljs-comment">// </span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">//静态成员函数也是有访问权限的</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;fn2调用&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br>SC2::m_A = <span class="hljs-number">10</span><br><br><span class="hljs-comment">// 1. 访问</span><br><span class="hljs-type">void</span> <span class="hljs-built_in">SCTest02</span>()<br>&#123;<br><span class="hljs-comment">// 1. 对象访问</span><br>SC2 sc2;<br>sc2.<span class="hljs-built_in">fn1</span>();<br><span class="hljs-comment">// 2. 类名访问</span><br>SC2::<span class="hljs-built_in">fn1</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//SCTest01();</span><br><span class="hljs-built_in">SCTest02</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-对象模型和-this-指针"><a href="#C-对象模型和-this-指针" class="headerlink" title="C++ 对象模型和 this 指针"></a>C++ 对象模型和 this 指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateC</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 非静态成员变量占对象空间</span><br><span class="hljs-type">int</span> CCA;<br><span class="hljs-comment">// 静态成员变量不占对象空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> CCB;<br><span class="hljs-comment">// 函数</span><br><span class="hljs-comment">// 同理，函数也不占用对象空间，所有函数共享一个函数实例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br><span class="hljs-comment">// 静态成员函数也不占对象空间</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><span class="hljs-type">int</span> CreateC::CCB = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>CreateC CC1;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof of CC1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(CC1) &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">CC</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029384.png" alt="image-20221221092632632"></p><h4 id="this-指针概念"><a href="#this-指针概念" class="headerlink" title="this 指针概念"></a>this 指针概念</h4><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>&#x3D;&#x3D;那么问题是：这一块代码是如何区分那个对象调用自己的呢？&#x3D;&#x3D;</p><p>C++ 通过提供特殊的对象指针，this 指针，解决上述问题。<strong>this 指针指向被调用的成员函数所属的对象</strong></p><p>this 指针是隐含每一个非静态成员函数内的一种指针</p><p>this 指针不需要定义，直接使用即可</p><p>this 指针的用途：</p><ul><li>当形参和成员变量同名时，可用 this 指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用 <code>return *this</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ThisClass</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">// 名称默认为相同的，则会不进行赋值</span><br><span class="hljs-comment">//age = age;</span><br><span class="hljs-comment">// this 指针指向对象类中的 age</span><br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><span class="hljs-comment">// this 指向 p2 的指针</span><br><span class="hljs-comment">// 而 *this 指向的就是 p2 这个对象类</span><br><span class="hljs-function">ThisClass&amp; <span class="hljs-title">ThisAddAge</span><span class="hljs-params">(ThisClass&amp; tc)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age += tc.age;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ThisClass <span class="hljs-title">TC1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;TC1.age = &quot;</span> &lt;&lt; TC1.age &lt;&lt; endl;<br><br><span class="hljs-function">ThisClass <span class="hljs-title">TC2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-comment">// 链式编程</span><br>TC2.<span class="hljs-built_in">ThisAddAge</span>(TC1).<span class="hljs-built_in">ThisAddAge</span>(TC1);<br>cout &lt;&lt; <span class="hljs-string">&quot;TC2.age = &quot;</span> &lt;&lt; TC2.age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">tc</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029906.png" alt="image-20221221100620804"></p><h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//空指针访问成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person08</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cout &lt;&lt; mAge &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person08* p = <span class="hljs-literal">NULL</span>;<br>p-&gt;<span class="hljs-built_in">ShowClassName</span>(); <span class="hljs-comment">//空指针，可以调用成员函数</span><br>p-&gt;<span class="hljs-built_in">ShowPerson</span>();  <span class="hljs-comment">//但是如果成员函数中用到了this指针，就不可以了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029249.png" alt="image-20221221101555097"></p><h4 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>m_A = <span class="hljs-number">0</span>;<br>m_B = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//const Type* const pointer;</span><br><span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span><br><span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span><br><br><span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//mA = 10000;</span><br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span><br>&#125;;<br><br><span class="hljs-comment">//const修饰对象  常对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">const</span> Person person; <span class="hljs-comment">//常量对象  </span><br>cout &lt;&lt; person.m_A &lt;&lt; endl;<br><span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span><br>person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span><br><br><span class="hljs-comment">//常对象访问成员函数</span><br>person.<span class="hljs-built_in">MyFunc</span>(); <span class="hljs-comment">//常对象不能调用const的函数</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到 友元 的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  &#x3D;&#x3D;friend&#x3D;&#x3D;</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">House</span><br>&#123;<br><span class="hljs-comment">// 创建友元</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Friend</span><span class="hljs-params">(House* house)</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">House</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;livingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;bedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义成员属性</span><br><span class="hljs-keyword">public</span>:<br>string livingRoom;<br><span class="hljs-keyword">private</span>:<br>string bedRoom;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Friend</span><span class="hljs-params">(House* house)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; house-&gt;livingRoom &lt;&lt; endl;<br><span class="hljs-comment">// 友元创建后，即可访问私有属性</span><br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; house-&gt;bedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br>House house1;<br><span class="hljs-built_in">Friend</span>(&amp;house1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011029750.png" alt="image-20230105093148644"></p><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Old</span><br>&#123;<br><span class="hljs-comment">// 创建类友元</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Young</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Old</span>();<br><span class="hljs-keyword">public</span>:<br>string name;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-comment">// 在全局环境中定义构造函数</span><br>Old::<span class="hljs-built_in">Old</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">12</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Young</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Young</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>Old* old;<br>&#125;;<br><span class="hljs-comment">// 在全局环境中定义构造函数</span><br>Young::<span class="hljs-built_in">Young</span>()<br>&#123;<br>old = <span class="hljs-keyword">new</span> Old;<br>&#125;<br><span class="hljs-comment">// 在全局环境定义类函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Young::answer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; old-&gt;name &lt;&lt; endl;<br><span class="hljs-comment">// 在 Old 中创建了 Young 的友元，这样即可访问 Old 类中的私有属性</span><br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; old-&gt;age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建 Young 类</span><br>Young y1;<br>y1.<span class="hljs-built_in">answer</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030023.png" alt="image-20230105095241517"></p><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Old</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Young</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Young</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">answer2</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>Old* old;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Old</span><br>&#123;<br><span class="hljs-comment">// 创建类友元</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Young::answer</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Old</span>();<br><span class="hljs-keyword">public</span>:<br>string name;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-comment">// 在全局环境中定义构造函数</span><br>Old::<span class="hljs-built_in">Old</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;name = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-number">12</span>;<br>&#125;<br><br><span class="hljs-comment">// 在全局环境中定义构造函数</span><br>Young::<span class="hljs-built_in">Young</span>()<br>&#123;<br>old = <span class="hljs-keyword">new</span> Old;<br>&#125;<br><span class="hljs-comment">// 在全局环境定义类函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Young::answer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; old-&gt;name &lt;&lt; endl;<br><span class="hljs-comment">// 在 Old 中创建了 Young 的友元，这样即可访问 Old 类中的私有属性</span><br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; old-&gt;age &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Young::answer2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;访问：&quot;</span> &lt;&lt; old-&gt;name &lt;&lt; endl;<br><span class="hljs-comment">// 报错</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;访问：&quot; &lt;&lt; old-&gt;age &lt;&lt; endl;</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建 Young 类</span><br>Young y1;<br>y1.<span class="hljs-built_in">answer</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><p>关键词：<strong>operator运算符</strong></p><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><p><strong>通过成员函数进行运算符的重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 方法一：通过成员变量进行运算符重载</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddClass</span>() &#123;&#125;;<br><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-built_in">AddClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-comment">// 定义运算符重载</span><br>AddClass <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> AddClass&amp; p)<br>&#123;<br><span class="hljs-comment">//  创建一个类</span><br>AddClass temp;<br>temp.a = <span class="hljs-keyword">this</span>-&gt;a + p.a;<br>temp.b = <span class="hljs-keyword">this</span>-&gt;b + p.b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">AddClass <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">AddClass <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>AddClass a3 = a1 + a2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a3.a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b: &quot;</span> &lt;&lt; a3.b &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030178.png" alt="image-20230105150655008"></p><p><strong>通过全局函数进行运算符的重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddClass</span>() &#123;&#125;;<br><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-built_in">AddClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-comment">// 方法二：通过全局函数进行运算符的重载</span><br>AddClass <span class="hljs-keyword">operator</span>+(AddClass&amp; p1, AddClass&amp; p2)<br>&#123;<br>AddClass temp;<br>temp.a = p1.a + p2.a;<br>temp.b = p1.b + p2.b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">AddClass <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">AddClass <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>AddClass a3 = a1 + a2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a3.a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b: &quot;</span> &lt;&lt; a3.b &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030842.png" alt="image-20230105152056025"></p><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><p><strong>通过全局函数进行左移重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 重载左移运算符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LeftClass</span><br>&#123;<br><span class="hljs-comment">// 通过友元进行访问</span><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, LeftClass&amp; l);<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">LeftClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;a = a;<br><span class="hljs-keyword">this</span>-&gt;b = b;<br>&#125;<br><span class="hljs-comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="hljs-comment">//void operator&lt;&lt;(LeftClass&amp; l)&#123;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-comment">// 方法一：通过全局函数进行左移运算符重载</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, LeftClass&amp; l)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; l.a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b: &quot;</span> &lt;&lt; l.b;<br><br><span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">LeftClass <span class="hljs-title">l1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>cout &lt;&lt; l1 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030657.png" alt="image-20230105161140770"></p><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 重载递增运算符</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddClass</span><br>&#123;<br><span class="hljs-comment">// 友元</span><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, AddClass addThis);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">AddClass</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>num = a;<br>&#125;<br><span class="hljs-comment">// 重载前置++运算符</span><br><span class="hljs-comment">// 返回引用是因为这样就会对一个数据进行递增</span><br>AddClass&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>num++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 重载后置++运算符，通过占位符区别前置++</span><br>AddClass <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br><span class="hljs-comment">// 1. 记录结果</span><br>AddClass temp = *<span class="hljs-keyword">this</span>;<br><span class="hljs-comment">// 2. 递增</span><br>num++;<br><span class="hljs-comment">// 3. 返回</span><br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-comment">// 需要左移运算符重载方法</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, AddClass addThis)<br>&#123;<br>cout &lt;&lt; addThis.num;<br><span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 前置++ 重载测试</span><br><span class="hljs-function">AddClass <span class="hljs-title">add01</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>cout &lt;&lt; ++(++add01) &lt;&lt; endl;<br>cout &lt;&lt; add01 &lt;&lt; endl;<br><br><span class="hljs-comment">// 后置++ 重载测试</span><br>cout &lt;&lt; add01++ &lt;&lt; endl;<br>cout &lt;&lt; add01 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="递减运算符重载"><a href="#递减运算符重载" class="headerlink" title="递减运算符重载"></a>递减运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinusClass</span><br>&#123;<br><span class="hljs-comment">// 设置友元</span><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, MinusClass minusNum);<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MinusClass</span>()<br>&#123;<br>num = <span class="hljs-number">12</span>;<br>&#125;<br><span class="hljs-comment">// 重载前置-- 运算符</span><br>MinusClass&amp; <span class="hljs-keyword">operator</span>--()<br>&#123;<br>num--;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 重载后置-- 运算符</span><br>MinusClass <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>)<br>&#123;<br>MinusClass temp = *<span class="hljs-keyword">this</span>;<br>num--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> num;<br>&#125;;<br><br><span class="hljs-comment">// 重载左移运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, MinusClass minusNum)<br>&#123;<br>cout &lt;&lt; minusNum.num;<br><br><span class="hljs-keyword">return</span> cout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MinusClass minus01;<br>cout &lt;&lt; minus01 &lt;&lt; endl;<br>cout &lt;&lt; --minus01 &lt;&lt; endl;<br>cout &lt;&lt; --(--minus01) &lt;&lt; endl;<br><br>cout &lt;&lt; minus01-- &lt;&lt; endl;<br>cout &lt;&lt; minus01 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EqualClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-built_in">EqualClass</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">// 在堆区内开辟年龄变量</span><br>Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>&#125;<br><br><span class="hljs-comment">// 重构赋值运算符</span><br>EqualClass&amp; <span class="hljs-keyword">operator</span>=(EqualClass&amp; EQC)<br>&#123;<br><span class="hljs-comment">// 首先清除对象</span><br><span class="hljs-keyword">if</span> (Age != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> Age;<br>Age = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">// 进行深拷贝</span><br>Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*EQC.Age);<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数清除对象</span><br>~<span class="hljs-built_in">EqualClass</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (Age != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> Age;<br>Age = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 定义年龄指针</span><br><span class="hljs-type">int</span>* Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">EqualClass <span class="hljs-title">EQ01</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">EqualClass <span class="hljs-title">EQ02</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">EqualClass <span class="hljs-title">EQ03</span><span class="hljs-params">(<span class="hljs-number">24</span>)</span></span>;<br><br><span class="hljs-comment">// 赋值操作测试</span><br>EQ01 = EQ02;<br>EQ02 = EQ03;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;EQ01 = &quot;</span> &lt;&lt; *EQ01.Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;EQ02 = &quot;</span> &lt;&lt; *EQ02.Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;EQ03 = &quot;</span> &lt;&lt; *EQ03.Age &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-built_in">CompareClass</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br>m_Name = name;<br>m_Age = age;<br>&#125;<br><br><span class="hljs-comment">// 重载 == 运算符</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(CompareClass&amp; CC)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Age == CC.m_Age &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Name == CC.m_Name)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 重载 != 运算符</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(CompareClass&amp; CC)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Age == CC.m_Age &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Name == CC.m_Name)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义数据</span><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义对象</span><br><span class="hljs-function">CompareClass <span class="hljs-title">CC01</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">12</span>)</span></span>;<br><span class="hljs-function">CompareClass <span class="hljs-title">CC02</span><span class="hljs-params">(<span class="hljs-string">&quot;Tom1&quot;</span>, <span class="hljs-number">12</span>)</span></span>;<br><br><span class="hljs-keyword">if</span> (CC01 == CC02)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;CC01 等于 CC02&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;CC01 不等于 CC02&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">if</span> (CC01 != CC02)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;CC01 不等于 CC02&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;CC01 等于 CC02&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 重载函数输出</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FnPrintClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string text)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; text &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 重载相加函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FnAddClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建函数输出重载类</span><br>FnPrintClass FPC01;<br><span class="hljs-built_in">FPC01</span>(<span class="hljs-string">&quot;测试重载字符串输出函数&quot;</span>);<br><br><span class="hljs-comment">// 创建函数相加重载类</span><br>FnAddClass FAC01;<br><span class="hljs-type">int</span> result = <span class="hljs-built_in">FAC01</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;a + b = &quot;</span> &lt;&lt; result &lt;&lt; endl;<br><span class="hljs-comment">// 匿名调用</span><br>cout &lt;&lt; <span class="hljs-string">&quot;a + b = &quot;</span> &lt;&lt; <span class="hljs-built_in">FnAddClass</span>()(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>) &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030391.png" alt="1544861202252"></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Java页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Java ja;<br>ja.<span class="hljs-built_in">header</span>();<br>ja.<span class="hljs-built_in">footer</span>();<br>ja.<span class="hljs-built_in">left</span>();<br>ja.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//Python页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Python py;<br>py.<span class="hljs-built_in">header</span>();<br>py.<span class="hljs-built_in">footer</span>();<br>py.<span class="hljs-built_in">left</span>();<br>py.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//C++页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>CPP cp;<br>cp.<span class="hljs-built_in">header</span>();<br>cp.<span class="hljs-built_in">footer</span>();<br>cp.<span class="hljs-built_in">left</span>();<br>cp.<span class="hljs-built_in">content</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>冗余代码过多不利于后续的维护</p></blockquote><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 公共类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Language</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 继承公共类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> Language<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span> : <span class="hljs-keyword">public</span> Language<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> : <span class="hljs-keyword">public</span> Language<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建 Java 类</span><br>Java ja;<br>ja.<span class="hljs-built_in">header</span>();<br>ja.<span class="hljs-built_in">content</span>();<br>ja.<span class="hljs-built_in">left</span>();<br>ja.<span class="hljs-built_in">footer</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>Python py;<br>py.<span class="hljs-built_in">header</span>();<br>py.<span class="hljs-built_in">content</span>();<br>py.<span class="hljs-built_in">left</span>();<br>py.<span class="hljs-built_in">footer</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br>CPP cpp;<br>cpp.<span class="hljs-built_in">header</span>();<br>cpp.<span class="hljs-built_in">content</span>();<br>cpp.<span class="hljs-built_in">left</span>();<br>cpp.<span class="hljs-built_in">footer</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;</p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030279.png" alt="image-20230118144450942"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 公共类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-comment">// 继承类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSon1</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>a;<br>b;<br><span class="hljs-comment">// c;  // 私有属性，无法访问</span><br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSon2</span> : <span class="hljs-keyword">protected</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>a;<br>b;<br><span class="hljs-comment">// c;  // 私有属性，无法访问</span><br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSon3</span> : <span class="hljs-keyword">private</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>a;<br>b;<br><span class="hljs-comment">// c;  // 私有属性，无法访问</span><br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 公共继承</span><br>BaseSon1 bs1;<br>bs1.a;<br><br><span class="hljs-comment">// 保护继承</span><br>BaseSon2 bs2;<br><span class="hljs-comment">// bs2.a;  // 保护类，无法外部输出</span><br><br><span class="hljs-comment">// 私有继承</span><br>BaseSon2 bs2;<br><span class="hljs-comment">// bs2.a;  // 私有类，无法外部输出</span><br><span class="hljs-comment">// 同理的子类再继承 BaseSon2 也是无法进行输出，因为私有化了</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 公共类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> c;<br>&#125;;<br><br><span class="hljs-comment">// 继承类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSon1</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>a;<br>b;<br><span class="hljs-comment">// c;  // 私有属性，无法访问</span><br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 公共继承</span><br>BaseSon1 bs1;<br>cout &lt;&lt; <span class="hljs-string">&quot;Size BaseSon1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(BaseSon1) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030239.png" alt="1545881904150"></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名   所属文件名</p><blockquote><p> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="继承中的析构顺序"><a href="#继承中的析构顺序" class="headerlink" title="继承中的析构顺序"></a>继承中的析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Base</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br>Son s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>m_A = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>m_A = <span class="hljs-number">200</span>;<br>&#125;<br><br><span class="hljs-comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="hljs-comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_A = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m_A = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">//同名成员属性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br><span class="hljs-comment">//通过类名访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//同名成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>Son s;<br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>Son::<span class="hljs-built_in">func</span>();<br>Son::Base::<span class="hljs-built_in">func</span>();<br><span class="hljs-comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br>Son::Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base1</span>()<br>&#123;<br>m_A = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base2</span>()<br>&#123;<br>m_A = <span class="hljs-number">200</span>;  <span class="hljs-comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base1 <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>m_C = <span class="hljs-number">300</span>;<br>m_D = <span class="hljs-number">400</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_C;<br><span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><br><span class="hljs-comment">//多继承容易产生成员同名的情况</span><br><span class="hljs-comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030946.jpg" alt="IMG_256"></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code class="hljs">羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code class="hljs">草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//继承前加virtual关键字后，变为虚继承</span><br><span class="hljs-comment">//此时公共的父类Animal称为虚基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span>   : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span> : <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SheepTuo st;<br>st.Sheep::m_Age = <span class="hljs-number">100</span>;<br>st.Tuo::m_Age = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态是C++面向对象三大特性之一</strong></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;动物说话！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatClass</span> : <span class="hljs-keyword">public</span> AnimalClass<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猫猫在说话！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DogClass</span> : <span class="hljs-keyword">public</span> AnimalClass<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;修狗在说话！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 传入对象并调用对应的类</span><br><span class="hljs-comment">// 如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="hljs-comment">// 如果函数地址在运行阶段才能确定，就是动态联编</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(AnimalClass&amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-comment">// 多态满足条件： </span><br><span class="hljs-comment">// 1、有继承关系</span><br><span class="hljs-comment">// 2、子类重写父类中的虚函数</span><br><span class="hljs-comment">// 多态使用：</span><br><span class="hljs-comment">// 父类指针或引用指向子类对象</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义猫猫类</span><br>CatClass cat01;<br><span class="hljs-built_in">doSpeak</span>(cat01);<br><br>DogClass dog02;<br><span class="hljs-built_in">doSpeak</span>(dog02);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011030461.png" alt="image-20230202102931998"></p><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="案例-计算器"><a href="#案例-计算器" class="headerlink" title="案例 - 计算器"></a>案例 - 计算器</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> num1;<br><span class="hljs-type">int</span> num2;<br>&#125;;<br><br><span class="hljs-comment">// 实现功能类</span><br><span class="hljs-comment">// 1.加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCal</span> : <span class="hljs-keyword">public</span> AbstractCal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> num1 + num2;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 2.减法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCal</span> : <span class="hljs-keyword">public</span> AbstractCal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> num1 - num2;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 3.除法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivCal</span> : <span class="hljs-keyword">public</span> AbstractCal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> num1 / num2;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 4.乘法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCal</span> : <span class="hljs-keyword">public</span> AbstractCal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> num1 * num2;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建加法计算器对象</span><br>AbstractCal* abc = <span class="hljs-keyword">new</span> AddCal;<br>abc-&gt;num1 = <span class="hljs-number">10</span>;<br>abc-&gt;num2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; abc-&gt;num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abc-&gt;num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 清除对象</span><br><span class="hljs-keyword">delete</span> abc;<br><br><span class="hljs-comment">// 创建减法</span><br>abc = <span class="hljs-keyword">new</span> SubCal;<br>abc-&gt;num1 = <span class="hljs-number">10</span>;<br>abc-&gt;num2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; abc-&gt;num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abc-&gt;num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;<br><br><span class="hljs-comment">// 创建乘法</span><br>abc = <span class="hljs-keyword">new</span> MulCal;<br>abc-&gt;num1 = <span class="hljs-number">10</span>;<br>abc-&gt;num2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; abc-&gt;num1 &lt;&lt; <span class="hljs-string">&quot; × &quot;</span> &lt;&lt; abc-&gt;num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;<br><br><span class="hljs-comment">// 创建除法</span><br>abc = <span class="hljs-keyword">new</span> DivCal;<br>abc-&gt;num1 = <span class="hljs-number">10</span>;<br>abc-&gt;num2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; abc-&gt;num1 &lt;&lt; <span class="hljs-string">&quot; / &quot;</span> &lt;&lt; abc-&gt;num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义纯虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 纯虚函数</span><br><span class="hljs-comment">// 类中只要有一个纯虚函数就称为抽象类</span><br><span class="hljs-comment">// 抽象类无法实例化对象</span><br><span class="hljs-comment">// 子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 并且定义完成后继承该类的子类必须进行声明</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtBase</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base* base = <span class="hljs-literal">NULL</span>;<br>base = <span class="hljs-keyword">new</span> ExtBase;<br>base-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> base;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011031731.png" alt="image-20230202144830919"></p><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p><strong>虚析构语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~类名()&#123;&#125;<br></code></pre></td></tr></table></figure><p>纯虚析构语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~类名() = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>类名::~类名(){}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="hljs-comment">//virtual ~Animal()</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><br>Animal::~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cat</span>(string name)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;<br>m_Name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *m_Name &lt;&lt;  <span class="hljs-string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Cat</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">delete</span> m_Name;<br>m_Name = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string *m_Name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>animal-&gt;<span class="hljs-built_in">Speak</span>();<br><br><span class="hljs-comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="hljs-comment">//怎么解决？给基类增加一个虚析构函数</span><br><span class="hljs-comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="hljs-keyword">delete</span> animal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>​1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​3. 拥有纯虚析构函数的类也属于抽象类</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>写文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 创建流对象</span><br>ofstream ofs;<br><span class="hljs-comment">// 2. 打开文件</span><br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br><br><span class="hljs-comment">// 写入信息</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：ZC&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;性别：Female&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;Age：22&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 4. 关闭文件</span><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011031105.png" alt="image-20230202151309543"></p><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件   </p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象  </p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main_open_file</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 创建流对象</span><br>ofstream ofs;<br><span class="hljs-comment">// 2. 打开文件</span><br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br><br><span class="hljs-comment">// 写入信息</span><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：ZC&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;性别：Female&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;Age：22&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 4. 关闭文件</span><br>ofs.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 1. 创建浏</span><br>ifstream ifs;<br><span class="hljs-comment">// 2. 打开文件</span><br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in);<br><span class="hljs-comment">// 3. 判断</span><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 4.1 查看方式一</span><br><span class="hljs-comment">/*char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">while (ifs &gt;&gt; buf)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">// 4.2 查看方式二</span><br><span class="hljs-comment">/*char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">while (ifs.getline(buf, sizeof(buf)))</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">// 4.3 查看方式三</span><br><span class="hljs-comment">/*string buf;</span><br><span class="hljs-comment">while (getline(ifs, buf))</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">&#125;*/</span><br><br><span class="hljs-comment">// 4.4 查看方式四</span><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF)<br>&#123;<br>cout &lt;&lt; c;<br>&#125;<br><br><span class="hljs-comment">// 5. 关闭</span><br>ifs.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011031221.png" alt="image-20230202152203567"></p><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;</p><h4 id="写入文件-1"><a href="#写入文件-1" class="headerlink" title="写入文件"></a>写入文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//二进制文件  写文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1、包含头文件</span><br><br><span class="hljs-comment">//2、创建输出流对象</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br><br><span class="hljs-comment">//3、打开文件</span><br><span class="hljs-comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><br>Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>  , <span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-comment">//4、写文件</span><br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br><span class="hljs-comment">//5、关闭文件</span><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="读取文件-1"><a href="#读取文件-1" class="headerlink" title="读取文件"></a>读取文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Person p;<br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件输入流对象 可以通过read函数，以二进制方式读数据</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.数据结构与算法概述</title>
    <link href="/2023/08/30/06.C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/30/06.C++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>概述</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 内存池剖析</title>
    <link href="/2023/08/28/05.C++%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/02.C++%20%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/28/05.C++%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/02.C++%20%E5%86%85%E5%AD%98%E6%B1%A0%E5%89%96%E6%9E%90/%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内存池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.C++ 面试题</title>
    <link href="/2023/08/27/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98/01.C++%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/08/27/00.C++%E9%9D%A2%E8%AF%95%E9%A2%98/01.C++%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>C&#x2F;C++</li><li>Effective C++ 相关</li><li>STL</li><li>数据结构</li><li>算法</li><li>Problems</li><li>操作系统</li><li>计算机网络</li><li>网络编程</li><li>数据库</li><li>设计模式</li><li>链接装载库</li><li>书籍</li></ul><h2 id="1-C-C"><a href="#1-C-C" class="headerlink" title="1. C&#x2F;C++"></a>1. C&#x2F;C++</h2><h3 id="1-const"><a href="#1-const" class="headerlink" title="1. const"></a>1. const</h3><p>作用：</p><ol><li>修饰变量，说明该变量不被改变。</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）。</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改。</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><p><strong>const 的指针与引用：</strong></p><ul><li><strong>指针</strong></li></ul><p>指向常量的指针（pointer to const）<br>自身是常量的指针（常量指针，const pointer）</p><ul><li><strong>引用</strong></li></ul><p>指向常量的引用（reference to const）<br>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</p><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 常对象成员，可以使用初始化列表或者类内初始化</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) <br>    &#123; <br>    <span class="hljs-comment">// 初始化列表</span><br>    &#125;;<br><br>    <span class="hljs-comment">// const可用于对重载函数的区分</span><br>    <span class="hljs-comment">// 普通成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对象</span><br>    <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span><br>    A b;<br>    <span class="hljs-comment">// 常对象，只能调用常成员函数</span><br>    <span class="hljs-type">const</span> A a;<br>    <span class="hljs-comment">// 指针变量，指向常对象</span><br>    <span class="hljs-type">const</span> A *p = &amp;a;<br>    <span class="hljs-comment">// 指向常对象的引用</span><br>    <span class="hljs-type">const</span> A &amp;q = a;<br><br>    <span class="hljs-comment">// 指针</span><br>    <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-comment">// 指针变量，指向字符数组变量</span><br>    <span class="hljs-type">char</span>* p1 = greeting;<br>    <span class="hljs-comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;<br>    <span class="hljs-comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;<br>    <span class="hljs-comment">// 自身是常量的指针，指向字符数组常量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;<br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-comment">// 传递过来的参数在函数内不可变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;<br><span class="hljs-comment">// 参数指针所指内容为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;<br><span class="hljs-comment">// 参数指针为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;<br><span class="hljs-comment">// 引用参数在函数内为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;<br><br><span class="hljs-comment">// 函数返回值</span><br><span class="hljs-comment">// 返回一个常数</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p><strong>宏定义 <code>#define</code> 和 const 常量：</strong></p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h3 id="2-static"><a href="#2-static" class="headerlink" title="2. static"></a>2. static</h3><ol><li>修饰普通变量；修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前进行分配空间，如果有初始值就就进行初始化，没有则用系统默认值初始化。</li><li>修饰普通函数；表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>修饰成员变量；修饰成员变量使所有对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数；成员函数使得不需要生成对象就可以方位该函数，但是在 static 函数内不能访问非静态成员。</li></ol><h3 id="3-this-指针"><a href="#3-this-指针" class="headerlink" title="3. this 指针"></a>3. this 指针</h3><ol><li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它只想调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象地址赋予 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象指针。</li><li>this 指针被隐含地声明为：<code>ClassName *const this</code>，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针类型为：<code>const ClassName* const</code>，这说明不能对 this 指针指向的这种对象是不可能修改的。（即不能对这种对象的数据成员进行赋值操作）</li><li>this 并不是一个常规变量，而是一个<strong>右值</strong>，所以不能取 this 的地址（不能 &amp;this）。</li><li>三种场景中经常需要隐式引用 this 指针：<ol><li>为实现对象的链式引用。</li><li>为避免对同一对象进行赋值操作。</li><li><ol><li>在实现一些数据结构时，如：list。</li></ol></li></ol></li></ol><h3 id="4-inline-内联函数"><a href="#4-inline-内联函数" class="headerlink" title="4. inline 内联函数"></a>4. inline 内联函数</h3><p><strong>特征：</strong></p><ul><li>相当于把内联函数里面的内容写在调用内联函数处。</li><li>相当于不用执行进入函数的步骤，直接调用函数体。</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性。</li><li>编译器一般不内联包含：循环、递归、switch 等复杂操作的内联函数。</li><li>在类声明中定义的函数，除了虚函数其他函数都会自动隐式地当成内联函数。</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明1（加 inline，建议使用）</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 声明2（不加 inline）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span> </span>&#123;<span class="hljs-comment">/****/</span>&#125;;<br><br><span class="hljs-comment">// 类内定义，隐式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;         <span class="hljs-comment">// 隐式内联</span><br>&#125;<br><br><span class="hljs-comment">// 类外定义，需要显式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;   <span class="hljs-comment">// 需要显式内联</span><br></code></pre></td></tr></table></figure><p><strong>编译器对 inline 函数的处理步骤：</strong></p><ol><li>将 inline 函数体复制到 inline 函数调用处。</li><li>为所用 inline 函数中的局部变量分配内存空间。</li><li>将 inline 函数的输入参数和返回值映射到调用方法的局部变量空间中。</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 goto）。</li></ol><p><strong>优缺点：</strong></p><ul><li>优点：</li></ul><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><ul><li>缺点：</li></ul><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline 函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><p><strong>虚函数（virtual）可以是内联函数（inline）吗？</strong></p><blockquote><ul><li></li><li></li></ul></blockquote><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am Base\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">who</span><span class="hljs-params">()</span>  <span class="hljs-comment">// 不写inline时隐式内联</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am Derived\n&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span><br>Base b;<br>b.<span class="hljs-built_in">who</span>();<br><br><span class="hljs-comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span><br>Base *ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>ptr-&gt;<span class="hljs-built_in">who</span>();<br><br><span class="hljs-comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span><br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="5-volatile"><a href="#5-volatile" class="headerlink" title="5. volatile"></a>5. volatile</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器的未知原因（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）。</li><li>const 可以是 volatile （如只读的状态寄存器）。</li><li>指针可以是 volatile。</li></ul><h3 id="6-assert"><a href="#6-assert" class="headerlink" title="6. assert()"></a>6. assert()</h3><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG          <span class="hljs-comment">// 加上这行，则 assert 不可用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-built_in">assert</span>( p != <span class="hljs-literal">NULL</span> );    <span class="hljs-comment">// assert 不可用</span><br></code></pre></td></tr></table></figure><h3 id="7-sizeof"><a href="#7-sizeof" class="headerlink" title="7. sizeof()"></a>7. sizeof()</h3><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 数据库连接池</title>
    <link href="/2023/08/24/05.C++%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/01.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/08/24/05.C++%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/01.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>关键技术点：</strong></p><ul><li>MySQL 数据库编程</li><li>单例模式</li><li>queue队列容器</li><li>C++11多线程编程、线程互斥、线程同步通信和 unique_lock</li><li>基于CAS的原子整形</li><li>智能指针shared_ptr</li><li>lambda表达式</li><li>生产者-消费者线程模型</li></ul><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>为了提高 MySQL 数据库（基于C&#x2F;S设计）的访问瓶颈，除了在服务器端增加缓存服务器缓存常用的数据之外（例如：redis），还可以增加连接池，来提高 MySQL Server 的访问效率，在高并发情况下，大量的 TCP 三次握手、 MySQL Server 连接认证、MySQL Server 关闭连接回收资源和 TCP 四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。</p><p>而常见的解决数据库访问瓶颈的方法有两种：</p><ul><li>一、为 <code>减少磁盘 I/O</code> 的次数，在数据库和服务器的应用中间加一层 <strong>缓存数据库</strong>（例如：Redis、Memcache）;</li><li>二、增加 <code>连接池</code>，来减少高并发情况下大量 <strong>TCP三次握手、MySQL Server连接认证、MySQL Server关闭连接回收资源和TCP四次挥手</strong> 所耗费的性能。</li></ul><blockquote><p>注：</p><p>在市场上比较流行的连接池包括阿里的 druid，c3p0 以及 apache dbcp 连接池，它们对于短时间内大量的数据库增删改查操作性能的提升是很明显的，但是它们有一个共同点就是，全部由 Java 实现的。 </p></blockquote><p>那么本项目就是为了在 C&#x2F;C++ 项目中，提供 MySQL Server 的访问效率，实现基于 C++ 代码的数据库连接 池模块。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>连接池一般包含了数据库连接所用的 ip 地址、port 端口、用户名和密码以及其他的性能参数，例如：初始连接量、最大量接量、最大空闲时间、连接超时时间等等，该项目是基于 C++ 语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能。</p><ol><li><strong>初始连接量（iniSize）</strong>：表示连接池实现和 MySQL Server 创建 iniSize 个数的 connection 连接，当应用发起 MySQL 访问时，不用再创建和 MySQL Server 新的连接，直接从连接池中获取一个可用的连接即可，使用完成后，并不去释放 connection，而是把当前 connection 在归还到连接池中。</li><li><strong>最大量接量（maxSize）</strong>：当并发访问 MySQL Server 的请求增多时，初始连接量已经不够使用时，此时会根据新的请求数量创建更多的连接给应用去使用，但是新创建的连接数量上限是 maxSize，不能无限制的创建连接，因为每一个连接都会占用一个 socket 资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多 socket 资源，那么服务器就不能接受太多的客户端请求了。当这些连接使用完成后，再次归还到连接池中来维护。</li><li><strong>最大空闲时间（maxIdleTime）</strong>：当访问 MySQL 的并发请求多了以后，连接池里面的连接数量会动态增加，上限是 maxSize 个，当这些连接用完再次归还到连接池当中。如果在指定的 maxIdleTime 里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接量 initSize 个连接就可以了。</li><li><strong>连接超时时间（connectionTimeout）</strong>：当 MySQL 的并发请求量过大，连接池中的连接数量已经到达 maxSize 了，而此时没有空闲的连接可供使用，那么此时应用从连接池获取连接无法成功，它通过阻塞的方式获取连接的时间如果超过 connectionTimeout 时间，那么获取连接失败，无法访问数据库。</li></ol><h2 id="MySQL-Server-参数介绍"><a href="#MySQL-Server-参数介绍" class="headerlink" title="MySQL Server 参数介绍"></a>MySQL Server 参数介绍</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show variables like &#x27;max_connections&#x27;;<br></code></pre></td></tr></table></figure><p>该命令可以查看 MySQL Server 所支持的最大连接个数，超过 <code>max_connections</code> 数量的连接，MySQL Server 会直接拒绝，所以在使用连接池增加连接数量的时候，MySQL Server 的 <code>max_connections</code> 参数也要适当的进行调整，以适配连接池的连接上限。</p><h2 id="功能实现设计"><a href="#功能实现设计" class="headerlink" title="功能实现设计"></a>功能实现设计</h2><p><code>ConnectionPool.cpp</code> 和 <code>ConnectionPool.h</code>：连接池代码实现 <code>Connection.cpp</code> 和 <code>Connection.h</code>：数据库操作代码、增删改查代码实现</p><p>连接池主要包含了以下功能点：</p><ol><li>连接池只需要一个实例，所以 ConnectionPool 以单例模式进行设计</li><li>从 ConnectionPool 中可以获取和 MySQL 的连接 Connection</li><li>空闲连接 Connection 全部维护在一个线程安全的 Connection 队列中，使用线程互斥锁保证队列的线程安全</li><li>如果 Connection 队列为空，还需要再获取连接，此时需要动态创建连接，上限数量是 maxSize</li><li>队列中空闲连接时间超过 maxIdleTime 的就要被释放掉，只保留初始的 initSize 个连接就可以了，这个功能点需要放在独立的线程中去做</li><li>如果 Connection 队列为空，而此时连接的数量已达上限 maxSize，那么等待 connectionTimeout 时间如果还获取不到空闲的连接，那么获取连接失败，此处从 Connection 队列获取空闲连接，可以使用带超时时间的 mutex 互斥锁来实现连接超时时间</li><li>用户获取的连接用 shared_ptr 智能指针来管理，用 lambda 表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）</li><li>连接的生产和连接的消费采用<strong>生产者-消费者线程模型</strong>来设计，使用了线程间的同步通信机制条件变量和互斥锁</li></ol><h2 id="开发平台选型"><a href="#开发平台选型" class="headerlink" title="开发平台选型"></a>开发平台选型</h2><p>有关 MySQL 数据库编程、多线程编程、线程互斥和同步通信操作、智能指针、设计模式、容器等等这些技术在 C++ 语言层面都可以直接实现，因此该项目选择直接在 windows 平台上进行开发，当然放在 Linux 平台下用 g++ 也可以直接编译运行。</p><h2 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h2><p>验证数据的插入操作所花费的时间，第一次测试使用普通的数据库访问操作，第二次测试使用带连接池的数据库访问操作，对比两次操作同样数据量所花费的时间，性能压力测试结果如下：</p><table><thead><tr><th align="center">数据量</th><th>未使用连接池花费时间</th><th>使用连接池花费时间</th></tr></thead><tbody><tr><td align="center">1000</td><td>单线程： 四线程：</td><td>单线程： 四线程：</td></tr><tr><td align="center">5000</td><td>单线程： 四线程：</td><td>单线程： 四线程：</td></tr><tr><td align="center">10000</td><td>单线程： 四线程：</td><td>单线程： 四线程：</td></tr></tbody></table><h2 id="MySQL-数据库编程"><a href="#MySQL-数据库编程" class="headerlink" title="MySQL 数据库编程"></a>MySQL 数据库编程</h2><p>这里的 MySQL 数据库编程直接采用 oracle 公司提供的 <code>MySQL C/C++</code> 客户端开发包，在 VS 上需要进行相应的头文件和库文件的配置，如下：</p><ol><li>右键项目 - C&#x2F;C++ - 常规 - 附加包含目录，填写mysql.h头文件的路径</li></ol><p><strong>找到 <code>mysql.h</code> 目录文件</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241633511.png" alt="image.png"></p><p><strong>在 VS 编译器设置中的 C&#x2F;C++ - 常规 中包含该目录</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241634829.png" alt="image.png"></p><ol start="2"><li>右键项目 - 链接器 - 常规 - 附加库目录，填写libmysql.lib的路径</li></ol><p><strong>找到 <code>libmysql.lib</code> 根目录</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241636559.png" alt="image.png"></p><p><strong>在 VS 编译器设置中的 链接器 - 常规 中包含该目录</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241637368.png" alt="image.png"></p><ol start="3"><li>右键项目 - 链接器 - 输入 - 附加依赖项，填写libmysql.lib库的名字</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241639697.png" alt="image.png"></p><ol start="4"><li>把libmysql.dll动态链接库（Linux下后缀名是.so库）放在工程目录下</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241640452.png" alt="image.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1-配置-MySQL"><a href="#1-配置-MySQL" class="headerlink" title="1. 配置 MySQL"></a>1. 配置 MySQL</h3><p><code>Connection.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mysql.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// 引入定义文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Common.h&quot;</span></span><br><span class="hljs-comment">// 定义命名空间</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">实现 MySQL 数据库的增删改查</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义数据库连接</span><br><span class="hljs-built_in">Connection</span>();<br><span class="hljs-comment">// 定义析构函数</span><br>~<span class="hljs-built_in">Connection</span>();<br><span class="hljs-comment">// 连接数据库</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">string ip,<span class="hljs-comment">// ip 地址</span></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port,<span class="hljs-comment">// 端口</span></span></span><br><span class="hljs-params"><span class="hljs-function">string user,<span class="hljs-comment">// 用户名</span></span></span><br><span class="hljs-params"><span class="hljs-function">string password,<span class="hljs-comment">// 密码</span></span></span><br><span class="hljs-params"><span class="hljs-function">string dbname<span class="hljs-comment">// 数据库名</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-comment">// 更新操作 insert、delete、update</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">update</span><span class="hljs-params">(string sql)</span></span>;<br><span class="hljs-comment">// 查询操作 select</span><br><span class="hljs-function">MYSQL_RES* <span class="hljs-title">query</span><span class="hljs-params">(string sql)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>MYSQL* _conn; <span class="hljs-comment">// 表示和MySQL Server的一条连接</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Connection.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Common.h&quot;</span></span><br><br><span class="hljs-comment">// 初始化数据库连接</span><br>Connection::<span class="hljs-built_in">Connection</span>()<br>&#123;<br>_conn = <span class="hljs-built_in">mysql_init</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-comment">// 释放数据库连接资源</span><br>Connection::~<span class="hljs-built_in">Connection</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (_conn != <span class="hljs-literal">nullptr</span>)<br><span class="hljs-built_in">mysql_close</span>(_conn);<br>&#125;<br><br><span class="hljs-comment">// 连接数据库</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Connection::connect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">string ip,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port,</span></span><br><span class="hljs-params"><span class="hljs-function">string user,</span></span><br><span class="hljs-params"><span class="hljs-function">string password,</span></span><br><span class="hljs-params"><span class="hljs-function">string dbname</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>MYSQL* p = <span class="hljs-built_in">mysql_real_connect</span>(_conn, ip.<span class="hljs-built_in">c_str</span>(), user.<span class="hljs-built_in">c_str</span>(),<br>password.<span class="hljs-built_in">c_str</span>(), dbname.<span class="hljs-built_in">c_str</span>(), port, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> p != <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 更新操作 insert、delete、update</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Connection::update</span><span class="hljs-params">(string sql)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_query</span>(_conn, sql.<span class="hljs-built_in">c_str</span>()))<br>&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;更新失败:&quot;</span> + sql);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 查询操作 select</span><br><span class="hljs-function">MYSQL_RES* <span class="hljs-title">Connection::query</span><span class="hljs-params">(string sql)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mysql_query</span>(_conn, sql.<span class="hljs-built_in">c_str</span>()))<br>&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;查询失败:&quot;</span> + sql);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">mysql_use_result</span>(_conn);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Common.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义公共日志</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG(str) \</span><br><span class="hljs-meta">cout &lt;&lt; __FILE__ &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="hljs-string">&quot; &quot;</span> \</span><br><span class="hljs-meta">__TIMESTAMP__ &lt;&lt; <span class="hljs-string">&quot; : &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br></code></pre></td></tr></table></figure><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Connection con;<br><span class="hljs-type">char</span> sql[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">// 创建 sql 语句</span><br><span class="hljs-built_in">sprintf</span>(sql, <span class="hljs-string">&quot;insert into users(name, age, sex) values(&#x27;%s&#x27;, &#x27;%d&#x27;, &#x27;%s&#x27;)&quot;</span>,<br><span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;male&quot;</span>);<br><span class="hljs-comment">// 连接</span><br>con.<span class="hljs-built_in">connect</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3306</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;chat&quot;</span>);<br>con.<span class="hljs-built_in">update</span>(sql);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-连接池单例实现"><a href="#2-连接池单例实现" class="headerlink" title="2. 连接池单例实现"></a>2. 连接池单例实现</h3><p><code>Connection.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">连接池功能模块</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 获取连接池对象实例</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConnectionPool* <span class="hljs-title">getConnectionPool</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 单例 #1 -- 构造函数私有化 </span><br><span class="hljs-built_in">ConnectionPool</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ConnectionPool.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ConnectionPool.h&quot;</span></span><br><br><span class="hljs-comment">// 线程安全的懒汉单例模式</span><br><span class="hljs-function">ConnectionPool* <span class="hljs-title">ConnectionPool::getConnectionPool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 静态类型初始化，编译器自动 lock 和 unlock</span><br><span class="hljs-type">static</span> ConnectionPool pool;<br><span class="hljs-keyword">return</span> &amp;pool;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-加载配置文件实现"><a href="#3-加载配置文件实现" class="headerlink" title="3. 加载配置文件实现"></a>3. 加载配置文件实现</h3><p><code>mysql.ini</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">数据库连接池配置文件</span><br>ip=127.0.0.1<br>port=3306<br>username=root<br>password=root<br>dbname=chat<br>initSize=10<br>maxSize=1024<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最大空闲时间 单位为：s/秒</span><br>maxIdleTime=60<br><span class="hljs-meta prompt_"># </span><span class="language-bash">连接超时时间 单位为：ms/毫秒</span><br>connectionTimeout=100<br></code></pre></td></tr></table></figure><p><code>Connection.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">连接池功能模块</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 获取连接池对象实例</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConnectionPool* <span class="hljs-title">getConnectionPool</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 单例 #1 -- 构造函数私有化 </span><br><span class="hljs-built_in">ConnectionPool</span>();<br><br><span class="hljs-comment">// 加载方法</span><br><span class="hljs-comment">// 1. 获取配置文件中相关数据库信息</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">loadConfigFile</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 定义所需数据</span><br><span class="hljs-comment">// 1. mysql 的 ip 地址</span><br>string _ip;<br><span class="hljs-comment">// 2. mysql 的端口号 3306</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _port;<br><span class="hljs-comment">// 3. mysql 登陆用户名</span><br>string _username;<br><span class="hljs-comment">// 4. mysql 登陆密码</span><br>string _password;<br><span class="hljs-comment">// 5. 连接的数据库名称</span><br>string _dbname;<br><span class="hljs-comment">// 6. 连接池的初始连接量</span><br><span class="hljs-type">int</span> _initSize;<br><span class="hljs-comment">// 7. 连接池的最大量接量</span><br><span class="hljs-type">int</span> _maxSize;<br><span class="hljs-comment">// 8. 连接池的最大空闲时间</span><br><span class="hljs-type">int</span> _maxIdleTime;<br><span class="hljs-comment">// 9. 连接池获取连接的超时时间</span><br><span class="hljs-type">int</span> _connectionTimeout;<br><br><span class="hljs-comment">// 1. 存储 mysql 连接队列</span><br>queue&lt;Connection*&gt; _connectionQue;<br><span class="hljs-comment">// 2. 维护连接队列的线程安全互斥锁</span><br>mutex _queueMutex;<br><span class="hljs-comment">// 3. 记录连接所创建的 connection 连接的总数量 </span><br>atomic_int _connectionCnt;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ConnectionPool.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ConnectionPool.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ConnectionPool::loadConfigFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 读取方式打开文件</span><br>FILE* pf = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;mysql.ini&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-comment">// 判断文件是否存在</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;mysql.ini file is not exist!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 遍历文件内容</span><br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">feof</span>(pf))<br>&#123;<br><span class="hljs-comment">// 定义保存字段</span><br><span class="hljs-type">char</span> line[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">// 按行读取并赋值</span><br><span class="hljs-built_in">fgets</span>(line, <span class="hljs-number">1024</span>, pf);<br>string str = line;<br><span class="hljs-comment">// 查找</span><br><span class="hljs-type">int</span> idx = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 无效的配置项</span><br><span class="hljs-keyword">if</span> (idx == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取结尾 \n</span><br><span class="hljs-comment">//    0     1   2     3</span><br><span class="hljs-comment">// password = 123456 \n</span><br><span class="hljs-type">int</span> endidx = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;\n&#x27;</span>, idx);<br><span class="hljs-comment">// 获取索引 0 的数据</span><br>string key = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, idx);<br><span class="hljs-comment">// 获取索引 2 的数据</span><br>string value = str.<span class="hljs-built_in">substr</span>(idx + <span class="hljs-number">1</span>, endidx - idx - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;ip&quot;</span>)<br>&#123;<br>_ip = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;port&quot;</span>)<br>&#123;<br>_port = <span class="hljs-built_in">atoi</span>(value.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;username&quot;</span>)<br>&#123;<br>_username = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;password&quot;</span>)<br>&#123;<br>_password = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;dbname&quot;</span>)<br>&#123;<br>_dbname = value;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;initSize&quot;</span>)<br>&#123;<br>_initSize = <span class="hljs-built_in">atoi</span>(value.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;maxSize&quot;</span>)<br>&#123;<br>_maxSize = <span class="hljs-built_in">atoi</span>(value.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;maxIdleTime&quot;</span>)<br>&#123;<br>_maxIdleTime = <span class="hljs-built_in">atoi</span>(value.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == <span class="hljs-string">&quot;connectionTimeout&quot;</span>)<br>&#123;<br>_connectionTimeout = <span class="hljs-built_in">atoi</span>(value.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 构造</span><br>ConnectionPool::<span class="hljs-built_in">ConnectionPool</span>()<br>&#123;<br><span class="hljs-comment">// 加载配置项</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">loadConfigFile</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 创建初始数量的连接</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _initSize; i++)<br>&#123;<br><span class="hljs-comment">// 实例化连接</span><br>Connection* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>();<br><span class="hljs-comment">// 调用 connection</span><br>p-&gt;<span class="hljs-built_in">connect</span>(_ip, _port, _username, _password, _dbname);<br><span class="hljs-comment">// 添加到队列中</span><br>_connectionQue.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-comment">// 连接量增加</span><br>_connectionCnt++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-创建链接的生产者线程"><a href="#4-创建链接的生产者线程" class="headerlink" title="4. 创建链接的生产者线程"></a>4. 创建链接的生产者线程</h3><p><code>ConnectionPool.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">连接池功能模块</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 获取连接池对象实例</span><br><span class="hljs-function"><span class="hljs-type">static</span> ConnectionPool* <span class="hljs-title">getConnectionPool</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 单例 #1 -- 构造函数私有化 </span><br><span class="hljs-built_in">ConnectionPool</span>();<br><br><span class="hljs-comment">// 加载方法</span><br><span class="hljs-comment">// 2. 专门负责生产新连接（C 语言），运行在独立的线程中</span><br><span class="hljs-comment">// 普通方法运行在成员对象需要把 this 指针进行绑定</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produceConnectionTask</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 4. 设置条件变量，用于连接生产线程和连接消费线程的通信</span><br>condition_variable cv;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ConnectionPool.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ConnectionPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Common.h&quot;</span></span><br><br><span class="hljs-comment">// 构造</span><br>ConnectionPool::<span class="hljs-built_in">ConnectionPool</span>()<br>&#123;<br><span class="hljs-comment">// 加载配置项</span><br><span class="hljs-comment">// ----</span><br><br><span class="hljs-comment">// 启动一个新的线程，作为连接的生产者 linux thread =&gt; pthread_create</span><br><span class="hljs-comment">// 需要一个线程函数，因为连接创建的是 C 接口函数，无法直接进行创建，所以创建了 produceConnectionTask</span><br><span class="hljs-function">thread <span class="hljs-title">produce</span><span class="hljs-params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 运行在独立的线程中，专门负责生产新连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::produceConnectionTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 循环，目的是反复查看</span><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br><span class="hljs-comment">// 创建互斥锁</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_queueMutex)</span></span>;<br><span class="hljs-comment">// 判断 连接队列是否为空</span><br><span class="hljs-keyword">if</span> (!_connectionQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 不为空，则进入生产者线程中进入等待状态</span><br>cv.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br><span class="hljs-comment">// 连接数量没有达到上限，继续创建新的连接</span><br><span class="hljs-keyword">if</span> (_connectionCnt &lt; _maxSize)<br>&#123;<br><span class="hljs-comment">// 实例化连接</span><br>Connection* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>();<br><span class="hljs-comment">// 调用 connection</span><br>p-&gt;<span class="hljs-built_in">connect</span>(_ip, _port, _username, _password, _dbname);<br><span class="hljs-comment">// 添加到队列中</span><br>_connectionQue.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-comment">// 连接量增加</span><br>_connectionCnt++;<br>&#125;<br><br><span class="hljs-comment">// 通知消费者线程，可以消费连接了</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-创建连接的消费者线程"><a href="#5-创建连接的消费者线程" class="headerlink" title="5. 创建连接的消费者线程"></a>5. 创建连接的消费者线程</h3><p><code>ConnectionPool.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">连接池功能模块</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 通过智能指针给外部提供接口，从连接池中获取一个可用的闲置连接</span><br><span class="hljs-comment">// 智能指针会自动析构，所以无需在进行释放。</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">getConnection</span><span class="hljs-params">()</span></span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ConnectionPool.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 给外部提供接口，从连接池中获取一个可用的空闲连接</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">ConnectionPool::getConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-comment">// 互斥锁</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_queueMutex)</span></span>;<br><span class="hljs-comment">// 判断为空</span><br><span class="hljs-keyword">if</span> (_connectionQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 等待线程</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">问题：</span><br><span class="hljs-comment">当在等在中时，有连接唤醒了队列，在等待中被其他线程抢走了，那么队列依旧为空</span><br><span class="hljs-comment">在 wait_for 中有两个状态：</span><br><span class="hljs-comment">- no_timeout：未超时唤醒</span><br><span class="hljs-comment">- timeout：   超时唤醒</span><br><span class="hljs-comment">所以这里需要进行一个判断</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (cv_status::timeout == cv.<span class="hljs-built_in">wait_for</span>(lock, chrono::<span class="hljs-built_in">milliseconds</span>(_connectionTimeout)))<br>&#123;<br><span class="hljs-keyword">if</span> (_connectionQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;获取空闲连接超时了...获取连接失败!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">shared_ptr智能指针析构时，会把connection资源直接delete掉，相当于</span><br><span class="hljs-comment">调用connection的析构函数，connection就被close掉了。</span><br><span class="hljs-comment">这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到queue当中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">sp</span><span class="hljs-params">(_connectionQue.front(),</span></span><br><span class="hljs-params"><span class="hljs-function">[&amp;](Connection* pcon) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作</span></span></span><br><span class="hljs-params"><span class="hljs-function">unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 回到队列中</span></span></span><br><span class="hljs-params"><span class="hljs-function">_connectionQue.push(pcon);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-comment">// 出队消费</span><br>_connectionQue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 消费完连接以后，通知生产者线程检查一下，如果队列为空了，赶紧生产连接</span><br>cv.<span class="hljs-built_in">notify_all</span>();  <br><br><span class="hljs-keyword">return</span> sp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-最大空闲时间"><a href="#6-最大空闲时间" class="headerlink" title="6. 最大空闲时间"></a>6. 最大空闲时间</h3><p><code>Connection.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-comment">// 定义命名空间</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">实现 MySQL 数据库的增删改查</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Connection</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 刷新一下连接的起始的空闲时间点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">refreshAliveTime</span><span class="hljs-params">()</span> </span>&#123; _alivetime = <span class="hljs-built_in">clock</span>(); &#125;<br><span class="hljs-comment">// 返回存活的时间</span><br><span class="hljs-function"><span class="hljs-type">clock_t</span> <span class="hljs-title">getAliveeTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">clock</span>() - _alivetime; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 记录进入空闲状态后的起始存活时间</span><br><span class="hljs-type">clock_t</span> _alivetime;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ConnectionPool.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造</span><br>ConnectionPool::<span class="hljs-built_in">ConnectionPool</span>()<br>&#123;<br><span class="hljs-comment">// 加载配置项</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">loadConfigFile</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 创建初始数量的连接</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; _initSize; i++)<br>&#123;<br><span class="hljs-comment">// 实例化连接</span><br>Connection* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>();<br><span class="hljs-comment">// 调用 connection</span><br>p-&gt;<span class="hljs-built_in">connect</span>(_ip, _port, _username, _password, _dbname);<br><span class="hljs-comment">// 刷新空闲起始时间</span><br>p-&gt;<span class="hljs-built_in">refreshAliveTime</span>();<br><span class="hljs-comment">// 添加到队列中</span><br>_connectionQue.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-comment">// 连接量增加</span><br>_connectionCnt++;<br>&#125;<br><br><span class="hljs-comment">// 启动一个新的线程，作为连接的生产者 linux thread =&gt; pthread_create</span><br><span class="hljs-comment">// 需要一个线程函数，因为连接创建的是 C 接口函数，无法直接进行创建，所以创建了 produceConnectionTask</span><br><span class="hljs-function">thread <span class="hljs-title">produce</span><span class="hljs-params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 运行在独立的线程中，专门负责生产新连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::produceConnectionTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 循环，目的是反复查看</span><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br><span class="hljs-comment">// 创建互斥锁</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_queueMutex)</span></span>;<br><span class="hljs-comment">// 判断 连接队列是否为空</span><br><span class="hljs-keyword">if</span> (!_connectionQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 不为空，则进入生产者线程中进入等待状态</span><br>cv.<span class="hljs-built_in">wait</span>(lock);<br>&#125;<br><span class="hljs-comment">// 连接数量没有达到上限，继续创建新的连接</span><br><span class="hljs-keyword">if</span> (_connectionCnt &lt; _maxSize)<br>&#123;<br><span class="hljs-comment">// 实例化连接</span><br>Connection* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Connection</span>();<br><span class="hljs-comment">// 调用 connection</span><br>p-&gt;<span class="hljs-built_in">connect</span>(_ip, _port, _username, _password, _dbname);<br><span class="hljs-comment">// 刷新空闲起始时间</span><br>p-&gt;<span class="hljs-built_in">refreshAliveTime</span>();<br><span class="hljs-comment">// 添加到队列中</span><br>_connectionQue.<span class="hljs-built_in">push</span>(p);<br><span class="hljs-comment">// 连接量增加</span><br>_connectionCnt++;<br>&#125;<br><br><span class="hljs-comment">// 通知消费者线程，可以消费连接了</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 给外部提供接口，从连接池中获取一个可用的空闲连接</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">ConnectionPool::getConnection</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-comment">// 互斥锁</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_queueMutex)</span></span>;<br><span class="hljs-comment">// 判断为空</span><br><span class="hljs-keyword">if</span> (_connectionQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 等待线程</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">问题：</span><br><span class="hljs-comment">当在等在中时，有连接唤醒了队列，在等待中被其他线程抢走了，那么队列依旧为空</span><br><span class="hljs-comment">在 wait_for 中有两个状态：</span><br><span class="hljs-comment">- no_timeout：未超时唤醒</span><br><span class="hljs-comment">- timeout：   超时唤醒</span><br><span class="hljs-comment">所以这里需要进行一个判断</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (cv_status::timeout == cv.<span class="hljs-built_in">wait_for</span>(lock, chrono::<span class="hljs-built_in">milliseconds</span>(_connectionTimeout)))<br>&#123;<br><span class="hljs-keyword">if</span> (_connectionQue.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-built_in">LOG</span>(<span class="hljs-string">&quot;获取空闲连接超时了...获取连接失败!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">shared_ptr智能指针析构时，会把connection资源直接delete掉，相当于</span><br><span class="hljs-comment">调用connection的析构函数，connection就被close掉了。</span><br><span class="hljs-comment">这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到queue当中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">shared_ptr&lt;Connection&gt; <span class="hljs-title">sp</span><span class="hljs-params">(_connectionQue.front(),</span></span><br><span class="hljs-params"><span class="hljs-function">[&amp;](Connection* pcon) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作</span></span></span><br><span class="hljs-params"><span class="hljs-function">unique_lock&lt;mutex&gt; lock(_queueMutex);</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 刷新空闲起始时间</span></span></span><br><span class="hljs-params"><span class="hljs-function">pcon-&gt;refreshAliveTime();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 回到队列中</span></span></span><br><span class="hljs-params"><span class="hljs-function">_connectionQue.push(pcon);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-comment">// 出队消费</span><br>_connectionQue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 消费完连接以后，通知生产者线程检查一下，如果队列为空了，赶紧生产连接</span><br>cv.<span class="hljs-built_in">notify_all</span>();  <br><br><span class="hljs-keyword">return</span> sp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-回收超时连接线程"><a href="#7-回收超时连接线程" class="headerlink" title="7. 回收超时连接线程"></a>7. 回收超时连接线程</h3><p> <code>ConnectionPool.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">连接池功能模块</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// --------</span><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 3. 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scannerConnectionTask</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>ConnectionPool.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造</span><br>ConnectionPool::<span class="hljs-built_in">ConnectionPool</span>()<br>&#123;<br><span class="hljs-comment">// 加载配置项</span><br><span class="hljs-comment">// -------</span><br><br><span class="hljs-comment">// 启动一个新的线程，作为连接的生产者 linux thread =&gt; pthread_create</span><br><span class="hljs-comment">// 需要一个线程函数，因为连接创建的是 C 接口函数，无法直接进行创建，所以创建了 produceConnectionTask</span><br><span class="hljs-function">thread <span class="hljs-title">produce</span><span class="hljs-params">(std::bind(&amp;ConnectionPool::produceConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>produce.<span class="hljs-built_in">detach</span>();<br><br><span class="hljs-comment">// 启动一个新的定时线程，扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 scannerConnectionTask</span><br><span class="hljs-function">thread <span class="hljs-title">scanner</span><span class="hljs-params">(std::bind(&amp;ConnectionPool::scannerConnectionTask, <span class="hljs-keyword">this</span>))</span></span>;<br>scanner.<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-comment">// 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 scannerConnectionTask</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ConnectionPool::scannerConnectionTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 循环扫描</span><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br><span class="hljs-comment">// 使用 sleep 模拟定时效果</span><br>this_thread::<span class="hljs-built_in">sleep_for</span>(chrono::<span class="hljs-built_in">seconds</span>(_maxIdleTime));<br><br><span class="hljs-comment">// 扫描整个队列，释放多余的连接</span><br><span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_queueMutex)</span></span>;<br><span class="hljs-comment">// 循环遍历</span><br><span class="hljs-keyword">while</span> (_connectionCnt &gt; _initSize)<br>&#123;<br><span class="hljs-comment">// 指向队列第一个</span><br>Connection* p = _connectionQue.<span class="hljs-built_in">front</span>();<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (p-&gt;<span class="hljs-built_in">getAliveeTime</span>() &gt;= (_maxIdleTime * <span class="hljs-number">1000</span>))<br>&#123;<br><span class="hljs-comment">// 出队</span><br>_connectionQue.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 数量递减</span><br>_connectionCnt--;<br><span class="hljs-comment">// 调用~Connection()释放连接</span><br><span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// 队头的连接没有超过_maxIdleTime，其它连接肯定没有</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连接池压力测试"><a href="#连接池压力测试" class="headerlink" title="连接池压力测试"></a>连接池压力测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Connection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ConnectionPool.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//int main()</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">///*</span><br><span class="hljs-comment">//*  测试 数据库连接、添加功能</span><br><span class="hljs-comment">//Connection con;</span><br><span class="hljs-comment">//char sql[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">//// 创建 sql 语句</span><br><span class="hljs-comment">//sprintf(sql, &quot;insert into users(name, age, sex) values(&#x27;%s&#x27;, &#x27;%d&#x27;, &#x27;%s&#x27;)&quot;,</span><br><span class="hljs-comment">//&quot;zs&quot;, 20, &quot;male&quot;);</span><br><span class="hljs-comment">//// 连接</span><br><span class="hljs-comment">//con.connect(&quot;127.0.0.1&quot;, 3306, &quot;root&quot;, &quot;root&quot;, &quot;chat&quot;);</span><br><span class="hljs-comment">//con.update(sql);</span><br><span class="hljs-comment">//*/</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//// 测试配置文件</span><br><span class="hljs-comment">//ConnectionPool* cp = ConnectionPool::getConnectionPool();</span><br><span class="hljs-comment">////cp-&gt;loadConfigFile();</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//return 0;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">clock_t</span> begin = <span class="hljs-built_in">clock</span>();<br>ConnectionPool* p = ConnectionPool::<span class="hljs-built_in">getConnectionPool</span>();<br><br><span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">250</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">/*Connection conn;</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">char sql[1024];</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">sprintf(sql,&quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;,i,i);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.connect(&quot;127.0.0.1&quot;, 3306, &quot;root&quot;, &quot;root&quot;, &quot;javaweb_login&quot;);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.update(sql);*/</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">ConnectionPool* p = ConnectionPool::getConnectionPool();</span></span><br><span class="hljs-params"><span class="hljs-function">shared_ptr&lt;Connection&gt; conn = p-&gt;getConnection();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">char</span> sql[<span class="hljs-number">1024</span>];</span></span><br><span class="hljs-params"><span class="hljs-function">sprintf(sql, <span class="hljs-string">&quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;</span>, i, i);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3306</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;javaweb_login&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;update(sql);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">t2</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">250</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">/*Connection conn;</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">char sql[1024];</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">sprintf(sql, &quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;, i, i);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.connect(&quot;127.0.0.1&quot;, 3306, &quot;root&quot;, &quot;root&quot;, &quot;javaweb_login&quot;);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.update(sql);*/</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">ConnectionPool* p = ConnectionPool::getConnectionPool();</span></span><br><span class="hljs-params"><span class="hljs-function">shared_ptr&lt;Connection&gt; conn = p-&gt;getConnection();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">char</span> sql[<span class="hljs-number">1024</span>];</span></span><br><span class="hljs-params"><span class="hljs-function">sprintf(sql, <span class="hljs-string">&quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;</span>, i, i);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3306</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;javaweb_login&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;update(sql);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><span class="hljs-function">thread <span class="hljs-title">t3</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">500</span>; i &lt; <span class="hljs-number">750</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">/*Connection conn;</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">char sql[1024];</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">sprintf(sql, &quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;, i, i);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.connect(&quot;127.0.0.1&quot;, 3306, &quot;root&quot;, &quot;root&quot;, &quot;javaweb_login&quot;);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.update(sql);*/</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">ConnectionPool* p = ConnectionPool::getConnectionPool();</span></span><br><span class="hljs-params"><span class="hljs-function">shared_ptr&lt;Connection&gt; conn = p-&gt;getConnection();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">char</span> sql[<span class="hljs-number">1024</span>];</span></span><br><span class="hljs-params"><span class="hljs-function">sprintf(sql, <span class="hljs-string">&quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;</span>, i, i);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3306</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;javaweb_login&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;update(sql);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-function">thread <span class="hljs-title">t4</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">750</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">/*Connection conn;</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">char sql[1024];</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">sprintf(sql, &quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;, i, i);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.connect(&quot;127.0.0.1&quot;, 3306, &quot;root&quot;, &quot;root&quot;, &quot;javaweb_login&quot;);</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">conn.update(sql);*/</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">ConnectionPool* p = ConnectionPool::getConnectionPool();</span></span><br><span class="hljs-params"><span class="hljs-function">shared_ptr&lt;Connection&gt; conn = p-&gt;getConnection();</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">char</span> sql[<span class="hljs-number">1024</span>];</span></span><br><span class="hljs-params"><span class="hljs-function">sprintf(sql, <span class="hljs-string">&quot; insert into user values(NULL, &#x27;%d&#x27;, &#x27;%d&#x27;)&quot;</span>, i, i);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3306</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;javaweb_login&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">conn-&gt;update(sql);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br>t3.<span class="hljs-built_in">join</span>();<br>t4.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-type">clock_t</span> end = <span class="hljs-built_in">clock</span>();<br>cout &lt;&lt; end - begin &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">getchar</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>MySQL</tag>
      
      <tag>对象池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.C++ 多线程编程</title>
    <link href="/2023/08/22/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/11.C++%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/08/22/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/11.C++%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本节分为五部分：</p><ul><li>C++ 11 的 thread 多线程类</li><li>线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁</li><li>线程间同步通信 - 生产者消费者模型</li><li>再谈 lock_guard 和 unique_lock</li><li>基于 CAS 操作的 atomic 原子类型</li></ul><p><strong>什么是多线程？</strong></p><p><strong>多线程（multithreading）</strong>：是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p><p>在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。</p><p><strong>进程与线程：</strong></p><p>进程是正在运行的程序的实例，而线程是是进程中的实际运作单位。</p><p>线程是操作系统能够进行<strong>运算调度的最小单位</strong>。被包含在进程之中，是<strong>进程的实际运作单位</strong>。一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发执行多个线程，每个线程会执行不同的任务。</p><p><strong>区别：</strong></p><ul><li>一个程序有且只有一个进程，但可以拥有至少一个的线程。</li><li>不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221613179.png" alt="image.png"></p><h2 id="1-C-11-的-thread-多线程类"><a href="#1-C-11-的-thread-多线程类" class="headerlink" title="1. C++ 11 的 thread 多线程类"></a>1. C++ 11 的 thread 多线程类</h2><p>C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是<code>&lt;atomic&gt;</code> ,<code>&lt;thread&gt;</code>,<code>&lt;mutex&gt;</code>,<code>&lt;condition_variable&gt;</code> 和 <code>&lt;future&gt;</code>。</p><ol><li><code>&lt;atomic&gt;</code>：该头文件主要声明两个类：<ul><li><code>std::atomic</code></li><li><code>std::atomic_flag</code><br> 另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li></ul></li><li><code>&lt;thread&gt;</code>：该头文件主要声明一个类：<ul><li><code>std::thread</code></li><li>另外 <code>std::this_thread</code> 命名空间也在该头文件中。</li></ul></li><li><code>&lt;mutex&gt;</code>：该头文件主要声明了与互斥量（mutex）相关的类：<ul><li><code>std::mutex</code></li><li><code>std::lock_guard</code></li><li><code>std::unique_lock</code><br> 以及其他的类型和函数。</li></ul></li><li><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类：<ul><li><code>std::condition_variable</code></li><li><code>std::condition_varible_any</code></li></ul></li><li><code>&lt;future&gt;</code>：该头文件主要声明了两个 Provider 类和 两个 Futrue 类：<ul><li><code>std::promise</code>：Provider 类</li><li><code>std::package_task</code>：Provider 类</li><li><code>std::future</code>：Futrue 类</li><li><code>std::shared_futrue</code>：Futrue 类<br> 另外还有一些与之相关的类型和函数：</li><li><code>std::async()</code> 函数声明在该文件中。</li></ul></li></ol><h3 id="1-开启和关闭线程"><a href="#1-开启和关闭线程" class="headerlink" title="1. 开启和关闭线程"></a>1. 开启和关闭线程</h3><p>在<strong>语言级别</strong>，一般调用 std 名称空间的 thread 类来启动一个线程。 </p><p>其对应操作系统层次的一下系统调用：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">windows： createThread<br>linux：   pthread_create<br></code></pre></td></tr></table></figure><p>以下是 thread 类的一个构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fn</span>, <span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread</span> <span class="hljs-params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>可以看到，其需要一个<strong>线程函数（也可以是类对象和 lambda 表达式）以及这个函数所需要传入的参数</strong>。</p><ol><li><strong>引入头文件：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>创建线程对象：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle1</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle2</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread2!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">3</span>)</span></span>;<br><br><br>cout &lt;&lt; <span class="hljs-string">&quot;main thread done&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：</p><p>主线程运行完成后，查看如果当前进程还有未运行完成的子线程，进程就会异常终止。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221632970.png" alt="image.png"></p><p>线程除了站在我们角度上的以名字区分，它还有一个属于自己的 id！通过 <code>std::thread::get_id()</code> 便可以获取到该成员对象线程的 id。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;t1 thread: ID = &quot;</span> &lt;&lt; t1.<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>而在线程函数中通过 <code>std::this_thread::get_id()</code> 获取线程 id。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;Inside t2 thread: ID = &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221643499.png" alt="image.png"></p><ol start="3"><li><strong>终止子线程：</strong></li></ol><p>**t.join()**：创建线程执行线程函数，调用该函数会阻塞当前线程，直到线程执行完 join 才返回；等待t线程结束，当前线程继续往下运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle1</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle2</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread2!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">3</span>)</span></span>;<br><br><span class="hljs-comment">// 终止</span><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;main thread done&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221638021.png" alt="image.png"></p><p>**t.detach()**：detach 调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的 <code>std::thread</code> 对象失去对目标线程的关联，无法再通过 <code>std::thread</code> 对象取得该线程的控制权，由操作系统负责回收资源；主线程结束，整个进程结束，所有子线程都自动结束了！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle1</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadHadnle2</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 让子线程睡眠 time 秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(time));<br>cout &lt;&lt; <span class="hljs-string">&quot;hello thread2!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(threadHadnle1, <span class="hljs-number">3</span>)</span></span>;<br><br><span class="hljs-comment">// 终止</span><br>t1.<span class="hljs-built_in">detach</span>();<br>t2.<span class="hljs-built_in">detach</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;main thread done&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221639317.png" alt="image.png"></p><p><strong>线程如何结束：</strong></p><ol><li>线程函数返回（推荐）</li><li>调用 ExitThread 函数，线程自行撤销</li><li>同一进程或者另一个进程中调用 TerminateThread 函数</li><li>ExitProcess 和 TerminateProcess 函数可以终止线程进行</li></ol><h2 id="2-线程间互斥-mutex-互斥锁和-lock-guard-自动释放锁"><a href="#2-线程间互斥-mutex-互斥锁和-lock-guard-自动释放锁" class="headerlink" title="2. 线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁"></a>2. 线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁</h2><p>Mutex 又称互斥量，C++ 11 中与 Mutex 相关的类（包括锁类型）和函数都声明在 <code>&lt;mutex&gt;</code> 头文件中，所以使用 <code>std::mutex</code>，就必须包含 <code>&lt;mutex&gt;</code> 头文件。</p><h3 id="1-头文件介绍"><a href="#1-头文件介绍" class="headerlink" title="1. &lt;mutex&gt; 头文件介绍"></a>1. <code>&lt;mutex&gt;</code> 头文件介绍</h3><ul><li><p><strong>Mutex 系列类（四种）：</strong></p><ol><li><code>std::mutex</code>：最基本的 Mutex 类</li><li><code>std::recursive_mutex</code>：递归 Mutex 类</li><li><code>std::time_mutex</code>：定时 Mutex 类</li><li><code>std::recursive_timed_mutex</code>：定时递归 Mutex 类</li></ol></li><li><p><strong>Lock 类（两种）：</strong></p><ol><li><code>std::lock_guard</code>：与 Mutex RAII 相关，方便线程对互斥量上锁。</li><li><code>std::unique_lock</code>：与 Mutex RAII 相关，方便线程对互斥量上锁，但是提供了更好的上锁和解锁控制。</li></ol></li><li><p><strong>其他类型：</strong></p><ol><li><code>std::once_flag</code></li><li><code>std::adopt_lock_t</code></li><li><code>std::defer_lock_t</code></li><li><code>std::try_to_lock_t</code></li></ol></li><li><p><strong>函数：</strong></p><ol><li><code>std::try_lock</code>：尝试同时对多个互斥量上锁</li><li><code>std::lock</code>：可以同时对多个互斥量上锁</li><li><code>std::call_once</code>：如果多个线程需要同时调用某个函数，<code>call_once</code> 可以保证多个线程对该函数只调用一次。</li></ol></li></ul><h3 id="2-std-mutex-介绍"><a href="#2-std-mutex-介绍" class="headerlink" title="2. std::mutex 介绍"></a>2. <code>std::mutex</code> 介绍</h3><p>下面以 <code>std::mutex</code> 为例介绍 C++ 11 中的互斥量用法。</p><p><code>std::mutex</code> 是 C++ 11 中最基本的互斥量，<code>std::mutex</code> 对象提供了独占所有权的特性——即不支持递归地对 <code>std::mutex</code> 对象上锁，而 <code>std::recursive_lock</code> 则可以递归地对互斥量对象上锁。</p><p><code>std::mutex</code> 成员函数：</p><ul><li><strong>构造函数</strong>：<code>std::mutex</code> 不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 <strong>unlocked 状态</strong>的</li><li>**lock()**：调用线程将锁住该互斥量。线程调用该函数会发生一下三种情况：<ol><li>如果该互斥里昂当前没有被锁住，则调用线程将该互斥量舵主，知道调用了 unlock 志强，该线程一直拥有该锁。</li><li>如果当前互斥被其他线程锁住，则当前的调用线程被阻塞。</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(<strong>deadlock</strong>)。</li></ol></li><li>**unlock()**：解锁，释放互斥量的所有权。</li><li>**try_lock()**：尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面三种情况：<ol><li>如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</li><li>如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</li><li>如果当前互斥量被当前调用线程锁住，则会产生死锁(<strong>deadlock</strong>)。</li></ol></li></ul><p>为了保证 <code>lock()</code> 和 <code>unlock()</code> 对应使用，一般不直接使用 mutex，而是和 <code>lock_guard</code>、<code>unique_lock</code> 一起使用。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><p>在多线程环境中运行的代码段，需要考虑是否存在竞态条件，如果存在竞态条件，就是说该代码段不是线程安全的，不能直接运行在多线程环境当中，对于这样的代码段，被称之为：临界区资源，对于临界区资源，多线程环境下需要保证它以原子操作执行，要保证临界区的原子操作，就需要用到线程间的互斥操作-锁机制，thread 类库还提供了更轻量级的基于 CAS 操作的原子操作类。</p><ul><li><strong>无锁时：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span><span class="hljs-comment">//C++11线程库提供的原子类</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span><span class="hljs-comment">//C++线程类库的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br> <br><span class="hljs-type">int</span> ticketCount = <span class="hljs-number">1</span>;<br> <br><span class="hljs-comment">//线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sumTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//每个线程给count加10次</span><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">40</span>; ++i)<br>  &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;窗口:&quot;</span> &lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;卖出第:&quot;</span> &lt;&lt; ticketCount &lt;&lt; <span class="hljs-string">&quot; 张票!&quot;</span> &lt;&lt; endl;<br>ticketCount++;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>  &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 开启线程</span><br>list&lt;std::thread&gt; tlist;<br><span class="hljs-comment">// 开启三个窗口</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>&#123;<br>tlist.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(sellTickets, i));<br>&#125;<br><br><span class="hljs-comment">// foreach 遍历终止线程</span><br><span class="hljs-keyword">for</span> (std::thread&amp; t : tlist)<br>&#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br> <br>​<br></code></pre></td></tr></table></figure><p>多线程同时对 ticketCount 进行操作，并不能保证同时只有一个线程对 ticketCount 执行 <code>++</code> 操作。最后的的结果不一定是100；</p><ul><li><strong>有锁操作：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 全局的一把互斥锁</span><br>std::mutex mtx; <br><br><span class="hljs-comment">// 数量</span><br><span class="hljs-type">int</span> ticketCount = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 模拟买票的线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sellTickets</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">40</span> ; i++)<br>&#123;<br>&#123;<br><span class="hljs-comment">// 保证所有线程都能释放锁，防止死锁问题的发生 scoped_ptr</span><br><span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-comment">// 临界区代码段  =&gt;  原子操作 =&gt; 线程间互斥操作了 =&gt; mutex</span><br>cout &lt;&lt; <span class="hljs-string">&quot;窗口:&quot;</span> &lt;&lt; index &lt;&lt; <span class="hljs-string">&quot;卖出第:&quot;</span> &lt;&lt; ticketCount &lt;&lt; <span class="hljs-string">&quot; 张票!&quot;</span> &lt;&lt; endl;<br>ticketCount++;<br>&#125;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 开启线程</span><br>list&lt;std::thread&gt; tlist;<br><span class="hljs-comment">// 开启三个窗口</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>&#123;<br>tlist.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(sellTickets, i));<br>&#125;<br><br><span class="hljs-comment">// foreach 遍历终止线程</span><br><span class="hljs-keyword">for</span> (std::thread&amp; t : tlist)<br>&#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对 <code>count++</code> 操作上锁，保证一次只有一个线程能对其操作，结果是 120。</p><h2 id="3-线程间同步通信-生产者消费者模型"><a href="#3-线程间同步通信-生产者消费者模型" class="headerlink" title="3. 线程间同步通信 - 生产者消费者模型"></a>3. 线程间同步通信 - 生产者消费者模型</h2><p>多线程在运行过程中，各个线程都是随着 OS 的调度算法，占用 CPU 时间片来执行指令做事情，每个线程的运行完全没有顺序可言。但是在某些应用场景下，一个线程需要等待另外一个线程的运行结果，才能继续往下执行，这就需要涉及线程之间的同步通信机制。</p><p>线程间同步通信最典型的例子就是<strong>生产者-消费者模型</strong>，生产者线程生产出产品以后，会通知消费者线程去消费产品；如果消费者线程去消费产品，发现还没有产品生产出来，它需要通知生产者线程赶快生产产品，等生产者线程生产出产品以后，消费者线程才能继续往下执行。</p><p>C++ 11 线程库提供的条件变量 <code>condition_variable</code>，就是 Linux 平台下的 Condition Variable 机制，用于解决线程间的同步通信问题，下面通过代码演示一个生产者-消费者线程模型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>           <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>             <span class="hljs-comment">//std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>              <span class="hljs-comment">//std::mutex, std::unique_lock</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span> <span class="hljs-comment">//std::condition_variable</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义互斥锁(条件变量需要和互斥锁一起使用)</span><br>std::mutex mtx;<br><span class="hljs-comment">//定义条件变量(用来做线程间的同步通信)</span><br>std::condition_variable cv;<br><br><span class="hljs-comment">// 定义：</span><br><span class="hljs-comment">// 生产者生产一个物品，通知消费者消费一个；</span><br><span class="hljs-comment">// 消费完成后通知生产者继续生产物品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 生产物品</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// lock_guard&lt;std::mutex&gt; guard(mtx); // scoped_ptr</span><br><span class="hljs-comment">// 设置锁</span><br><span class="hljs-function">unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-comment">// 遍历生产物品队列中是否存有商品</span><br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// que不为空，生产者应该通知消费者去消费，消费完了，再继续生产</span><br><span class="hljs-comment">// 生产者线程进入等待状态，并且把mtx互斥锁释放掉</span><br>cv.<span class="hljs-built_in">wait</span>(lck);<br>&#125;<br><span class="hljs-comment">// 存放货物</span><br>que.<span class="hljs-built_in">push</span>(val);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">notify_one：通知另外的一个线程</span><br><span class="hljs-comment">notify_all：通知其他所有线程</span><br><span class="hljs-comment">通知其它所有的线程，我生产了一个物品，你们赶紧消费吧</span><br><span class="hljs-comment">其它线程得到该通知，就会从等待状态 =&gt; 阻塞状态 =&gt; 获取互斥锁才能继续执行</span><br><span class="hljs-comment">*/</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;生产者正在生产：&quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; 号物品。&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 消费物品</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// lock_guard&lt;std::mutex&gt; guard(mtx); // scoped_ptr</span><br><span class="hljs-function">unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-keyword">while</span> (que.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// 消费者线程发现que是空的，通知生产者线程先生产物品</span><br><span class="hljs-comment">// 进入等待状态 # 把互斥锁mutex释放</span><br>cv.<span class="hljs-built_in">wait</span>(lck);<br>&#125;<br><span class="hljs-type">int</span> val = que.<span class="hljs-built_in">front</span>();<br>que.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 通知其它线程我消费完了，赶紧生产吧</span><br>cv.<span class="hljs-built_in">notify_all</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;消费者 消费:&quot;</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; 号物品。&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> val;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>queue&lt;<span class="hljs-type">int</span>&gt; que;<br>&#125;;<br><br><span class="hljs-comment">// 生产者线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(Queue* que)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>que-&gt;<span class="hljs-built_in">put</span>(i);<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125;<br><span class="hljs-comment">// 消费者线程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(Queue* que)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; ++i)<br>&#123;<br>que-&gt;<span class="hljs-built_in">get</span>();<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建队列</span><br>Queue que;<br><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(producer, &amp;que)</span></span>;<br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(consumer, &amp;que)</span></span>;<br><br>t1.<span class="hljs-built_in">join</span>();<br>t2.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241033564.png" alt="image.png"></p><h2 id="4-再谈-lock-guard-和-unique-lock"><a href="#4-再谈-lock-guard-和-unique-lock" class="headerlink" title="4. 再谈 lock_guard 和 unique_lock"></a>4. 再谈 lock_guard 和 unique_lock</h2><p>这两个其实可以类比智能指针来记：<br><code>lock_gurad</code> 类比于 <code>scoped_ptr</code>，它的拷贝构造和复制构造都被删除了，<strong>不可用在函数参数传递或者返回过程中</strong>，只能用在简单的临界区代码段的互斥操作中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lock_ <span class="hljs-title">guard</span><span class="hljs-params">(<span class="hljs-type">const</span> lock_ guard&amp;)</span></span>=<span class="hljs-keyword">delete</span>;<br>lock_ guard&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> lock_ guard&amp;)=<span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><p>而 <code>unique_lock</code> 可以类比于 <code>unique_ptr</code>，它不仅可以用在简单的临界代码段的互斥操作中，还能用在函数调用过程中。</p><p>总的来说，建议使用<code>unique_lock</code>.</p><h3 id="1-std-lock-gurad"><a href="#1-std-lock-gurad" class="headerlink" title="1. std::lock_gurad"></a>1. <code>std::lock_gurad</code></h3><p><code>std::lock_guard</code> 是 <code>RAII 模板类</code> 的简单实现，功能简单。</p><blockquote><ol><li>std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE lock_guard</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span><br>&#123;<br><span class="hljs-comment">// class with destructor that unlocks a mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> mutex_type = _Mutex;<br> <br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">lock_guard</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _MyMutex(_Mtx)</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock</span><br>_MyMutex.<span class="hljs-built_in">lock</span>();<br>&#125;<br> <br><span class="hljs-built_in">lock_guard</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _MyMutex(_Mtx)<br>&#123;<br><span class="hljs-comment">// construct but don&#x27;t lock</span><br>&#125;<br><br>~<span class="hljs-built_in">lock_guard</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-comment">// unlock</span><br>_MyMutex.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><br><span class="hljs-built_in">lock_guard</span>(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br>lock_guard&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> lock_guard&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">private</span>:<br>_Mutex&amp; _MyMutex;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>lock_gurad</code> 源码中看出，它在构造时进行上锁，在出作用域执行析构函数时释放锁；同时不允许拷贝构造和赋值运算符操作；</p><p>比较简单，不能用在函数参数传递或者返回过程中，因为它的拷贝构造和赋值运算符被禁用了；只能用在简单的临界区代码的互斥操作。</p><h3 id="2-std-unique-lock"><a href="#2-std-unique-lock" class="headerlink" title="2. std::unique_lock"></a>2. <code>std::unique_lock</code></h3><p>类 <code>unique_lock</code> 是通用互斥包装器，<strong>允许延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</strong>。</p><p><code>unique_lock</code> 比 <code>lock_guard</code> 使用更加灵活，功能更加强大。使用 <code>unique_lock</code> 需要付出更多的时间、性能成本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Mutex</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_lock</span><br>&#123;<br><span class="hljs-comment">// whizzy class with destructor that unlocks mutex</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> _Mutex mutex_type;<br> <br><span class="hljs-comment">// CONSTRUCT, ASSIGN, AND DESTROY</span><br><span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span><br>: _Pmtx(<span class="hljs-literal">nullptr</span>), _Owns(<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">// default construct</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx)</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx))</span><br><span class="hljs-function">, _Owns(false)</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock</span><br>_Pmtx-&gt;<span class="hljs-built_in">lock</span>();<br>_Owns = <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">adopt_lock_t</span>)<br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx))<br>, _Owns(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// construct and assume already locked</span><br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">defer_lock_t</span>) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx))<br>, _Owns(<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">// construct but don&#x27;t lock</span><br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">try_to_lock_t</span>)<br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx))<br>, _Owns(_Pmtx-&gt;<span class="hljs-built_in">try_lock</span>())<br>&#123;<br><span class="hljs-comment">// construct and try to lock</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Rep, <span class="hljs-keyword">class</span> _Period&gt;</span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx))</span><br><span class="hljs-function">, _Owns(_Pmtx-&gt;try_lock_for(_Rel_time))</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock with timeout</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Clock, <span class="hljs-keyword">class</span> _Duration&gt;</span><br><span class="hljs-function"><span class="hljs-title">unique_lock</span><span class="hljs-params">(_Mutex&amp; _Mtx,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)</span></span><br><span class="hljs-function">: _Pmtx(_STD addressof(_Mtx))</span><br><span class="hljs-function">, _Owns(_Pmtx-&gt;try_lock_until(_Abs_time))</span><br><span class="hljs-function">&#123;</span><br><span class="hljs-comment">// construct and lock with timeout</span><br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(_Mutex&amp; _Mtx, <span class="hljs-type">const</span> xtime *_Abs_time)<br>: _Pmtx(_STD <span class="hljs-built_in">addressof</span>(_Mtx)), _Owns(<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">// try to lock until _Abs_time</span><br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_until</span>(_Abs_time);<br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(unique_lock&amp;&amp; _Other) <span class="hljs-keyword">noexcept</span><br>: _Pmtx(_Other._Pmtx)<br>, _Owns(_Other._Owns)<br>&#123;<br><span class="hljs-comment">// destructive copy</span><br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br> <br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(unique_lock&amp;&amp; _Other)<br>&#123;<br><span class="hljs-comment">// destructive copy</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Other))<br>&#123;<br><span class="hljs-comment">// different, move contents</span><br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br><br>_Pmtx = _Other._Pmtx;<br>_Owns = _Other._Owns;<br>_Other._Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Other._Owns = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br> <br>~<span class="hljs-built_in">unique_lock</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-comment">// clean up</span><br><span class="hljs-keyword">if</span> (_Owns)<br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>&#125;<br> <br><span class="hljs-built_in">unique_lock</span>(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br>unique_lock&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_lock&amp;) = <span class="hljs-keyword">delete</span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// lock the mutex</span><br>_Validate();<br>_Pmtx-&gt;<span class="hljs-built_in">lock</span>();<br>_Owns = <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock the mutex</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock</span>();<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Rep, <span class="hljs-keyword">class</span> _Period&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock_for</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::duration&lt;_Rep, _Period&gt;&amp; _Rel_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock mutex for _Rel_time</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_for</span>(_Rel_time);<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Clock, <span class="hljs-keyword">class</span> _Duration&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; _Abs_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock mutex until _Abs_time</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_until</span>(_Abs_time);<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">try_lock_until</span><span class="hljs-params">(<span class="hljs-type">const</span> xtime *_Abs_time)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to lock the mutex until _Abs_time</span><br>_Validate();<br>_Owns = _Pmtx-&gt;<span class="hljs-built_in">try_lock_until</span>(_Abs_time);<br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// try to unlock the mutex</span><br><span class="hljs-keyword">if</span> (!_Pmtx || !_Owns)<br>_THROW(<span class="hljs-built_in">system_error</span>(<br>_STD <span class="hljs-built_in">make_error_code</span>(errc::operation_not_permitted)));<br> <br>_Pmtx-&gt;<span class="hljs-built_in">unlock</span>();<br>_Owns = <span class="hljs-literal">false</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_lock&amp; _Other)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// swap with _Other</span><br><span class="hljs-function">_STD <span class="hljs-title">swap</span><span class="hljs-params">(_Pmtx, _Other._Pmtx)</span></span>;<br><span class="hljs-function">_STD <span class="hljs-title">swap</span><span class="hljs-params">(_Owns, _Other._Owns)</span></span>;<br>&#125;<br> <br><span class="hljs-function">_Mutex *<span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// disconnect</span><br>_Mutex *_Res = _Pmtx;<br>_Pmtx = <span class="hljs-literal">nullptr</span>;<br>_Owns = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> (_Res);<br>&#125;<br> <br><span class="hljs-function">_NODISCARD <span class="hljs-type">bool</span> <span class="hljs-title">owns_lock</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return true if this object owns the lock</span><br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return true if this object owns the lock</span><br><span class="hljs-keyword">return</span> (_Owns);<br>&#125;<br> <br><span class="hljs-function">_NODISCARD _Mutex *<span class="hljs-title">mutex</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return pointer to managed mutex</span><br><span class="hljs-keyword">return</span> (_Pmtx);<br>&#125;<br> <br><span class="hljs-keyword">private</span>:<br>_Mutex *_Pmtx;<br><span class="hljs-type">bool</span> _Owns;<br> <br><span class="hljs-type">void</span> _Validate() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-comment">// check if the mutex can be locked</span><br><span class="hljs-keyword">if</span> (!_Pmtx)<br>_THROW(<span class="hljs-built_in">system_error</span>(<br>_STD <span class="hljs-built_in">make_error_code</span>(errc::operation_not_permitted)));<br> <br><span class="hljs-keyword">if</span> (_Owns)<br>_THROW(<span class="hljs-built_in">system_error</span>(<br>_STD <span class="hljs-built_in">make_error_code</span>(errc::resource_deadlock_would_occur)));<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中，有 <code>_Mutec* _Pmtx；</code> 只想一把锁的指针；不允许使用左值拷贝构造和赋值，但是可以使用右值拷贝构造和赋值，可以在函数调用过程中使用。</p><p>因此可以和条件变量一起使用：<code>cv.wait(lock);</code> 可以作为函数参数传入；</p><h2 id="5-基于-CAS-操作的-atomic-原子类型"><a href="#5-基于-CAS-操作的-atomic-原子类型" class="headerlink" title="5. 基于 CAS 操作的 atomic 原子类型"></a>5. 基于 CAS 操作的 atomic 原子类型</h2><p>因为锁的操作是比较重，对于系统消耗有些大，而且在临界区代码做的事情比较复杂，比较多。所以引入了 CAS 来保证上面的 <code>--操作</code> 的<strong>原子特性</strong>。同时这也是无锁操作。</p><p>C++ 11 的 thread 类库提供了针对简单类型的原子操作类，如： <code>std::atomic_int</code>，<code>atomic_long</code>，<code>atomic_bool</code> 等，它们值的增减都是基于 CAS 操作的，既保证了线程安全，效率还非常高。</p><blockquote><p>互斥锁用于比较复杂的场景，而简单的 ++，– 使用轻量的 atomic 原子类型即可。<br>一般也搭配 volatile使用，volatile 防止线程对变量进行缓存，操作的都是原始内存中的值。<br>不加 volatile 的话，每个线程都会拷贝一份自己的线程栈上的变量，带到 CPU 的寄存器，这样效率较高，但也可能出错。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span> <span class="hljs-comment">// C++11 线程库提供的原子类</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span> <span class="hljs-comment">// C++ 线程类库的头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br> <br><span class="hljs-keyword">volatile</span> std::atomic_bool isReady = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">volatile</span> std::atomic_int mycount = <span class="hljs-number">0</span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (!isReady)<br>&#123;<br><span class="hljs-comment">// 线程出让当前的CPU时间片，等待下一次调度</span><br>std::this_thread::<span class="hljs-built_in">yield</span>(); <br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)<br>&#123;<br>mycount++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>list&lt;std::thread&gt; tlist;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br>tlist.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(task));<br>&#125;<br><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>isReady = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span> (std::thread &amp;t : tlist)<br>&#123;<br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;mycount:&quot;</span> &lt;&lt; mycount &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="番外介绍：线程死锁"><a href="#番外介绍：线程死锁" class="headerlink" title="番外介绍：线程死锁"></a>番外介绍：线程死锁</h2><p><strong>概述死锁：</strong></p><p>线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于 <code>synchronized</code> 特性，一个线程池有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，而且会一直死等下去，因此便造成了死锁。</p><p><strong>死锁产生的条件：</strong></p><ul><li><strong>互斥条件</strong>：一个资源或者说一个锁只能被一个线程所占有，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其他线程均无法获取到这个锁。</li><li><strong>占有且等待</strong>：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。</li><li><strong>不可剥夺条件</strong>：任何一个线程都无法强制获取别的线程已经占有的锁。</li><li><strong>循环等待条件</strong>：线程A拿着线程B的锁，线程B拿着线程A的锁。</li></ul><h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h3><p>当一个程序的多个线程获取多个互斥锁资源的时候，就有可能发生死锁问题，比如线程 A 先获取了锁 1，线程 B 获取了锁 2，进而线程 A 还需要获取锁 2 才能继续执行，但是由于锁 2 被线程 B 持有还没有释放，线程 A 为了等待锁 2 资源就阻塞了；线程 B 这时候需要获取锁 1 才能往下执行，但是由于锁 1 被线程 A 持有，导致 A 也进入阻塞。</p><p>线程 A 和线程 B 都在等待对方释放锁资源，但是它们又不肯释放原来的锁资源，导致线程 A 和 B 一直互相等待，进程死锁了。下面代码示例演示这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>           <span class="hljs-comment">//std::cout</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span>             <span class="hljs-comment">//std::thread</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span>              <span class="hljs-comment">//std::mutex, std::unique_lock</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span> <span class="hljs-comment">//std::condition_variable</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br> <br><span class="hljs-comment">//锁资源1</span><br>std::mutex mtx1;<br><span class="hljs-comment">//锁资源2</span><br>std::mutex mtx2;<br> <br><span class="hljs-comment">//线程A的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//保证线程A先获取锁1</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockA</span><span class="hljs-params">(mtx1)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程A获取锁1&quot;</span> &lt;&lt; std::endl;<br> <br>  <span class="hljs-comment">//线程A睡眠2s再获取锁2，保证锁2先被线程B获取，模拟死锁问题的发生</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br> <br>  <span class="hljs-comment">//线程A先获取锁2</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockB</span><span class="hljs-params">(mtx2)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程A获取锁2&quot;</span> &lt;&lt; std::endl;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程A释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;<br>&#125;<br> <br><span class="hljs-comment">//线程B的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">taskB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//线程B先睡眠1s保证线程A先获取锁1</span><br>  std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockB</span><span class="hljs-params">(mtx2)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程B获取锁2&quot;</span> &lt;&lt; std::endl;<br> <br>  <span class="hljs-comment">//线程B尝试获取锁1</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lockA</span><span class="hljs-params">(mtx1)</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程B获取锁1&quot;</span> &lt;&lt; std::endl;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;线程B释放所有锁资源，结束运行！&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//创建生产者和消费者线程</span><br>  <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(taskA)</span></span>;<br>  <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(taskB)</span></span>;<br> <br>  <span class="hljs-comment">//main主线程等待所有子线程执行完</span><br>  t1.<span class="hljs-built_in">join</span>();<br>  t2.<span class="hljs-built_in">join</span>();<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241112703.png" alt="image.png"></p><p>可以看到，线程 A 获取锁 1、线程 B 获取锁 2 以后，进程就不往下继续执行了，一直等待在这里，如果这就碰到的一个问题场景，<strong>如何判断出这是由于线程间死锁引起的呢？</strong></p><p>打开 process Explorer。找到该进程，查看线程状态，发现线程的 cpu 利用率为 0，那么应该不是死循环，应该是死锁了：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241113352.png" alt="image.png"></p><p>断：查看每一个线程的函数执行的位置</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241115303.png" alt="image.png"></p><p>发现当前线程正在申请锁的位置,判断出应该是锁了。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241118313.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308241119893.png" alt="image.png"></p><p>同时主线程走了等待子线程结束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00.C++ 设计模式概述</title>
    <link href="/2023/08/21/04.C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/21/04.C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.C++%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>设计模式</strong>：是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。</p><p>设计模式与方法或库的使用方式不同，你很难直接在自己的程序中套用某个设计模式。模式并不是一段特定的代码，而是解决特定问题的一般性概念。你可以根据模式来实现符合自己程序实际所需的解决方案。</p><p>“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。 ——Christopher Alexander</p><p><strong>作用：</strong></p><ul><li>提高思维能力、编程能力和设计能力。</li><li>使程序<strong>设计更加标准化</strong>、代码编制<strong>更加工程化</strong>，使软件开发效率大大提高，从而<strong>缩短软件的开发周期</strong>。</li><li>使设计的代码<strong>可重用性高、可读性强、可靠性高、灵活性好、可维护性强</strong>。</li></ul><h2 id="7-种开发原则"><a href="#7-种开发原则" class="headerlink" title="7 种开发原则"></a>7 种开发原则</h2><blockquote><ol><li>开闭原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>单一职责原则</li><li>接口隔离职责</li><li>迪米特法则</li><li>合成复用原则</li></ol></blockquote><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h3><p><strong>定义：</strong></p><ul><li>Open Closed Principle, OCP</li><li>软件实体应当<strong>对扩展开发，对修改关闭</strong>。即：当应用的需求改变时，在不修改软件的实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</li></ul><p><strong>作用：</strong></p><ul><li><p>对软件测试的影响：<br>  测试时<strong>只需要对扩展的代码进行测试</strong>就可以了，因为原有的测试代码仍然能够正常运行。</p></li><li><p>提高代码的<strong>可复用</strong>性<br>  粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p></li><li><p>提高软件的<strong>可维护</strong>性<br>  稳定性高和延续性强，从而易于扩展和维护。</p></li></ul><h3 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2. 里氏替换原则"></a>2. 里氏替换原则</h3>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.C++ bind 绑定器和 function 函数对象</title>
    <link href="/2023/08/18/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/10.C++%20bind%20%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%20function%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/18/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/10.C++%20bind%20%E7%BB%91%E5%AE%9A%E5%99%A8%E5%92%8C%20function%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>本节分为四部分：</p><ol><li>C++ STL 中的绑定器</li><li>function 示例和实现</li><li>bind 和 function 实现线程池</li><li>lambda 表达式</li></ol><h2 id="1-C-STL-中的绑定器"><a href="#1-C-STL-中的绑定器" class="headerlink" title="1. C++ STL 中的绑定器"></a>1. C++ STL 中的绑定器</h2><h3 id="1-介绍绑定器"><a href="#1-介绍绑定器" class="headerlink" title="1. 介绍绑定器"></a>1. 介绍绑定器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bind1st<br><span class="hljs-comment">// 和</span><br>std::bind2nd<br></code></pre></td></tr></table></figure><p>以上两个函数用于将一个 <strong>二元函数对象</strong> 转换为 <strong>一元函数对象</strong> 。</p><p>bind 意思为：<strong>绑定</strong>，1st 代表 first；2nd 代表 second，说明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::binder1st&lt;F&gt; <span class="hljs-title">bind1st</span><span class="hljs-params">(<span class="hljs-type">const</span> F&amp; f, <span class="hljs-type">const</span> T&amp; x)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T &gt;</span><br><span class="hljs-function">std::binder2nd&lt;F&gt; <span class="hljs-title">bind2nd</span><span class="hljs-params">( <span class="hljs-type">const</span> F&amp; f, <span class="hljs-type">const</span> T&amp; x )</span></span><br></code></pre></td></tr></table></figure><p>将给定的参数 x 绑定到 二元函数对象 F 的第一个或第二个形参。也就是说，将 x 存储在该包装器中，如果调用该包装器，则将 x 作为 F 的第一个或第二个形参传递。</p><p><code>bind1st</code>：相当于操作：<code>x Operation value</code> &#x3D;&#x3D; <code>operator()</code> 的第一个形参变量绑定成一个确定的值。<br><code>bind2nd</code>：相当于操作：<code>Operation value x</code> &#x3D;&#x3D; <code>operator()</code> 的第二个形参变量绑定成一个确定的值。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211548667.png" alt="image.png"></p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContainer</span><span class="hljs-params">(Container&amp; con)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量</span><br><span class="hljs-comment">// typename告知编译器后面类型的作用域后面是类型</span><br><span class="hljs-keyword">typename</span> Container::iterator it = con.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != con.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义容器</span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br><br><span class="hljs-comment">// 遍历添加</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">//随机出来的数字，并不是有序的 </span><br>&#125;<br><br><span class="hljs-comment">// 初始化状态</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Init：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">// 从大到小排序</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Sort：&quot;</span>;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">// 把 70 按照顺序插入到 vec 容器当中，找第一个小于 70 的数字</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = <span class="hljs-built_in">find_if</span>(<br>vec.<span class="hljs-built_in">begin</span>(),<br>vec.<span class="hljs-built_in">end</span>(),<br><span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">70</span>)<br>);<br><span class="hljs-comment">// auto it1 = find_if(vec.begin(), vec.end(),bind2nd(less&lt;int&gt;(), 70));</span><br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (it != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br>vec.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">70</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Insert：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211600501.png" alt="image.png"></p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><ol><li><strong><code>find_if</code></strong> 源码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// FUNCTION TEMPLATE find_if</span><br>_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_InIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Pr</span>&gt;<br><span class="hljs-function">_NODISCARD _CONSTEXPR20 _InIt <span class="hljs-title">find_if</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">_InIt _First, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _InIt _Last, </span></span><br><span class="hljs-params"><span class="hljs-function">_Pr _Pred</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123; <br><span class="hljs-comment">// find first satisfying _Pred</span><br>    _Adl_verify_range(_First, _Last);<br>    <span class="hljs-keyword">auto</span> _UFirst      = _Get_unwrapped(_First);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> _ULast = _Get_unwrapped(_Last);<br>    <span class="hljs-keyword">for</span> (; _UFirst != _ULast; ++_UFirst) &#123;<br>        <span class="hljs-keyword">if</span> (_Pred(*_UFirst)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    _Seek_wrapped(_First, _UFirst);<br>    <span class="hljs-keyword">return</span> _First;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中第三个参数 <code>_Pred</code> 是一个一元函数对象</p><ol start="2"><li><strong><code>bind1st</code></strong> 源码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// FUNCTION TEMPLATE bind1st</span><br>_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fn</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD binder1st&lt;_Fn&gt; <span class="hljs-title">bind1st</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _Fn&amp; _Func, </span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> _Ty&amp; _Left</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// return a binder1st functor adapter</span><br>    <span class="hljs-keyword">typename</span> _Fn::first_argument_type _Val(_Left);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">binder1st</span>&lt;_Fn&gt;(_Func, _Val);<br>&#125;<br></code></pre></td></tr></table></figure><p>它是一个函数模板，返回一元函数对象 <code>binder1st</code></p><ol start="3"><li><strong><code>bind2nd</code></strong> 源码：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE binder1st</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fn</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">binder1st</span><br>: <span class="hljs-keyword">public</span> unary_function&lt;<br><span class="hljs-keyword">typename</span> _Fn::second_argument_type,<br><span class="hljs-keyword">typename</span> _Fn::result_type&gt;<br>&#123;<br><span class="hljs-comment">// functor adapter _Func(stored, right)</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> unary_function&lt;<br><span class="hljs-keyword">typename</span> _Fn::second_argument_type,<br><span class="hljs-keyword">typename</span> _Fn::result_type&gt; _Base;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Base::argument_type argument_type;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Base::result_type result_type;<br> <br><span class="hljs-built_in">binder1st</span>(<br><span class="hljs-type">const</span> _Fn&amp; _Func,<br><span class="hljs-type">const</span> <span class="hljs-keyword">typename</span> _Fn::first_argument_type&amp; _Left)<br>: <span class="hljs-built_in">op</span>(_Func)<br>, <span class="hljs-built_in">value</span>(_Left)<br>&#123;<br><span class="hljs-comment">// construct from functor and left operand</span><br>&#125;<br> <br><span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> argument_type&amp; _Right)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// apply functor to operands</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">op</span>(value, _Right));<br>&#125;<br> <br><span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(argument_type&amp; _Right)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// apply functor to operands</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">op</span>(value, _Right));<br>&#125;<br> <br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// the functor to apply</span><br>_Fn op;<br><span class="hljs-comment">// the left operand</span><br><span class="hljs-keyword">typename</span> _Fn::first_argument_type value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一元函数对象默认构造函数接受两个参数， <code>op</code> 和 <code>value</code>。赋值运算符接收一个参数，并使用传入的 <code>op</code> 和 <code>vaule</code> 进行运算：<code>op(value, _Right)</code></p><h3 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// bind1st 实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Container&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContainer</span><span class="hljs-params">(Container&amp; con)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量</span><br><span class="hljs-comment">// typename告知编译器后面类型的作用域后面是类型</span><br><span class="hljs-keyword">typename</span> Container::iterator it = con.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != con.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// 实现 find_if</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Compare&gt;</span><br><span class="hljs-function">Iterator <span class="hljs-title">my_find_if</span><span class="hljs-params">(Iterator first, Iterator last, Compare comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 遍历这2个迭代器之间的元素，如果满足函数对象的运算，就返回当前迭代器，如果都不满足，返回end()</span><br><span class="hljs-keyword">for</span> (; first != last; first++)<br>&#123;<br><span class="hljs-comment">// comp.operator()(*first)一元函数对象，因为要从容器拿1个元素和它指定的元素比较</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">comp</span>(*first))<br>&#123;<br><span class="hljs-comment">// my_find_if 需要 一元函数对象，而在库里面都是二元的</span><br><span class="hljs-keyword">return</span> first;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> last;<br>&#125;<br><br><span class="hljs-comment">// 实现 bind1st</span><br><span class="hljs-comment">// 绑定器是函数对象的一个应用</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_mybind1st</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>_mybind1st(Compare comp, T val)<br>: _comp(comp)<br>, _val(val)<br>&#123;<br><span class="hljs-comment">// 列表初始化</span><br>&#125;<br><br><span class="hljs-comment">// 函数对象</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; second)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _comp(_val, second);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Compare _comp;<br>T _val;<br>&#125;;<br><br><span class="hljs-comment">// mybind1st(greater&lt;int&gt;(), 70)</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Compare, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">_mybind1st&lt;Compare, T&gt; <span class="hljs-title">mybind1st</span><span class="hljs-params">(Compare comp, <span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 直接使用函数模板，好处是，可以进行类型的推演</span><br><span class="hljs-keyword">return</span> _mybind1st&lt;Compare, T&gt;(comp, val);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Init：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">// greater 二元函数对象</span><br><span class="hljs-comment">// 大到小排序</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>cout &lt;&lt; <span class="hljs-string">&quot;Sort：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">把70按顺序插入到vec容器当中   找第一个小于70的数字</span><br><span class="hljs-comment">operator()(const T &amp;val)</span><br><span class="hljs-comment">greater   a &gt; b</span><br><span class="hljs-comment">less      a &lt; b</span><br><span class="hljs-comment">绑定器 + 二元函数对象 =&gt; 一元函数对象</span><br><span class="hljs-comment">bind1st: + greater bool operator()(70, const _Ty&amp; _Right)</span><br><span class="hljs-comment">bind2nd: + less bool operator()(const _Ty&amp; _Left, 70)</span><br><span class="hljs-comment">*/</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it1 = <span class="hljs-built_in">my_find_if</span>(<br>vec.<span class="hljs-built_in">begin</span>(), <br>vec.<span class="hljs-built_in">end</span>(),<br><span class="hljs-built_in">mybind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">70</span>)<br>);<br><span class="hljs-comment">// auto it1 = my_find_if(vec.begin(), vec.end(),bind2nd(less&lt;int&gt;(), 70));</span><br><span class="hljs-keyword">if</span> (it1 != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br>vec.<span class="hljs-built_in">insert</span>(it1, <span class="hljs-number">70</span>);<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Insert：&quot;</span>;<br><span class="hljs-built_in">showContainer</span>(vec);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211759070.png" alt="image.png"></p><h2 id="2-function-示例和实现"><a href="#2-function-示例和实现" class="headerlink" title="2. function 示例和实现"></a>2. function 示例和实现</h2><p>function 是一个函数包装器模板，最早来自 boost 库。在 c11 标准中将其纳入标准库。该函数包装器模板可以包装任何类型的可调用元素，<strong>例如普通函数和函数对象</strong>。  </p><p>function 最大的作用就是<strong>保留可调用元素的类型</strong>。</p><p>解决绑定器，函数对象，lambda 表达式只能使用在一条语句中的问题；</p><p>定义：传递一个  <code>_Fty  function type</code> 希望传递一个函数类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <br><span class="hljs-comment">// CLASS TEMPLATE function</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">function</span><br>: <span class="hljs-keyword">public</span> _Get_function_impl&lt;_Fty&gt;::type<br>&#123;<br><span class="hljs-comment">// wrapper for callable objects</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Get_function_impl&lt;_Fty&gt;::type _Mybase;<br> <br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">function</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-comment">// construct empty function wrapper</span><br>&#125;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-function的应用"><a href="#1-function的应用" class="headerlink" title="1. function的应用"></a>1. function的应用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world1!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// void (*pfunc)(string)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; str &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Sum：&quot;</span>;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 必须依赖一个对象 void (Test::*pfunc)(string)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.用函数类型实例化 function</span><br><span class="hljs-comment">2.通过 function 调用 operator() 函数的时候，需要根据函数类型传入相应的参数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 从 function 的类模板定义出，看到希望用一个函数类型实例化 function</span><br>function&lt;<span class="hljs-type">void</span>()&gt; func1 = hello1;<br><span class="hljs-comment">// func1.operator()() =&gt; hello();</span><br><span class="hljs-built_in">func1</span>();<br><br>function&lt;<span class="hljs-type">void</span>(string)&gt; func2 = hello2;<br><span class="hljs-built_in">func2</span>(<span class="hljs-string">&quot;hello world2!&quot;</span>);<br><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func3 = sum;<br><span class="hljs-built_in">sum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// operator() 表达式</span><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; func4 =<br>[](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cout &lt;&lt; <span class="hljs-string">&quot;function::operator()：&quot;</span> &lt;&lt; <span class="hljs-built_in">func4</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// 成员函数变量</span><br>function&lt;<span class="hljs-type">void</span>(Test*, string)&gt; func5 = &amp;Test::hello;<br>Test* t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-built_in">func5</span>(t, <span class="hljs-string">&quot;call Test::hello!&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类成员函数  </span><br><span class="hljs-comment">// 报错：&amp; 左值引用问题</span><br>function&lt;<span class="hljs-type">void</span>(Test*, string)&gt; func5 = &amp;Test::hello;<br>   <span class="hljs-built_in">func5</span>(&amp;<span class="hljs-built_in">Test</span>(), <span class="hljs-string">&quot;call Test::hello!&quot;</span>);<span class="hljs-comment">//临时对象调用</span><br></code></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>其实是可以实现取地址的，对象是在站内构造的，可以通过栈偏移指向；但是编译器不支持，无法实现兼容。</p><p>报左值引用错误是因为<strong>仿函数</strong>要用，上面初始化的仿函数是个 this call，要提供 this，而 this 是结构体的指针，无法通过取地址实现，而且临时构造不能允许取地址。</p><p><code>test()</code> 的声明周期就那一行，结束就被销毁了是个右值，只有左值能取址。</p><h3 id="2-模板的完全特例化和部分特例化"><a href="#2-模板的完全特例化和部分特例化" class="headerlink" title="2. 模板的完全特例化和部分特例化"></a>2. 模板的完全特例化和部分特例化</h3><p>对于下面的 compare，对于 char 类型的比较不能满足实际的需要，因此对 compare 特例化一个版本 <code>compare&lt;const char *&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;template compare&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-type">bool</span> <span class="hljs-built_in">compare</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)<span class="hljs-comment">//特例化 </span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;compare&lt;const char*&gt;&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a, b) &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<span class="hljs-comment">// </span><br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<span class="hljs-comment">//T const char*</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>匹配原则：有完全特例化则先匹配完全特例化，其次部分特例化，最后函数模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector template init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 下面这个是对char*类型提供的完全特例化版本（&lt;&gt;中T已知：即下面的char *）  #1 </span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">// 特例化的语法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-type">char</span>*&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;char*&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 下面这个是对指针类型提供的部分特例化版本  #2</span><br><span class="hljs-comment">// 仅知道是一个指针，类型需要提供</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;Ty*&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;Ty*&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 指针函数指针（有返回值，有两个形参变量）提供的部分特例化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-built_in">R</span>(*)(A1, A2)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;R(*)(A1, A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 针对函数（有一个返回值，有两个形参变量）类型提供的部分特例化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;<span class="hljs-built_in">R</span>(A1, A2)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;call Vector&lt;R(A1, A2)&gt; init&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Vector&lt;<span class="hljs-type">int</span>&gt; vec1;<br>Vector&lt;<span class="hljs-type">char</span>*&gt; vec2;<br>Vector&lt;<span class="hljs-type">int</span>*&gt; vec3;<br>Vector&lt;<span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; vec4;<br>Vector&lt;<span class="hljs-built_in">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; vec5;<span class="hljs-comment">// function</span><br><br><span class="hljs-comment">// 注意区分一下函数类型和函数指针类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*PFUNC1)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>PFUNC1 pfunc1 = sum;<br>cout &lt;&lt; <span class="hljs-built_in">pfunc1</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-title">PFUNC2</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>PFUNC2* pfunc2 = sum;<br>cout &lt;&lt; (*pfunc2)(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308220929678.png" alt="image.png"></p><p><strong>实参推演：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// T 包含了所有的大的类型  返回值，所有形参的类型都取出来</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//细化返回值类型和参数类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(R(*a)(A1, A2))</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(R).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-comment">//实参推演每一个类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> A1, <span class="hljs-keyword">typename</span> A2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(R(T::* a)(A1, A2))</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(R).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(A2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------func1\n&quot;</span>;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-built_in">func</span>(sum);<span class="hljs-comment">//T  int (*)(int,int)   int (int,int)</span><br><span class="hljs-built_in">func</span>(&amp;Test::sum);<span class="hljs-comment">//int (__thiscall Test::*)(int,int)</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------func2\n&quot;</span>;<br><span class="hljs-built_in">func2</span>(sum);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------func3\n&quot;</span>;<br><span class="hljs-built_in">func3</span>(&amp;Test::sum);<span class="hljs-comment">// int (__thiscall Test::*)(int,int)</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308220936036.png" alt="image.png"></p><h3 id="3-function-原理解析"><a href="#3-function-原理解析" class="headerlink" title="3. function 原理解析"></a>3. function 原理解析</h3><p><strong>源码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">function</span> : <span class="hljs-keyword">public</span> _Get_function_impl&lt;_Fty&gt;::type &#123; <span class="hljs-comment">// wrapper for callable objects</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> _Mybase = <span class="hljs-keyword">typename</span> _Get_function_impl&lt;_Fty&gt;::type;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">function</span>() <span class="hljs-keyword">noexcept</span> &#123;&#125;<br><br>    <span class="hljs-built_in">function</span>(<span class="hljs-type">nullptr_t</span>) <span class="hljs-keyword">noexcept</span> &#123;&#125;<br><br>    <span class="hljs-built_in">function</span>(<span class="hljs-type">const</span> function&amp; _Right) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_Reset_copy(_Right);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Fx</span>, <span class="hljs-keyword">typename</span> _Mybase::<span class="hljs-keyword">template</span> _Enable_if_callable_t&lt;_Fx, function&gt; = <span class="hljs-number">0</span>&gt;<br>    <span class="hljs-built_in">function</span>(_Fx&amp;&amp; _Func) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_Reset(_STD forward&lt;_Fx&gt;(_Func));<br>    &#125;<br>    <br>function&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> function&amp; _Right) &#123;<br>        <span class="hljs-built_in">function</span>(_Right).<span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span>(function&amp;&amp; _Right) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">this</span>-&gt;_Reset_move(_STD <span class="hljs-built_in">move</span>(_Right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>function 底层是一个可变参的偏特化函数对象</p><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// function 函数对象类型的实现原理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// 定义函数模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Fty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&#123;&#125;;<br><br><span class="hljs-comment">// 部分偏特化版本 &lt;R(A1)&gt;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">R</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(A1)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(A1);<br><span class="hljs-built_in">myfunction</span>(PFUNC pfunc) : _pfunc(pfunc) &#123;&#125;<br><br><span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A1 arg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// hello(arg);</span><br><span class="hljs-keyword">return</span> _pfunc(arg);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>PFUNC _pfunc;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//部分偏特化版本   R(*)(A1, A2);</span><br><span class="hljs-comment">template&lt;class R, class A1, class A2&gt;</span><br><span class="hljs-comment">class myfunction&lt;R(A1, A2)&gt;</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">using PFUNC = R(*)(A1, A2);</span><br><span class="hljs-comment">myfunction(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;</span><br><span class="hljs-comment">R operator()(A1 arg1, A2 arg2)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">return _pfunc(arg1, arg2);//hello(arg)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">private:</span><br><span class="hljs-comment">PFUNC _pfunc;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">//通用版本</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... A&gt;<span class="hljs-comment">//一组可变参数个数：表示一组类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(A...)&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(A...);<br><span class="hljs-built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc) &#123;&#125;<br><span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(A... arg)</span><span class="hljs-comment">//一组形参变量</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _pfunc(arg...);<span class="hljs-comment">//hello(arg) 表示一组形参变量</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br>PFUNC _pfunc;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">myfunction&lt;<span class="hljs-title">void</span><span class="hljs-params">(string)</span>&gt; <span class="hljs-title">func1</span><span class="hljs-params">(hello)</span></span>;<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<span class="hljs-comment">// func1.operator()(&quot;hello world!&quot;)</span><br><br><span class="hljs-function">myfunction&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">func2</span><span class="hljs-params">(sum)</span></span>;<br>cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-bind-和-function-实现线程池"><a href="#3-bind-和-function-实现线程池" class="headerlink" title="3. bind 和 function 实现线程池"></a>3. bind 和 function 实现线程池</h2><p><strong>C++11 bind 绑定器，是一个函数模板 ，可以自动推演模板类型参数&#x3D;&gt; 返回的结果还是一个函数对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-comment">// C++ 11 bind 绑定器 -&gt; 返回的结果是一个函数对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// bind 是函数模板，可以自动退盐模板类型参数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;----- bind -----&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">bind</span>(hello, <span class="hljs-string">&quot;hello bind 1!&quot;</span>)();<br>cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>)() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">bind</span>(&amp;Test::sum, <span class="hljs-built_in">Test</span>(), <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)() &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;----- placeholder -----&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 参数占位符 placeholder 绑定器除了语句，无法继续使用</span><br><span class="hljs-comment">// 只是占位的作用，调用的时候就要传递参数了</span><br><span class="hljs-comment">// 书写的时候使用多少个占位符，就是意味着用户调用的时候要传入几个参数</span><br><span class="hljs-built_in">bind</span>(hello, placeholders::_1)(<span class="hljs-string">&quot;hello bind 2!&quot;</span>);<br>cout &lt;&lt; <span class="hljs-built_in">bind</span>(sum, placeholders::_1, placeholders::_2)(<span class="hljs-number">200</span>, <span class="hljs-number">300</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">// 此处把 bind 返回的绑定器 binder 复用</span><br>cout &lt;&lt; <span class="hljs-string">&quot;----- function -----&quot;</span> &lt;&lt; endl;<br>function&lt;<span class="hljs-type">void</span>(string)&gt; func1 = <span class="hljs-built_in">bind</span>(hello, _1);<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function 1!&quot;</span>);<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function 2!&quot;</span>);<br><span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;hello function 3!&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在语句 <code>bind(hello, &quot;hello bind!&quot;)();</code> 中，bind 将 “hello bind 1！” 绑定至 hello 的 string 类型参数，并返回一个函数对象，调用这个函数对象的<code>operator（）</code> 函数，完成打印字符串的过程。</p><p>在语句 <code>bind(hello, _1)(&quot;hello bind 2!&quot;);</code> 中的 <code>_1</code> 是名称空间  placeholders 中的，用法 <code>placeholder::_1</code>。此为<strong>参数占位符</strong>，代表 hello 的第一个参数等待用户输入。在本例中将参数 “hello bind 2!” 传递给 <code>operator（）</code> 函数完成调用。</p><p><strong>用 function 实现对 bind 绑定的函数对象的类型保留</strong></p><p>bind 有个缺点：<strong>bind 无法保存它所绑定过的函数对象！</strong></p><p>所以就需要 function 和它进行配合。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221040672.png" alt="image.png"></p><p>placeholders 占位符：最多支持20个</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221041770.png" alt="image.png"></p><h3 id="1-线程池模拟"><a href="#1-线程池模拟" class="headerlink" title="1. 线程池模拟"></a>1. 线程池模拟</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> placeholders;<br><br><span class="hljs-comment">// 线程类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Thread</span>(function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>)&gt; func, <span class="hljs-type">int</span> no)<br>: _func(func)<br>, _no(no) &#123; &#125;<br><span class="hljs-comment">// 这里需要包含头文件 #include&lt;thread&gt;</span><br><span class="hljs-function">thread <span class="hljs-title">start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义线程 t 执行 func 函数</span><br><span class="hljs-comment">// _func(_no)</span><br><span class="hljs-function">thread <span class="hljs-title">t</span><span class="hljs-params">(_func, _no)</span></span>;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 接收绑定器返回的函数对象</span><br>function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; _func;<br><span class="hljs-comment">// 线程池编号</span><br><span class="hljs-type">int</span> _no;<br>&#125;;<br><br><span class="hljs-comment">// 线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ThreadPool</span>() &#123;&#125;<br>~<span class="hljs-built_in">ThreadPool</span>()<br>&#123;<br><span class="hljs-comment">// 这里是指针，所以不能依靠vector析构自动析构，得手动释放Thread对象占用的堆资源</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _pool.<span class="hljs-built_in">size</span>(); ++i)<br>&#123;<br><span class="hljs-keyword">delete</span> _pool[i];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 开启线程池</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startPool</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 遍历线程大小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>&#123;<br><span class="hljs-comment">// 添加线程</span><br>_pool.<span class="hljs-built_in">push_back</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(<span class="hljs-built_in">bind</span>(&amp;ThreadPool::runInThread, <span class="hljs-keyword">this</span>, _1), i)<br>);<br>&#125;<br><br><span class="hljs-comment">// 执行线程函数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>&#123;<br><span class="hljs-comment">// 添加线程池</span><br>_handler.<span class="hljs-built_in">push_back</span>(_pool[i]-&gt;<span class="hljs-built_in">start</span>());<br>&#125;<br><br><span class="hljs-keyword">for</span> (thread&amp; t : _handler)<br>&#123;<br><span class="hljs-comment">// 等待线程执行完毕</span><br>t.<span class="hljs-built_in">join</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>vector&lt;Thread*&gt; _pool;<br>vector&lt;thread&gt; _handler;<br><br><span class="hljs-comment">// 把runInThread这个成员方法充当线程函数  thread   pthread_create</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInThread</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call runInThread! id: &quot;</span> &lt;&lt; id &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ThreadPool pool;<br>pool.<span class="hljs-built_in">startPool</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-lambda-表达式"><a href="#4-lambda-表达式" class="headerlink" title="4. lambda 表达式"></a>4. lambda 表达式</h2><p>lambda这个词起源于数学上的λ，在C++中利用lambda表达式，可以方便的定义和创建匿名函数。lambda可以看做<strong>函数对象的升级版</strong>。改进了函数对象以下的缺点：</p><ul><li>使用在泛型算法中的参数传递 </li><li>比较性质&#x2F;自定义操作 </li><li>优先级队列 </li><li>智能指针</li></ul><h3 id="1-表达式语法"><a href="#1-表达式语法" class="headerlink" title="1. 表达式语法"></a>1. 表达式语法</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221059552.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[捕获外部变量]（形参列表）-&gt;返回值&#123;操作代码&#125;；<br></code></pre></td></tr></table></figure><p>如果 lambda 不需要返回值，那么返回值可以省略。也就是这样：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[捕获外部变量]（形参列表）&#123;操作代码&#125;；<br></code></pre></td></tr></table></figure><ul><li><strong>参数列表</strong>：与普通函数的参数列表一致，如果不需要参数传递，则可以连同()一起省略。</li><li><strong>mutable</strong>：<strong>默认情况下，lambda函数总是一个const函数</strong>，mutable可以取消其常量性。使用该修饰符时，参数列表不可省略</li><li>-&gt; <strong>返回值类型</strong>：与普通函数返回值一样表达函数的返回值类型，可以省略，译器会对返回值类型进行推导。</li><li><strong>函数体</strong>：可以使用参数以及捕获到的变量。</li></ul><p><strong>捕获外部变量方式：</strong></p><ul><li><code>[]</code>：表示不捕获任何外部变量</li><li><code>[=]</code>：捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li><code>[&amp;]</code>：捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li><code>[this]</code>：捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 &#x3D;，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。</li><li><code>[=，&amp;a]</code>：以传值的方式捕获外部的所有变量，但是a变量以传引用的方式捕获</li><li><code>[a，b]</code>：以传值的方式捕获外部变量 a 和 b</li><li><code>[a,&amp;b]</code>：a 以传值方式捕获，b 以传引用的方式捕获</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 最简单的lamber表达式，没有任何意义</span><br>[] &#123;&#125;;<br><br><span class="hljs-comment">// 省略参数列表和返回值类型，由编译器推导</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">4</span>;<br>[=] &#123; <span class="hljs-keyword">return</span> a + b; &#125;; <span class="hljs-comment">// 函数体被的分号不要忘</span><br><br><span class="hljs-comment">// 引用传递的方式可以改变变量的值</span><br><span class="hljs-keyword">auto</span> func1 = [&amp;](<span class="hljs-type">int</span> c) &#123; <span class="hljs-keyword">return</span> b = a + c; &#125;;<br><span class="hljs-built_in">func1</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 值传递捕获不能改变变量的值，除非使用 mutable</span><br><span class="hljs-keyword">auto</span> func2 = [=](<span class="hljs-type">int</span> c) <span class="hljs-keyword">mutable</span> &#123; <span class="hljs-keyword">return</span> b = a + c; &#125;;<br><span class="hljs-built_in">func2</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-lambda-底层原理-函数对象"><a href="#2-lambda-底层原理-函数对象" class="headerlink" title="2. lambda 底层原理 - 函数对象"></a>2. lambda 底层原理 - 函数对象</h3><ul><li><strong>无参无返回值的 lambda</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func1 = []()&#123;cout &lt;&lt; <span class="hljs-string">&quot;hello world!&quot;</span> &lt;&lt; endl; &#125;;<br><span class="hljs-built_in">func1</span>();<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">void</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda01<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestLambda01</span>() &#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()()<span class="hljs-type">const</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello world!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>参数为整型返回值为整型的</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> func2 = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">func2</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda02<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestLambda02</span>() &#123;&#125;<br><span class="hljs-type">int</span> <span class="hljs-built_in">operator</span>()(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>以引用方式获取参数的lambda</strong>：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// “a”: 无法在非可变 lambda 中修改通过复制捕获</span><br><span class="hljs-keyword">auto</span> func3 = [&amp;]()<br>&#123;<br><span class="hljs-type">int</span> tmp = a;<br>a = b;<br>b = tmp;<br>&#125;;<br><span class="hljs-built_in">func3</span>();<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda03<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestLambda03</span>(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b):<span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b) &#123;&#125;<br><span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-type">int</span> tmp = ma;<br>ma = mb;<br>mb = tmp;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> &amp;ma;<br><span class="hljs-type">int</span> &amp;mb;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>以值方式获取参数的lambda</strong>:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> func4 = [=]() <span class="hljs-keyword">mutable</span><span class="hljs-comment">//并没有改变外面的a b ，传值</span><br>&#123;<br>    <span class="hljs-type">int</span> tmp = a;<br>    a = b;<br>    b = tmp;<br>&#125;;<br><span class="hljs-built_in">func4</span>();<br></code></pre></td></tr></table></figure><p>其对应的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-type">int</span>&gt;<br><span class="hljs-keyword">class</span> TestLambda04<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TestLambda04</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) :<span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b) &#123; &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-built_in">operator</span>()() <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-type">int</span> tmp = ma;<br>        ma = mb;<br>        mb = tmp;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> ma;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p><strong>lambda 中的捕获参数列表对应类中成员变量的类型，返回值和参数列表对应 <code>operator（）</code> 的返回值和参数列表。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221517145.png" alt="image.png"></p><p>lambda 表达式在编译期间被编译器自动转换成函数对象执行，调研 operator</p><h3 id="3-lambda-表达式代替-switch"><a href="#3-lambda-表达式代替-switch" class="headerlink" title="3. lambda 表达式代替 switch"></a>3. lambda 表达式代替 switch</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; caculateMap;<br>caculateMap[<span class="hljs-number">1</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b; &#125;;<br>caculateMap[<span class="hljs-number">2</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a - b; &#125;;<br>caculateMap[<span class="hljs-number">3</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a * b; &#125;;<br>caculateMap[<span class="hljs-number">4</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a / b; &#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;选择:&quot;</span>;<br><span class="hljs-type">int</span> choice;<br>cin &gt;&gt; choice;<br>cout &lt;&lt; <span class="hljs-string">&quot;10 op  15:&quot;</span> &lt;&lt; caculateMap[choice](<span class="hljs-number">10</span>, <span class="hljs-number">15</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="4-按值捕获-捕获时机"><a href="#4-按值捕获-捕获时机" class="headerlink" title="4. 按值捕获 &amp; 捕获时机"></a>4. 按值捕获 &amp; 捕获时机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-keyword">auto</span> localStr = [=](string&amp; s) &#123; s = str; &#125;;<br><br>    str = <span class="hljs-string">&quot;hello world&quot;</span>;<br><br>    string str1;<br>    <span class="hljs-built_in">localStr</span>(str1);<br><br>    cout &lt;&lt; str;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>str = &quot;abc&quot;</code> 当闭包生成的那一刻，被捕获的变量已经按值赋值的方式进行了捕获，后面那个<code>str</code>再怎么变化，已经和闭包对象里面的值没有关系了.</p><p>localStr 中 str 中的值在localStr 定义的时候就已经确定为abc了，不会再发生变化。</p><h3 id="5-按引用捕获-悬空引用"><a href="#5-按引用捕获-悬空引用" class="headerlink" title="5. 按引用捕获 &amp; 悬空引用"></a>5. 按引用捕获 &amp; 悬空引用</h3><p>在 C++ 编程中，程序员有责任保证 Lambda 调用的时候，保证被捕获的变量仍然有效~！是的，责任在你，而不在编译器。如果不能很好理解这点，就会遇到悬空引用的问题！</p><p><strong>悬空引用（ dangling references ）</strong>：就是说当创建了一个对象的引用类型的变量，但是被引用的对象被析构了、无效了。一般情况下，引用类型的变量必须在初始化的时候赋值，很少遇到这种情况，但是如果 lambda 被延迟调用，在调用时，已经脱离了当前的作用域，那么按引用捕获的对象就是悬空引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br>std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">void</span>)&gt; func;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>std::string str = <span class="hljs-string">&quot;abc&quot;</span>;<br>func = [&amp;]() &#123; std::string a = str; cout &lt;&lt; a; &#125;;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-built_in">func</span>();<br>  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221527791.png" alt="image.png"></p><p>发生 crash：func 引用的对象 str 在离开作用域 <code>test()</code> 后被析构了，在 main 函数中执行 <code>func()</code> 导致找到引用的对象 str,导致 crash。</p><h3 id="6-lambda-实现指针自定义删除器"><a href="#6-lambda-实现指针自定义删除器" class="headerlink" title="6. lambda 实现指针自定义删除器"></a>6. lambda 实现指针自定义删除器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 智能指针自定义删除器   delete p;  FILE*   fclose(FILE*)</span><br>unique_ptr&lt;FILE, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <br><span class="hljs-built_in">ptr1</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), [](FILE *pf) &#123;<span class="hljs-built_in">fclose</span>(pf); &#125;);<br></code></pre></td></tr></table></figure><h3 id="7-lambda实现多种比较操作"><a href="#7-lambda实现多种比较操作" class="headerlink" title="7. lambda实现多种比较操作"></a>7. lambda实现多种比较操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> val1 = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> val2 = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ma</span>(val1), <span class="hljs-built_in">mb</span>(val2) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Data &amp;data) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ma &gt; data.ma; &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Data &amp;data) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> ma &lt; data.ma; &#125;<br>    <span class="hljs-type">int</span> ma;<br>    <span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 优先级队列</span><br>    <span class="hljs-comment">//priority_queue&lt;Data&gt; queue;</span><br>    <span class="hljs-keyword">using</span> FUNC = function&lt;<span class="hljs-built_in">bool</span>(Data&amp;, Data&amp;)&gt;;<br><br>    priority_queue&lt;<br>        Data, <br>        vector&lt;Data&gt;, <br>        FUNC<br>    &gt; <span class="hljs-built_in">maxHeap</span>([](Data&amp; d1, Data&amp; d2)-&gt;<span class="hljs-type">bool</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> d1.mb &gt; d2.mb;<br>        &#125;);<br><br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>));<br>    maxHeap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Data</span>(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>09.C++ 智能指针</title>
    <link href="/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/09.C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/09.C++%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>本节分为五部分：</p><ol><li>自己实现智能指针</li><li>不带引用计数的智能指针：<strong>auto_ptr</strong>、<strong>scoped_ptr</strong>、<strong>unique_ptr</strong></li><li>带引用计数的智能指针：<strong>shared_ptr</strong>、<strong>weak_ptr</strong></li><li>多线程访问共享对象问题</li><li>自定义删除器</li></ol><p>我们知道除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为自由空间或者堆。程序用堆来存储动态分配的对象即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。</p><p>在 C++ 中，动态内存的管理是用一对运算符完成的：new 和 delete。</p><ul><li>new：在动态内存中为对象分配一块空间并返回一个指向该对象的指针;</li><li>delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。</li></ul><p>动态内存管理经常会出现以下几种问题：</p><ol><li>忘记释放资源，导致资源泄露（常发生内存泄漏问题）。</li><li>尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。</li><li>统一资源释放多次，导致释放野指针，程序崩溃。</li><li>代码的后面写了释放资源的代码，但是由于程序逻辑满足条件，从中间 return 掉了，导致释放资源的代码未被执行到。</li><li>代码运行过程中发生异常，随着异常栈展开，导致释放资源的代码未被执行到。</li></ol><p>为了更加容易（更加安全）的使用动态内存，引入了智能指针的概念。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。</p><p>主要体现在用户可以不关注资源的释放，因为智能指针会帮你完全管理资源的释放，它会保证无论程序逻辑怎么跑，正常执行或者产生异常，资源在到期的情况下，一定会进行释放。</p><p>C++ 11 库中，提供了 <strong>带引用计数的智能指针和不带引用计数的智能指针</strong>，本章节主要以原理和应用场景。</p><h2 id="1-自己实现智能指针"><a href="#1-自己实现智能指针" class="headerlink" title="1. 自己实现智能指针"></a>1. 自己实现智能指针</h2><p>智能指针的基本原理：</p><p><strong>利用栈上的对象做出作用域会自动析构</strong> 的特点，把资源释放代码全部放在析构函数中执行，就达到了所谓的智能指针。</p><ol><li><strong>使用裸指针：</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">/*其它的代码...*/</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果这里忘记写 delete，或者上面的代码段中程序 return 掉了，</span><br><span class="hljs-comment">没有执行到这里，都会导致这里没有释放内存，内存泄漏</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>使用智能指针</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">CSmartPtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-comment">// ....</span><br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">CSmartPtr</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* mptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">/*其它的代码...*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">由于 ptr 是栈上的智能指针对象，不管是函数正常执行完，</span><br><span class="hljs-comment">还是运行过程中出现异常，栈上的对象都会自动调用析构函数，</span><br><span class="hljs-comment">在析构函数中进行了 delete 操作，保证释放资源</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码实现了较为简单的智能指针，主要用到两点：</p><p>（1）<strong>智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源。</strong><br>（2）<strong>利用栈上的对象出作用域自动析构这一特点，在智能指针的析构函数中保证释放资源。</strong></p><p>所以，智能指针一般都是定义在栈上的。</p><p>面试题：<strong>能不能在堆上定义智能指针？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">CSmartPtr* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CSmartPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这里定义的 p 虽然是智能指针类型，但它实质上还是一个裸指针，因此 p 还是需要进行手动 delete，又回到了最开始裸指针的问题。</p><p>当然，智能指针要做到和裸指针相似，还得提供裸指针常见的 * <strong>和-&gt;两种运算符的重载函数</strong>，使用起来才真正的和裸指针一样，代码扩充如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">CSmartPtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-comment">// ....</span><br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">CSmartPtr</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>&#125;<br><br><span class="hljs-comment">// 重载函数</span><br><span class="hljs-comment">// 1. *</span><br>T&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-comment">// 2. -&gt;</span><br>T&amp; <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>T* mptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><br>*ptr = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;ptr = &quot;</span> &lt;&lt; *ptr &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171446300.png" alt="image.png"></p><p>上面的这个智能指针，使用起来就和普通的裸指针非常相似了，但是它还存在很大的问题，看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 main 函数运行，代码直接崩溃，问题出在<strong>默认的拷贝构造函数做的浅拷贝，两个智能指针都持有一个 <code>new int</code> 资源，ptr2 仙溪沟释放了资源，到了 ptr1 析构的时候，就变成了 delete 野指针，造成程序的崩溃</strong>。所以这里引出来智能指针需要解决的两件事情：</p><ol><li>怎么解决智能指针的浅拷贝问题</li><li>多个智能指针指向同一个资源的时候，怎么保证资源只释放一次，而不是每个智能指针都释放一次，造成代码运行不可预期的严重后果</li></ol><p>查看 C++ 库中的智能指针如何解决的问题。</p><h2 id="2-不带引用计数的智能指针"><a href="#2-不带引用计数的智能指针" class="headerlink" title="2. 不带引用计数的智能指针"></a>2. 不带引用计数的智能指针</h2><p>C++ 库中提供的不带引用计数的智能指针主要包括：<strong>auto_ptr，scoped_ptr，unique_ptr</strong>，下面一一进行介绍。</p><h3 id="1-auto-ptr-源码"><a href="#1-auto-ptr-源码" class="headerlink" title="1. auto_ptr 源码"></a>1. <strong><code>auto_ptr</code></strong> 源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">auto_ptr</span><br>&#123;<span class="hljs-comment">// wrap an object pointer to ensure destruction</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> _Ty element_type;<br><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">auto_ptr</span><span class="hljs-params">(_Ty * _Ptr = <span class="hljs-literal">nullptr</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function">: _Myptr(_Ptr)</span><br><span class="hljs-function">&#123;</span><span class="hljs-comment">// construct from object pointer</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里是 auto_ptr 的拷贝构造函数，</span><br><span class="hljs-comment">_Right.release() 函数中，把 _Right 的 _Myptr</span><br><span class="hljs-comment">赋为 nullptr，也就是换成当前 auto_ptr 持有资源地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">auto_ptr</span>(auto_ptr&amp; _Right) <span class="hljs-keyword">noexcept</span><br>: _Myptr(_Right.<span class="hljs-built_in">release</span>())<br>&#123;<span class="hljs-comment">// construct by assuming pointer from _Right auto_ptr</span><br>&#125;<br><br><span class="hljs-function">_Ty * <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return wrapped pointer and give up ownership</span><br>_Ty * _Tmp = _Myptr;<br>_Myptr = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">return</span> (_Tmp);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>_Ty * _Myptr;<span class="hljs-comment">// the wrapped object pointer</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171454384.png" alt="image.png"></p><p>从 <code>auto_ptr</code> 的源码可以看到，只有最后一个 <code>auto_ptr</code> 智能指针持有资源，原来的 <code>auto_ptr</code> 都被赋 <code>nullptr</code> 了，考虑如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">经过拷贝构造，p2 指向了 new int 资源，</span><br><span class="hljs-comment">p1 现在为 nullptr 了，如果使用 p1，相当于</span><br><span class="hljs-comment">访问空指针了，很危险</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">auto_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br>*p1 = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1 = &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171457368.png" alt="image.png"></p><p>上面的程序，如果用户不了解 <code>auto_ptr</code> 的实现，代码就会出现严重的问题。</p><p>面试题：<strong>auto_ptr 能不能使用在容器当中？</strong>，看下面的代码描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>)));<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>)));<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">30</span>)));<br><br><span class="hljs-comment">// 输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;vec[0] = &quot;</span> &lt;&lt; *vec[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><br><span class="hljs-comment">// 拷贝</span><br>vector&lt;auto_ptr&lt;<span class="hljs-type">int</span>&gt;&gt; vec2 = vec;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">这里由于上面做了 vector 容器的拷贝，相当于容器中</span><br><span class="hljs-comment">的每一个元素都进行了拷贝构造，原来 vec 中的智能指针</span><br><span class="hljs-comment">全部为 nullptr了，再次访问就成访问空指针了，程序崩溃</span><br><span class="hljs-comment">*/</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;vec[0] = &quot;</span> &lt;&lt; *vec[<span class="hljs-number">0</span>] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171502615.png" alt="image.png"></p><p>所以不要在容器中使用 <code>auto_ptr</code>，<strong>C++ 建议最好不要使用 auto_ptr</strong>，除非应用场景非常简单。</p><p>【总结】：<strong>auto_ptr 智能指针不带引用计数，那么它处理浅拷贝的问题，是直接把前面的 auto_ptr 都置为 nullptr，只让最后一个 auto_ptr 持有资源。</strong></p><h3 id="2-scoped-ptr-源码"><a href="#2-scoped-ptr-源码" class="headerlink" title="2. scoped_ptr 源码"></a>2. <strong><code>scoped_ptr</code></strong> 源码</h3><p><strong>源码展示：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_ptr</span> <span class="hljs-comment">// noncopyable</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    T * px;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">私有化拷贝构造函数和赋值函数，这样scoped_ptr的智能指针</span><br><span class="hljs-comment">对象就不支持这两种操作，从根本上杜绝浅拷贝的发生</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-built_in">scoped_ptr</span>(scoped_ptr <span class="hljs-type">const</span> &amp;);<br>    scoped_ptr &amp; <span class="hljs-keyword">operator</span>=(scoped_ptr <span class="hljs-type">const</span> &amp;);<br> <br>    <span class="hljs-keyword">typedef</span> scoped_ptr&lt;T&gt; this_type;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">私有化逻辑比较运算符重载函数，不支持scoped_ptr的智能指针</span><br><span class="hljs-comment">对象的比较操作</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>==( scoped_ptr <span class="hljs-type">const</span>&amp; ) <span class="hljs-type">const</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>!=( scoped_ptr <span class="hljs-type">const</span>&amp; ) <span class="hljs-type">const</span>;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> T element_type;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_ptr</span><span class="hljs-params">( T * p = <span class="hljs-number">0</span> )</span>: px( p ) // never throws</span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span><br>        boost::<span class="hljs-built_in">sp_scalar_constructor_hook</span>( px );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BOOST_NO_AUTO_PTR</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">支持从 auto_ptr 构造一个 scoped_ptr 智能指针对象，</span><br><span class="hljs-comment">但是 auto_ptr 因为调用 release() 函数，导致其内部指</span><br><span class="hljs-comment">针为 nullptr</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_ptr</span><span class="hljs-params">( std::auto_ptr&lt;T&gt; p )</span> BOOST_NOEXCEPT : px( p.release() )</span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span><br>        boost::<span class="hljs-built_in">sp_scalar_constructor_hook</span>( px );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/*析构函数，释放智能指针持有的资源*/</span><br>    ~<span class="hljs-built_in">scoped_ptr</span>() <span class="hljs-comment">// never throws</span><br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(BOOST_SP_ENABLE_DEBUG_HOOKS)</span><br>        boost::<span class="hljs-built_in">sp_scalar_destructor_hook</span>( px );<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        boost::<span class="hljs-built_in">checked_delete</span>( px );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">scoped_ptr</span>(scoped_ptr <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br>scoped_ptr &amp; <span class="hljs-keyword">operator</span>=(scoped_ptr <span class="hljs-type">const</span> &amp;) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><p>从 <code>scoped_ptr</code> 的源码中可以看到，该智能指针私有化了拷贝构造函数和<br><code>operator=</code> 重载赋值函数，因此<strong>从根本上杜绝了智能指针浅拷贝的发生，所以 scoped_ptr 也是不能用在容器当中的，如果容器互相进行拷贝或者赋值，就会引起 scoped_ptr 对象的拷贝构造和赋值，这是不允许的，代码会提示编译错误</strong>。</p><p><code>auto_ptr</code> 和 <code>scoped_ptr</code> 这一点上的区别，有些资料上用<strong>所有权</strong>的概念来描述，道理是相同的，<strong>auto_ptr 可以任意转移资源的所有权，而 scoped_ptr 不会转移所有权</strong>（因为拷贝构造和赋值被禁止了）。</p><h3 id="3-unique-ptr-源码"><a href="#3-unique-ptr-源码" class="headerlink" title="3. unique_ptr 源码"></a>3. <strong><code>unique_ptr</code></strong> 源码</h3><p>要深入了解 <code>unique_ptr</code>，需要先了解 C++ 的右值引用原理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>,<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Dx</span>&gt;<span class="hljs-comment">// = default_delete&lt;_Ty&gt;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span><br>: <span class="hljs-keyword">public</span> _Unique_ptr_base&lt;_Ty, _Dx&gt;<br>&#123;<span class="hljs-comment">// non-copyable pointer to an object</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> _Unique_ptr_base&lt;_Ty, _Dx&gt; _Mybase;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> _Mybase::pointer pointer;<br><span class="hljs-keyword">typedef</span> _Ty element_type;<br><span class="hljs-keyword">typedef</span> _Dx deleter_type;<br><br><span class="hljs-comment">/*提供了右值引用的拷贝构造函数*/</span><br><span class="hljs-built_in">unique_ptr</span>(unique_ptr&amp;&amp; _Right) <span class="hljs-keyword">noexcept</span><br>: _Mybase(_Right.<span class="hljs-built_in">release</span>(),<br>_STD forward&lt;_Dx&gt;(_Right.<span class="hljs-built_in">get_deleter</span>()))<br>&#123;<span class="hljs-comment">// construct by moving _Right</span><br>&#125;<br><br><span class="hljs-comment">/*提供了右值引用的operator=赋值重载函数*/</span><br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&amp;&amp; _Right) <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// assign by moving _Right</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != _STD <span class="hljs-built_in">addressof</span>(_Right))<br>&#123;<span class="hljs-comment">// different, do the move</span><br><span class="hljs-built_in">reset</span>(_Right.<span class="hljs-built_in">release</span>());<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>() = _STD forward&lt;_Dx&gt;(_Right.<span class="hljs-built_in">get_deleter</span>());<br>&#125;<br><span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">交换两个unique_ptr智能指针对象的底层指针</span><br><span class="hljs-comment">和删除器</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(unique_ptr&amp; _Right)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// swap elements</span><br>_Swap_adl(<span class="hljs-keyword">this</span>-&gt;_Myptr(), _Right._Myptr());<br>_Swap_adl(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>(), _Right.<span class="hljs-built_in">get_deleter</span>());<br>&#125;<br><br><span class="hljs-comment">/*通过自定义删除器释放资源*/</span><br>~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// destroy the object</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">pointer</span>())<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>()(<span class="hljs-built_in">get</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*unique_ptr提供-&gt;运算符的重载函数*/</span><br>_NODISCARD pointer <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// return pointer to class object</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;_Myptr());<br>&#125;<br><br><span class="hljs-comment">/*返回智能指针对象底层管理的指针*/</span><br><span class="hljs-function">_NODISCARD pointer <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// return pointer to object</span><br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;_Myptr());<br>&#125;<br><br><span class="hljs-comment">/*提供bool类型的重载，使unique_ptr对象可以</span><br><span class="hljs-comment">直接使用在逻辑语句当中，比如if,for,while等*/</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// test for non-null pointer</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">pointer</span>());<br>&#125;<br>    <br>    <span class="hljs-comment">/*功能和auto_ptr的release函数功能相同，最终也是只有一个unique_ptr指针指向资源*/</span><br><span class="hljs-function">pointer <span class="hljs-title">release</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// yield ownership of pointer</span><br>pointer _Ans = <span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">this</span>-&gt;_Myptr() = <span class="hljs-built_in">pointer</span>();<br><span class="hljs-keyword">return</span> (_Ans);<br>&#125;<br><br><span class="hljs-comment">/*把unique_ptr原来的旧资源释放，重置新的资源_Ptr*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(pointer _Ptr = pointer())</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// establish new pointer</span><br>pointer _Old = <span class="hljs-built_in">get</span>();<br><span class="hljs-keyword">this</span>-&gt;_Myptr() = _Ptr;<br><span class="hljs-keyword">if</span> (_Old != <span class="hljs-built_in">pointer</span>())<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>()(_Old);<br>&#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">删除了unique_ptr的拷贝构造和operator=赋值函数，</span><br><span class="hljs-comment">因此不能做unique_ptr智能指针对象的拷贝构造和</span><br><span class="hljs-comment">赋值，防止浅拷贝的发生</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">unique_ptr</span>(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>unique_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> unique_ptr&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从源码中可以看出，<code>unique_ptr</code> 有一点和 <code>scoped_ptr</code> 做的一样，就是<strong>去掉了拷贝构造函数和 <code>operator=</code> 赋值重载函数，静止了用于对 unique_ptr 进行显示的拷贝和赋值，放置智能指针浅拷贝问题的发生。</strong></p><p><strong>但是 unique_ptr 提供了带右值引用参数的拷贝构造和赋值</strong>，也就是说，<code>unique_ptr</code> 智能指针可以通过右值引用进行拷贝构造和赋值操作，或者在产生 <code>unique_ptr</code> 临时对象的地方，如把 <code>unique_ptr</code> 作为函数的返回值时，示例代码如下：</p><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// 转换为 优质引用</span><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br>ptr2 = std::<span class="hljs-built_in">move</span>(ptr1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">test_uniqueptr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-keyword">return</span> ptr1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">此处调用 test_uniqueptr 函数，在 return ptr1 代码处，</span><br><span class="hljs-comment">调用右值引用的拷贝构造函数，由 ptr1 拷贝构造 ptr</span><br><span class="hljs-comment">*/</span><br>unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = <span class="hljs-built_in">test_uniqueptr</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unique_ptr</code> 还提供了 reset 重置资源，swap 交换资源等函数，也经常会使用到。</p><p><strong>可以看到，unique_ptr 从名字就可以看出来，最终也是只能有一个该智能指针引用资源，因此建议在使用不带引用计数的智能指针时，可以优先选择 unique_ptr 智能指针</strong>。</p><h2 id="3-带引用计数的智能指针"><a href="#3-带引用计数的智能指针" class="headerlink" title="3. 带引用计数的智能指针"></a>3. 带引用计数的智能指针</h2><p>带引用计数的智能指针可以实现<strong>多个智能指针管理同一个资源。</strong> 通过给每个被管理的资源匹配一个<strong>引用计数</strong>来实现。当新增一个智能指针指向该资源时，引用计数 +1，当减少一个智能指向该资源是，引用计数 -1，知道引用计数为 0 时，资源被释放掉。由最后一个智能指针的析构函数来处理资源的释放问题，这就是引用计数的概念。</p><ul><li>带引用计数：多个智能指针可以管理同一个资源</li><li>带引用计数：给每一个对象资源，匹配一个引用计数</li></ul><p><strong>智能指针 -&gt; 引用资源的时候 -&gt; 引用计数 +1</strong></p><p><strong>智能指针 -&gt; 不适用资源的时候 -&gt; 引用计数 -1 -&gt;  !&#x3D; 0 不释放资源，为 0 则释放资源</strong></p><p>库里面的 <code>shared_ptr</code> 和 <code>weak_ptr</code> 引用计数的加减是线程安全的，因为用 atomic 定义了引用计数。</p><p><strong>计数实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现计数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCnt</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数初始化</span><br><span class="hljs-built_in">RefCnt</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-keyword">if</span> (mptr != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>mcount = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现增加和减少引用方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addRef</span><span class="hljs-params">()</span> </span>&#123; mcount++; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delRef</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> --mcount; &#125;<br><br><span class="hljs-keyword">private</span>:<br>T* mptr;<br><span class="hljs-type">int</span> mcount;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>智能指针类：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现智能指针</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CSmartPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数 - 初始化</span><br><span class="hljs-built_in">CSmartPtr</span>(T* ptr = <span class="hljs-literal">nullptr</span>)<br>: <span class="hljs-built_in">mptr</span>(ptr)<br>&#123;<br><span class="hljs-comment">// 调用引用计数</span><br>mpRefCnt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RefCnt</span>&lt;T&gt;(mptr);<br>&#125;<br><span class="hljs-comment">/*CSmartPtr(const Csmartptr&lt;T&gt; &amp;src) &#123; mptr = new T(*src .mptr) ; &#125;*/</span><br><span class="hljs-comment">// 析构函数 - 释放内存</span><br>~<span class="hljs-built_in">CSmartPtr</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (mpRefCnt-&gt;<span class="hljs-built_in">delRef</span>() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>mptr = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 重载函数</span><br>T&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *mptr; &#125;<br>T* <span class="hljs-keyword">operator</span>-&gt;() &#123; <span class="hljs-keyword">return</span> mptr; &#125;<br><br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">CSmartPtr</span>(CSmartPtr&lt;T&gt;&amp; src)<br>: <span class="hljs-built_in">mptr</span>(src.mptr)<br>, <span class="hljs-built_in">mpRefCnt</span>(src.mpRefCnt)<br>&#123;<br><span class="hljs-keyword">if</span> (mptr != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>mpRefCnt-&gt;<span class="hljs-built_in">addRef</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 赋值重载函数</span><br>CSmartPtr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CSmartPtr&lt;T&gt;&amp; src)<br>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断计时器</span><br><span class="hljs-keyword">if</span> (mpRefCnt-&gt;<span class="hljs-built_in">delRef</span>() == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> mptr;<br>&#125;<br><br><span class="hljs-comment">// 重新赋值</span><br>mptr = src.mptr;<br>mpRefCnt = src.mpRefCnt;<br>mpRefCnt-&gt;<span class="hljs-built_in">addRef</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向资源的指针</span><br>T* mptr;<br><span class="hljs-comment">// 指向该资源引用计数对象的指针</span><br>RefCnt&lt;T&gt;* mpRefCnt;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>main 函数测试：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 普通初始化</span><br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// 拷贝构造函数初始化</span><br><span class="hljs-function">CSmartPtr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;<br><span class="hljs-comment">// 初始化</span><br>CSmartPtr&lt;<span class="hljs-type">int</span>&gt; ptr3;<br><span class="hljs-comment">// 复制构造函数</span><br>ptr3 = ptr2;<br><br><span class="hljs-comment">// 赋值</span><br>*ptr1 = <span class="hljs-number">20</span>;<br><br>cout &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *ptr3 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171609802.png" alt="image.png"></p><h3 id="1-shared-ptr-实现"><a href="#1-shared-ptr-实现" class="headerlink" title="1. shared_ptr 实现"></a>1. <strong><code>shared_ptr</code></strong> 实现</h3><p>内部大概实现：每次复制，多一个共享同处资源的 <code>shared_ptr</code> 时，计数 +1。每次释放 <code>shared_ptr</code> 时，计数 -1。<br>当 shared 计数为 0 时，则证明所有指向同一处资源的 <code>shared_ptr</code> 们全都释放了，则随即释放该资源（还会释放 new 出来的 SharedPtrControlBlock）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//shared计数放在这个结构体里面，实际上结构体里还应该有另一个weak计数。下文介绍weak_ptr时会解释。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedPtrControlBlock</span><br>&#123;　　<br>  <span class="hljs-type">int</span> shared_count;<br>&#125;;<br><span class="hljs-comment">//大概长这个样子（简化版）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span><br>&#123;　　<br>  T* ptr;　　<br>  SharedPtrControlBlock* count;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>shared_ptr 是强智能指针，可以改变资源的引用计数</strong></p><p>循环引用问题，造成 new 出来的资源无法释放，资源泄露</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>shared_ptr&lt;B&gt; ptrb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>shared_ptr&lt;A&gt; ptra;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br><br>pa-&gt;ptrb = pb;<br>pb-&gt;ptra = pa;<br><br>cout &lt;&lt; pa.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;  <span class="hljs-comment">//打印引用计数</span><br>cout &lt;&lt; pb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171614731.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171614091.png" alt="image.png"></p><ol><li>首先，初始化时：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br></code></pre></td></tr></table></figure><p><code>shared_ptr</code> 创建后，栈上的指针指向了对应的对象上，时期计数 +1。</p><ol start="2"><li>其次，指向</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">pa-&gt;ptrb = pb;<br>pb-&gt;ptra = pa;<br></code></pre></td></tr></table></figure><p>指针互相指向，其计数器又 +1。</p><p><strong>这就是交叉引用问题。！！！！</strong></p><ol start="3"><li>最后，析构，无法释放对象中互相引用的内存。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171626154.png" alt="image.png"></p><p>如下表所示是 <code>shared_ptr</code> 特有的操作：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171627469.png" alt="image.png"></p><p>如何解决循环引用问题？</p><ul><li>定义对象的时候，用强智能指针；引用对象的地方，使用弱智能指针</li><li><code>weak_ptr</code> 之所以可以打破循环引用，是因为：将一个 <code>weak_ptr</code> 绑定到一个 <code>shared_ptr</code> 不会改变 <code>shared_ptr</code> 的引用计数</li></ul><h3 id="2-weak-ptr"><a href="#2-weak-ptr" class="headerlink" title="2. weak_ptr"></a>2. <strong><code>weak_ptr</code></strong></h3><p><code>weak_ptr</code> 是为了辅助 <code>shared_ptr</code> 的存在，它只提供了对管理对象的一个访问手段，同时也可以实时动态地知道指向的对象是否存活。</p><p>（只有某个对象的访问权，而没有它的生命控制权 即是 弱引用，所以 <code>weak_ptr</code> 是一种弱引用型指针）</p><p><strong>内部大概实现：</strong></p><ul><li>计数区域(SharedPtrControlBlock)结构体引进新的 int 变量 <code>weak_count</code>，来作为弱引用计数。</li><li>每个 <code>weak_ptr</code> 都占指针的两倍空间，一个装着原始指针，一个装着计数区域的指针（和 <code>shared_ptr</code> 一样的成员）。</li><li><code>weak_ptr</code> 可以由一个 <code>shared_ptr</code> 或者另一个 <code>weak_ptr</code> 构造。</li><li><code>weak_ptr</code> 的构造和析构不会引起 <code>shared_count</code> 的增加或减少，只会引起 <code>weak_count</code> 的增加或减少。</li></ul><p>被管理资源的释放只取决于 shared 计数，当 shared 计数为0，才会释放被管理资源，也就是说 <strong>weak_ptr 不控制资源的生命周期</strong>。</p><p>但是计数区域的释放却取决于 shared 计数和 weak 计数，当两者均为 0 时，才会释放计数区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//shared引用计数和weak引用计数</span><br><span class="hljs-comment">//之前的计数区域实际最终应该长这个样子</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SharedPtrControlBlock</span><br>&#123;　　<br>   <span class="hljs-type">int</span> shared_count;　　<br>   <span class="hljs-type">int</span> weak_count;<br>&#125;;<br><span class="hljs-comment">//大概长这个样子（简化版）</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">weak_ptr</span><br>&#123;　　<br>   T* ptr;　　<br>   SharedPtrControlBlock* count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>弱智能指针 <code>weak_ptr</code> 区别于 <code>shared_ptr</code> 之处在于：</p><ol><li><code>weak_ptr</code> 不会改变资源的引用计数，只是一个观察者的角色，通过观察 <code>shared_ptr</code> 来判定资源是否存在</li><li><code>weak_ptr</code> 持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</li><li><code>weak_ptr</code> 没有提供常用的指针操作，无法直接访问资源，需要先通过 lock方法提升为 <code>shared_ptr</code> 强智能指针，才能访问资源</li></ol><p>解决问题方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前置声明类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;<br>weak_ptr&lt;B&gt; _ptrb; <span class="hljs-comment">// 指向B对象的弱智能指针。引用对象时，用弱智能指针</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;<br>~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;<br>weak_ptr&lt;A&gt; _ptra; <span class="hljs-comment">// 指向A对象的弱智能指针。引用对象时，用弱智能指针</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 定义对象时，用强智能指针</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">ptra</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<span class="hljs-comment">// ptra指向A对象，A的引用计数为1</span><br><span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">ptrb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<span class="hljs-comment">// ptrb指向B对象，B的引用计数为1</span><br><span class="hljs-comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为1，因为是弱智能指针，引用计数没有改变</span><br>ptra-&gt;_ptrb = ptrb;<br><span class="hljs-comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为1，因为是弱智能指针，引用计数没有改变</span><br>ptrb-&gt;_ptra = ptra;<br><br>cout &lt;&lt; ptra.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 打印结果:1</span><br>cout &lt;&lt; ptrb.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">// 打印结果:1</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span><br><span class="hljs-comment">B对象的引用计数从1减到0，达到释放A和B的条件，因此new出来的A和B对象</span><br><span class="hljs-comment">被析构掉，解决了“强智能指针的交叉引用(循环引用)问题”</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>weak_ptr</code> 是弱智能指针，不会改变资源的引用计数</p><p><code>weak_ptr</code> -&gt; (观察）<code>shared_ptr</code> -&gt;（管理） 资源（内存）</p><p><strong>注意：</strong></p><p><code>weak_ptr</code> 只是一个观察者，它并不能直接操纵资源，没有重载 <code>-&gt;</code> 和<code>*</code>  运算符，所以不能 <code>-&gt;</code> 这样输出，要用 lock 返回 <code>shared_ptr</code> 类型才能用 <code>-&gt;</code></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171631672.png" alt="image.png"></p><h2 id="4-多线程访问共享对象问题"><a href="#4-多线程访问共享对象问题" class="headerlink" title="4. 多线程访问共享对象问题"></a>4. 多线程访问共享对象问题</h2><p><strong>强弱智能指针解决的另一问题：多线程访问共享对象的线程安全问题</strong></p><p>有一个用 C++ 写的开源网络库，muduo 库，作者陈硕</p><p>该源码中对于智能指针的应用非常优秀，其中借助 <code>shared_ptr</code> 和 <code>weak_ptr</code> 解决了这样一个问题，多线程访问共享对象的线程安全问题。</p><p>解释如下：线程 A 和线程 B 访问一个共享的对象，如果线程 A 正在析构这个对象的时候，线程 B 又要调用该共享对象的成员方法，此时可能线程 A 已经把对象析构完了，线程 B 再去访问该对象，就会发生不可预期的错误。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span><br><span class="hljs-built_in">Test</span>() <br>:_ptr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 析构Test对象，释放_ptr指向的堆内存</span><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> _ptr;<br>_ptr = <span class="hljs-literal">nullptr</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 该show会在另外一个线程中被执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *_ptr &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* <span class="hljs-keyword">volatile</span> _ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadProc</span><span class="hljs-params">(Test* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 睡眠两秒，此时main主线程已经把Test对象给delete析构掉了</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">此时当前线程访问了main线程已经析构的共享对象，结果未知，隐含bug。</span><br><span class="hljs-comment">此时通过p指针想访问Test对象，需要判断Test对象是否存活，如果Test对象</span><br><span class="hljs-comment">存活，调用show方法没有问题；如果Test对象已经析构，调用show有问题！</span><br><span class="hljs-comment">*/</span><br>p-&gt;<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在堆上定义共享对象</span><br>Test* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-comment">// 使用C++11的线程类，开启一个新线程，并传入共享对象的地址p</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, p)</span></span>;<br><br><span class="hljs-comment">// 在main线程中析构Test共享对象</span><br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-comment">// 等待子线程运行结束</span><br>t1.<span class="hljs-built_in">join</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，发现在 main 主线程已经 delete 析构 Test 对象以后，子线程 threadProc 再去访问 Test 对象的 show 方法，无法打印出 <code>*_ptr</code> 的值 20。可以用 <code>shared_ptr</code> 和 <code>weak_ptr</code> 来解决多线程访问共享对象的线程安全问题，上面代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造Test对象，_ptr指向一块int堆内存，初始值是20</span><br><span class="hljs-built_in">Test</span>() :_ptr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">20</span>))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 析构Test对象，释放_ptr指向的堆内存</span><br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> _ptr;<br>_ptr = <span class="hljs-literal">nullptr</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 该show会在另外一个线程中被执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *_ptr &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* <span class="hljs-keyword">volatile</span> _ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadProc</span><span class="hljs-params">(weak_ptr&lt;Test&gt; pw)</span> <span class="hljs-comment">// 通过弱智能指针观察强智能指针</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 睡眠两秒</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升</span><br><span class="hljs-comment">为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存</span><br><span class="hljs-comment">的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象</span><br><span class="hljs-comment">已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。</span><br><span class="hljs-comment">*/</span><br>shared_ptr&lt;Test&gt; ps = pw.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (ps != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>ps-&gt;<span class="hljs-built_in">show</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在堆上定义共享对象</span><br><span class="hljs-function">shared_ptr&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;<br><span class="hljs-comment">// 在main线程中析构Test共享对象</span><br><span class="hljs-comment">// 等待子线程运行结束</span><br>t1.<span class="hljs-built_in">join</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，show 方法可以打印出 20，因为 main 线程调用了 <code>t1.join()</code> 方法等待子线程结束，此时 pw 通过 lock 提升为 ps 成功，见上面代码示例。</p><p>如果设置 t1 为分离线程，让 main 主线程结束，p 智能指针析构，进而把 Test 对象析构，此时 show 方法已经不会被调用，因为在 threadProc 方法中，pw 提升到 ps 时，lock 方法判定 Test 对象已经析构，提升失败！main 函数代码可以如下修改测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 在堆上定义共享对象</span><br><span class="hljs-function">shared_ptr&lt;Test&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test)</span></span>;<br><span class="hljs-comment">// 使用C++11的线程，开启一个新线程，并传入共享对象的弱智能指针</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(threadProc, weak_ptr&lt;Test&gt;(p))</span></span>;<br><span class="hljs-comment">// 在main线程中析构Test共享对象</span><br><span class="hljs-comment">// 设置子线程分离</span><br>t1.<span class="hljs-built_in">detach</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该 main 函数运行后，最终的 threadProc 中，show 方法不会被执行到。<strong>以上是在多线程中访问共享对象时，对shared_ptr和weak_ptr的一个典型应用</strong>。</p><h2 id="5-自定义删除器"><a href="#5-自定义删除器" class="headerlink" title="5. 自定义删除器"></a>5. 自定义删除器</h2><p>在用智能指针管理的资源是堆内存，当智能指针出作用域的时候，在其析构函数中会 delete 释放堆内存资源，但是除了堆内存资源，智能指针还可以管理其它资源，比如：打开的文件，此时对于文件指针的关闭，就不能用 delete 了，这时需要自定义智能指针释放资源的方式，先看看 <code>unique_ptr</code> 智能指针的析构函数代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">~<span class="hljs-built_in">unique_ptr</span>() <span class="hljs-keyword">noexcept</span><br>&#123;<span class="hljs-comment">// destroy the object</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">pointer</span>())<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">get_deleter</span>()(<span class="hljs-built_in">get</span>()); <span class="hljs-comment">// 这里获取底层的删除器，进行函数对象的调用</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 <code>unique_ptr</code> 的析构函数可以看到，如果要实现一个自定义的删除器，实际上就是定义一个函数对象而已，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDeleter</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 删除器负责删除资源的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE* pf)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">fclose</span>(pf);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 由于用智能指针管理文件资源，因此传入自定义的删除器类型FileDeleter</span><br><span class="hljs-function">unique_ptr&lt;FILE, FileDeleter&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>))</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这种方式需要定义额外的函数对象类型，不推荐，可以用 C++11 提供的函数对象 function 和 lambda 表达式更好的处理自定义删除器，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 自定义智能指针删除器，关闭文件资源</span><br>unique_ptr&lt;FILE, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <br><span class="hljs-built_in">filePtr</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), [](FILE *pf)-&gt;<span class="hljs-type">void</span>&#123;<span class="hljs-built_in">fclose</span>(pf);&#125;);<br><br><span class="hljs-comment">// 自定义智能指针删除器，释放数组资源</span><br>unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt;<br><span class="hljs-built_in">arrayPtr</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], [](<span class="hljs-type">int</span> *ptr)-&gt;<span class="hljs-type">void</span> &#123;<span class="hljs-keyword">delete</span>[]ptr; &#125;);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>想进一步了解智能指针，可以查看智能指针的源码实现，或者看 muduo 网络库的源码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>08.C++ 优化</title>
    <link href="/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/08.C++%20%E4%BC%98%E5%8C%96/"/>
    <url>/2023/08/17/03.C++%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/08.C++%20%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>本节分为六部分：</p><ol><li>对象使用时调用了哪些方法</li><li>函数使用时调用了哪些方法</li><li>三条对象优化规则</li><li>右值引用</li><li>move 移动语义</li><li>forward 完美转义</li></ol><h3 id="1-对象使用时调用了哪些方法"><a href="#1-对象使用时调用了哪些方法" class="headerlink" title="1. 对象使用时调用了哪些方法"></a>1. 对象使用时调用了哪些方法</h3><p><strong>C++ 编译器对于对象构造的优化，用临时对象生成新对象的时候，临时对象不产生了，直接构建新对象。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ma</span>(a)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(int)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) :<span class="hljs-built_in">ma</span>(t.ma)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>        ma = t.ma;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;1.Test t1;&quot;</span> &lt;&lt; endl;<br>    Test t1;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n2.Test t2(t1)&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n3.Test t3 = t1;&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    Test t3 = t1;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n4.Test t4 = Test(20);&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    C++ 编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象</span><br><span class="hljs-comment">    就不产生了，直接构造新对象就可以了</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 和Test t4(20);没有区别的！ 仅调用一次默认构造函数</span><br>    Test t4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">20</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308170951985.png" alt="image.png"></p><p><strong>调用赋值函数，因为t4原本已存在</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n5. t4 = t2;&quot;</span> &lt;&lt; endl;<br>t4 = t2;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171001411.png" alt="image.png"></p><p><strong>显式生成临时对象，临时对象生成后，给 t4 赋值,出语句后，临时对象析构 (默认构造函数，赋值运算符，析构函数)</strong></p><p>用临时对象赋值给已存在的对象的时候，要产生临时对象，再调用 <code>operator=</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n6. t4 = Test(20);&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 显式生成临时对象,临时对象生成后</span><br><span class="hljs-comment">// 给t4赋值,出语句后，临时对象析构 (默认构造函数，赋值运算符，析构函数)</span><br>t4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171003567.png" alt="image.png"></p><p><strong>构造函数完成类型转换。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"> cout &lt;&lt; <span class="hljs-string">&quot;\n7.t4 = (Test)30;&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">/************************************************************************/</span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment">把其他类型转成类类型的时候，编译器就看这个类的类型</span><br><span class="hljs-comment">有没有合适的构造函数 把整型转成 Test，就看这个类的类型有没有</span><br><span class="hljs-comment">    带 int 类型参数的构造函数 ，有，就可以显式生成临时对象，然后</span><br><span class="hljs-comment">    赋值给 t4 出语句后，临时对象析构</span><br><span class="hljs-comment">*/</span><span class="hljs-comment">/************************************************************************/</span><br><span class="hljs-comment">// 把 30 强转成 Test 类型 int-&gt;Test(int)  同 t4 = Test(20);</span><br>t4 = (Test)<span class="hljs-number">30</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;\n8.t4 = 40;&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 隐式生成临时对象,然后赋值给t4，出语句后，临时对象析构  同7</span><br>t4 = <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171006393.png" alt="image.png"></p><p><strong>临时对象生存周期：所在的语句</strong></p><p>而引用就是别名，相当于给这块内存又给了个名字，所以用引用来引用临时对象，临时对象的生命周期就变成引用变量的生命周期了。</p><p>所以用指针指向临时变量是不安全的，而用引用引用临时对象是安全的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n9. Test *p = &amp;Test(40);&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 指针指向临时对象，这个临时对象肯定是要生成的</span><br>Test* p = &amp;<span class="hljs-built_in">Test</span>(<span class="hljs-number">40</span>);<br><span class="hljs-comment">// 然后p指向这个临时对象的地址</span><br><span class="hljs-comment">// 出语句后，临时对象析构 </span><br><span class="hljs-comment">// 此时p指向的是一个已经析构的临时对象，p相当于野指针了</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;\n10. const Test &amp;ref = Test(50);&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 引用一个临时对象，这个临时对象也是要生成的</span><br><span class="hljs-type">const</span> Test&amp; ref = <span class="hljs-built_in">Test</span>(<span class="hljs-number">50</span>);<br><span class="hljs-comment">// 出语句后，临时对象不析构，因为引用相当于是别名，临时对象出语句析构是因为没有名字 </span><br><span class="hljs-comment">// 用引用变量引用临时对象是安全的，临时对象就是有名字了，临时对象的生存周期就变成引用变量的</span><br><span class="hljs-comment">// 生存周期了。引用变量是这个函数的局部变量，return完，这个临时对象才析构 </span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171011279.png" alt="image.png"></p><p><strong>程序运行，对象构造顺序以及背后调用总结</strong></p><ul><li>先全局</li><li>再进入 main</li></ul><p><strong>注意：</strong></p><ul><li>静态局部变量，内存分配是在程序运行之前就分配好的，因为有初值的静态局部变量存储在 <code>.data</code> 区，<code>.data</code> 区的内存是事先就分配好的；但是静态局部变量的初始化（对象的构造）是在运行到它的时候才初始化，<code>.data</code> 区析构的时候是程序结束（main 结束）的时候析构</li><li>new 比 malloc 多的：new 不仅分配内存，还构建对象；delete 比 free 多的：delete 不仅释放内存，释放之前先调用析构函数。</li></ul><p><strong>对象底层调用代码示例：（注释是构造顺序与底层调用的方法）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//因为a,b有默认值所以构造有3种方式：</span><br>    <span class="hljs-comment">//Test() Test(10) Test(10, 10)</span><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">5</span>)<span class="hljs-comment">//构造函数 </span><br>        :<span class="hljs-built_in">ma</span>(a), <span class="hljs-built_in">mb</span>(b)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(int, int)：&quot;</span> &lt;&lt; ma &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; mb &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>()<span class="hljs-comment">//析构函数 </span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Test()：&quot;</span> &lt;&lt; ma &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; mb &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; src)<span class="hljs-comment">//拷贝构造函数 </span><br>        :<span class="hljs-built_in">ma</span>(src.ma), <span class="hljs-built_in">mb</span>(src.mb)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; src)<span class="hljs-comment">//赋值函数 </span><br>    &#123;<br>        ma = src.ma;<br>        mb = src.mb;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ma;<br>    <span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-comment">// 在mian函数之前构造，在main函数结束后释放，存储在.data段</span><br><span class="hljs-function">Test <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n---------------------------main()&quot;</span> &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 1.Test t2(20,20); &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 2.Test t3 = t2&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    Test t3 = t2;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 3.Test t3 = t2&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 第一次运行到它才初始化</span><br>    <span class="hljs-type">static</span> Test t4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">30</span>, <span class="hljs-number">30</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 4 t2 = (Test)(50, 50);&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// (50,50)是逗号表达式，(表达式1，表达式2，表达式n)</span><br>    <span class="hljs-comment">// (50,50)的最后的结果是最后一个表达式n的结果 50</span><br>    <span class="hljs-comment">// (50, 50) =  (Test)50;</span><br>    t2 = (Test)(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);    <span class="hljs-comment">// Test(int,int) operator= 出语句调用~Test()</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 5  Test* p1 = new Test(70, 70);&quot;</span> &lt;&lt; endl;<br>    Test* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">70</span>, <span class="hljs-number">70</span>);    <span class="hljs-comment">// Test(int,int) 要调用delete才析构对象</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 6  Test* p2 = new Test[2];&quot;</span> &lt;&lt; endl;<br>    Test* p2 = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">2</span>];         <span class="hljs-comment">// Test(int,int) Test(int,int) 要调用delete才析构对象</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 7  Test* p3 = &amp;Test(80, 80);&quot;</span> &lt;&lt; endl;<br>    Test* p3 = &amp;<span class="hljs-built_in">Test</span>(<span class="hljs-number">80</span>, <span class="hljs-number">80</span>);       <span class="hljs-comment">// Test(int,int) 出语句调用~Test()</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n 8  const Test&amp; p4 = Test(90, 90);&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">const</span> Test&amp; p4 = <span class="hljs-built_in">Test</span>(<span class="hljs-number">90</span>, <span class="hljs-number">90</span>);  <span class="hljs-comment">// Test(int,int)</span><br><br>    <span class="hljs-comment">// ~Test()</span><br>    <span class="hljs-keyword">delete</span> p1;<br>    <span class="hljs-comment">// ~Test() ~Test()</span><br>    <span class="hljs-keyword">delete</span>[]p2;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n---------------------------finish&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Test <span class="hljs-title">t5</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span></span>;<span class="hljs-comment">//Test(int, int)</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171023620.png" alt="image.png"></p><h2 id="2-函数使用时调用了哪些方法"><a href="#2-函数使用时调用了哪些方法" class="headerlink" title="2. 函数使用时调用了哪些方法"></a>2. 函数使用时调用了哪些方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//有默认值，可以有2种构造方式：Test()  Test(20)</span><br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ma</span>(data)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Test(int):&quot;</span> &lt;&lt;  ma &lt;&lt;  endl;<br>  &#125;<br>  ~<span class="hljs-built_in">Test</span>()<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; ma &lt;&lt;  endl;<br>  &#125;<br>  <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test &amp;t) :<span class="hljs-built_in">ma</span>(t.ma)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;<br>  &#125;<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test &amp;t)<br>  &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>    ma = t.ma;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> ma; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> ma;<br>&#125;;<br> <br><span class="hljs-function">Test <span class="hljs-title">GetObject</span><span class="hljs-params">(Test t)</span></span><br><span class="hljs-function"></span>&#123;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------GetObject1 \n&quot;</span>;<br>  <span class="hljs-type">int</span> val = t.<span class="hljs-built_in">getData</span>();<br>  <span class="hljs-function">Test <span class="hljs-title">tmp</span><span class="hljs-params">(val)</span></span>;<br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------GetObject2 \n&quot;</span>;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Test t1;<span class="hljs-comment">//1、调用带整型参数的构造函数 </span><br>  Test t2;<span class="hljs-comment">//2、调用带整型参数的构造函数</span><br>  <br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------main GetObject1 \n&quot;</span>;<br>  t2 = <span class="hljs-built_in">GetObject</span>(t1);<span class="hljs-comment">//函数调用</span><br>  cout &lt;&lt; <span class="hljs-string">&quot;\n----------------main GetObject2 \n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）实参传递给形参：调用 <code>Test(const Test&amp;)</code> 拿 t1 拷贝构造形参 t。<br>（2）调用 <code>Test(int)</code> 的构造，构造 tmp 对象。<br>（3）<code>return tmp;</code> tmp 和 t2 是两个不同函数栈帧上的对象，是不能直接进行赋值的 GetObject 函数完成调用时 tmp 对象作为局部对象就析构 ，为了把返回值带出来， 在 <code>return tmp;</code> 这里，首先要 在main 函数栈帧上构建一个临时对象，目的就是把 tmp 对象带出来。<br>（4）调用 <code>Test(const Test&amp;)</code>，tmp 拷贝构造 main 函数栈帧上的临时对象<br>（5）出 GetObject 作用域，tmp 析构。<br>（6）形参 t 对象析构。<br>（7）<code>operator =</code>，把 main 函数刚才构建的临时对象赋值给 t2，临时对象没名字，出了语句就要析构。<br>（8）把 main 函数刚才构建的临时对象析构。<br>（9）main 函数结束，t2 析构。<br>（10）t1 析构。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171025935.png" alt="image.png"></p><p>短短的代码调用了11个函数，可以优化。</p><h2 id="3-三条对象优化规则"><a href="#3-三条对象优化规则" class="headerlink" title="3. 三条对象优化规则"></a>3. 三条对象优化规则</h2><ol><li>函数参数传递过程中，对象优先按引用传递，这样可以省去一个形参t的拷贝构造调用，形参没有构建新的对象，出作用域也不用析构了，所以不要按值传！</li><li>函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象</li><li>接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收</li></ol><p>优化 1：<strong>没有 t1 的拷贝构造，形参 t 没有新的对象，出作用域也不用析构。</strong></p><p>省去了形参t的拷贝构造和形参t的析构</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171034781.png" alt="image.png"></p><p> 优化 2：<strong>函数返回对象的时候，应该优先返回一个临时对象，而不要返回一个定义过的对象</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171035711.png" alt="image.png"></p><p>优化 3：<strong>接收返回值是对象的函数调用的时候，优先按初始化的方式接收，不要按赋值的方式接收</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171036229.png" alt="image.png"></p><p>函数返回值临时对象给 t2 初始化！用这个临时对象拷贝构造同类型的新对象 t2。<strong>C++ 编译器会进行优化，这个 main 函数栈帧上的临时对象都不产生了，直接构造 t2 对象。也就是 <code>return Test(val);</code> 直接构造 t2 对象了</strong>。</p><p><code>Test t2= GetObject(t1);</code> 在汇编上，除了把 t1 的地址传进去，还把 t2 的地址也传进去了，也压到函数栈帧上，所以 <code>return Test(val);</code> 就可以取到 t2 的地址，就知道在哪块内存上构造一个名为 t2 的对象。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171039594.png" alt="image.png"></p><h2 id="4-右值引用"><a href="#4-右值引用" class="headerlink" title="4. 右值引用"></a>4. 右值引用</h2><p>如果有的应用场景必须返回的是定义过的对象，也必须按赋值的方式来接收函数调用，那优化的后两条规则就用不成了。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171044277.png" alt="image.png"></p><p>解决办法：</p><ul><li>给该类添加一个右值引用拷贝构造函数，函数内部不做资源的分配，而是资源的转移，每当有通过右值（临时对象）来构建对象的时候，就调用右值引用拷贝构造函数。</li></ul><h3 id="1-详解"><a href="#1-详解" class="headerlink" title="1. 详解"></a>1. 详解</h3><ul><li>左值：有名字或有内存</li><li>右值：没名字（临时量）或没内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;b = a;  <span class="hljs-comment">// ok</span><br>    <span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>;  <span class="hljs-comment">//error, 10是纯右值，不能拿普通引用引用它，可以拿常引用引用它</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>;  <span class="hljs-comment">//ok，因为const做了这两件事：int tmp = 10; const int &amp;c= 10;</span><br>    <br>    <span class="hljs-type">int</span> &amp;&amp; d = <span class="hljs-number">10</span>; <span class="hljs-comment">//ok，右值引用，可以把一个右值绑定到右值引用上，底层汇编指令类似于int tmp = 10; int &amp;&amp;d = tmp;</span><br>    <br>    <span class="hljs-comment">//通过const方式不能改右值的值，通过&amp;&amp;右值引用是可以改右值的值的</span><br>    <br>    <span class="hljs-comment">//一个右值引用的变量，本身是一个左值，如int &amp;&amp; d = 10; d本身 是左值，类型是int，变量值是10，所以不能int &amp;&amp;f =d;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>记住两句话：</p><ul><li>常量、数字、临时量、<strong>函数返回值</strong>都是右值，要引用它们就要用右值引用&amp;&amp;，将亡值也属于右值</li><li>一个右值引用的变量，本身是一个左值</li></ul><h3 id="2-提高效率"><a href="#2-提高效率" class="headerlink" title="2. 提高效率"></a>2. 提高效率</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171050183.png" alt="image.png"></p><p>我直接指向你的资源，再把你的指针置为空，你的资源相当于移动给我了</p><p>下图中 tmpStr 匹到的就是右值引用的拷贝构造，因为函数返回值属于右值。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171051588.png" alt="image.png"></p><p><strong>CMyString 的重载加号运算符函数</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171052705.png" alt="image.png"></p><h3 id="3-给容器里拷贝构造对象（笔试题）"><a href="#3-给容器里拷贝构造对象（笔试题）" class="headerlink" title="3. 给容器里拷贝构造对象（笔试题）"></a>3. 给容器里拷贝构造对象（笔试题）</h3><p>vector 提供了左值引用与右值引用的拷贝构造函数，传的是左值就调用左值引用的拷贝构造函数，传的是右值，就调用右值引用的拷贝构造函数。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171053392.png" alt="image.png"></p><h2 id="5-move-移动语义"><a href="#5-move-移动语义" class="headerlink" title="5.  move 移动语义"></a>5.  move 移动语义</h2><p>move：移动语义，<strong>将 val 的类型强转右值引用类型继而可以通过右值引用使用该值，以用于移动语义。</strong></p><p><code>std::move</code> 源码：<code>_Ty</code> 是未定的引用类型，<code>remove_reference_t</code> 用于移除<code>_Ty</code> 的引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>) :<span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data)) &#123; cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span> ptr; ptr = <span class="hljs-literal">nullptr</span>; cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; src)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(const A&amp;)&quot;</span> &lt;&lt; endl;<br>        ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*src.ptr);<br>    &#125;<br>    <span class="hljs-built_in">A</span>(A&amp;&amp; src)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;A(A&amp;&amp;)&quot;</span> &lt;&lt; endl;<br>        ptr = src.ptr;<br>        src.ptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* ptr;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;A&gt; vec;<br>    vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------begin&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(i)</span></span>;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里a是一个左值，因此vec.push_back(a)会调用左值的</span><br><span class="hljs-comment">        拷贝构造函数，用a拷贝构造vector底层数组中的对象</span><br><span class="hljs-comment">        */</span><br>        vec.<span class="hljs-built_in">push_back</span>(a);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;--------------------endl&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171105811.png"></p><p>每次循环都需要首先构造 A,调用 A 的默认构造函数，然后 调用左值引用的拷贝构造函数，看上面的代码，<code>A a(i)</code> 在 for 循环中其实算是局部对象，在 <code>vec.push_back(a)</code> 完成后，a 对象调用析构函数。</p><p>在 <code>vec.push_back(a)</code> 时，应该把对象 a 的资源直接移动给 vector 容器底层的对象，也就是调用右值引用参数的拷贝构造函数，怎么做到呢？这时候就用到了带移动语义的 <code>std::move</code> 函数，main 函数代码修改如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;--------------------begin&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i)&#123;<br>  <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(i)</span></span>;<br> <br>  vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(a));<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------endl&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171109450.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">_EXPORT_STD <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function">_NODISCARD _MSVC_INTRINSIC <span class="hljs-keyword">constexpr</span> <span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，函数参数 <code>T&amp;&amp;</code> 是一个指向模板类型参数的右值引用，通过引用折叠，此参数可以与任何类型的实参匹配（可以传递左值或右值，这是 <code>std::move</code> 主要使用的两种场景)。关于引用折叠如下：</p><p><strong>公式一. <code>X&amp; &amp;</code>、<code>X&amp;&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code> 都折叠成 <code>X&amp;</code>，用于处理左值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>std::<span class="hljs-built_in">move</span>(s) =&gt; std::<span class="hljs-built_in">move</span>(string&amp; &amp;&amp;) =&gt; 折叠后 std::<span class="hljs-built_in">move</span>(string&amp; )<br>此时：T的类型为string&amp;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type为string <br>整个std::move被实例化如下<br>string&amp;&amp; <span class="hljs-built_in">move</span>(string&amp; t) <span class="hljs-comment">//t为左值，移动后不能在使用t</span><br>&#123;<br>    <span class="hljs-comment">//通过static_cast将string&amp;强制转换为string&amp;&amp;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;string&amp;&amp;&gt;(t); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>公式二、<code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code>，用于处理右值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">move</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello&quot;</span>)) =&gt; std::<span class="hljs-built_in">move</span>(string&amp;&amp;)<br><span class="hljs-comment">//此时：T的类型为string </span><br><span class="hljs-comment">//     remove_reference&lt;T&gt;::type为string </span><br><span class="hljs-comment">//整个std::move被实例如下</span><br>string&amp;&amp; <span class="hljs-built_in">move</span>(string&amp;&amp; t) <span class="hljs-comment">//t为右值</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;string&amp;&amp;&gt;(t);  <span class="hljs-comment">//返回一个右值引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用</p><p><code>remove_reference</code> 是通过类模板的部分特例化进行实现的，其实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//原始的，最通用的版本</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&#123;<br>    <span class="hljs-keyword">typedef</span> T type;  <span class="hljs-comment">//定义T的类型别名为type</span><br>&#125;;<br> <br><span class="hljs-comment">//部分版本特例化，将用于左值引用和右值引用</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&gt; <span class="hljs-comment">//左值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;T&amp;&amp;&gt; <span class="hljs-comment">//右值引用</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;   <br>  <br><span class="hljs-comment">//举例如下,下列定义的a、b、c三个变量都是int类型</span><br><span class="hljs-type">int</span> i;<br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-number">42</span>)&gt;::type a;             <span class="hljs-comment">//使用原版本，</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(i)&gt;::type  b;             <span class="hljs-comment">//左值引用特例版本</span><br>remove_refrence&lt;<span class="hljs-keyword">decltype</span>(std::<span class="hljs-built_in">move</span>(i))&gt;::type  b;  <span class="hljs-comment">//右值引用特例版本 </span><br></code></pre></td></tr></table></figure><blockquote><p><code>std::move</code>实现：</p><p>首先，通过右值引用传递模板实现，利用引用折叠原理将右值经过 <code>T&amp;&amp;</code> 传递类型保持不变还是右值，而左值经过 <code>T&amp;&amp;</code> 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变。然后我们通过 <code>static_cast&lt;&gt;</code> 进行强制类型转换返回 <code>T&amp;&amp;</code> 右值引用，而 <code>static_cast</code> 之所以能使用类型转换，是通过 <code>remove_refrence::type</code> 模板移除 <code>T&amp;&amp;</code>，<code>T&amp;</code> 的引用，获取具体类型 T。 </p></blockquote><p><code>std::move</code> 函数可以以非常简单的方式将左值引用转换为右值引用</p><ul><li>C++ 标准库使用比如 <code>vector::push_back</code> 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数 <code>push_back</code> 进去就行了,通 <code>std::move</code>，可以避免不必要的拷贝操作。</li><li><code>std::move</code> 是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。</li><li>对指针类型的标准库对象并不需要这么做.</li></ul><p>使用 <code>std::move</code> 后，左值的内容将会被转移，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//摘自https://zh.cppreference.com/w/cpp/utility/move</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::vector&lt;std::string&gt; v;<br>    <span class="hljs-comment">//调用常规的拷贝构造函数，新建字符数组，拷贝数据</span><br>    v.<span class="hljs-built_in">push_back</span>(str);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>    <span class="hljs-comment">//调用移动构造函数，掏空str，掏空后，最好不要使用str</span><br>    v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="hljs-number">0</span>]<br>                                         &lt;&lt; <span class="hljs-string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171158831.png" alt="image.png"></p><h2 id="6-forward-完美转义"><a href="#6-forward-完美转义" class="headerlink" title="6. forward 完美转义"></a>6. forward 完美转义</h2><p><code>std::forward</code> 通常是用于完美转发的，它会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。一个经典的完美转发的场景是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">forward</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的有 2 点：</p><ul><li>输入参数的类型是 <code>Args&amp;&amp;...</code> ， &amp;&amp; 的作用是引用折叠</li><li><code>std::forward</code> 的模板参数必须是 <code>&lt;Args&gt;</code>，而不能是 <code>&lt;Args...&gt;</code>，这是由于我们不能对 Args 进行解包之后传递给 <code>std::forward</code>，而解包的过程必须在调用 <code>std::forward</code> 之后.</li></ul><p>其实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// FUNCTION TEMPLATE forward</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Ty&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// forward an lvalue as either an lvalue or an rvalue</span><br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg));<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> _Ty&gt;</span><br><span class="hljs-function">_NODISCARD <span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">// forward an rvalue as an rvalue</span><br><span class="hljs-built_in">static_assert</span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="hljs-string">&quot;bad forward call&quot;</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::remove_reference_t</code> 是一个模板类的类型别名，用于去掉 T 的引用属性。</p><p><strong>实例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-type">int</span> value;<br>  <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> value=<span class="hljs-number">0</span>) : <span class="hljs-built_in">value</span>(value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;construct&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br> <br>   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;a) : <span class="hljs-built_in">value</span>(a.value) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;A(const A&amp;a):&quot;</span> &lt;&lt; a.value  &lt;&lt; std::endl;<br>  &#125;<br> <br>   <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;&amp;a) : <span class="hljs-built_in">value</span>(a.value) &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;A(const A&amp;&amp;a):&quot;</span> &lt;&lt; a.value &lt;&lt; std::endl;<br>   &#125;<br> <br>  ~<span class="hljs-built_in">A</span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;deconstruct&quot;</span> &lt;&lt; std::endl;<br>  &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(A&amp;&amp; a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;完美转发 右值引用： &quot;</span> &lt;&lt; a.value &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(A&amp; a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;完美转发 左值引用： &quot;</span> &lt;&lt; a.value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_forward</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>  <span class="hljs-built_in">test</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>  <span class="hljs-type">float</span> b = <span class="hljs-number">2.1</span>;<br>  <span class="hljs-built_in">test_forward</span>(a, b);<br> <br>  <span class="hljs-built_in">test_forward</span>(std::<span class="hljs-built_in">move</span>(a), b);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>test_forward</code> 第一个参数通过 forward 完美转发到 <code>void test(A&amp; a, double b)</code> 以及 <code>void test(A&amp;&amp; a, double b)；</code></p><p>首先传入左值 <code>test_forward(a,b)</code>  -&gt; 调用 <code>void test(A&amp; a, double b)</code>。</p><p>之后传入传入左值 <code>test_forward(std::move(a),b)</code>  -&gt;调用 <code>void test(A&amp;&amp; a, double b)</code>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308171201247.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07.C++ STL</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/07.C++%20STL/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/07.C++%20STL/</url>
    
    <content type="html"><![CDATA[<p>本节分为十部分：</p><ol><li>vector 容器</li><li>deque 容器</li><li>list 容器</li><li>vector、deque、list 对比分析</li><li>详解容器适配器</li><li>无序关联容器</li><li>有序关联容器</li><li>迭代器 iterator</li><li>函数对象</li><li>泛型算法和绑定器</li></ol><p><strong>STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。</strong></p><h2 id="1-vector-容器"><a href="#1-vector-容器" class="headerlink" title="1. vector 容器"></a>1. vector 容器</h2><p><strong>vector</strong>：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 </p><p>容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。</p><h3 id="1-使用方法合集"><a href="#1-使用方法合集" class="headerlink" title="1. 使用方法合集"></a>1. 使用方法合集</h3><p><strong>语法结构：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure><p><strong>使用方式：</strong> 使用前包含头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure><ol><li><strong>增加：</strong></li></ol><ul><li>**<code>push_back()</code>**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。</li><li>**<code>insert(迭代器，迭代器位置)</code>**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。</li></ul><ol start="2"><li><strong>删除：</strong></li></ol><ul><li>**<code>pop_back()</code>**：在容器末尾删除一个元素，时间复杂度O(1)。</li><li>**<code>erase()</code>**：删除it迭代器指向的元素，时间复杂度O(n)。</li></ul><ol start="3"><li><strong>查询：</strong></li></ol><ul><li>**<code>operator[]</code>**：数据下标的随机访问<code>vec[5]</code>，时间复杂度O(1)。</li><li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li><li>**<code>find()\for_each</code>**：泛型算法。</li><li>**<code>foreach</code>**：C++11提供的语法糖，通过迭代器iterator来实现的。</li></ul><ol start="4"><li><strong>常用方法：</strong></li></ol><ul><li>**<code>size()</code>**：返回容器底层有效元素的个数。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>reserve()</code>**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</li><li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li><li>**<code>swap()</code>**：两个容器进行元素交换。</li></ul><h3 id="2-容器使用"><a href="#2-容器使用" class="headerlink" title="2. 容器使用"></a>2. 容器使用</h3><ol><li><strong>对 vector 容器中元素遍历。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector </span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 1. 运算符重载遍历</span><br><span class="hljs-type">int</span> size = vec.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 2. 迭代器遍历</span><br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png" alt="image.png"></p><ol start="2"><li><strong>把 vec 容器中所有偶数全部删除</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector </span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">auto</span> it1 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it1 != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <br>&#123;<br>it1 = vec.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it1++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 2. 迭代器遍历</span><br><span class="hljs-keyword">auto</span> it2 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png" alt="image.png"></p><ol start="3"><li><strong>在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义 vector </span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//vec的operator[]运算符重载函数进行vector遍历</span><br><span class="hljs-type">int</span> size = vec.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>&#123;<br>cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">auto</span> it1 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it1 != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <br>&#123;<br>it1 = vec.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it1++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 迭代器遍历</span><br><span class="hljs-keyword">auto</span> it2 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 添加</span><br><span class="hljs-keyword">for</span> (it2 = vec.<span class="hljs-built_in">begin</span>(); it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br><span class="hljs-keyword">if</span> (*it2 % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>&#123;<br>it2 = vec.<span class="hljs-built_in">insert</span>(it2, *it2<span class="hljs-number">-1</span>);<br>++it2;<br>&#125;<br>&#125;<br><br>it2 = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it2 != vec.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br>cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png" alt="image.png"></p><ol start="4"><li><strong>reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</strong></li></ol><p>默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<span class="hljs-comment">// 默认定义的 vector 底层为 0</span><br>vec.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">20</span>);<span class="hljs-comment">// 给 vector 容器预留空间</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果: <code>empty()</code> 是 1 为空，0 为非空。刚开始为空，<code>reserve(20)</code> 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png" alt="image.png"></p><ol start="5"><li><strong>resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。</strong></li></ol><p><code>resize()</code> 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 使用 vector 库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<span class="hljs-comment">//默认定义的vector底层为0</span><br>vec.<span class="hljs-built_in">resize</span>(<span class="hljs-number">20</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png" alt="image.png"></p><h2 id="2-deque-容器"><a href="#2-deque-容器" class="headerlink" title="2. deque 容器"></a>2. deque 容器</h2><p><strong>deque：双端队列容器，底层为动态开辟的二维数组。</strong> **</p><p>一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 <code>oldsize/2</code> 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。</p><h3 id="1-容器结构"><a href="#1-容器结构" class="headerlink" title="1. 容器结构"></a>1. 容器结构</h3><p>其底层为：<strong>动态开辟的二维数组</strong>。</p><p>其有两个宏：<code>MAP_SIZE</code>，为2；<code>QUE_SIZE</code>，为 <code>4096/sizeof(T)</code>，T 为实际的类型。底层有 2 个维度，还有一个 mapper 指针，指向第一维的一维数组，默认大小为<code> MAP_SIZE 2</code>；第二维为动态开辟的 <code>QUE_SIZE</code> 的大小，例如：使用整型时会有1024个元素。</p><p>双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；</p><p>简易的画了一个方向，first 与 last 处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150854875.png" alt="image.png"></p><h3 id="2-扩容方式"><a href="#2-扩容方式" class="headerlink" title="2. 扩容方式"></a>2. 扩容方式</h3><p>当我们元素的不断增加，相应的指示位置向后移动。</p><ul><li>如图 2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150858867.png" alt="image.png"></p><ul><li>如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150902713.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150903312.png" alt="image.png"></p><ul><li>如图5，6；刚才的第二维移动到第一维中间部分(<code>oldsize/2</code>)，方便任何一边的元素改动。若需再次扩容，同理。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150906687.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150909908.png" alt="image.png"></p><h3 id="3-使用方法合集"><a href="#3-使用方法合集" class="headerlink" title="3. 使用方法合集"></a>3. 使用方法合集</h3><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">deque&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure><ol><li><strong>增加：</strong></li></ol><ul><li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li><li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li><li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(n)。</li></ul><ol start="2"><li><strong>删除：</strong></li></ol><ul><li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li><li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li><li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li></ul><ol start="3"><li><strong>查询：</strong></li></ol><ul><li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li></ul><ol start="4"><li><strong>常用方法：</strong></li></ol><ul><li>**<code>size()</code>**：返回容器底层有效元素的个数。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li><li>**<code>swap()</code>**：两个容器进行元素交换。</li></ul><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><p>和 vector 实例类似，直接参考 vector 容器实例即可。</p><h2 id="3-list-容器"><a href="#3-list-容器" class="headerlink" title="3. list 容器"></a>3. list 容器</h2><p><strong>list：链表容器，底层数据结构为双向循环链表。</strong></p><h3 id="1-使用方法合集-1"><a href="#1-使用方法合集-1" class="headerlink" title="1. 使用方法合集"></a>1. 使用方法合集</h3><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure><ol><li><strong>增加：</strong></li></ol><ul><li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li><li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li><li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行 <code>insert()</code> 时，要先进行 <code>query()</code> 操作，效率就慢了。</li></ul><ol start="2"><li><strong>删除：</strong></li></ol><ul><li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li><li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li><li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li></ul><ol start="3"><li><strong>查询：</strong></li></ol><ul><li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li></ul><ol start="4"><li><strong>常用方法：</strong></li></ol><ul><li>**<code>size()</code>**：返回容器底层有效元素的个数。</li><li>**<code>empty()</code>**：判断容器是否为空。</li><li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li><li>**<code>swap()</code>**：两个容器进行元素交换。</li></ul><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h3><p>使用实例与vector类似。</p><h2 id="4-vector、deque、list-对比分析"><a href="#4-vector、deque、list-对比分析" class="headerlink" title="4. vector、deque、list 对比分析"></a>4. vector、deque、list 对比分析</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150924833.png" alt="image.png"></p><ol><li><strong>deque 底层内存是否是连续的？</strong></li></ol><p>不是，deque 底层是动态开辟的二维数组，第二维都是独立开辟的空间，每一个第二维是连续的，但是所有的二维不是连续的。</p><ol start="2"><li><strong>vector 与 deque 容器之间的区别：</strong></li></ol><ul><li><strong>vector 特点：</strong> 底层是一个动态开辟数组，内存是连续的，2 倍的方式进行扩容。当默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li><li><strong>deque 特点：</strong> 底层为动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容时候(第一维的数组进行 2 倍扩容，原来的第二维的数组放入新扩容的数组中间)，支持前后插入删除为 O(1) 的操作。</li></ul><p><strong>区别：</strong></p><ul><li><strong>底层数据结构不同</strong>：vector 底层为动态开辟的数组，内存是连续的；deque 底层是动态开辟的二维数组空间，内存不连续。</li><li><strong>前中后删除的时间复杂度不同</strong>：它们中间与末尾插入删除一样为 O(1)，但最前面进行元素添加时候 deque 为 O(1)，vector 为 O(n)。</li><li><strong>内存使用效率不同</strong>：vector 低，需要的内存空间必须是连续的；deque 第二维内存空间不一定连续，可以分块进行数据存储，对内存使用效率会更高。</li><li><strong>在中间进行 insert 或者 erase，vector 与 deque 的效率不同</strong>：它们时间复杂度都为 O(n)，但 vecto r内存完全连续，其他元素容易移动；但 deque 内存不连续，元素移动更加麻烦一些，效率不如 vector。</li></ul><ol start="3"><li><strong>vector 与 list 容器之间的区别：</strong></li></ol><ul><li><strong>vector 特点</strong>： 底层是一个动态开辟的数组，内存是连续的，2 倍的方式进行扩容。当我们默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li><li><strong>list 特点</strong>： 底层是一个双向循环链表。</li></ul><p><strong>区别：</strong></p><p><strong>数组与链表区别</strong>：数组增加删除为 O(n)，查询 O(n)，随机访问为 O(1)；链表增加删除一个结点本身为 O(1)，但搜索的时间为 O(n)。如果增加删除使用多，优先使用 list；随机访问使用多，优先使用 vector。</p><h2 id="5-详解容器适配器"><a href="#5-详解容器适配器" class="headerlink" title="5. 详解容器适配器"></a>5. 详解容器适配器</h2><p>容器适配器：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。</p><p><strong>使用容器适配器实现栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">typename</span> Container=deque&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> Stack<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">void</span> <span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; val)<br>&#123;<br>con.<span class="hljs-built_in">push_back</span>(val);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>con.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br><span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> con.<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Container con;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>s.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>s.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现成功，相当于栈将 deque 代理了一下，也成为代理模式。push 将底层容器的 <code>push_back</code> 代理了，pop 将底层 <code>pop_back</code> 代理了，栈的 top 将容器底层的 back 代理了。</p><h3 id="1-Stack-栈容器"><a href="#1-Stack-栈容器" class="headerlink" title="1. Stack 栈容器"></a>1. Stack 栈容器</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151017597.png" alt="image.png"></p><p><code>stack&lt;T&gt;</code> 容器适配器中的数据是以 LIFO（Last In First Out） 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。</p><p>上图：展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。</p><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li>**<code>push()</code>**：入栈  </li><li>**<code>pop()</code>**：  出栈 </li><li>**<code>top()</code>**：查看栈顶元素  </li><li>**<code>empty()</code>**：判断栈空  </li><li>**<code>size()</code>**：返回元素个数</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;栈中元素个数:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>s.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151023238.png" alt="image.png"></p><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>只能访问 <code>queue&lt;T&gt;</code> 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。  </p><p>许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO（First In First Out） 准则处理的序列来说，使用 queue 容器适配器都是好的选择。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151024083.png" alt="image.png"></p><p><strong>使用前提：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><ul><li>**<code>push()</code>**：入栈  </li><li>**<code>pop()</code>**：  出栈 </li><li>**<code>front()</code>**：查看对头元素</li><li>**<code>back()</code>**：查看队尾元素</li><li>**<code>empty()</code>**：判断空  </li><li>**<code>size()</code>**：返回元素个数</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;队列中元素个数:&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151027513.png" alt="image.png"></p><h3 id="3-优先级队列"><a href="#3-优先级队列" class="headerlink" title="3. 优先级队列"></a>3. 优先级队列</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151036304.png" alt="image.png"></p><p><strong>优先级队列：底层数据结构为大根堆。</strong> </p><p>使用库中的优先级队列，需要加上头文件<code>&lt;queue&gt;</code>；<strong>优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。</strong></p><p><strong>常用方法：</strong></p><ul><li>**<code>push()</code>**：入栈  </li><li>**<code>pop()</code>**：  出栈 </li><li>**<code>top()</code>**：查看栈顶元素  </li><li>**<code>empty()</code>**：判断栈空  </li><li>**<code>size()</code>**：返回元素个数</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;优先队列中元素个数:&quot;</span> &lt;&lt; q.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>数据从大到小依次出队，数据越大优先级越高。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151039915.png" alt="image.png"></p><p><strong>问题一：stack 与 queue 第二个模板类型参数依赖 deque，为什么不依赖 vector？</strong></p><ol><li>vector 的初始化内存使用效率太低了，没有 deque 好。</li><li>对于 queue 来说，需要支持尾部插入，头部删除，时间复杂度需要为 O(1)，deque 恰好符合条件，若用 vector 其底层效率太低。</li><li>vector 需要大片的连续内存，而 deque 只需要分段的内存，当存储大量数据时，显然 deuqe 对于内存的利用率更高更好一些。</li></ol><p><strong>问题二：优先级队列为什么底层依赖 vector？</strong></p><p>优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为 i，左孩子为 <code>2i+1</code>，右孩子为 <code>2i+2</code>；大根堆为堆顶，其元素最大，结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的，因此底层依赖 vector；而 deque 的第二维不是连续的，不能使用。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151042363.png" alt="image.png"></p><h2 id="6-无序关联容器"><a href="#6-无序关联容器" class="headerlink" title="6. 无序关联容器"></a>6. 无序关联容器</h2><p><strong>关联容器分为：无序关联容器与有序关联容器，简单对比下：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151043482.png" alt="image.png"></p><p><strong>无序关联容器：底层为哈希表，里面元素无顺序，增删查为O(1)。</strong></p><h3 id="1-单重集合与多重集合"><a href="#1-单重集合与多重集合" class="headerlink" title="1. 单重集合与多重集合"></a>1. 单重集合与多重集合</h3><ul><li><strong>set 集合</strong>：存储的是关键字。<code>[key]</code></li><li><strong>unordered_set</strong>：单重集合；不允许 key 重复。</li><li><strong>unordered_multiset</strong>：多重集合；允许 key 重复。</li></ul><p><strong>包含文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p><p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p><p><strong>使用1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 不允许存储key值重复的元素</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; ++i)<br>&#123;<br><span class="hljs-comment">// 与vector/deque/list插入不同</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 返回key为15的元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151117267.png" alt="image.png"></p><p><strong>使用2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 不允许存储key值重复的元素</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; ++i)<br>&#123;<br><span class="hljs-comment">// 与vector/deque/list插入不同</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 迭代器遍历容器</span><br><span class="hljs-keyword">auto</span> it1 = set1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it1 != set1.<span class="hljs-built_in">end</span>(); ++it1)<br>&#123;<br>cout &lt;&lt; *it1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 按key值删除元素</span><br>set1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> (it1 = set1.<span class="hljs-built_in">begin</span>(); it1 != set1.<span class="hljs-built_in">end</span>();)<br>&#123;<br><span class="hljs-keyword">if</span> (*it1 == <span class="hljs-number">30</span>)<br>&#123;<br><span class="hljs-comment">// 迭代器删除元素</span><br>it1 = set1.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>++it1;<br>&#125;<br>&#125;<br><br>it1 = set1.<span class="hljs-built_in">find</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">if</span> (it1 != set1.<span class="hljs-built_in">end</span>())<br>&#123;<br>set1.<span class="hljs-built_in">erase</span>(it1);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set1)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151119097.png" alt="image.png"></p><p><strong>使用3：unordered_multiset</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 允许存储key值重复的元素</span><br>unordered_multiset&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; ++i)<br>&#123;<br><span class="hljs-comment">// 与vector/deque/list插入不同</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><span class="hljs-comment">// 返回key为15的元素的个数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">15</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151121798.png" alt="image.png"></p><h3 id="2-单重映射表与多重映射表"><a href="#2-单重映射表与多重映射表" class="headerlink" title="2. 单重映射表与多重映射表"></a>2. 单重映射表与多重映射表</h3><ul><li><strong>map 集合</strong>：存储的是键值对。<code>[key，value]</code></li><li><strong>unordered_map</strong>：单重映射表；不可重复。</li><li><strong>unordered_multimap</strong>：多重映射表；可重复。</li></ul><p><strong>包含文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p><p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p><p><strong>使用1：unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map1;<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;size: &quot;</span> &lt;&lt; map1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">//键值对个数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用2：unordered_multimap</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_multimap&lt;<span class="hljs-type">int</span>,string&gt; map1;<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;张三&quot;</span>));<span class="hljs-comment">//打包成键值对</span><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>,<span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>,<span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;王五&quot;</span>));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;size: &quot;</span> &lt;&lt; map1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">// 键值对个数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用3：查询</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//map operator[](key) =&gt;value </span><br>cout &lt;&lt; map1[<span class="hljs-number">1000</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map1;<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br><br>map1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1020</span>);<span class="hljs-comment">//删除</span><br>map1[<span class="hljs-number">2000</span>] = <span class="hljs-string">&quot;刘帅&quot;</span>;<span class="hljs-comment">//相当于插入</span><br>map1[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;张三2&quot;</span>;<span class="hljs-comment">//相当于修改操作</span><br><br>cout &lt;&lt; map1.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<span class="hljs-comment">//键值对个数</span><br><span class="hljs-comment">// map operator[](key) =&gt;value 查询</span><br>cout &lt;&lt; map1[<span class="hljs-number">1000</span>] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用4：iterator 查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>, string&gt; map1;<br><br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1030</span>, <span class="hljs-string">&quot;赵六&quot;</span>));<br><br><span class="hljs-keyword">auto</span> it1 = map1.<span class="hljs-built_in">find</span>(<span class="hljs-number">1030</span>);<br><span class="hljs-keyword">if</span> (it1 != map1.<span class="hljs-built_in">end</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it1-&gt;first &lt;&lt; <span class="hljs-string">&quot; value:&quot;</span> &lt;&lt; it1-&gt;second &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-海量数据"><a href="#3-海量数据" class="headerlink" title="3. 海量数据"></a>3. 海量数据</h3><p><strong>案例1：处理海量数据数据查重，经常会使用map。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ARR_LEN = <span class="hljs-number">1000</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[ARR_LEN] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ARR_LEN; i++)<br>&#123;<br>arr[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数</span><br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k : arr)<br>&#123;<br><span class="hljs-keyword">auto</span> it = map1.<span class="hljs-built_in">find</span>(k);<br><span class="hljs-keyword">if</span> (it == map1.<span class="hljs-built_in">end</span>())<span class="hljs-comment">//数字没出现过</span><br>&#123;<br>map1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(k, <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it-&gt;second++;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">auto</span> it = map1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != map1.<span class="hljs-built_in">end</span>(); ++it)<br>&#123;<br><span class="hljs-keyword">if</span> (it-&gt;second &gt; <span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>案例2：海量数据去重。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ARR_LEN = <span class="hljs-number">1000</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[ARR_LEN] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ARR_LEN; i++)<br>&#123;<br>arr[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">20</span> + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 上面的整数中，将数字进行去重打印</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr)<br>&#123;<br>set.<span class="hljs-built_in">insert</span>(v);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-有序关联容器"><a href="#7-有序关联容器" class="headerlink" title="7. 有序关联容器"></a>7. 有序关联容器</h2><p><strong>有序关联容器：底层为红黑树，里面元素有序，增删查 $O(log^{2n})$。</strong></p><p><strong>包含文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。</li><li>multiset：多重集合，可以存储重复的元素，从小到大元素有序排列。</li><li>map：单重映射表，重复的只出现一次，从小到大元素有序排列。</li><li>multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。</li></ul><p><strong>实例1：set 实例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; set1;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; i++)<br>&#123;<br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>()%<span class="hljs-number">20</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set1)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>实例2：set 存放自定义类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> id, string name)<br>: _id(id)<br>, _name(name)<br>&#123;<br><span class="hljs-comment">// 舒适化列表</span><br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Student&amp; stu) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _id &lt; stu._id;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _id;<br>string _name;<br><span class="hljs-comment">// 友元</span><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Student&amp; str);<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Student&amp; stu)<br>&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;id: &quot;</span> &lt;&lt; stu._id &lt;&lt; endl;<br>out &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; stu._name;<br><br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>set&lt;Student&gt; set1;<br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Student</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;张文&quot;</span>));<br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">Student</span>(<span class="hljs-number">1020</span>, <span class="hljs-string">&quot;李广&quot;</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = set1.<span class="hljs-built_in">begin</span>(); it != set1.<span class="hljs-built_in">end</span>(); ++it)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>实例3：map 实例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(<span class="hljs-type">int</span> id = <span class="hljs-number">0</span>, string name = <span class="hljs-string">&quot;&quot;</span>)<br>:_id(id), _name(name)&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _id;<br>string _name;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Student &amp;stu);<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> Student &amp;stu)<br>&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class="hljs-string">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">int</span>, Student&gt; stuMap;<br>stuMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1010</span>,<span class="hljs-built_in">Student</span>(<span class="hljs-number">1010</span>,<span class="hljs-string">&quot;张文&quot;</span>)));<br>stuMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1020</span>,<span class="hljs-built_in">Student</span>(<span class="hljs-number">1020</span>,<span class="hljs-string">&quot;李广&quot;</span>)));<br>stuMap.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1030</span>,<span class="hljs-built_in">Student</span>(<span class="hljs-number">1030</span>,<span class="hljs-string">&quot;高阳&quot;</span>)));<br><br><span class="hljs-comment">//stuMap.erase(it) stuMap.erase(1020)</span><br><span class="hljs-comment">//cout &lt;&lt; stuMap[1020] &lt;&lt; endl;</span><br><span class="hljs-keyword">auto</span> it = stuMap.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it!=stuMap.<span class="hljs-built_in">end</span>(); ++it)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-迭代器-iterator"><a href="#8-迭代器-iterator" class="headerlink" title="8. 迭代器 iterator"></a>8. 迭代器 iterator</h2><ol><li>正向迭代器 <code>iterator</code>：输出元素时从第一个到对后一个，既可以读也可修改。</li><li>常量的正向迭代器 <code>const_iterator</code>：输出元素时从第一个到对后一个，只可以读。</li><li>反向迭代器 <code>reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li><li>常量的反向迭代器 <code>const_reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li></ol><p><strong>顺序容器、关联容器，都支持正向迭代器与反向迭代器。</strong></p><h3 id="1-iterator"><a href="#1-iterator" class="headerlink" title="1. iterator"></a>1. iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>*it = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161445442.png" alt="image.png"></p><h3 id="2-const-iterator"><a href="#2-const-iterator" class="headerlink" title="2. const_iterator"></a>2. const_iterator</h3><p><strong>底层原理：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// const_iterator &lt;= iterator</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const_iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> : <span class="hljs-keyword">public</span> const_iterator<br>&#123;<br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br>&#125;<br><span class="hljs-comment">// class const_iterator&#123;&#125;基类</span><br><span class="hljs-comment">// class iterator : public const_iterator派生类</span><br></code></pre></td></tr></table></figure><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// vector&lt;int&gt;::iterator it1 = vec.begin();//可以接受派生类对象</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator it1 = vec.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure><p>将上面普通的正向迭代器换为常量的正向迭代器，编译器报错。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161447974.png" alt="image.png"></p><h3 id="3-reverse-iterator"><a href="#3-reverse-iterator" class="headerlink" title="3. reverse_iterator"></a>3. reverse_iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator it = vec.<span class="hljs-built_in">rbegin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">rend</span>(); it++)<br>&#123;<br>cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>*it = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161450170.png" alt="image.png"></p><h3 id="4-const-reverse-iterator"><a href="#4-const-reverse-iterator" class="headerlink" title="4. const_reverse_iterator"></a>4. const_reverse_iterator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//vector&lt;int&gt;::reverse_iterator rit = vec.rbegin();</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_reverse_iterator rit = vec.<span class="hljs-built_in">rbegin</span>();<br></code></pre></td></tr></table></figure><h2 id="9-函数对象"><a href="#9-函数对象" class="headerlink" title="9. 函数对象"></a>9. 函数对象</h2><p><strong>函数对象</strong>：拥有 <code>()operator</code> 重载函数的对象即函数对象，函数对象类似 C 语言里面的函数指针，但在 C++ 里为函数对象。</p><h3 id="1-函数对象解释"><a href="#1-函数对象解释" class="headerlink" title="1. 函数对象解释"></a>1. 函数对象解释</h3><p>下图为，C 语言进行函数调用与 C++ 中两个函数调用。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161453547.png" alt="image.png"></p><p>看起来它们好像一模一样，但是 C 语言中的 <code>sum()</code>，是函数名为一个地址；但 C++ 中的 <code>sum()</code> 为一个对象，sum 调用自己的 <code>( )</code> 重载函数将 10 与 20 传给 sum 调用的 <code>()</code> 运算符重载函数了，它接受两个实参，再执行 a+b。</p><p><strong>这里就把 <code>()</code> 运算符重载函数的对象，称作函数对象，或者称作仿函数。</strong></p><p><strong>好处：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现了一个比较大于的函数模板，这里编译器会根据实参推导出 T 的类型，再从原模板实例化处理整型与 char 类型的 <code>compare()</code> 函数。  </p><p>但是它不够灵活，有时想比较小于，每次改动符号有些麻烦，C 语言中的函数指针刚好可以很好解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 使用C的函数指针解决</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myGreater</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">myLess</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b;<br>&#125;<br><br><span class="hljs-comment">// compare是C++的库函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> Compare&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b, Compare comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;大于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, myGreater&lt;<span class="hljs-type">int</span>&gt;) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;小于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, myLess&lt;<span class="hljs-type">int</span>&gt;) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161516099.png" alt="image.png"></p><p>此时，就可以很好的解决这个问题了，当传入不同的函数指针来解决，想比较大就传入 myGreater，想比较小就传入 myLess，通过函数指针间接调用函数。</p><p>这里，使用函数指针虽然解决了问题，但函数指针无法进行内联，有函数的调用开销，效率很低；即使将其能够写为内联函数，编译的时候还是不知道调用时 myGreater，myLess。这里是通过函数指针间接调用的，编译器在编译过程中看到函数指针时候，不知道其调用的哪个函数，只有运行时候才知道。</p><p>因此，C++ 有一个专门的函数对象来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// C++ 对象实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myGreater</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myLess</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &lt; b;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// compare 是 C++ 的库函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">class</span> Compare&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(T a, T b, Compare comp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 编译过程知道调用对象的函数 operator()(a, b);</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">comp</span>(a, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;大于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-built_in">myGreater</span>&lt;<span class="hljs-type">int</span>&gt;()) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;小于：&quot;</span><br>&lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-built_in">myLess</span>&lt;<span class="hljs-type">int</span>&gt;()) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>通过函数对象调用 <code>()</code> 运算符重载，可以省略函数的调用开销，比通过函数指针调用函数(不能内联调用)效率高。  </li><li>因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。</li></ol><h3 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2. 使用示例"></a>2. 使用示例</h3><ol><li><strong>优先级队列</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 底层vector</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; que.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>que.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161525837.png" alt="image.png"></p><p><strong>如何使用小根堆：</strong></p><p>库中的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>,<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Container</span> = vector&lt;_Ty&gt;,<br><span class="hljs-keyword">class</span> _Pr = less&lt;<span class="hljs-keyword">typename</span> _Container::value_type&gt; &gt;<br></code></pre></td></tr></table></figure><p>将 less 改为 greater 即可变为小根堆即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> MinHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;;<br></code></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> MinHeap = priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 底层vector</span><br>MinHeap que;<br><span class="hljs-comment">// 大根堆</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span> + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; que.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>que.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161528812.png" alt="image.png"></p><ol start="2"><li><strong>set 集合</strong></li></ol><p>set 底层为红黑树，默认底层从小到大进行输出。底层为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Kty</span>,<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_Pr</span> = less&lt;_Kty&gt;,<br><span class="hljs-keyword">class</span> _Alloc = allocator&lt;_Kty&gt; &gt;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; set;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ++i)<br>&#123;<br>set.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : set)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="10-泛型算法和绑定器"><a href="#10-泛型算法和绑定器" class="headerlink" title="10. 泛型算法和绑定器"></a>10. 泛型算法和绑定器</h2><h3 id="1-泛型算法"><a href="#1-泛型算法" class="headerlink" title="1. 泛型算法"></a>1. 泛型算法</h3><p>使用 STL 库中提供的泛型算法需要引入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br></code></pre></td></tr></table></figure><p>泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果。</p><p><strong>特点：</strong></p><ol><li>泛型算法的参数接受的都是迭代器。</li><li>泛型算法的参数还可以接受函数对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">78</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">43</span>, <span class="hljs-number">56</span>, <span class="hljs-number">52</span>, <span class="hljs-number">42</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(arr, arr+<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]))</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//begin——end之间元素默认小到大排序</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161543085.png" alt="image.png"></p><p><strong>在上面有序的容器进行二分查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">78</span>, <span class="hljs-number">9</span>, <span class="hljs-number">21</span>, <span class="hljs-number">43</span>, <span class="hljs-number">56</span>, <span class="hljs-number">52</span>, <span class="hljs-number">42</span>, <span class="hljs-number">31</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(arr, arr+<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]))</span></span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//begin——end之间元素默认小到大排序</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">binary_search</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">21</span>));<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;21存在&quot;</span> &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改变 sort 排序方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传入函数对象greater，改变容器元素比较方式</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p><strong>for_each 将容器中所有偶数打印出来。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// for_each可以遍历容器的所有元素，可以自行添加合适的函数对象</span><br><span class="hljs-comment">// 对容器的元素进行过滤。</span><br>for_each(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <br>[](<span class="hljs-type">int</span> val)-&gt;<span class="hljs-type">void</span>   <span class="hljs-comment">// 拉姆达表达式</span><br>&#123;<br><span class="hljs-keyword">if</span> (val %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-绑定器"><a href="#2-绑定器" class="headerlink" title="2. 绑定器"></a>2. 绑定器</h3><p><strong>包含头文件：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure><p>绑定器：绑定器 + 二元函数对象 &#x3D; 一元函数对象。</p><ul><li><strong>bind1st</strong>：把二元函数对象 <code>operator()(a,b)</code> 第一个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li><li><strong>bind2nd</strong>：把二元函数对象 <code>operator()(a,b)</code> 第二个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//78 56 52 43 42 31 21 12 9 4</span><br><span class="hljs-comment">//find_if</span><br><span class="hljs-comment">//将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象</span><br><span class="hljs-comment">//因此我们需要绑定器</span><br><span class="hljs-comment">//greater a &gt; b   less a &lt; b</span><br><span class="hljs-keyword">auto</span> it2 = <span class="hljs-built_in">find_if</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <br><span class="hljs-built_in">bind1st</span>(<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">48</span>));<br><span class="hljs-comment">//bind2nd(less&lt;int&gt;(),48);</span><br><span class="hljs-comment">//[](int val)-&gt;bool&#123;return val &lt; 48;&#125;); 拉姆达表达式</span><br>vec.<span class="hljs-built_in">insert</span>(it2, <span class="hljs-number">48</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec)<br>&#123;<br>cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>06.C++ 继承与多态</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/06.C++%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/06.C++%20%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p>本节分为十部分：</p><ol><li>继承的基本意义</li><li>派生类的构造过程</li><li>重载、覆盖、隐藏</li><li>虚函数、静态绑定和动态绑定</li><li>虚析构函数</li><li>理解多态是什么</li><li>理解抽象类</li><li>理解虚基类和虚继承</li><li>菱形继承问题</li><li>C++ 的 四种类型转换</li></ol><h2 id="1-继承的基本意义"><a href="#1-继承的基本意义" class="headerlink" title="1. 继承的基本意义"></a>1. 继承的基本意义</h2><p><strong>继承的本质：</strong></p><p>代码的复用，实现多态的基础。</p><p><strong>关系：</strong></p><ul><li>组合：a part of…  一部分的关系</li><li>继承：a kind of… 一种的关系</li></ul><p><strong>继承方式和访问限定罗列：</strong></p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>继承方式</td><td>基类的访问限定</td><td>派生类的访问限定</td><td>(main)外部的访问限定</td></tr><tr><td>public</td><td></td><td></td><td></td></tr><tr><td></td><td>public</td><td>public</td><td>Y</td></tr><tr><td></td><td>protected</td><td>protected</td><td>N</td></tr><tr><td></td><td>private</td><td>不可见的</td><td>N</td></tr><tr><td>protected</td><td></td><td></td><td></td></tr><tr><td></td><td>public</td><td>protected</td><td>N</td></tr><tr><td></td><td>protected</td><td>protected</td><td>N</td></tr><tr><td></td><td>private</td><td>不可见的</td><td>N</td></tr><tr><td>private</td><td></td><td></td><td></td></tr><tr><td></td><td>public</td><td>private</td><td>N</td></tr><tr><td></td><td>protected</td><td>private</td><td>N</td></tr><tr><td></td><td>private</td><td>不可见的</td><td>N</td></tr></tbody></table><p><strong>protected继承方式下：</strong> <strong>基类的成员的访问限定，在派生类里面是不可能超过继承方式的。public降为protected的。</strong></p><p><strong>private继承方式下：</strong> <strong>public与protected降为private。</strong></p><p><strong>总结：</strong></p><ol><li>外部只能看到并使用 public 成员，protected 和 private 成员无法直接访问。</li><li>在继承结构中，派生类从基类继承来的 private 成员，然是无法直接访问（派生类中不可见）。</li><li>基类成员访问限定，在派生类里面不能超过继承方式。</li></ol><p><strong>protected 和 private 区别：</strong></p><ol><li>如果只是单纯的一个类，没有继承结构，则二者没有区别，外部都是无法访问的。</li><li>若存在继承关系，在基类中定义的成员，想被派生类访问，但不想被外部访问，那么可以在基类中将该成员定义为保护型。</li><li>若存在继承关系，在基类中定义的成员，不想被派生类访问，也不想被外部访问，则可以在基类中将该成员定义为私有。</li></ol><p><strong>默认继承方式：</strong></p><ul><li>要看派生类是用 class 定义的，还是 struct 定义的：<ul><li>若 class 定义派生类，则默认继承方式是私有的。</li><li>若 struct 定义派生类，则默认继承方式是共有的。</li></ul></li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-type">int</span> ma;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mb;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mc;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> _md, <span class="hljs-type">int</span> _mba, <span class="hljs-type">int</span> _maa)<br>: <span class="hljs-built_in">md</span>(_md)<br>, <span class="hljs-built_in">ma</span>(_mba)<br>&#123;<br>A::ma = _maa;<br>&#125;<br><span class="hljs-type">int</span> md;<br><span class="hljs-comment">// 作用域不同：派生类可以定义与基类同名的成员数据</span><br><span class="hljs-type">int</span> ma;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; md &lt;&lt; endl;<br>cout &lt;&lt; A::ma &lt;&lt; endl;<br>cout &lt;&lt; B::ma &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 公有继承下 ：基类私有的成员在派生类中不可见</span><br><span class="hljs-comment">// cout &lt;&lt; mc &lt;&lt; endl; </span><br>cout &lt;&lt; <span class="hljs-string">&quot;ok&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> me;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mf;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>)</span></span>;<br>A a;<br><br>b.<span class="hljs-built_in">func</span>();<br>b.<span class="hljs-built_in">func1</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(a) &lt;&lt; endl;<span class="hljs-comment">// 3 * int(4)</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(b) &lt;&lt; endl;<span class="hljs-comment">// (3 + 4) * int(4)</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-派生类的构造过程"><a href="#2-派生类的构造过程" class="headerlink" title="2. 派生类的构造过程"></a>2. 派生类的构造过程</h2><p>派生类从基类可以继承来所有的成员（成员变量和成员方法）。</p><p><strong>派生类如何初始化基类继承的成员变量：</strong></p><p>通过调用基类相应的构造函数来初始化</p><ul><li>派生类的构造函数和析构函数，负责初始化和清理派生类部分；</li><li>派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数来负责。</li></ul><p><strong>派生类对象构造和析构过程：</strong></p><ol><li>派生类调用基类的构造函数，初始化从基类继承来的成员。</li><li>培生类调用自己的构造函数，初始化自身的成员。</li><li>……….. 派生类对象的作用域到期。</li><li>派生类调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存、文件）。</li><li>系统自动调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件）。</li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data) <br>        : <span class="hljs-built_in">ma</span>(data) <br>    &#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;基类构造函数：Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br>    ~<span class="hljs-built_in">Base</span>() <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;基类析构函数：~Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data)<br>        : <span class="hljs-built_in">Base</span>(data), <span class="hljs-built_in">mb</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;派生类构造函数：Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Derive</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;派生类析构函数：~Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mb;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110913834.png" alt="image.png"></p><h2 id="3-重载、覆盖、隐藏"><a href="#3-重载、覆盖、隐藏" class="headerlink" title="3. 重载、覆盖、隐藏"></a>3. 重载、覆盖、隐藏</h2><p>继承结构中，名字相同的成员会产生关系，基类派生类里面相关的成员方法我们经常使用三种关系来描述它们，即：<strong>重载、隐藏、覆盖</strong>关系。</p><ul><li><strong>重载：</strong></li></ul><p>一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同。</p><ul><li><strong>隐藏：</strong></li></ul><p>在继承结构当中，派生类的同名成员，把基类的同盟成员给隐藏掉了，即作用域的隐藏。</p><ul><li><strong>覆盖：</strong></li></ul><p>父子类中的同名、同参数、同返回值的多个成员函数，从子到父形成的关系称为覆盖关系，在虚函数中会详谈它。</p><h3 id="1-隐藏关系"><a href="#1-隐藏关系" class="headerlink" title="1. 隐藏关系"></a>1. 隐藏关系</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">ma</span>(data) &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">20</span>) <br>:<span class="hljs-built_in">Base</span>(data), <span class="hljs-built_in">mb</span>(data) &#123; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Derive d;<br>d.<span class="hljs-built_in">show</span>();<br>d.<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类对象调用了不带参数的show方法，派生类本身没有这个方法。<br>执行结果：调用成功，而且<strong>1与2是函数重载关系</strong>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110931669.png" alt="image.png"></p><p>我们又给派生类添加了一个不带参数的show方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">20</span>):<span class="hljs-built_in">Base</span>(data), <span class="hljs-built_in">mb</span>(data)&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-comment">//3</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure><p>派生类调用 show 时优先调用自己的 <code>show()</code>，在自己的作用域下找相应的成员名字，若没有才去基类找；当我们调用带整数参数的 <code>show(int)</code>，自己并没有，从基类继承来一个带整型参数的 <code>show(int)</code>。</p><p>执行一下：第二个 <code>show(int)</code> 调用执行出错。1 与 3 属于隐藏关系；2 与 3 也属于隐藏关系。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110932089.png" alt="image.png"></p><p>第二个调用的是派生类的 <code>show()</code>，不接受参数。</p><p><strong>为什么不调用基类中的 <code>show(int)</code>？</strong></p><p>派生类对象调用派生类与基类同盟成员时，派生类已经有一个名字 show 了，派生类的 <code>show()</code> 将基类同盟 <code>show()</code>隐藏掉了。</p><p>如果想调用基类成员函数，必须指明基类的作用域来调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Derive d;<br>d.Base::<span class="hljs-built_in">show</span>();<br>d.Base::<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>指明作用域调用成功。  </p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110934024.png" alt="image.png"></p><h3 id="2-继承中的类型转换"><a href="#2-继承中的类型转换" class="headerlink" title="2. 继承中的类型转换"></a>2. 继承中的类型转换</h3><p>继承结构，我们也称为从上(基类)到下(派生类)的结构。</p><p><strong>类型转换是否可以？</strong></p><ol><li><strong>基类对象——&gt;派生类对象的转换：类型从上到下的转换(NO)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//基类对象——&gt;派生类对象</span><br>d = b;<br></code></pre></td></tr></table></figure><p>执行结果：执行失败。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110942832.png" alt="image.png"></p><ol start="2"><li><strong>派生类对象——&gt;基类对象的转换：类型从下到上的转换(YES)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//派生类对象——&gt;基类对象</span><br>b = d;<br></code></pre></td></tr></table></figure><p>执行结果：成功执行。</p><ol start="3"><li><strong>基类指针(引用)——&gt;指向派生类对象：类型从下到上的转换(YES)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//基类指针(引用)——&gt;派生类对象</span><br>Base *pb = &amp;d;<br>pb-&gt;<span class="hljs-built_in">show</span>();<br>pb-&gt;<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>执行结果：成功执行。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110953689.png" alt="image.png"></p><ol start="4"><li><strong>派生类指针(引用)——&gt;指向基类对象：类型从上到下的转换(NO)</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Base <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//派生类指针(引用)——&gt;指向基类对象</span><br>Derive *pd = &amp;b;<br></code></pre></td></tr></table></figure><p>执行结果：执行失败。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110954145.png" alt="image.png"></p><p><strong>总结：</strong></p><p>在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转不安全会涉及内存的非法访问。</p><h2 id="4-虚函数、静态绑定和动态绑定"><a href="#4-虚函数、静态绑定和动态绑定" class="headerlink" title="4. 虚函数、静态绑定和动态绑定"></a>4. 虚函数、静态绑定和动态绑定</h2><p><strong>覆盖：</strong></p><p>如果派生类中的方法和基类继承的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 <strong>virtual 虚函数</strong> ，那么派生类的这个方法，自动被处理成虚函数，它们之间成为覆盖关系；也就是说派生类会在自己虚函数表中将从基类继承来的虚函数进行替换，替换成派生类自己的。</p><p><strong>静态绑定：</strong></p><p>编译时期的多态，通过函数的重载以及模板来实现，也就是说调用函数的地址在编译时期我们就可以确定，在汇编代码层次，呈现的就是 call 函数名。</p><p><strong>动态绑定：</strong></p><p>动态时期的多态，通过派生类重写基类的虚函数来实现。在汇编代码层次，呈现的就是 call 寄存器，寄存器的值只有运行起来才能确定。</p><h3 id="1-不存在的虚函数"><a href="#1-不存在的虚函数" class="headerlink" title="1. 不存在的虚函数"></a>1. 不存在的虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">ma</span>(data) &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) <br>:<span class="hljs-built_in">Base</span>(data)<br>, <span class="hljs-built_in">mb</span>(data) &#123; &#125;<br><br>~<span class="hljs-built_in">Derive</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br>Base* pb = &amp;d;<br><br><span class="hljs-comment">// 静态（编译时期）绑定(函数调用) Base::show (06F12E4h)</span><br>pb-&gt;<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// Base::show (06F12BCh)</span><br>pb-&gt;<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Base size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derive) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111036581.png" alt="image.png"></p><p><strong>反汇编查看：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111039623.png" alt="image.png"></p><p>可以看到调用的都是基类的 <code>show()</code>,在编译阶段已经生成指令调用 Base 下的 show。</p><p><strong>结果：</strong></p><ul><li>因为 pb 是 Base 类型的指针，所以调用的都是 Base 类的成员方法。  </li><li>基类 Base 只有一个数据成员 ma，所以大小只有 4 字节。  </li><li>派生类 Derive 继承了 ma，其次还有自己的 mb，所以有 8 字节。  </li><li>pb 的类型是一个 <code>class Base *</code>；  </li><li><code>*pb</code> 的类型是一个 <code>class Base</code>。</li></ul><p><strong>图示:</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111042657.png" alt="image.png"></p><p>为什么 <code>Base *</code> 类型的指针，Derive 类型的对象，调用方法的时候是 Base 而不是 Derive 呢？</p><p>原因如上图：</p><p>Derive 类继承了 Base 类，导致了派生类的大小要比基类大，而 pb 的类型是基类的指针，所以通过 pb 调用方法时只能访问到 Derive 中从 Base 继承而来的方法，访问不到自己重写的方法（指针的类型限制了指针解引用的能力）。</p><h3 id="2-基类定义虚函数"><a href="#2-基类定义虚函数" class="headerlink" title="2. 基类定义虚函数"></a>2. 基类定义虚函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">ma</span>(data) &#123; &#125;<br><br>~<span class="hljs-built_in">Base</span>() &#123;&#125;<br><br><span class="hljs-comment">// 虚基类</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) <br>:<span class="hljs-built_in">Base</span>(data)<br>, <span class="hljs-built_in">mb</span>(data) &#123; &#125;<br><br>~<span class="hljs-built_in">Derive</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建类</span><br><span class="hljs-function">Derive <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br>Base* pb = &amp;d;<br><br>pb-&gt;<span class="hljs-built_in">show</span>();<br>pb-&gt;<span class="hljs-built_in">show</span>(<span class="hljs-number">10</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Base size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Base) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Derive size:&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Derive) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(*pb).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111047159.png" alt="image.png"></p><p><strong>反汇编：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111048405.png" alt="image.png"></p><p><code>pb-&gt;show();</code> 中 pb 指针是 base 类型，如果发现 Base 中的 show 是虚函数，就进行动态绑定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">|63..32|31..16|15-8|7-0| <br>               |AH.|AL.| <br>               |AX.....| <br>       |EAX............| <br>|RAX...................|<br></code></pre></td></tr></table></figure><ol><li><strong><code>mov   rax, qword ptr [pb]</code></strong></li></ol><p>将 pb 指向的内存前 4 个字节放入 rax 寄存器，pb指向derive对象，前四个字节即 <code>vfptr</code>，将虚函数表地址加载到 rax</p><ol start="2"><li><strong><code>mov   rax, qword ptr [rax]</code></strong></li></ol><p>将 rax 的前四个字节 即 <code>Derive::show</code> 加载到 rax 中。</p><ol start="3"><li><strong><code>call   qword ptr [rax]</code></strong></li></ol><p>虚函数的地址</p><p>可以看到这一次，汇编码 call 的就不是确切的函数地址了，而是寄存器 rax。</p><p>那么就很好理解了：rax 寄存器里存放的是什么内容，编译阶段根本无从知晓，只能在运行的时候确定； 故为，动态绑定。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111100188.png" alt="image.png"></p><p>pb的类型：Base类型，查看Base中有没有虚函数</p><p>（1）Base中没有虚函数 <code>*pb</code> 识别的就是编译时期的类型 <code>*pb</code> 就是 Base 类型。<br>（2） Base中有虚函数，<code>*pb</code> 识别的就是运行时期的类型 RTTI 类型为：Derive。</p><p>在添加了 virtual 关键字后，对应的函数就变成了虚函数。</p><p><strong>那么，一个类添加了虚函数，对这个类有什么影响呢？</strong></p><ul><li>如果类中定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的 <code>vftable</code> 虚函数表，虚函数表中主要存储的内容是：RTTI（Run-time Type Information）指针和虚函数的地址；当程序运行时，每一张虚函数表都会加载到内存的 <code>.rodata</code> 区（只读数据区）。</li><li>一个类中定义了虚函数，那么这个类定义的对象，在运行时，内存中会多存储一个 <code>vfptr</code> 虚函数的指针，指向对应类型的虚函数表 <code>vftable</code>。</li><li>一个类型定义的 n 个对象，它们的 <code>vfptr</code> 指向的都是同一张虚函数表。</li><li>一个类中的虚函数个数，不影响对象内存的大小（vfptr），影响的是虚函数表 <code>vftable</code> 的大小。</li><li>如果派生类中的方法和从基类继承的某个方法中返回值、函数名以及参数列表都相同，且基类方法为 virtual ，那么派生类的这个方法自动被处理为虚函数。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111110387.png" alt="image.png"></p><p><strong>虚函数表：</strong></p><ol><li>RTTI：存放的是类型信息，也就是（Base 或 Derive）。</li><li>偏移地址：虚函数指针相对于对象内存空间的便宜，一般 <code>vfptr</code> 都在 0 偏移位置。</li><li>之后是函数时虚函数入口地址。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111112719.png" alt="image.png"></p><p>在 Derive 类中，由于重写了 <code>show()</code>,因此在 Derive 的虚函数表中，是使用子类的 show() 方法代替了 Base 类的 <code>show()</code>。</p><h3 id="3-VS-工具查看虚函数表相关"><a href="#3-VS-工具查看虚函数表相关" class="headerlink" title="3. VS 工具查看虚函数表相关"></a>3. VS 工具查看虚函数表相关</h3><ol><li>找到</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111116949.png" alt="image.png"></p><p>打开后：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111117972.png" alt="image.png"></p><ol start="2"><li>在打开的窗口中切换到当前工程所在目录</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111119264.png" alt="image.png"></p><ol start="3"><li>输入指令</li></ol><p>可通过 dir 命令查看当前目录所有文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111120593.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cl XXX.cpp /d1reportSingleClassLayoutXX<br></code></pre></td></tr></table></figure><p>第一个XXX表示源文件的名字，第二个代表你想查看的类类型，我这里就是<code>Derive</code></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111123449.png" alt="image.png"></p><p>以看到 <code>class Derived</code> 的对象的内存布局，在派生类对象的开始包含了基类 Base 的对象，其中有一个虚表指针，指向的就是下面的<code>Derived::$vftable@ （virtual function table）</code>，表中包含了 Derived 类中所有的虚函数。</p><h2 id="5-虚析构函数"><a href="#5-虚析构函数" class="headerlink" title="5. 虚析构函数"></a>5. 虚析构函数</h2><p>析构函数：可以成为虚函数，调用时候对象存在。</p><p>虚析构函数：在析构函数前加上 virtual 关键字。</p><p>什么时候需要把基类的析构函数必须实现成虚函数？<br>       <br>基类的指针(引用)指向堆上 new 出来的派生类对象的时候，delete 调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> data) <br>        : <span class="hljs-built_in">ma</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;call Base::show()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> data) <br>        : <span class="hljs-built_in">Base</span>(data)<br>        , <span class="hljs-built_in">mb</span>(data)<br>        , <span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data))<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Derive</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> ptr;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Derive() &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> mb;<br>    <span class="hljs-type">int</span>* ptr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base* pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// 静态绑定pb Base*   *pb Derive</span><br>    pb-&gt;<span class="hljs-built_in">show</span>();<br><br>    <span class="hljs-keyword">delete</span> pb;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111143308.png" alt="image.png"></p><p><strong>没有调用派生类的析构函数，造成内存泄漏。</strong></p><p><strong>问题：</strong></p><p>pb 的配型是 Base 类型，因此 delete 调用析构函数先去 Base 找 <code>Base::~Base()</code>，对于析构函数的第哦啊用就是静态绑定，之间编译，没有机会调用派生类的析构函数，最后发生内存泄漏。</p><p><strong>解决：</strong></p><p>将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb 的类型是 Base 类型，调用析构时去 Base 中找 <code>Base::~Base</code> 发现它为虚函数，发生动态绑定。派生类的虚函数表中：<code>&amp;Derive:: ~derive</code>，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。</p><p><strong>注意：</strong></p><p><strong>构造函数不能为虚函数！！！</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111146816.png" alt="image.png"></p><p>（1）从存储空间角度：</p><p>虚函数对应一个 <code>vftable</code> ，这个 <code>vftable</code> 其实是存储在内存空间的。问题来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找 <code>vtable</code> 呢？所以构造函数不能是虚函数。</p><p>（2）从使用角度：</p><p>虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。</p><p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p><p>（4）构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p><p>（5）从实现上看，<code>vbtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数</p><p>从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p><h2 id="6-理解多态是什么"><a href="#6-理解多态是什么" class="headerlink" title="6. 理解多态是什么"></a>6. 理解多态是什么</h2><p>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。</p><p>所谓“虚函数”，就是在声明时前面加了virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。  </p><p>包含虚函数的类称为“<strong>多态类</strong>”。  </p><p>多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。  </p><p>多态在面向对象的程序设计语言中如此重要，以至于有类和对象的概念，但是不支持多态的语言，只能被称作“基于对象的程序设计语言”，而不能被称为“面向对象的程序设计语言”。例如，Visual Basic 就是“基于对象的程序设计语言”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> : <span class="hljs-keyword">public</span> B<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;E::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A a;<br>    B b;<br>    D d;<br>    E e;<br><br>    A* pa = &amp;a;<br>    B* pb = &amp;b;<br><br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = pb;<br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;d;<br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;e;<br>    pa-&gt;<span class="hljs-built_in">Print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405480.png" alt="image.png"></p><p>程序中，四个类之间的派生关系如下所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405483.png" alt="image.png"></p><p>每个类都有同名、同参数表的虚函数 Print（每个 Print 函数声明时都加了 virtual 关键字）。根据多态的规则，对于语句<code>pa-&gt;Print()</code>，由于 Print 是虚函数，尽管 pa 是基类 A 的指针，编译时也不能确定调用的是哪个类的 Print 函数。当程序运行到该语句时，pa 指向的是哪个类的对象，调用的就是哪个类的 Print 函数。    </p><p>多态的语句调用哪个类的成员函数是在运行时才能确定的，编译时不能确定（具体原理后面会解释）。因此，多态的函数调用语句被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。</p><h3 id="1-多态起手式以及内存分布"><a href="#1-多态起手式以及内存分布" class="headerlink" title="1.多态起手式以及内存分布"></a>1.多态起手式以及内存分布</h3><p>假设有一个基类 ClassA，一个继承了该基类的派生类 ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。</p><p>在代码中运用多态这个特性时，通常以两种方式起手：<br>(1) <code>ClassA *a = new ClassB();</code><br>(2) <code>ClassB b; ClassA *a = &amp;b;</code></p><p>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第 1 个用了 new 关键字而分配在堆上，第 2 个分配在栈上：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111411592.png" alt="image.png"></p><p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，<code>ClassA *a</code> 是一个栈上的指针。</p><p>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向 <strong>该类的虚函数表(这里是类ClassB)</strong> 的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p><h3 id="2-类的虚函数表与类实例的虚函数指针"><a href="#2-类的虚函数表与类实例的虚函数指针" class="headerlink" title="2. 类的虚函数表与类实例的虚函数指针"></a>2. 类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况；如果一个类中有虚函数，那么该类就有一个虚函数表。</p><p>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。</p><p>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111417318.png" alt="image.png"></p><h3 id="3-多态代码及多重继承情况"><a href="#3-多态代码及多重继承情况" class="headerlink" title="3. 多态代码及多重继承情况"></a>3. 多态代码及多重继承情况</h3><p>讨论了在没有继承的情况下，虚函数表的逻辑结构。</p><p>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::~ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassA::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassA::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassA::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> aData;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassB</span> : <span class="hljs-keyword">public</span> ClassA<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassB::ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassB::~ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassB::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassB::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> bData;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassC</span> : <span class="hljs-keyword">public</span> ClassA<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassC::ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassC::~ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ClassC::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfn2</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;virtual ClassC::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> aData;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ClassC c;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(1) ClassA 是基类, 有普通函数: <code>fn1()、fn2()</code> 。虚函数: <code>vfn1()、vfn2()、~ClassA()</code><br>(2) ClassB 继承 ClassA, 有普通函数: <code>fn1()</code>。虚函数: <code>vfn1()、~ClassB()</code><br>(3) ClassC 继承 ClassB, 有普通函数: <code>fn2()</code>。虚函数: <code>vfn2()、~ClassB()</code></p><p>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。</p><p>ClassB 继承与 ClassA，其虚函数表是在 ClassA 虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassA* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassB</span>();<br><br>a-&gt;<span class="hljs-built_in">fn1</span>();<br>a-&gt;<span class="hljs-built_in">fn2</span>();<br><br>a-&gt;<span class="hljs-built_in">vfn1</span>();<br>a-&gt;<span class="hljs-built_in">vfn2</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111430434.png" alt="image.png"></p><p><strong>使用 VS 开发者工具查看：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111432206.png" alt="image.png"></p><p>这个结果不难想象，看上图，ClassA 类型的指针 a 能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同</p><p>这个结果已经说明了 C++ 的隐藏、重写(覆盖)特性。</p><p>同理，也就不难推导出 ClassC 的逻辑结构图了</p><p>类的继承情况是: ClassC 继承 ClassB，ClassB 继承 ClassA；这是一个多次单继承的情况。(多重继承)。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111435576.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111436071.png" alt="image.png"></p><h3 id="4-多继承下的虚函数表-同时继承多个基类"><a href="#4-多继承下的虚函数表-同时继承多个基类" class="headerlink" title="4. 多继承下的虚函数表 (同时继承多个基类)"></a>4. 多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA1</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ClassA1</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassA1</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::~ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA1::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a1Data;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassA2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ClassA2</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassA2</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::~ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc4</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassA2::vfunc4()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a2Data;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassC</span> : <span class="hljs-keyword">public</span> ClassA1, <span class="hljs-keyword">public</span> ClassA2<br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ClassC</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::ClassC()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ClassC</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::~ClassC()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vfunc3</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;ClassC::vfunc3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ClassC c;<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111445452.png" alt="image.png"></p><p>（1）ClassA1 是第一个基类，拥有普通函数 <code>func1()</code>，虚函数<code>vfunc1()、 vfunc2()</code>。<br>（2）ClassA2 是第二个基类，拥有普通函数 <code>func1()</code>，虚函数 <code>vfunc1()、 vfunc2()、vfunc4()</code>。<br>（3）ClassC 依次继承 ClassA1、ClassA2。普通函数 <code>func1()</code>,虚函数<code>vfunc1()、vfunc2()、vfunc3()</code>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111442375.png" alt="image.png"></p><p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。</p><p>如图，虚函数表指针 01 指向的虚函数表是以 ClassA1 的虚函数表为基础的，子类的 <code>ClassC::vfunc1()</code>,和 <code>vfunc2()</code> 的函数指针覆盖了虚函数表 01 中的虚函数指针 01 的位置、02 位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。注意：</p><ol><li>子类虚函数会覆盖每一个父类的每一个同名虚函数。</li><li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li><li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用</li></ol><p>最后给出代码和结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassA1 *a1 = <span class="hljs-keyword">new</span> ClassC;<br>a1-&gt;<span class="hljs-built_in">func1</span>();               <span class="hljs-comment">// &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span><br>a1-&gt;<span class="hljs-built_in">vfunc1</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span><br>a1-&gt;<span class="hljs-built_in">vfunc2</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span><br>没有a1-&gt;<span class="hljs-built_in">vfunc3</span>()，父类没有这个虚函数<br><br>ClassA2 *a2 = <span class="hljs-keyword">new</span> ClassC;<br>a2-&gt;<span class="hljs-built_in">func1</span>();               <span class="hljs-comment">// &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span><br>a2-&gt;<span class="hljs-built_in">vfunc1</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class="hljs-built_in">vfunc2</span>();              <span class="hljs-comment">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class="hljs-built_in">vfunc4</span>();              <span class="hljs-comment">// &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span><br><br>ClassC *c = <span class="hljs-keyword">new</span> ClassC;<br>c-&gt;<span class="hljs-built_in">func1</span>();                <span class="hljs-comment">// &quot;ClassC::func1()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc1</span>();               <span class="hljs-comment">// &quot;ClassC::vfunc1()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc2</span>();               <span class="hljs-comment">// &quot;ClassC::vfunc2()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc3</span>();               <span class="hljs-comment">// &quot;ClassC::vfunc3()&quot;</span><br>c-&gt;<span class="hljs-built_in">vfunc4</span>();               <span class="hljs-comment">// &quot;ClassA2::func4()&quot;</span><br></code></pre></td></tr></table></figure><h2 id="7-理解抽象类"><a href="#7-理解抽象类" class="headerlink" title="7. 理解抽象类"></a>7. 理解抽象类</h2><p>抽象类(接口)：接口描述了类的行为和功能,而无需完成类的特定实现</p><p>C++ 接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用</p><p><strong>注意:</strong></p><p>如果试图实例化一个抽象类的对象，会导致编译错误。</p><p>因此，如果一个抽象类的派生类需要被实例化(建立对象)，则必须对每个继承来的纯虚函数进行函数体实现。<br>如果没有在派生类中重写所有纯虚函数，就尝试实例化派生类的对象，也会导致编译错误，这是因为如果派生类没有实现父类的纯虚函数，则派生类变为抽象类。</p><p>抽象类基类为派生自抽象基类的派生类提供了约束条件，即：派生类必须要实现继承自抽象基类中的纯虚函数，否则此派生类不可进行实例化，且派生类将继承为抽象派生类。</p><h3 id="1-抽象类与纯虚函数（抽象方法）"><a href="#1-抽象类与纯虚函数（抽象方法）" class="headerlink" title="1. 抽象类与纯虚函数（抽象方法）"></a>1. 抽象类与纯虚函数（抽象方法）</h3><p><strong>纯虚函数</strong>是一个在 <strong>基类中声明的虚函数</strong>，它在该基类中<strong>没有定义具体的函数体</strong>(操作内容),要求<strong>派生类根据实际需要定义自己的版本</strong>，设计多层次类继承关系时用到。把某个方法声明为一个抽象方法等于告诉编译器,这个方法<strong>必不可少</strong>，但目前在基类中还不能为它提供实现</p><p>纯虚函数的标准格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> 函数类型 函数名（参数表）= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明了一个纯虚函数 也就是在虚函数尾部加上&quot; = 0 &quot; 一个虚函数便被声明成为了一个纯虚函数</span><br><span class="hljs-comment">// 等于 0 表示该函数仅声明而没有函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>一旦类中有了纯虚函数，这个类便被称为：<strong>抽象类</strong>。</p><blockquote><p><strong>且此类不能被实例化！！！（不可建立类对象实例！！！）</strong></p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 报错！带有纯虚函数的类称为抽象类，不可实例化</span><br>Pet pet; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抽象类：</strong></p><p>只能作为积累使用，无法定义抽象类对象实例，这是因为 <strong>抽象类中包含了没有定义的纯虚函数</strong>，在 C++ 中，我们把 <strong>只能由于被继承而不能直接创建对象的类</strong> 称之为：<strong>抽象类</strong>，这种基类不能直接生成对象，而只有被继承后，并重写其虚函数后，才能使用。</p><p>当抽象类的派生类实现了继承而来的纯虚函数后，才能实例化对象。</p><p>之所以要存在抽象类，最主要是因为它具有不确定因素，我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为虚函数。虚函数是一种特殊的函数，在抽象类中只有声明，没有具体的定义。</p><p><strong>抽象类和纯虚函数的关系</strong></p><p>抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类，存在纯虚函数是成为抽象类的充要条件。</p><h3 id="2-为什么需要一个抽象类"><a href="#2-为什么需要一个抽象类" class="headerlink" title="2. 为什么需要一个抽象类"></a>2. 为什么需要一个抽象类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// todonew 与 delete 动态分配内存,与用指针调用对象 通过对象的不同调用不同的同名虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span> <span class="hljs-comment">// 声明纯虚函数 sound 后 Pet 类变为抽象类(接口)</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Pet</span>(string thename);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">// 声明纯虚函数 sound  (并未进行函数实现 函数实现放在派生类中)</span><br><br>    <span class="hljs-comment">//注意:   </span><br>    <span class="hljs-comment">//todo1.继承自抽象基类 Pet 的子类必须全部实现基类中的所有纯虚函数</span><br>    <span class="hljs-comment">//todo2.抽象基类 Pet 不可进行实例化</span><br><br><span class="hljs-keyword">protected</span>:<br>    string name;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Pet<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(string thename);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">climb</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Pet<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Dog</span>(string thename);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jump</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><br>Pet::<span class="hljs-built_in">Pet</span>(string thename) <span class="hljs-comment">// todo 基类构造器(抽象类也有构造函数)</span><br>&#123;<br>    name = thename;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pet::sleep</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;正在睡大觉\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pet::sound</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;动物发声\n&quot;</span>;<br>&#125;<br><br>Cat::<span class="hljs-built_in">Cat</span>(string thename) :<span class="hljs-built_in">Pet</span>(thename) <span class="hljs-comment">// 派生类 Cat 构造函数</span><br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cat::climb</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;正在爬树\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">Cat::sound</span><span class="hljs-params">()</span> <span class="hljs-comment">// 派生类虚函数</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//Pet::sound(); // todo 如果需要调用基类中的 play() 函数  在原本的play()函数的基础上加上覆盖上的子类play()函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;喵喵喵!\n&quot;</span>;<br>&#125;<br><br><br>Dog::<span class="hljs-built_in">Dog</span>(string thename) :<span class="hljs-built_in">Pet</span>(thename)<span class="hljs-comment">// 派生类 Dog 构造函数</span><br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::jump</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;跳过了栅栏\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dog::sound</span><span class="hljs-params">()</span> <span class="hljs-comment">// 派生类虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Pet::sound();</span><br>    cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;汪汪汪!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(Pet* x)</span></span><br><span class="hljs-function"></span>&#123;<br>    x-&gt;<span class="hljs-built_in">sound</span>();<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//Pet pet; // todo 用带有抽象方法(纯虚函数)的抽象类 Pet 无法实例化对象</span><br><br>    <span class="hljs-comment">// todo 创建指向子类实例的基类指针和引用来调用纯虚函数</span><br>    Pet* cat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;猫&quot;</span>);<br>    Pet* dog = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>(<span class="hljs-string">&quot;狗&quot;</span>);<br><br>    <span class="hljs-comment">// todo 创建对象实例来调用纯虚函数</span><br>    <span class="hljs-function">Cat <span class="hljs-title">cat2</span><span class="hljs-params">(<span class="hljs-string">&quot;对象实例调用 猫&quot;</span>)</span></span>;<br>    cat2.<span class="hljs-built_in">sound</span>();<br><br>    <span class="hljs-built_in">func</span>(cat);<br>    <span class="hljs-built_in">func</span>(dog);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中定义了三个类,它们的继承关系为：<code>Animal--&gt;Cat</code>和<code>Animal--&gt;Dog</code></p><p>Animal 是一个抽象类，也是最顶层的基类，在 Animal 类中定义了一个<strong>纯虚函数</strong><code>sound()</code>，在 <code>Cat</code> 类中，实现了<code>sound()</code>函数。所谓实现，就是定义了纯虚函数的函数体，抽象类 Animal 虽然不能实例化，但它为派生类提供了<strong>约束条件</strong>，派生类必须要实现这个函数，完成动物发声功能，否则就不能对派生类进行实例化。</p><p>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的，虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111557893.png" alt="image.png"></p><p><strong>总结：</strong></p><ol><li>任何具有纯虚函数的类都是抽象类。</li><li>抽象类基类不可建立实例。</li><li>抽象类派生出的子类需将继承的纯虚函数全部进行实例化，才能建立其实例。</li><li>抽象类可以有构造函数。</li><li>如果派生类没有实现父类的纯虚函数，则派生类变为抽象类，即不可建立其实例。</li><li>抽象基类除了约束派生类的功能，还可以实现多态，可以创建指向子类的实例的抽象基类的指针和引用。</li><li>只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。</li></ol><h2 id="8-理解虚基类和虚继承"><a href="#8-理解虚基类和虚继承" class="headerlink" title="8. 理解虚基类和虚继承"></a>8. 理解虚基类和虚继承</h2><p><strong>virtual作用：</strong></p><ol><li>virtual 修饰了成员方法是虚函数。  </li><li>可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。</li></ol><ul><li><strong>vfptr</strong>：一个类有虚函数，这个类生成的对象就有 vfptr，指向 vftable。  </li><li><strong>vbptr</strong>：在派生类中从基类虚继承而来。  </li><li><strong>vftable</strong>：第一行为向上偏移量，第二行为虚基类指针离虚基类内存的偏移量。  </li><li><strong>vbtable</strong>：存放的 RTTI 指针，指向运行时 RTTI 信息与虚函数地址。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-comment">//A a; 4个字节</span><br><span class="hljs-comment">//B b; 8个字节</span><br></code></pre></td></tr></table></figure><p>这里我们的对象 a 占 4 个字节，对象 8 占 8 个字节。但如果我们给 B 的继承方式访问限定符前面加了一个 virtual 关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>类 A 被虚继承了，但内存布局没有变化：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111611448.png" alt="image.png"></p><p><strong>类 B 在继承普通基类的内存变化：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111612673.png"></p><p>再看一下类 B，不是之前的 8 个字节，变为 12 个字节，多了一个 vbptr 指针。原来最上面应该为 ma 与 mb，但是现在多了一个 <code>vbptr</code>(虚基类指针)，ma 跑到派生类最后面去了。<code>vbptr</code> 指向的是 <code>vbtable</code>，<code>vbtable</code> 第一行为 0，第二行为虚基类指针到虚基类数据的偏移量。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111614890.png" alt="image.png"></p><p>当遇到虚继承时候，要考虑派生类 B 的内存布局时；</p><p>首先，先不考虑虚继承，类 B 继承了基类的 ma，还有自己的mb；当基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个 <code>vbptr</code>。派生类的内存就由这几部分来构成。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111618147.png" alt="image.png"></p><p>虚基类指针(<code>vbptr</code>)指向虚基类表(<code>vbtable</code>)，<code>vbtable</code> 第一行为向上的偏移量，因为 <code>vbptr</code> 在该派生类内存起始部分，因此向上的偏移量为 0；第二行为向下的偏移量(<code>vbptr</code> 离虚基类数据的偏移量)，原来基类的数据放到最后，找 ma 的时候还是在最开始找，但 ma 被移动，根据偏移的字节就可以找到。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111619886.png" alt="image.png"></p><h3 id="1-虚基类和虚继承出错情况分析"><a href="#1-虚基类和虚继承出错情况分析" class="headerlink" title="1. 虚基类和虚继承出错情况分析"></a>1. 虚基类和虚继承出错情况分析</h3><p><strong>那么当我们虚基类指针与虚函数指针在一起出现的时候会发生什么呢？</strong></p><p>调用是没有问题的，但是 delete 会出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</span><br>A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<span class="hljs-comment">// B::vftable</span><br>p-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图：调用成功，但delete时会出错。  </p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111623556.png" alt="image.png"></p><p><strong>分析：</strong></p><p>B 的内存布局：</p><p>B 首先从 A 中获取 <code>vfptr</code> 与 ma， B 中还有自身的 mb；<br>此时 A 被虚继承，A 中所有的东西都移动到派生类最后面，最上面补一个<code>vbptr</code>，<code>vbptr</code> 指向 <code>vbtable</code>，<code>vfptr</code> 指向 <code>vftable</code>；基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</p><p>普通情况下，派生类内存布局先是基类，在是派生类，基类指针指向派生类对象时，基类指针指向的就是派生类内存的起始部分。但是，虚继承下基类称为虚基类，虚基类的数据在派生类最后面，原地方补上 <code>vbptr</code>，此时再用基类指针指向派生类对象时候，基类指针永远指向派生类基类部分的起始地址。虚基类一开始就是 <code>vfptr</code>，能够用 p 指向的对象访问 <code>vfptr</code> 与 <code>vftable</code> 的原因。释放内存时候出错，因为对象开辟是在最上面即绿色部分，但是 p 所持有的是虚基类的地址，delete 时从虚基类起始地址 delete，因此出错。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111627334.png" alt="image.png"></p><p>命令验证如下：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111628141.png" alt="image.png"></p><p><strong>验证一下内存地址：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator delete p:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br><span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>cout &lt;&lt; <span class="hljs-string">&quot;operator new p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(); <span class="hljs-comment">// B::vftable</span><br>cout &lt;&lt; <span class="hljs-string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>p-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111629072.png" alt="image.png"></p><p><code>00000119E9411CB0</code> 为分配的内存的起始地址，我们用基类指针指向派生类对象一定是指向派生类内存基类的起始部分：<code>00000119E9411CC0</code> 刚好比 <code>00000119E9411CB0</code> 多了 16 个字节，是 <code>vbptr</code> 与 mb，但是 delete 时候从 <code>00000119E9411CC0</code> 开始释放，因此崩溃。</p><p>Windows 的 VS 下这样写会出错，但是 Linux 下的 <code>g++ delete</code> 时会自动偏移到 new 内存的起始部分，进行内存 <code>free()</code>，不会出错。</p><p>如果在栈上开辟内存，基类指针指向派生类对象，出了作用域自己进行析构，这样是没有问题的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">B b;<br>A *p = &amp;b; <span class="hljs-comment">// B::vftable</span><br>cout &lt;&lt; <span class="hljs-string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>p-&gt;<span class="hljs-built_in">func</span>();<br></code></pre></td></tr></table></figure><h2 id="9-菱形继承问题"><a href="#9-菱形继承问题" class="headerlink" title="9. 菱形继承问题"></a>9. 菱形继承问题</h2><p><strong>多重继承：</strong> 一个<code>派生类</code>如果只继承一个<code>基类</code>，称作单继承； 一个<code>派生类</code>如果继承了多个<code>基类</code>，称作多继承。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111602992.png" alt="image.png"></p><p><strong>优点：</strong></p><ul><li>多重继承可以做更多的代码复用！</li><li>派生类通过多重继承，可以得到多个基类的数据和方法，更大程度的实现了代码复用。</li></ul><p><strong>问题：</strong></p><p>菱形继承的问题：在于继承时有重复利用的数据。</p><p><strong>会导致派生类有多份间接基类的数据，可以采用虚继承来解决。</strong> <strong>A 为 B、C 的基类，B 从 A 单继承而来，C 从 A 也是单继承而来；D 是 B 和 C 多继承而来，D 有两个基类分别为 B 和 C。A 称为 D 的间接基类，D 也有 A 的数据。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111637497.png" alt="image.png"></p><p>当然，多重继承还会出现别的问题：</p><p><strong>半圆形继承问题：</strong> <strong>B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111638517.png" alt="image.png"></p><p>多重继承虽然可以复用多个基类的代码到派生类中，但是会出现许多问题，因此 C++ 开源代码上很少见到多重继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">ma</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mb</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">B</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mc</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">C</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~C()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mc;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">B</span>(data), <span class="hljs-built_in">C</span>(data), <span class="hljs-built_in">md</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;D()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">D</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~D()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> md;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>画一下 d 对象的内存布局：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641312.png" alt="image.png"></p><p>D 能看见 B，C 与 md，所以 D 在构造时调用 B，C 的构造及 ma 的初始化。 ma 的初始化在 B 与 C 的构造函数中进行，因此 D 内存为 20 个字节。</p><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641957.png" alt="image.png"></p><p>先是 A 的构造，B 的构造，又是 A 的构造，C 的构造，最后是 D 的构造；析构顺序与其相反。就会发现，D 这个派生类中调用了两次 A 的构造，数据重复，浪费内存，这种情况必须被杜绝。</p><p><strong>如何处理？</strong></p><p><strong>虚继承来处理，所有从A继承而来的地方都采用虚继承，A 就为虚基类。</strong></p><p>此时：<br>B 从 A 虚继承而来，A 为虚基类，<code>A::ma</code> 移动到派生类最后面，在 <code>A::ma</code> 位置上补一个 <code>vbptr</code>；C 也是从 A 虚继承而来，<code>A::ma</code> 移动到派生类最后面，但发现已经有一份同样的虚基类的数据，那么 C 的 <code>A::ma</code> 丢弃，在 <code>A::ma</code> 位置存放 <code>vbptr</code>。此时派生类中只有一份基类 <code>A::ma</code> 的数据，以后访问都是同一个 ma；同时 ma 的初始化由 D 来负责。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111645047.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">ma</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> ma;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mb</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;B()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">B</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mb;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">mc</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">C</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~C()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> mc;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> data) : <span class="hljs-built_in">A</span>(data), <span class="hljs-built_in">B</span>(data), <span class="hljs-built_in">C</span>(data), <span class="hljs-built_in">md</span>(data)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;D()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">D</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~D()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> md;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：修改成功；A、B、C、D各初始化与析构一次。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111646462.png" alt="image.png"></p><h2 id="10-C-的-四种类型转换"><a href="#10-C-的-四种类型转换" class="headerlink" title="10. C++ 的 四种类型转换"></a>10. C++ 的 四种类型转换</h2><blockquote><ol><li>const_cast</li><li>static_cast</li><li>reinterpert_cast</li><li>dynamic_cast</li></ol></blockquote><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1. const_cast"></a>1. const_cast</h3><p><strong>const_cast：修改类型的const或volatile属性。</strong> 使用该运算方法可以返回一个指向非常量的指针（或引用）指向，就可以通过该指针（或引用）对它的数据成员任意改变。</p><p><strong>注意：</strong>  </p><p>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。  </p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const_cast</span>&lt;里面必须是指针或引用类型&gt;<br></code></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1 = (<span class="hljs-type">int</span>*)&amp;a;<span class="hljs-comment">// C 中类型转换</span><br><span class="hljs-type">int</span> *p2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;a);<span class="hljs-comment">// C++ 中类型转换 const_cast</span><br></code></pre></td></tr></table></figure><p>转换为相同类型的时候，通过反汇编查看时候，发现 C 中的类型强转与 C++ 中 <code>const_cast</code> 所生成的汇编指令底层是一模一样的。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111757973.png" alt="image.png"></p><p>但是在转换成汇编指令之前，即编译阶段，就有所不同。</p><p><strong>注意：</strong></p><ol><li><strong>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// C 中类型转换，可以</span><br><span class="hljs-type">char</span> *p1 = (<span class="hljs-type">char</span>*)&amp;a;<br><span class="hljs-comment">// C++ 中类型转换 const_cast，不可以</span><br><span class="hljs-type">char</span> *p2 = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;a);<br></code></pre></td></tr></table></figure><p>通过 C中类型转换可以将 <code>int *</code> 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过 <code>const_cast</code> 将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。<code>const_cast</code>使用时，地址的类型是与左边类型以及转换的类型需要保持一致。防止了 C 中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。</p><p>编译出错：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111806390.png" alt="image.png"></p><ol start="2"><li><strong><code>const_cast&lt;里面必须是指针或引用类型&gt;</code>，否则出错</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);<br></code></pre></td></tr></table></figure><p>编译出错：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111807110.png" alt="image.png"></p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. static_cast</h3><p><strong><code>static_cast(静态)</code>：编译时期的类型转换，提供编译器认为安全的类型转换。</strong></p><p>是一个 c++ 运算符，功能是把一个表达式转换为某种类型，使用最多。</p><p><strong>注意：</strong></p><ol><li><strong>有联系的类型之间可以互相转换。</strong></li><li><strong>没有任何联系的类型之前转换会被否定。</strong></li><li><strong>基类类型与派生类类型进行转换，可以用 <code>static_cast</code>，它们类型之间有关系，但不一定安全。</strong></li></ol><p><strong>实例：</strong></p><ol><li>有联系的类型之间可以互相转换</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a);<br></code></pre></td></tr></table></figure><p>编译成功，int 与 char 直之间有联系。</p><ol start="2"><li>有任何联系的类型之间的转换会被否定</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// double* = (double*)p; C 可以转换</span><br><span class="hljs-type">double</span>* b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111811911.png" alt="image.png"></p><h3 id="3-reinterpert-cast"><a href="#3-reinterpert-cast" class="headerlink" title="3. reinterpert_cast"></a>3. reinterpert_cast</h3><p><strong><code>reinterpret_cast</code>：类似于 C 风格的强制类型转换，是 C++ 里的强制类型转换符，不安全。</strong></p><p><strong>注意：</strong></p><ol><li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li></ol><p><strong>实例：</strong> </p><ol><li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">double</span>* b = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure><p><code>reinterpret_cast</code> 与 C 中类型转换类似，转换成功，不安全。</p><h3 id="4-dynamic-cast"><a href="#4-dynamic-cast" class="headerlink" title="4. dynamic_cast"></a>4. dynamic_cast</h3><p><strong><code>dynamic_cast</code>(动态)：运行时期的类型转换，用于继承结构中，可以支持 RTTI 类型识别的上下转换及识别。</strong></p><p><strong>将一个基类对象指针（或引用）转换到继承类指针，<code>dynamic_cast</code> 会根据基类指针是否真正指向继承类指针来做相应处理。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive1</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call Derive1::func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive2</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showFunc</span><span class="hljs-params">(Base* p)</span></span><br><span class="hljs-function"></span>&#123;<br>p-&gt;<span class="hljs-built_in">func</span>();<span class="hljs-comment">//动态绑定</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Derive1 d1;<br>Derive1 d2;<br><br><span class="hljs-built_in">showFunc</span>(&amp;d1);<br><span class="hljs-built_in">showFunc</span>(&amp;d2);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：执行成功。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111838785.png" alt="image.png"></p><p>需求改变了，<code>Derive</code> 实现了一个新功能的 API 接口函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive2</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//需求更改 Derive2实现新功能的API接口函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derive02func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;call derive02func()::func&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>void show()</code> 应该区分判断一下，如果 <code>Base* p</code> 指向了其他的派生类对象，调用 <code>p-&gt;func()</code> 方法就好。但如果指向 Derive2 对象，不调用 <code>func()</code> 方法，而调用 Derive2 的 <code>derive02 func()</code>方法。该如何做呢？</p><p>这里就要识别 <code>*p</code> 的类型，看它指向哪个对象。此时就需要<code>dynamic_cast()</code>了。dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象；<code>p-&gt;vfptr-&gt;vftable</code> RTTI 信息 如果是 <code>dynamic_cast</code>，转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showFunc</span><span class="hljs-params">(Base* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象</span><br><span class="hljs-comment">// p-&gt;vfptr-&gt;vftable RTTI 信息 如果是 dynamic_cast，</span><br><span class="hljs-comment">// 转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr</span><br>Derive2 *pd2 = <span class="hljs-built_in">dynamic_cast</span>&lt;Derive2*&gt;(p);<br><span class="hljs-keyword">if</span> (pd2 != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>pd2-&gt;<span class="hljs-built_in">derive02func</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>p-&gt;<span class="hljs-built_in">func</span>();<span class="hljs-comment">//动态绑定</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>指向结果：调用成功。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111845822.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05.C++ 运算符重载</title>
    <link href="/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/05.C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2023/08/09/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/05.C++%20%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>本节分为七个部分：</p><ol><li>学习复数类 Complex</li><li>模拟实现 C++ 的 string 类</li><li>string 字符串对象的迭代器</li><li>vector 容器的迭代器 iterator 实现</li><li>什么是容器的迭代器失效问题</li><li>new 和 delete 重载实现的对象池</li><li>深入理解 new 和 delete 的原理</li></ol><p><strong>什么是运算符重载</strong></p><p>运算符重载实质还是一个 函数。<br>通过重载运算符，可以让类在一些场景下使用起来更加方便。</p><p><strong>语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">返回值类型 <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">op</span> <span class="hljs-params">(参数)</span></span>;​​​​​​​<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ClassType&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> ClassType&amp; src); <span class="hljs-comment">// 重载 “=” 运算符</span><br></code></pre></td></tr></table></figure><h2 id="1-学习复数类-Complex"><a href="#1-学习复数类-Complex" class="headerlink" title="1. 学习复数类 Complex"></a>1. 学习复数类 Complex</h2><p>复数是形如 <code>a+b</code> 的数，复数由实部和虚部构成，在 C++ 的模板库中由 complex 类，可以直接调用，包含在complex头文件中，再使用时应该添加 <code>#include&lt;complex&gt;</code>。下面介绍一些基本操作</p><h3 id="1-生成复数对象"><a href="#1-生成复数对象" class="headerlink" title="1. 生成复数对象"></a>1. 生成复数对象</h3><p>complex 类型的构造函数接受两个参数，第一个参数是复数实部的值，第二个参数是虚部的值。要想生成一个复数对象，并且对其值进行修改，参考以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>complex&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">x1</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>complex&lt;<span class="hljs-type">double</span>&gt;x2;<br>complex&lt;<span class="hljs-type">double</span>&gt;<span class="hljs-built_in">x3</span>(x1);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;<span class="hljs-comment">// x1 = (2, 3)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;x2 = &quot;</span> &lt;&lt; x2 &lt;&lt; endl;<span class="hljs-comment">// x2 = (0, 0)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;x3 = &quot;</span> &lt;&lt; x3 &lt;&lt; endl;<span class="hljs-comment">// x3 = (2, 3)</span><br><br>x1.<span class="hljs-built_in">real</span>(<span class="hljs-number">22</span>);<span class="hljs-comment">// 修改实数部</span><br>x1.<span class="hljs-built_in">imag</span>(<span class="hljs-number">33</span>);<span class="hljs-comment">// 修改虚数部</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;<span class="hljs-comment">// x1 = (22,33)</span><br><br>complex&lt;<span class="hljs-type">double</span>&gt;a, b, c;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入三个复数：&quot;</span>;<br>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100912113.png" alt="image.png"></p><h3 id="2-复数的运算"><a href="#2-复数的运算" class="headerlink" title="2. 复数的运算"></a>2. 复数的运算</h3><p>复数和实数一样都有加减乘除四则运算，这些运算符号在 complex 模板中已经被重载过，能够直接使用，下面代码示例展示了其功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>complex&lt;<span class="hljs-type">double</span>&gt; z1 = z + <span class="hljs-number">5.0</span>;<br>cout &lt;&lt; z1 &lt;&lt; endl;<br>complex&lt;<span class="hljs-type">double</span>&gt; z2 = z - <span class="hljs-number">5.0</span>;<br>cout &lt;&lt; z2 &lt;&lt; endl;<br>complex&lt;<span class="hljs-type">double</span>&gt; z3 = z * <span class="hljs-number">2.0</span>;<br>cout &lt;&lt; z3 &lt;&lt; endl;<br>complex&lt;<span class="hljs-type">double</span>&gt;z4 = z / <span class="hljs-built_in">complex</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>cout &lt;&lt; z4 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100914081.png" alt="image.png"></p><h3 id="3-复数的比较"><a href="#3-复数的比较" class="headerlink" title="3. 复数的比较"></a>3. 复数的比较</h3><p>复数的比较需要同时比较实部和虚部是否都相等，有其一不等两数就 不等，下面是示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-function">complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">z3</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br><br>cout &lt;&lt; boolalpha &lt;&lt; (z1 == z3) &lt;&lt; endl;<br>cout &lt;&lt; boolalpha &lt;&lt; (z1 == z2) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100916498.png" alt="image.png"></p><h3 id="4-实现-Complex-类"><a href="#4-实现-Complex-类" class="headerlink" title="4. 实现 Complex 类"></a>4. 实现 Complex 类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//#include &lt;complex&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义Complex 类</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 无参构造函数</span><br><span class="hljs-built_in">Complex</span>()<br>: <span class="hljs-built_in">real</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">imag</span>(<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 初始化列表</span><br>&#125;<br><span class="hljs-comment">// 有参构造函数</span><br><span class="hljs-built_in">Complex</span>(T re, T im)<br>: <span class="hljs-built_in">real</span>(re)<br>, <span class="hljs-built_in">imag</span>(im)<br>&#123;<br><span class="hljs-comment">// 初始化列表</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-built_in">Complex</span>(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>: <span class="hljs-built_in">real</span>(com.real)<br>, <span class="hljs-built_in">imag</span>(com.imag)<br>&#123;<br><span class="hljs-comment">// 初始化列表</span><br>&#125;<br><span class="hljs-comment">// 析构</span><br>~<span class="hljs-built_in">Complex</span>()<br>&#123;<br><span class="hljs-comment">// ......</span><br>&#125;<br><br><span class="hljs-comment">// 方法</span><br><span class="hljs-comment">// 1. printComplex 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printComplex</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 2. + 方法重载：复数的加法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real += com.real;<br><span class="hljs-keyword">this</span>-&gt;imag += com.imag;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 3. - 方法重载：复数的减法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real -= com.real;<br><span class="hljs-keyword">this</span>-&gt;imag -= com.imag;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 4. * 方法重载：复数的乘法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real = (real * com.real) - (imag * com.imag);<br><span class="hljs-keyword">this</span>-&gt;imag = (real * com.real) + (imag * com.imag);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 5. / 方法重载：复数的除法</span><br>Complex&amp; <span class="hljs-keyword">operator</span>/(<span class="hljs-type">const</span> Complex&lt;T&gt;&amp; com)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;real = (real * com.real + imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br><span class="hljs-keyword">this</span>-&gt;real = (real * com.real - imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T real;<span class="hljs-comment">// 实部</span><br>T imag;<span class="hljs-comment">// 虚部</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>)</span></span>;<br>c1.<span class="hljs-built_in">printComplex</span>();<br><span class="hljs-function">Complex&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>)</span></span>;<br>c2.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c1 = c1 + c2;<br>cout &lt;&lt; <span class="hljs-string">&quot;c1 加法后：&quot;</span>;<br>c1.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c2 = c2 - c1;<br>cout &lt;&lt; <span class="hljs-string">&quot;c2 减法后：&quot;</span>;<br>c2.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c1 = c2 * c1;<br>cout &lt;&lt; <span class="hljs-string">&quot;c1 乘法后：&quot;</span>;<br>c1.<span class="hljs-built_in">printComplex</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>c2 = c2 / c1;<br>cout &lt;&lt; <span class="hljs-string">&quot;c2 除法后：&quot;</span>;<br>c2.<span class="hljs-built_in">printComplex</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100954476.png" alt="image.png"></p><p>另一种实现方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CComplex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CComplex</span>(<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>)<br>:_mreal(r)<br>,_mimage(i)<br>&#123;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> CComplex&amp;obj)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_mreal = obj._mreal;<br><span class="hljs-keyword">this</span>-&gt;_mimage = obj._mimage;<br>&#125;<br><span class="hljs-comment">//指导编译器怎么做CComplex类对象的加法操作</span><br><span class="hljs-comment">/*CComplex operator+(const CComplex&amp;com)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">return CComplex(this-&gt;_mreal + com._mreal,</span><br><span class="hljs-comment">this-&gt;_mimage + com._mimage);</span><br><span class="hljs-comment">&#125;*/</span><br>CComplex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CComplex</span>(<span class="hljs-keyword">this</span>-&gt;_mreal++, <span class="hljs-keyword">this</span>-&gt;_mimage++);<br><span class="hljs-comment">/*CComplex comp = *this;</span><br><span class="hljs-comment">this-&gt;_mimage++;</span><br><span class="hljs-comment">this-&gt;_mreal++;</span><br><span class="hljs-comment">return comp;*/</span><br>&#125;<br>CComplex&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_mreal += <span class="hljs-number">1</span>;<br>_mimage += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> CComplex&amp;rhs)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;_mreal += rhs._mreal;<br><span class="hljs-keyword">this</span>-&gt;_mimage += rhs._mimage;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;real:&quot;</span> &lt;&lt; _mreal &lt;&lt; <span class="hljs-string">&quot;image:&quot;</span> &lt;&lt; _mimage &lt;&lt; endl; &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _mreal;<br><span class="hljs-type">int</span> _mimage;<br><span class="hljs-keyword">friend</span> CComplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> CComplex &amp;lhs, <span class="hljs-type">const</span> CComplex &amp;rhs);<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;out, <span class="hljs-type">const</span> CComplex&amp;src);<br><span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src);<br>&#125;;<br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src)<br>&#123;<br><span class="hljs-type">int</span> a, b;<br>in &gt;&gt; a &gt;&gt; b;<br>src._mreal = a;<br>src._mimage = b;<br><span class="hljs-keyword">return</span> in;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp;out, <span class="hljs-type">const</span> CComplex&amp;src)<br>&#123;<br>out &lt;&lt; <span class="hljs-string">&quot;real:&quot;</span> &lt;&lt; src._mreal &lt;&lt; <span class="hljs-string">&quot;image:&quot;</span> &lt;&lt; src._mimage &lt;&lt; endl;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br>CComplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> CComplex &amp;lhs, <span class="hljs-type">const</span> CComplex &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">CComplex</span>(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">CComplex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">CComplex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>CComplex c4;<br><br>c4 = c1+c2;<br>c4.<span class="hljs-built_in">show</span>();<br><br>c4 = c1 + <span class="hljs-number">20</span>;<br>c4.<span class="hljs-built_in">show</span>();<br><br>c4 = <span class="hljs-number">30</span> + c2;<br>c4.<span class="hljs-built_in">show</span>();<br><br>CComplex c5;<br>c5 = c4++;<br>c5.<span class="hljs-built_in">show</span>();<br> <br>c5 = ++c4;<br>c5.<span class="hljs-built_in">show</span>();<br> <br>c5 += c4;<br>c5.<span class="hljs-built_in">show</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;<br> <br>cout &lt;&lt; c5;<br> <br>CComplex c6;<br>cin &gt;&gt; c6;<br>cout &lt;&lt; c6;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-模拟实现-C-的-string-类"><a href="#2-模拟实现-C-的-string-类" class="headerlink" title="2. 模拟实现 C++ 的 string 类"></a>2. 模拟实现 C++ 的 string 类</h2><p>string 类中的基本方法有：</p><ol><li>构造函数</li><li><ul><li>运算符重载</li></ul></li><li><code>&lt;&lt;</code> 运算符重载</li><li><blockquote><p>运算符重载</p></blockquote></li><li>len 方法</li><li><code>[]</code> 运算符重载</li><li>迭代器实现</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//默认构造函数</span><br>    string str1;<br>    string str2 = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    string str3 = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-comment">//+ 运算符重载</span><br>    string str4 = str2 + str3;<br>    string str5 = str2 + <span class="hljs-string">&quot;ccc&quot;</span>;<br>    string str6 = <span class="hljs-string">&quot;ddd&quot;</span> + str2;<br><br>    <span class="hljs-comment">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// &gt;  运算符重载</span><br>    <span class="hljs-keyword">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-type">int</span> len = str6.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-comment">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// c_str()</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">strcpy</span>(buff, str6.<span class="hljs-built_in">c_str</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 迭代器实现</span><br>    string::iterator it = str2.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (it = str2.<span class="hljs-built_in">begin</span>(); it != str2.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101003436.png" alt="image.png"></p><h3 id="1-实现-string"><a href="#1-实现-string" class="headerlink" title="1. 实现 string"></a>1. 实现 string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建 string 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 创建</span><br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 拷贝</span><br>            <span class="hljs-built_in">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *_pstr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br>        _pstr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 运算符重载</span><br>    <span class="hljs-comment">// 1. =</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br><br>        <span class="hljs-comment">// 创建</span><br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. &gt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3. &lt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4. ==</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5. []</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class="hljs-comment">// 公共方法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(_pstr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">return</span> _pstr; <br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _pstr;<br><br>    <span class="hljs-comment">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class="hljs-comment">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str);<br><span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  重载+；</span><br><span class="hljs-comment">  重载+ 有两种方式：</span><br><span class="hljs-comment">  (1)定义成成员函数</span><br><span class="hljs-comment">  String operator+(const String&amp; s)&#123;</span><br><span class="hljs-comment">    String tmp;</span><br><span class="hljs-comment">    .....</span><br><span class="hljs-comment">    return tmp;</span><br><span class="hljs-comment">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class="hljs-comment">  （2）重载为全局函数</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/************************************************************************/</span><br>    <span class="hljs-keyword">friend</span> String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class="hljs-comment">并以此开辟空间大小，</span><br><span class="hljs-comment">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class="hljs-comment">*/</span><br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">char</span>* _ptmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(lhs._pstr) + <span class="hljs-built_in">strlen</span>(rhs._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拷贝</span><br>    <span class="hljs-built_in">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(_ptmp)</span></span>;<br>    <span class="hljs-keyword">delete</span>[]_ptmp;<br>    <br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    String str3 = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-comment">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class="hljs-string">&quot;ccc&quot;</span>;<br>    String str6 = <span class="hljs-string">&quot;ddd&quot;</span> + str2;<br><br>    <span class="hljs-comment">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// &gt;  运算符重载</span><br>    <span class="hljs-keyword">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-type">int</span> len = str6.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-comment">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// c_str()</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">strcpy</span>(buff, str6.<span class="hljs-built_in">c_str</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//  string::iterator it = str2.begin();</span><br>    <span class="hljs-comment">// for (it = str2.begin(); it != str2.end(); ++it) &#123;</span><br>     <span class="hljs-comment">// cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">char</span>* _ptmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(lhs._pstr) + <span class="hljs-built_in">strlen</span>(rhs._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拷贝</span><br>    <span class="hljs-built_in">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(_ptmp)</span></span>;<br>    <span class="hljs-keyword">delete</span>[]_ptmp;<br>    <br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了将局部新开辟的内存空间 <code>_ptmp</code> 资源释放，我们后面又构造了一个临时对象 <code>String tmp(_ptmp)</code>，之后将局部变量资源释放 <code>delete[]_ptmp</code>，但是这样一来的效率非常低！</p><h2 id="3-string-字符串对象的迭代器"><a href="#3-string-字符串对象的迭代器" class="headerlink" title="3. string 字符串对象的迭代器"></a>3. string 字符串对象的迭代器</h2><p>容器的迭代器可以透明的访问容器内部的元素的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">string::iterator it = str2.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (it = str2.<span class="hljs-built_in">begin</span>(); it != str2.<span class="hljs-built_in">end</span>(); ++it) &#123;<br> cout &lt;&lt; (*it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代器创建</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">iterator</span>(<span class="hljs-type">char</span> *p = <span class="hljs-literal">nullptr</span>) : _p(p) &#123; &#125;<br>    <span class="hljs-comment">// 拷贝函数</span><br>    <span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>    <br>    <span class="hljs-comment">// 重载运算符</span><br>     <span class="hljs-comment">// !=  如 it != s1.end()</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it) &#123;<br>        <span class="hljs-keyword">return</span> _p != it._p;<span class="hljs-comment">//比较地址</span><br>    &#125;<br>    <span class="hljs-comment">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>    iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>        ++_p;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//后置++  返回临时量</span><br>    iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>        <span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>        _p++;<br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br>    <span class="hljs-comment">//解引用  *iter</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *_p; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _p;<br>&#125;;<br><br><span class="hljs-comment">// 创建迭代器的 begin 和 end</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr + <span class="hljs-built_in">length</span>()); &#125;<br></code></pre></td></tr></table></figure><p><strong>完整代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 创建 string 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 迭代器创建</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-built_in">iterator</span>(<span class="hljs-type">char</span> *p = <span class="hljs-literal">nullptr</span>) : _p(p) &#123; &#125;<br>        <span class="hljs-comment">// 拷贝函数</span><br>        <span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>        <br>        <span class="hljs-comment">// 重载运算符</span><br>         <span class="hljs-comment">// !=  如 it != s1.end()</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; it) &#123;<br>            <span class="hljs-keyword">return</span> _p != it._p;<span class="hljs-comment">//比较地址</span><br>        &#125;<br>        <span class="hljs-comment">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>        iterator&amp; <span class="hljs-keyword">operator</span>++() &#123;<br>            ++_p;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-comment">//后置++  返回临时量</span><br>        iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>            <span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>            _p++;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>        <span class="hljs-comment">//解引用  *iter</span><br>        <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>*() &#123; <span class="hljs-keyword">return</span> *_p; &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">char</span>* _p;<br>    &#125;;<br><br>    <span class="hljs-comment">// 创建迭代器的 begin 和 end</span><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr); &#125;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(_pstr + <span class="hljs-built_in">length</span>()); &#125;<br><br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 创建</span><br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(p) + <span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 拷贝</span><br>            <span class="hljs-built_in">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *_pstr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">String</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br>        _pstr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 运算符重载</span><br>    <span class="hljs-comment">// 1. =</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>        &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] _pstr;<br><br>        <span class="hljs-comment">// 创建</span><br>        _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2. &gt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3. &lt;</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4. ==</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String&amp; str) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(_pstr, str._pstr) == <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5. []</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> <br>    &#123; <br>        <span class="hljs-keyword">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class="hljs-comment">// 公共方法</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(_pstr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-keyword">return</span> _pstr; <br>    &#125;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* _pstr;<br><br>    <span class="hljs-comment">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class="hljs-comment">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str);<br><span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  重载+；</span><br><span class="hljs-comment">  重载+ 有两种方式：</span><br><span class="hljs-comment">  (1)定义成成员函数</span><br><span class="hljs-comment">  String operator+(const String&amp; s)&#123;</span><br><span class="hljs-comment">    String tmp;</span><br><span class="hljs-comment">    .....</span><br><span class="hljs-comment">    return tmp;</span><br><span class="hljs-comment">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class="hljs-comment">  （2）重载为全局函数</span><br><span class="hljs-comment">  */</span><br><span class="hljs-comment">/************************************************************************/</span><br>    <span class="hljs-keyword">friend</span> String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class="hljs-comment">并以此开辟空间大小，</span><br><span class="hljs-comment">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class="hljs-comment">*/</span><br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String&amp; lhs, <span class="hljs-type">const</span> String&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// 计算长度</span><br>    <span class="hljs-type">char</span>* _ptmp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(lhs._pstr) + <span class="hljs-built_in">strlen</span>(rhs._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 拷贝</span><br>    <span class="hljs-built_in">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-built_in">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(_ptmp)</span></span>;<br>    <span class="hljs-keyword">delete</span>[]_ptmp;<br>    <br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    String str3 = <span class="hljs-string">&quot;bbb&quot;</span>;<br><br>    <span class="hljs-comment">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class="hljs-string">&quot;ccc&quot;</span>;<br>    String str6 = <span class="hljs-string">&quot;ddd&quot;</span> + str2;<br><br>    <span class="hljs-comment">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class="hljs-comment">// &gt;  运算符重载</span><br>    <span class="hljs-keyword">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class="hljs-string">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-type">int</span> len = str6.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-comment">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// c_str()</span><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">1024</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-built_in">strcpy</span>(buff, str6.<span class="hljs-built_in">c_str</span>());<br>    cout &lt;&lt; <span class="hljs-string">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br><br>    <span class="hljs-comment">// 迭代器</span><br>    String::iterator it = str2.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (it = str2.<span class="hljs-built_in">begin</span>(); it != str2.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// auto</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str2) &#123;<br>        cout &lt;&lt; ch &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-代码优化"><a href="#1-代码优化" class="headerlink" title="1. 代码优化"></a>1. 代码优化</h3><p><strong>带右值引用参数的拷贝构造与带右值引用参数的赋值重载函数</strong></p><p>考虑这样一个操作：</p><p><strong>由于问题场景的特殊，子函数调用时我们无法返回一个临时对象。<br>而且我们也只能用赋值的方式接收一个函数调用的返回值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">String <span class="hljs-title">GetString</span><span class="hljs-params">(<span class="hljs-type">const</span> String&amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n  GetString() begin\n&quot;</span>;<br>  <span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(str.c_str())</span></span>;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n  GetString() end\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> tmp;<br>&#125;<br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  String s1 = <span class="hljs-string">&quot;123&quot;</span>;<br>  String s2;<br> <br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n main call GetString() begin\n&quot;</span>;<br>  s2 = <span class="hljs-built_in">GetString</span>(s1);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;\n main call GetString() end\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101105643.png" alt="image.png"></p><p> 存在的问题：</p><p>（1）在调用 <code>return tmp;</code> 时 实际是使用构造一个临时对象，临时对象调用拷贝构造函数从 tmp 中复制数据，然后调用析构函数析构 tmp 对象，这样就白耗费资源了，tmpStr 资源不要就早说，直接给函数栈帧上临时对象就好了；<br>（2）s2 调用赋值运算符 ：临时量给 str2 赋值，str2 是原本已经存在的对象，它也有一个指针 mptr，原先也指向了一个空间。</p><p>对于赋值来说，排除自赋值，然后把原先指向的空间释放掉，然后按照 str 的尺寸开辟空间，然后拷贝数据进行来。即按照临时对象的字符串大小开辟空间，然后把数据一个一个拷贝进来。</p><p>然后出语句，把这个临时对象析构及它指向的堆内存空间释放掉。</p><p>过程过于复杂，为什么不能直接把临时对象的外部资源给 str2 不就完了吗？</p><h3 id="2-右值引用"><a href="#2-右值引用" class="headerlink" title="2. 右值引用"></a>2. 右值引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++11把临时量都当做右值处理 </span><br>String &amp;&amp;e = <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//可以！ </span><br>    <span class="hljs-type">const</span> String &amp;e = <span class="hljs-built_in">MyString</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<span class="hljs-comment">//可以！</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-comment">/*拷贝构造函数   //String s2 = s1;*/</span><br>  <span class="hljs-comment">/************************************************************************/</span><br>  <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (str._pstr !=<span class="hljs-literal">nullptr</span>) &#123;<br>      _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str._pstr) + <span class="hljs-number">1</span>];<br>      <span class="hljs-built_in">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 左值拷贝构造函数\n&quot;</span>;<br>  &#125;<br> <br>  <span class="hljs-comment">//带右值引用参数的拷贝构造</span><br>  <span class="hljs-built_in">String</span>(String &amp;&amp;str)<span class="hljs-comment">//str引用的就是一个临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 右值拷贝构造函数\n&quot;</span>;<br>      _pstr = str._pstr;<br>    str._pstr = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br> <br>  <span class="hljs-comment">/************************************************************************/</span><br><span class="hljs-comment">/*赋值运算符    //s2 = s1*/</span><br><span class="hljs-comment">/************************************************************************/</span><br>  String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; src)<br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 左值赋值运算符\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;src)<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> <br>    <span class="hljs-keyword">if</span> (src._pstr == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">if</span> (_pstr) &#123;<br>      <span class="hljs-keyword">delete</span>[]_pstr;<br>    &#125;<br> <br> <br>    _pstr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(src._pstr) + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(_pstr, src._pstr);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br> <br>  <span class="hljs-comment">//带右值引用参数的赋值重载函数</span><br>  String&amp; <span class="hljs-keyword">operator</span>=(String &amp;&amp;str)<span class="hljs-comment">//str引用的是临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String 右值引用参数的赋值重载函数\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> <br>    <span class="hljs-keyword">if</span> (str._pstr == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">delete</span>[]_pstr;<br> <br>    <span class="hljs-type">char</span> * tmp=_pstr ;<br>    _pstr = str._pstr;<br>    str._pstr = tmp;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>通过右值引用，<strong>没有任何内存的开辟和释放和数据的拷贝</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101116493.png" alt="image.png"></p><p>右值引用前：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117001.png" alt="image.png"></p><p>右值引用后：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117760.png" alt="image.png"></p><h2 id="4-vector-容器的迭代器-iterator-实现"><a href="#4-vector-容器的迭代器-iterator-实现" class="headerlink" title="4. vector 容器的迭代器 iterator 实现"></a>4. vector 容器的迭代器 iterator 实现</h2><p><strong>问题 1：删除 vector 中所有的偶数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 删除偶数</span><br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it &lt; vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br>vec.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101137035.png" alt="image.png"></p><p>运行导致程序崩溃！</p><p><strong>问题 2：vector 容器插入元素问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it &lt; vec.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>vec.<span class="hljs-built_in">insert</span>(it, *it - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101430280.png" alt="image.png"></p><p>运行导致程序崩溃！</p><p><strong>问题 3：push_back 触发扩容时</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;容量：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;后push_back容量：&quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;添加后，it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101503945.png" alt="image.png"></p><p><strong>原因：iterator 失效</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101431915.png" alt="image.png"></p><p>当删除（获取增加）it 位置的元素时，导致 it 后面的迭代器全部失效。因此多次调用 <code>erase\insert</code>导致崩溃</p><h2 id="5-什么是容器的迭代器失效问题"><a href="#5-什么是容器的迭代器失效问题" class="headerlink" title="5. 什么是容器的迭代器失效问题"></a>5. 什么是容器的迭代器失效问题</h2><h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h3><p><strong>问题一：</strong></p><p>当容器调用 erase 时，当前位置到容器末尾元素的所有的迭代器全部失效</p><p><strong>问题二：</strong></p><p>当容器调用 insert 时，当前位置到容器末尾元素的所有的迭代器全部失效</p><p>当容器调用 insert 时，如果引起容器内存扩容，原来容器的所有的迭代器就全部失效</p><p><strong>问题三：</strong></p><p>当容器 push_back 时，如果当前容量不足，则会触发扩容，导致整个容器重新申请内存，并且将原有的数据复制到新内存中将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放。</p><h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h3><p>进行更新操作：<code>erase\insert</code> 后会返回指向下一个元素的迭代器</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101510112.png" alt="image.png"></p><ul><li>[vector::erase] <a href="https://cplusplus.com/reference/vector/vector/erase/">https://cplusplus.com/reference/vector/vector/erase/</a></li></ul><p>从向量中删除单个元素（位置）或一系列元素（<code>[第一、最后一个]</code>）。</p><p>这有效地减少了容器的大小，减少了被删除的元素的数量，这些元素会被销毁。</p><p>由于向量使用数组作为其底层存储，擦除向量端以外位置的元素会导致容器在段擦除后将所有元素重新定位到其新位置。与其他类型的序列容器对相同操作执行的操作相比，这通常是一种低效的操作（如列表或转发列表）。</p><p>同理，insert</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101512469.png" alt="image.png"></p><p>通过在指定位置的元素之前插入新元素来扩展向量，从而通过插入的元素数量有效地增加容器大小。</p><p>当且仅当新向量大小超过当前向量容量时，这会导致自动重新分配分配分配的存储空间。</p><p>因为向量使用数组作为其底层存储，所以在向量末端以外的位置插入元素会导致容器将位置之后的所有元素重新定位到它们的新位置。与其他类型的序列容器（如 list 或 forward_list）对相同操作执行的操作相比，这通常是一种低效的操作。</p><p>这些参数确定插入的元素数量及其初始化值：</p><p>也说明了进行插入操作会导致之后的迭代器失效。</p><p>修改代码：</p><p>erase 解决代码：**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>vec.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><br><span class="hljs-comment">// 把 vec 容器中的所有偶数删除</span><br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != vec.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 重新赋值</span><br>it = vec.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>it++;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 输出查看</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : vec)<br>&#123;<br>cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101516128.png" alt="image.png"></p><p><strong>insert 解决代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>    vec.<span class="hljs-built_in">push_back</span>(i);<br>  &#125;<br> <br>  <span class="hljs-comment">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>  <span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); it++) &#123;<br>    <span class="hljs-keyword">if</span> ((*it) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>      it = vec.<span class="hljs-built_in">insert</span>(it, *it - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// it原来的位置插入了新的，需要++it两次，才能到该偶数的后一个元素</span><br>      it++;<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : vec) &#123;<br>    cout &lt;&lt; val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101520065.png" alt="image.png"></p><h3 id="3-vector-实现中的-insert-和-erase"><a href="#3-vector-实现中的-insert-和-erase" class="headerlink" title="3. vector 实现中的 insert 和 erase"></a>3. vector 实现中的 insert 和 erase</h3><p>头插法：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101522251.png" alt="image.png"></p><p>检查迭代器失效：</p><p>在进行删除或增加的时候，要检测该位置到 last 位置，使其迭代器失效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> <span class="hljs-comment">// 从容器末尾删除元素</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br> <br>  <span class="hljs-comment">//检查迭代器 从该位置到最后</span><br>  <span class="hljs-built_in">verify</span>(Last<span class="hljs-number">-1</span>,Last);<br> <br>  <span class="hljs-comment">// 不仅要把_last指针--，还需要析构删除的元素</span><br>  --Last;<br>  _allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>迭代器检查实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">verify</span><span class="hljs-params">(T* first, t* last)</span></span><br><span class="hljs-function"></span>&#123;<br>Iterator_Base* pre = &amp;<span class="hljs-keyword">this</span>-&gt;head;<br>Iterator_Base* it = &amp;<span class="hljs-keyword">this</span>-&gt;head._next;<br><br><span class="hljs-keyword">while</span> (it != <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)<br>&#123;<br><span class="hljs-comment">// 迭代器失效，把 iterator 持有的容器指针置空</span><br>it-&gt;_cur-&gt;_pVec = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// 删除当前迭代器节点，继续判断后面的迭代器是否失效</span><br>pre-&gt;_next = it-&gt;_next;<br><span class="hljs-keyword">delete</span> it;<br>it = pre-&gt;_next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pre = it;<br>it = it-&gt;_next;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-new-和-delete-重载实现的对象池"><a href="#6-new-和-delete-重载实现的对象池" class="headerlink" title="6. new 和 delete 重载实现的对象池"></a>6. new 和 delete 重载实现的对象池</h2><p>在编程中，我们经常会涉及到对象的操作，而经常的操作模式如下图所示:<code>创建对象</code>-&gt;<code>使用对象</code>-&gt;<code>销毁对象</code>。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101557430.png" alt="image.png"></p><p>而这个对象有可能创建的时候会需要构建很多资源，消耗比较大, 比如：在<code>hiredis</code>的SDK中每次都创建一个<code>redisContext</code>，如果需要查询，那就首先要进行网络连接。如果一直都是上图的工作方式，那将会频繁的创建连接，查询完毕后再释放连接。重新建立连接，让网络的查询效率降低。</p><p>这个时候就可以构建一个<code>对象池</code>来重复利用这个对象，并且一般要做到线程安全:</p><ol><li>从<code>对象池</code>中获取对象，如果没有对象，则创建一个，并返回</li><li>使用对象</li><li>使用完成对象后，将对象还回<code>对象池</code></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101559621.png" alt="image.png"></p><p>那么符合如下条件的，应该适合使用<code>对象池</code>技术:</p><ul><li>有一些对象虽然创建开销比较大，但是不一定能够重复使用。要使用<code>对象池</code>一定要确保对象能够重复使用。</li><li>这个对象构建的时候，有一些耗时的资源可以重复利用。比如<code>redisContext</code>的网络连接。又或者如果对象的频繁申请释放会带来一些其他的资源使用问题，比如<code>内存碎片</code>。重复利用能够提升程序的效率。</li><li><code>对象池</code>的数量应该控制在能够接受的范围内，并不会无限膨胀。</li></ul><h3 id="1-对象池实现原理"><a href="#1-对象池实现原理" class="headerlink" title="1. 对象池实现原理"></a>1. 对象池实现原理</h3><ol><li><strong>分配过程：</strong></li></ol><p><strong>我们首先申请比如 100000 块内存空间，用这个块类型的指针指向这个申请好内存的首地址。如图：这个块可以是一个链式队列的一个节点或者一个树的节点等。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101603100.png" alt="image.png"><br><strong>当我们要分配给用户一块空间的时候我们就可以，先将 <code>_itemPool</code> 的地址保存到临时指针 p，然后再 <code>_itemPool++</code> 的操作，然后再将 p 返回给用户即可。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101604537.png" alt="image.png"></p><ol start="2"><li><strong>释放过程：</strong></li></ol><p><strong>比如现在的内存分配状况如图所示：现在用户需要归还第 1 块内存。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101605266.png" alt="image.png"></p><p>我们首先要归还块的首地址指向 <code>_itemPool</code> 的下一个块，然后再将 <code>_itemPool</code> 指向归还的块的地址。即可</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101606815.png" alt="image.png"></p><h3 id="2-以队列实现一个简单对象池"><a href="#2-以队列实现一个简单对象池" class="headerlink" title="2. 以队列实现一个简单对象池"></a>2. 以队列实现一个简单对象池</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运算符的重载  :成员方法、全局方法</span><br><span class="hljs-comment">内存池 进程池 线程池 连接池 对象池</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">Queue</span>()<br>&#123;<br><span class="hljs-comment">// 初始化指针</span><br>_front = _rear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueItem</span>();<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">Queue</span>()<br>&#123;<br><span class="hljs-comment">// 创建新对象</span><br>QueueItem* cur = _front;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>)<br>&#123;<br>_front = cur-&gt;_next;<br><span class="hljs-keyword">delete</span> cur;<br>cur = _front;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 拷贝对象</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">const</span> Queue&amp; obj) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">// 赋值重载</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Queue&amp; obj) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-comment">// 方法</span><br><span class="hljs-comment">// 1. push 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>QueueItem* item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QueueItem</span>(val);<br>_rear-&gt;_next = item;<br>_rear = item;<br>&#125;<br><span class="hljs-comment">// 2. pop 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>QueueItem* first = _front-&gt;_next;<br>_front-&gt;_next = first-&gt;_next;<br><span class="hljs-keyword">if</span> (_front-&gt;_next == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>_rear = _front;<br>&#125;<br><span class="hljs-keyword">delete</span> first;<br>&#125;<br><span class="hljs-comment">// 3. front 方法</span><br><span class="hljs-function">T <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> _front-&gt;_next-&gt;_data;<br>&#125;<br><span class="hljs-comment">// 4. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _rear == _front; &#125;<br><br><span class="hljs-comment">// 产生一个 QueueItem 的对象池</span><br><span class="hljs-comment">// 创建一个对象池结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueItem</span><br>&#123;<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">QueueItem</span>(T data = <span class="hljs-built_in">T</span>()) :_data(data), _next(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><br><span class="hljs-comment">// new 重载</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (_itemPool == <span class="hljs-literal">nullptr</span>)<br>&#123;<br><span class="hljs-comment">//由于我们不知道QueueItem的具体大小(模板未进行实例化)所以我们这里用char 1字节作为new的基准</span><br>_itemPool = (QueueItem*)<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[POOL_ITEM_SIZE * <span class="hljs-built_in">sizeof</span>(QueueItem)];<br>QueueItem* p = _itemPool;<br><span class="hljs-comment">//把开辟的POOL_ITEM_SIZE个块关联起来</span><br><span class="hljs-keyword">for</span> (; p != _itemPool + POOL_ITEM_SIZE - <span class="hljs-number">1</span>; ++p)<br>&#123;<br>p-&gt;_next = p + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//最后一块的next置为空</span><br>p-&gt;_next = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">//将第一块可以分配的块分配给用户</span><br>QueueItem* p = _itemPool;<br>_itemPool = _itemPool-&gt;_next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">// delete 重载</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//进行归还操作</span><br>QueueItem* p = (QueueItem*)ptr;<br>p-&gt;_next = _itemPool;<br>_itemPool = p;<br>&#125;<br><br><span class="hljs-comment">// 静态数据</span><br><span class="hljs-type">static</span> QueueItem* _itemPool;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> POOL_ITEM_SIZE = <span class="hljs-number">1000000</span>;<br><br><span class="hljs-comment">// 对象池单个对象</span><br>T _data;<br>QueueItem* _next;<br>&#125;;<br><br><span class="hljs-keyword">private</span>:<br>QueueItem* _front;<span class="hljs-comment">//指向头节点</span><br>QueueItem* _rear;<span class="hljs-comment">//指向队尾</span><br>&#125;;<br><br><span class="hljs-comment">//typename 告诉编译器后面是类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> Queue&lt;T&gt;::QueueItem* Queue&lt;T&gt;::QueueItem::_itemPool = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Queue&lt;<span class="hljs-type">int</span>&gt; que;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; ++i)<span class="hljs-comment">//大量的new delete;不划算</span><br>&#123;<br>que.<span class="hljs-built_in">push</span>(i);<br>que.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br>cout &lt;&lt; que.<span class="hljs-built_in">empty</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-深入理解-new-和-delete-的原理"><a href="#7-深入理解-new-和-delete-的原理" class="headerlink" title="7. 深入理解 new 和 delete 的原理"></a>7. 深入理解 new 和 delete 的原理</h2><p><strong>new和delete</strong>是用户进行<strong>动态内存申请和释放的操作符</strong>，<strong>operator new 和operator delete</strong>是系统提供的<strong>全局函数</strong>，<strong>new在底层调用operator new</strong>全局函数来申请空间，<strong>delete在底层通过operator delete</strong>全局函数来释放空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator new:该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span>* __CRTDECL <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> _<span class="hljs-title">THROW1</span><span class="hljs-params">(_STD bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// try to allocate size bytes</span><br>    <span class="hljs-type">void</span>* p;<br>    <span class="hljs-keyword">while</span> ((p = <span class="hljs-built_in">malloc</span>(size)) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> (_callnewh(size) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// report no memory</span><br>            <span class="hljs-comment">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常 </span><br>            <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::bad_alloc nomem; <br>            _RAISE(nomem);<br>        &#125;<br>        <br>    <span class="hljs-keyword">return</span> (p);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">operator delete: 该函数最终是通过free来释放空间的 </span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pUserData)</span></span><br><span class="hljs-function"></span>&#123;<br>    _CrtMemBlockHeader* pHead;<br>    <br>    <span class="hljs-built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">if</span> (pUserData == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    _mlock(_HEAP_LOCK);  <span class="hljs-comment">/* block other threads */</span><br>    __TRY<br>    <br>        <span class="hljs-comment">/* get a pointer to memory block header */</span><br>        pHead = <span class="hljs-built_in">pHdr</span>(pUserData);<br>        <br>    <span class="hljs-comment">/* verify block type */</span><br>    _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));<br>    <br>    _free_dbg(pUserData, pHead-&gt;nBlockUse);<br>    <br>    __FINALLY<br>        _munlock(_HEAP_LOCK);  <span class="hljs-comment">/* release other threads */</span><br>    __END_TRY_FINALLY<br>    <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">free的实现</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> free(p) _free_dbg(p, _NORMAL_BLOCK)</span><br></code></pre></td></tr></table></figure><p><strong>1. 内置类型：</strong></p><p>如果申请的是内置类型的空间 <code>new</code> 和 <code>malloc</code>，<code>delete</code> 和 <code>free</code> 基本类似，不同的地方是：<code>new/delete</code> 申请和释放的是单个元素的空间，<code>new[]</code> 和 <code>delete[]</code> 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc会返回NULL。</p><p><strong>2. 自定义类型:</strong></p><p><strong>new的原理：</strong></p><ol><li>调用operator new函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ol><p><strong>delete的原理：</strong></p><p>在空间上执行析构函数，完成对象中资源的清理工作在空间上执行析构函数，完成对象中资源的清理工作</p><p><code>new T[N]</code> 的原理：</p><ol><li>调用 <code>operator new[]</code> 函数，在 <code>operator new[]</code> 中实际调用 <code>operator new</code> 函数完成 N 个对象空间的申请</li><li>在申请的空间上执行N次构造函数</li></ol><p><code>delete[ ]</code>的原理：</p><ol><li>在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理</li><li>调用 <code>operator delete[]</code> 释放空间，实际在 <code>operator delete[]</code> 中调用 <code>operator delete</code> 来释放空间</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04.C++ 函数模板</title>
    <link href="/2023/08/08/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/04.C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/08/08/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/04.C++%20%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>本节分为四个部分：</p><ol><li>理解函数模板</li><li>理解类模板</li><li>实现 C++ STL 向量容器 vector</li><li>理解容器控件配置器 allocator</li></ol><h2 id="1-理解函数模板"><a href="#1-理解函数模板" class="headerlink" title="1. 理解函数模板"></a>1. 理解函数模板</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</p><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h3><p>面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = x;<br>x = y;<br>y = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-type">double</span> &amp; xr <span class="hljs-type">double</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。</p><p>能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。</p><p>程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。</p><p><strong>模板函数、模板的特例化和非模板函数的重载关系</strong>：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。</p><p><strong>模板代码是不能声明在.h，实现在.cpp</strong>，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 <code>#include</code></p><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><p>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p><p>在 C++ 中，模板分为函数模板和类模板两种。</p><ul><li>函数模板是用于生成函数；</li><li>类模板则是用于生成类的。</li></ul><p>函数模板的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">1</span>, <span class="hljs-keyword">class</span>类型参数<span class="hljs-number">2</span>, ...&gt;<br>返回值类型  模板名(形参表)<br>&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中的 class 关键字也可以用 typename 关键字替换</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> 类型参数<span class="hljs-number">1</span>, <span class="hljs-keyword">typename</span> 类型参数<span class="hljs-number">2</span>, ...&gt;<br></code></pre></td></tr></table></figure><p>函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp = x; <br>x = y; <br>y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>T 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp = x;<br>x = y;<br>y = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">1</span>, m = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 编译器自动生成 void Swap (int &amp;, int &amp;)函数</span><br><span class="hljs-built_in">Swap</span>(n, m);<br><br><span class="hljs-type">double</span> f = <span class="hljs-number">1.2</span>, g = <span class="hljs-number">3.4</span>;<br><span class="hljs-comment">// 编译器自动生成 void Swap (double &amp;, double &amp;)函数</span><br><span class="hljs-built_in">Swap</span>(f, g);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器在编译到 <code>Swap(n, m);</code> 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span> <span class="hljs-params">(<span class="hljs-type">int</span> &amp; x, <span class="hljs-type">int</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数可以匹配 <code>Swap(n, m);</code> 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 <code>Swap(n, m);</code> 编译成对自动生成的 Swap 函数的调用。</p><p>同理，编译器在编译到 <code>Swap(f, g);</code> 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(<span class="hljs-type">double</span> &amp; x, <span class="hljs-type">double</span> &amp; y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再将 <code>Swap(f, g);</code> 编译成对该 Swap 函数的调用。</p><p>编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。</p><p>编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">模板名&lt;实际类型参数<span class="hljs-number">1</span>, 实际类型参数<span class="hljs-number">2</span>, ...&gt;<br></code></pre></td></tr></table></figure><h2 id="2-理解类模板"><a href="#2-理解类模板" class="headerlink" title="2. 理解类模板"></a>2. 理解类模板</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>为了多快好省地定义出一批<strong>相似的类</strong>,可以定义「类模板」，然后<strong>由类模板生成不同的类</strong>。</p><p>类模板的定义形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">1</span>，<span class="hljs-keyword">class</span> 类型参数<span class="hljs-number">2</span>，...&gt; <span class="hljs-comment">//类型参数表</span><br><span class="hljs-keyword">class</span> 类模板名<br>&#123;<br>   成员函数和成员变量<br>&#125;;<br></code></pre></td></tr></table></figure><p>用类模板定义对象的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实参表);<br></code></pre></td></tr></table></figure><ul><li>类模板用于实现类所需数据的类型参数化</li><li>类模板在表示如数组、表、图等数据结构显得特别重要</li><li>这些数据结构的表示和算法不受所包含的元素类型的影响</li></ul><h3 id="2-类模板实现顺序栈"><a href="#2-类模板实现顺序栈" class="headerlink" title="2. 类模板实现顺序栈"></a>2. 类模板实现顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqStack</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 构造函数初始化</span><br><span class="hljs-comment">// 构造和析构函数名不加&lt;T&gt; 其他出现模板的地方都加上类型参数列表</span><br><span class="hljs-built_in">SeqStack</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">PStack</span>(<span class="hljs-keyword">new</span> T[size])<br>, <span class="hljs-built_in">Top</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">Size</span>(size) &#123;<br><span class="hljs-comment">// 初始化生成的指令更少，效率更高。</span><br><span class="hljs-comment">// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符</span><br>&#125;;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-comment">// 初始化列表的方式初始化 size 和 top</span><br><span class="hljs-built_in">SeqStack</span>(<span class="hljs-type">const</span> SeqStack&lt;T&gt;&amp; stack)<br>: <span class="hljs-built_in">Top</span>(stack.Top)<br>, <span class="hljs-built_in">Size</span>(stack.Size) &#123;<br><span class="hljs-comment">// 重新设置栈</span><br>PStack = <span class="hljs-keyword">new</span> T[stack.Size];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>PStack[i] = stack.PStack[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 析构函数 释放内存</span><br>~<span class="hljs-built_in">SeqStack</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (PStack)<br>&#123;<br><span class="hljs-keyword">delete</span>[] PStack;<br>PStack = <span class="hljs-literal">nullptr</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 复制重载</span><br>SeqStack&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SeqStack&lt;T&gt;&amp; stack)<br>&#123;<br><span class="hljs-comment">// 判断是否相等</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;stack)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span>[] PStack;<br><br><span class="hljs-comment">// 重新赋值</span><br>Top = stack.Top;<br>Size = stack.Size;<br>PStack = <span class="hljs-keyword">new</span> T[stack.Size];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>PStack[i] = stack.PStack[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 共有方法</span><br><span class="hljs-comment">// 1. push 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">resize</span>();<br>&#125;<br>PStack[Top] = val;<br>Top++;<br>&#125;<br><br><span class="hljs-comment">// 2. pop 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>Top--;<br>&#125;<br><br><span class="hljs-comment">// 3. top 方法</span><br><span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Stack is empty!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> PStack[Top - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> Top == Size;<br>&#125;<br><br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> Top == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 私有方法和数据</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>T* p = <span class="hljs-keyword">new</span> T[Size * <span class="hljs-number">2</span>];<br><span class="hljs-comment">// 将值赋值过去</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; Top; i++)<br>&#123;<br>p[i] = PStack[i];<br>&#125;<br><span class="hljs-comment">// 扩大</span><br>Size *= <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span> PStack;<br><span class="hljs-comment">// 重新赋值</span><br>PStack = p;<br>&#125;<br><br>T* PStack;<br><span class="hljs-type">int</span> Top;<br><span class="hljs-type">int</span> Size;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SeqStack&lt;<span class="hljs-type">int</span>&gt; stack;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>stack.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; stack.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>stack.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-实现-C-STL-向量容器-vector"><a href="#3-实现-C-STL-向量容器-vector" class="headerlink" title="3. 实现 C++ STL 向量容器 vector"></a>3. 实现 C++ STL 向量容器 vector</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png" alt="image.png"></p><p>vector 的本质是一个数组，在vector 中需要有三个指针：</p><ul><li><code>First</code>：指向数组的起始位置</li><li><code>Last</code>：指向已经存放的最后一个元素的下一个位置</li><li><code>End</code>：指向数组长度的末尾元素的下一个位置。</li></ul><p>vector 方法：</p><ul><li>数组的容量：<code>End-First</code></li><li>数组中存放的元素个数：<code>Last-First</code></li><li>数组是否为空：<code>First == Last</code></li><li>数组是否已满：<code>Last == End</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(<span class="hljs-keyword">new</span> T[size])<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 使用初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 获取容器长度</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 创建新容器</span><br>First = <span class="hljs-keyword">new</span> T[size];<br><span class="hljs-comment">// 获取数据长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>First[i] = rhs.First[i];<br>&#125;<br><span class="hljs-comment">// 重置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] First;<br>First = End = Last = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 清除</span><br><span class="hljs-keyword">delete</span>[] First;<br><br><span class="hljs-comment">// 重新计算并赋值</span><br><span class="hljs-comment">// 获取容器长度</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 创建新容器</span><br>First = <span class="hljs-keyword">new</span> T[size];<br><span class="hljs-comment">// 获取数据长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><span class="hljs-comment">// 遍历赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>First[i] = rhs.First[i];<br>&#125;<br><span class="hljs-comment">// 重置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 共有方法</span><br><span class="hljs-comment">// push_back 方法：容器添加内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">extend</span>();<br>&#125;<br><span class="hljs-comment">// 先给之以后，下次 push 则会递增内存</span><br>*Last++ = val;<br>&#125;<br><span class="hljs-comment">// pop_back 方法：容器删除内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>--Last;<br>&#125;<br><span class="hljs-comment">// back 方法：输出删除内容</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// full 方法：容器是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last == End;<br>&#125;<br><span class="hljs-comment">// empty 方法：容器是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last == First;<br>&#125;<br><span class="hljs-comment">// size 方法：获取内容厂区</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Last - First;<br>&#125;<br><br><span class="hljs-comment">// 私有方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// vector 容器扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> size = End - First;<br>T* ptmp = <span class="hljs-keyword">new</span> T[size * <span class="hljs-number">2</span>];<br><br><span class="hljs-comment">// 遍历并转移</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>ptmp[i] = First[i];<br>&#125;<br><span class="hljs-comment">// 删除原先的</span><br><span class="hljs-keyword">delete</span>[] First;<br><br><span class="hljs-comment">// 重新覆盖</span><br>First = ptmp;<br>Last = First + size;<br>End = First + <span class="hljs-number">2</span> * size;<br>&#125;<br><br><span class="hljs-comment">// 私有数据</span><br><span class="hljs-keyword">private</span>:<br>T* First;<br>T* Last;<br>T* End;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t) <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl; <br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1;<br>Test t2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; std::endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png" alt="image.png"></p><p>问题：在我们实现的 <code>vector</code> 构造函数中，使用 <code>new T[size]</code>  ：它做了两件事情：</p><p>（1）开辟内存空间<br>（2）调用 T 类型的默认构造函数构造对象</p><p>其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。</p><p>同时：在实现 <code>pop_back(）</code> 时，存在内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span> <span class="hljs-comment">// 从容器末尾删除元素</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br>  --Last;<br>&#125;<br></code></pre></td></tr></table></figure><p> 仅仅将 Last 指针 –，并没有释放 Test 申请的资源。<strong>需要调用对象的析构函数</strong></p><h2 id="4-理解容器控件配置器-allocator"><a href="#4-理解容器控件配置器-allocator" class="headerlink" title="4. 理解容器控件配置器 allocator"></a>4. 理解容器控件配置器 allocator</h2><p><strong>通过 Win msvc 编译器的实现：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CLASS TEMPLATE vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>: <span class="hljs-keyword">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>&#123;<span class="hljs-comment">// varying size array of values</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">using</span> _Mybase = _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;;<br><span class="hljs-keyword">using</span> _Alty = <span class="hljs-keyword">typename</span> _Mybase::_Alty;<br><span class="hljs-keyword">using</span> _Alty_traits = <span class="hljs-keyword">typename</span> _Mybase::_Alty_traits;<br>......<br></code></pre></td></tr></table></figure><p>系统的实现，除了数据类型外，还有一个<code>allocator</code>,它将开辟空间和构造对象分离开。  </p><p>而这，也就是空间配置器做的工作；</p><h3 id="1-容器的空间配置器"><a href="#1-容器的空间配置器" class="headerlink" title="1. 容器的空间配置器"></a>1. 容器的空间配置器</h3><p>空间配置器主要有四个功能：</p><ol><li>内存开辟 allocate（底层调用<code>malloc</code>）；</li><li>内存释放 deallocate（底层调用<code>free</code>）；</li><li>对象构造 construct（调用<code>构造函数</code>）；</li><li>对象析构 destroy（调用<code>析构函数</code>）；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-comment">// 负责内存的开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存的释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p) <span class="hljs-built_in">T</span>(val);<br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory</span><span class="hljs-params">(T* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ~T() 代表了 T 类型的析构函数</span><br> p-&gt;~<span class="hljs-built_in">T</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>重新实现 vector：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 负责内存开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p)<span class="hljs-built_in">T</span>(val); <span class="hljs-comment">// 定位new</span><br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(T* p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p-&gt;~<span class="hljs-built_in">T</span>(); <span class="hljs-comment">// ~T()代表了T类型的析构函数</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 allocator 适配器重写 vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-comment">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 需要把内存开辟和对象构造分开处理</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(_allocator.<span class="hljs-built_in">allocate</span>(size))<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 通过初始化列表的方式，初始化数据</span><br>&#125;<br><br><span class="hljs-comment">// 拷贝函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~vector&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != Last; p++)<br>&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><span class="hljs-comment">// 重置 指针</span><br>First = Last = End = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 1. 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 3. 重新计算</span><br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 1. push_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">expand</span>();<br>&#125;<br><span class="hljs-comment">// 通过适配器添加内容</span><br>_allocator.<span class="hljs-built_in">construct</span>(Last, val);<br>Last++;<br>&#125;<br><span class="hljs-comment">// 2. pop_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>--Last;<br>_allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br><span class="hljs-comment">// 3. back 方法</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last == End; &#125;<br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> First == Last; &#125;<br><span class="hljs-comment">// 6. size 方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last - First; &#125;<br><br><span class="hljs-comment">// 私有属性和方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向数组起始的位置</span><br>T* First;<br><span class="hljs-comment">// 指向数组中有效元素的后继位置</span><br>T* Last;<br><span class="hljs-comment">// 指向数组空间的后继位置</span><br>T* End;<br><span class="hljs-comment">// 定义容器的空间配置器对象</span><br>Alloc _allocator;<br><br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取大小</span><br><span class="hljs-type">int</span> size = End - First;<br><span class="hljs-comment">// 配置 2 倍适配器空间</span><br>T* ptmp = _allocator.<span class="hljs-built_in">allocate</span>(size * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>_allocator.<span class="hljs-built_in">construct</span>(ptmp + i, First[i]);<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 重新赋值</span><br>First = ptmp;<br>Last = First + size;<br>End = First + size * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;)<br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1, t2;<br>cout &lt;&lt; <span class="hljs-string">&quot;1.&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png" alt="image.png"></p><p>现在的效果就和 msvc 实现的 vector 相同了</p><h3 id="2-运算符重载与迭代器实现"><a href="#2-运算符重载与迭代器实现" class="headerlink" title="2. 运算符重载与迭代器实现"></a>2. 运算符重载与迭代器实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 迭代器一般是现成容器的嵌套类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">iterator</span>(T* p = <span class="hljs-literal">nullptr</span>)<br>: _ptr(p)<br>&#123;<br><span class="hljs-comment">// 初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter)<br>: _ptr(iter._ptr)<br>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 重载函数合集</span><br><span class="hljs-comment">// 1. 前置 ++</span><br>iterator&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_ptr++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 后置 ++</span><br>iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>_ptr++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// 3. 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br><span class="hljs-comment">// 4. !=</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; iter) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _ptr != iter._ptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* _ptr;<br>&#125;;<br><br><br><span class="hljs-comment">//迭代器方法</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(First); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(Last); &#125;<br><br><span class="hljs-comment">//运算符重载[]</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;<br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;OutofRangeException&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> First[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-最终-vector-实现"><a href="#3-最终-vector-实现" class="headerlink" title="3. 最终 vector 实现"></a>3. 最终 vector 实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-comment">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Allocator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 负责内存开辟</span><br><span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (T*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(T) * size);<br>&#125;<br><span class="hljs-comment">// 负责内存释放</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-comment">// 负责对象构造</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(T* p, <span class="hljs-type">const</span> T&amp; val)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">new</span> (p)<span class="hljs-built_in">T</span>(val); <span class="hljs-comment">// 定位new</span><br>&#125;<br><span class="hljs-comment">// 负责对象析构</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(T* p)</span> </span><br><span class="hljs-function"></span>&#123;<br>p-&gt;~<span class="hljs-built_in">T</span>(); <span class="hljs-comment">// ~T()代表了T类型的析构函数</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 allocator 适配器重写 vector</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class="hljs-keyword">class</span> vector<br>&#123;<br><span class="hljs-comment">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// 需要把内存开辟和对象构造分开处理</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">10</span>)<br>: <span class="hljs-built_in">First</span>(_allocator.<span class="hljs-built_in">allocate</span>(size))<br>, <span class="hljs-built_in">Last</span>(First)<br>, <span class="hljs-built_in">End</span>(First + size)<br>&#123;<br><span class="hljs-comment">// 通过初始化列表的方式，初始化数据</span><br>&#125;<br><br><span class="hljs-comment">// 拷贝函数</span><br><span class="hljs-built_in">vector</span>(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br>&#125;<br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">vector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~vector&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != Last; p++)<br>&#123;<br><span class="hljs-comment">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><span class="hljs-comment">// 重置 指针</span><br>First = Last = End = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 赋值重载</span><br>vector&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&lt;T&gt;&amp; rhs)<br>&#123;<br><span class="hljs-comment">// 1. 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 3. 重新计算</span><br><span class="hljs-comment">// 定义 大小</span><br><span class="hljs-type">int</span> size = rhs.End - rhs.First;<br><span class="hljs-comment">// 空间适配器开辟空间</span><br>First = _allocator.<span class="hljs-built_in">allocate</span>(size);<br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-type">int</span> len = rhs.Last - rhs.First;<br><br><span class="hljs-comment">// 拷贝数据</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">// 空间适配器的构造方法赋值</span><br>_allocator.<span class="hljs-built_in">construct</span>(First + i, rhs.First[i]);<br>&#125;<br><span class="hljs-comment">// 重新配置 Last 和 End</span><br>Last = First + len;<br>End = First + size;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//运算符重载[]</span><br>T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <br>&#123;<br><span class="hljs-comment">// 判断索引位置</span><br><span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= <span class="hljs-built_in">size</span>()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;OutofRangeException&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 返回索引值</span><br><span class="hljs-keyword">return</span> First[index];<br>&#125;<br><br><span class="hljs-comment">// 公共方法</span><br><span class="hljs-comment">// 1. push_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">expand</span>();<br>&#125;<br><span class="hljs-comment">// 通过适配器添加内容</span><br>_allocator.<span class="hljs-built_in">construct</span>(Last, val);<br>Last++;<br>&#125;<br><span class="hljs-comment">// 2. pop_back 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>--Last;<br>_allocator.<span class="hljs-built_in">destroy</span>(Last);<br>&#125;<br><span class="hljs-comment">// 3. back 方法</span><br><span class="hljs-function">T <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *(Last - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 4. full 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last == End; &#125;<br><span class="hljs-comment">// 5. empty 方法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> First == Last; &#125;<br><span class="hljs-comment">// 6. size 方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> Last - First; &#125;<br><br><span class="hljs-comment">// 迭代器一般是现成容器的嵌套类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">iterator</span>(T* p = <span class="hljs-literal">nullptr</span>)<br>: _ptr(p)<br>&#123;<br><span class="hljs-comment">// 初始化列表方式</span><br>&#125;<br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">iterator</span>(<span class="hljs-type">const</span> iterator&amp; iter)<br>: _ptr(iter._ptr)<br>&#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 重载函数合集</span><br><span class="hljs-comment">// 1. 前置 ++</span><br>iterator&amp; <span class="hljs-keyword">operator</span>++()<br>&#123;<br>_ptr++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 2. 后置 ++</span><br>iterator <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-function">iterator <span class="hljs-title">tmp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>_ptr++;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-comment">// 3. 解引用</span><br>T&amp; <span class="hljs-keyword">operator</span>*()<br>&#123;<br><span class="hljs-keyword">return</span> *_ptr;<br>&#125;<br><span class="hljs-comment">// 4. !=</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> iterator&amp; iter) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> _ptr != iter._ptr;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>T* _ptr;<br>&#125;;<br><span class="hljs-comment">//迭代器方法</span><br><span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(First); &#125;<br><span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">iterator</span>(Last); &#125;<br><br><br><span class="hljs-comment">// 私有属性和方法</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 指向数组起始的位置</span><br>T* First;<br><span class="hljs-comment">// 指向数组中有效元素的后继位置</span><br>T* Last;<br><span class="hljs-comment">// 指向数组空间的后继位置</span><br>T* End;<br><span class="hljs-comment">// 定义容器的空间配置器对象</span><br>Alloc _allocator;<br><br><span class="hljs-comment">// 扩容方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获取大小</span><br><span class="hljs-type">int</span> size = End - First;<br><span class="hljs-comment">// 配置 2 倍适配器空间</span><br>T* ptmp = _allocator.<span class="hljs-built_in">allocate</span>(size * <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 赋值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>&#123;<br>_allocator.<span class="hljs-built_in">construct</span>(ptmp + i, First[i]);<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>T* p = First;<br><span class="hljs-keyword">for</span> (p = First; p != End; p++)<br>&#123;<br><span class="hljs-comment">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>_allocator.<span class="hljs-built_in">destroy</span>(p);<br>&#125;<br><span class="hljs-comment">// 释放堆上的数组内存</span><br>_allocator.<span class="hljs-built_in">deallocate</span>(First);<br><br><span class="hljs-comment">// 重新赋值</span><br>First = ptmp;<br>Last = First + size;<br>End = First + size * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; t)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Test</span>() <br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>&#125;<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;)<br>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Test t1, t2;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>vector&lt;Test&gt; vec;<br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>vec.<span class="hljs-built_in">push_back</span>(t1);<br>vec.<span class="hljs-built_in">push_back</span>(t2);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>vec.<span class="hljs-built_in">pop_back</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;end&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-------------------------------&quot;</span> &lt;&lt; endl;<br>vector&lt;Test&gt;::iterator it = vec.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != vec.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;it = &quot;</span> &lt;&lt; &amp;(*it) &lt;&lt; endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;iterator&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03.C++ 面向对象</title>
    <link href="/2023/08/04/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/04/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>本节分为 7 大类：</p><ol><li>类和对象、this 指针</li><li>构造函数和析构函数</li><li>深拷贝和浅拷贝</li><li>类和对象代码应用实践</li><li>构造函数的初始化列表</li><li>类的各种成员方法及区别</li><li>指向类成员的指针</li></ol><h2 id="1-类和对象、this-指针"><a href="#1-类和对象、this-指针" class="headerlink" title="1. 类和对象、this 指针"></a>1. 类和对象、this 指针</h2><p>C 语言是<strong>面向过程</strong>的，关注的是过程。分析出求解问题的步骤，通过函数调用<strong>逐步</strong>解决问题。</p><p>C++ 是基于<strong>面向对象</strong>的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的<strong>交互</strong>完成。</p><h3 id="1-类的引入"><a href="#1-类的引入" class="headerlink" title="1. 类的引入"></a>1. 类的引入</h3><p>C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetStudentInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* gender, <span class="hljs-type">int</span> age)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">strcpy</span>(_name, name);<br><span class="hljs-built_in">strcpy</span>(_gender, gender);<br>_age = age;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStudentInfo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; _name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;gender = &quot;</span> &lt;&lt; _gender &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;age = &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> _name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> _gender[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student s;<br>s.<span class="hljs-built_in">SetStudentInfo</span>(<span class="hljs-string">&quot;Peter&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">18</span>);<br>s.<span class="hljs-built_in">PrintStudentInfo</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png" alt="image.png"></p><p>上面结构体的定义，在 C++ 中更喜欢用<code>class</code>来代替。</p><h3 id="2-类的定义"><a href="#2-类的定义" class="headerlink" title="2. 类的定义"></a>2. 类的定义</h3><p>语法结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">className</span> &#123;<br> <span class="hljs-comment">// 类体：由成员函数和成员变量组成</span><br><br>&#125;; <span class="hljs-comment">// 要注意后面的分号</span><br></code></pre></td></tr></table></figure><ul><li><code>class</code>为定义类的关键字</li><li><code>ClassName</code>为类的名字</li><li><code>&#123;&#125;</code>中为类的主体</li><li>注意类定义结束时后面分号。</li></ul><p>类中的元素称为<strong>类的成员</strong>，类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>。 类中的函数称为<strong>类的方法</strong>或者<strong>成员函数</strong>。</p><p>类的两种定义方式：</p><ol><li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</li><li>声明放在.h文件中，类的定义放在<code>cpp</code>文件中。推荐使用！</li></ol><h3 id="3-类的访问限定符及封装"><a href="#3-类的访问限定符及封装" class="headerlink" title="3. 类的访问限定符及封装"></a>3. 类的访问限定符及封装</h3><ol><li><strong>访问限定符：</strong></li></ol><p><code>C++</code>实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。</p><p>访问限定符说明：</p><ol><li><code>public</code> 修饰的成员在类外可以直接被访问</li><li><code>protected</code> 和 <code>private</code> 修饰的成员在类外不能直接被访问(此处 <code>protected</code> 和 <code>private</code> 是类似的)</li><li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li><li><code>class</code> 的默认访问权限为 <code>private</code>，<code>struct</code> 为 <code>public</code> (因为 <code>struct</code> 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</li></ol><blockquote><ul><li>问：C++ 中 <code>struct</code> 和 <code>class</code> 的区别是什么？</li><li>答：C++ 需要兼容 C 语言，所以 C++ 中 <code>struct</code> 可以当成结构体去使用。另外 C++ 中 <code>struct</code> 还可以用来定义类。 和 <code>class</code> 是定义类是一样的，区别是 <code>struct</code> 的成员默认访问方式是 <code>public</code>，<code>class</code> 的成员默认访问方式是 <code>private</code>。</li></ul></blockquote><ol start="2"><li><strong>封装</strong></li></ol><p>面向对象的三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p><p>在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。</p><blockquote><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p></blockquote><p>封装本质上是一种管理：</p><p>使用类数据和方法都封装到一下。 不想给别人看到的，使用 <code>protected</code> &#x2F; <code>private</code> 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p><h3 id="4-类的作用域"><a href="#4-类的作用域" class="headerlink" title="4. 类的作用域"></a>4. 类的作用域</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用<code>::</code>作用域解析符指明成员属于哪个类域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPersonInfo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> _name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> _gender[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> _age;<br>&#125;;<br><br><span class="hljs-comment">// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Person::PrintPersonInfo</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;_name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;_gender&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-类的实例化"><a href="#5-类的实例化" class="headerlink" title="5. 类的实例化"></a>5. 类的实例化</h3><p><strong>用类类型创建对象的过程</strong>，称为类的实例化。</p><ol><li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。</li><li>一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。</li><li>做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li></ol><h3 id="6-类对象模型"><a href="#6-类对象模型" class="headerlink" title="6. 类对象模型"></a>6. 类对象模型</h3><p><strong>如何计算类对象的大小</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; _a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span> _a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _a;<br>&#125;;<br><br><span class="hljs-comment">// 类中仅有成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 类中什么都没有---空类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A3</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">sizeof</span>(A1) :<span class="hljs-number">4</span><br><span class="hljs-built_in">sizeof</span>(A2) :<span class="hljs-number">1</span><br><span class="hljs-built_in">sizeof</span>(A3) :<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结论：</p><p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 <strong>一个字节</strong> 来唯一标识这个类。</p><h3 id="7-this-指针"><a href="#7-this-指针" class="headerlink" title="7. this 指针"></a>7. this 指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Display</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetDate</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)</span> </span>&#123;<br>_year = year;<br>_month = month;<br>_day = day;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _year; <span class="hljs-comment">// 年</span><br><span class="hljs-type">int</span> _month; <span class="hljs-comment">// 月</span><br><span class="hljs-type">int</span> _day; <span class="hljs-comment">// 日</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Date d1, d2;<br><br>d1.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>d2.<span class="hljs-built_in">SetDate</span>(<span class="hljs-number">2018</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>);<br><br>d1.<span class="hljs-built_in">Display</span>();<br>d2.<span class="hljs-built_in">Display</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述类，有这样的一个问题： <code>Date</code> 类中有 <code>SetDate</code> 与 <code>Display</code> 两个成员函数，函数体中没有关于不同对象的区分，那当 <code>s1</code> 调用 <code>SetDate</code> 函数时，该函数是如何知道应该设置 <code>s1</code> 对象，而不是设置 <code>s2</code> 对象呢？</p><p>C++ 中通过引入 <code>this</code> 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p><h3 id="8-this-指针特性"><a href="#8-this-指针特性" class="headerlink" title="8. this 指针特性"></a>8. this 指针特性</h3><ul><li><code>this</code>指针的类型：<code>类类型* const</code>。</li><li>只能在“成员函数”的内部使用。</li><li><code>this</code>指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给<code>this</code>形参。所以对象中不存储<code>this</code>指针。</li><li><code>this</code>指针是成员函数第一个隐含的指针形参，一般情况由编译器通过<code>ecx</code>寄存器自动传递，不需要用户传递。</li></ul><h2 id="2-构造函数和析构函数"><a href="#2-构造函数和析构函数" class="headerlink" title="2. 构造函数和析构函数"></a>2. 构造函数和析构函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h3><ul><li>因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。</li><li>C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。</li><li>构造函数没有返回值，名字与类名相同。</li></ul><p><strong>注意事项：</strong></p><ol><li>类的构造函数支持函数重载。</li><li>类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。</li><li>类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。</li><li>使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。</li><li>构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 <code>int a = 10;</code> 这是初始化 )，赋值是数据成员定义之后进行的( 像 <code>int b; b = 12;</code> 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> nn, <span class="hljs-type">double</span> dd, <span class="hljs-type">char</span> cc) <br>        : <span class="hljs-built_in">d</span>(dd), <span class="hljs-built_in">n</span>(nn), <span class="hljs-built_in">c</span>(cc) <br>    &#123;<br>        n = <span class="hljs-number">10</span>;<br>        d = <span class="hljs-number">3.4</span>;<br>        c = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> d;<br>    <span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2.1</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;<br>test.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// 运行结果：10 3.4 b</span><br><span class="hljs-comment">// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果</span><br></code></pre></td></tr></table></figure><ol start="6"><li>初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致</li><li>类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>&amp; nn, <span class="hljs-type">const</span> <span class="hljs-type">double</span> dd) <br>        : <span class="hljs-built_in">d</span>(dd), <span class="hljs-built_in">n</span>(nn)<br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>&amp; n;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> d;<br>&#125;;<br><br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(n, <span class="hljs-number">3.5</span>)</span></span>;<br>test.<span class="hljs-built_in">show</span>();<br><span class="hljs-comment">// 运行结果：5 3.5</span><br></code></pre></td></tr></table></figure><h3 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2. 析构函数"></a>2. 析构函数</h3><ul><li>形式是构造函数名字前面加一个 “~”</li><li>析构函数只有一个没有重载</li><li>析构函数也没有形参</li><li>析构函数是在对象生命周期结束时自动调用的，它负责清理工作</li><li>与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用</li></ul><h2 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3. 深拷贝和浅拷贝"></a>3. 深拷贝和浅拷贝</h2><p>在了解拷贝前，我们需要先知道 <strong>拷贝构造函数</strong> 的本质</p><ul><li>拷贝构造本质上也是构造函数</li><li>参数是所在类的常引用的构造函数</li><li>类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ====== 浅拷贝示例代码 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> nn, <span class="hljs-type">double</span> dd) <br>        : <span class="hljs-built_in">n</span>(nn), <span class="hljs-built_in">d</span>(dd)<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <span class="hljs-comment">// 定义拷贝构造函数</span><br>        : <span class="hljs-built_in">n</span>(t.n), <span class="hljs-built_in">d</span>(t.d)<br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br><br><span class="hljs-comment">// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数</span><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>)</span></span>; <span class="hljs-comment">// 实例化一个对象</span><br><span class="hljs-function">Test <span class="hljs-title">test1</span><span class="hljs-params">(t)</span></span>;  <span class="hljs-comment">// 用对象t初始化另一个对象，调用拷贝构造函数</span><br>Test test2 = t; <span class="hljs-comment">// 通过重载的 &quot;=&quot; 初始化对象，调用拷贝构造函数</span><br>Test* test3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(t);  <span class="hljs-comment">// 调用拷贝构造函数初始化对象</span><br><span class="hljs-keyword">delete</span> test3;<br></code></pre></td></tr></table></figure><ul><li>浅拷贝方式对于一般的数据成员是”OK”的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是”OK”的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题</li><li>针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ====== 浅拷贝 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> n) <br>    : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(n))<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <br>        : <span class="hljs-built_in">p</span>(t.p)<br>    &#123; &#125;<br><br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(t)</span></span>;<br><span class="hljs-comment">// 程序运行出错，重复释放内存</span><br><br><span class="hljs-comment">// ====== 深拷贝 ======</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> n)<br>        : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(n))<br>    &#123; &#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; t) <br>        : <span class="hljs-built_in">p</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*t.p))<br>    &#123; &#125;<br><br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        <span class="hljs-keyword">delete</span> p;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* p;<br>&#125;;<br><br><span class="hljs-function">Test <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Test <span class="hljs-title">test</span><span class="hljs-params">(t)</span></span>;<br><span class="hljs-comment">// 程序正常运行</span><br></code></pre></td></tr></table></figure><h3 id="1-浅拷贝和深拷贝原理"><a href="#1-浅拷贝和深拷贝原理" class="headerlink" title="1. 浅拷贝和深拷贝原理"></a>1. 浅拷贝和深拷贝原理</h3><p>拷贝就是 <strong>复制</strong>，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。</p><p>对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：</p><ul><li>第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。</li><li>第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。</li></ul><p>拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。</p><p><strong>总结</strong>：</p><ul><li><p><strong>浅拷贝</strong>：位拷贝，拷贝构造函数，赋值重载<br>  多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏</p></li><li><p><strong>深拷贝</strong>：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。</p></li></ul><p>简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><h3 id="2-浅拷贝和深拷贝实现"><a href="#2-浅拷贝和深拷贝实现" class="headerlink" title="2. 浅拷贝和深拷贝实现"></a>2. 浅拷贝和深拷贝实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// --- 浅拷贝实现 ---</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">Light</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br><span class="hljs-built_in">Light</span>(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B) : <span class="hljs-built_in">a</span>(A), <span class="hljs-built_in">b</span>(B) &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;b &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-function">Light <span class="hljs-title">obj1</span><span class="hljs-params">(a, b)</span></span>;<br>Light obj2 = obj1;<br><br>obj2.<span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png" alt="image.png"></p><p><strong>实现 String 类来了解 深拷贝：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// --- 深拷贝实现 ---</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-literal">nullptr</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; 默认构造函数:&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (str)<br>&#123;<br><span class="hljs-comment">// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，</span><br><span class="hljs-comment">// 直到碰到第一个字符串结束符&#x27;\0&#x27;为止，然后返回计数器值(长度不包含&#x27;\0&#x27;)</span><br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br><span class="hljs-comment">// strcpy把含有&#x27;\0&#x27;结束符的字符串复制到另一个地址空间</span><br><span class="hljs-built_in">strcpy</span>(data_, str);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">//new 数组类型 与delete []对应</span><br>*data_ = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造函数</span><br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造：&quot;</span> &lt;&lt; endl;<br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.data_) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(data_, str.data_);<br>&#125;<br><br><span class="hljs-comment">// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左</span><br>    <span class="hljs-comment">// 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败</span><br>String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;赋值重载：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;str)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-keyword">delete</span>[] data_;<br><br>data_ = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.data_) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(data_, str.data_);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br><span class="hljs-comment">// 释放内存</span><br>~<span class="hljs-built_in">String</span>() &#123;<br><span class="hljs-keyword">delete</span>[] data_;<br>data_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* data_ = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>String s1;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;123&quot;</span>)</span></span>;<span class="hljs-comment">//默认构造函数</span><br>String s3 = s2;<span class="hljs-comment">//拷贝构造函数</span><br>String s4 = <span class="hljs-string">&quot;hello&quot;</span>;<span class="hljs-comment">//默认构造函数</span><br><span class="hljs-function">String <span class="hljs-title">s5</span><span class="hljs-params">(s4)</span></span>;<span class="hljs-comment">//拷贝构造函数   是构造过程发生</span><br>String s6;<br>s6 = s5;<span class="hljs-comment">//=重载  是赋值，左右两边的对象都已经存在</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类和对象代码应用实践"><a href="#4-类和对象代码应用实践" class="headerlink" title="4. 类和对象代码应用实践"></a>4. 类和对象代码应用实践</h2><p><strong>实现：循环队列</strong></p><p>当队列空时，条件就是 <code>front = rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png" alt="image.png"></p><p>由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 <code>(rear+1) %QueueSize == front</code> (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。</p><p>比如：QueueSize &#x3D; 5，当 front&#x3D;0，而 rear&#x3D;4, (4+1) %5 &#x3D; 0，所以此时队列满。再比如，front &#x3D; 2而rear &#x3D;1。(1 + 1) %5 &#x3D; 2，所以此时 队列也是满的。而对于下图, front &#x3D; 2而rear&#x3D; 0, (0+1) %5 &#x3D; 1，1!&#x3D;2,所以此时队列并没有满。</p><p>另外，当 <code>rear &gt; front</code> 时，此时队列的长度为 <code>rear—front</code>。但当rear &lt; front时，队列长度分为两段，一段是 <code>QueueSize-front</code>，另一段是0 + rear，加在一起，队列长度为 <code>rear-front + QueueSize</code></p><p>因此通用的计算队列长度公式为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">(rear — front + QueueSize) % QueueSize<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>队空条件：front &#x3D;&#x3D; rear</li><li>队满条件：(rear+1) %QueueSize &#x3D;&#x3D; front</li><li>队列长度：(rear—front + QueueSize) % QueueSize</li></ul><p><strong>实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 初始化构造</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">int</span> size = <span class="hljs-number">20</span>) &#123;<br><span class="hljs-comment">// 创建队列</span><br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><span class="hljs-comment">// 初始化值</span><br>front_ = <span class="hljs-number">0</span>;<br>rear_ = <span class="hljs-number">0</span>;<br>size_ = size;<br>&#125;<br><br><span class="hljs-comment">// 拷贝构造</span><br><span class="hljs-built_in">Queue</span>(<span class="hljs-type">const</span> Queue* queue) &#123;<br><span class="hljs-comment">// 传值</span><br>size_ = queue-&gt;size_;<br>front_ = queue-&gt;front_;<br>rear_ = queue-&gt;rear_;<br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>queue_[i] = queue_[i];<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 复制重构</span><br>Queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Queue&amp; q) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;q)<br>&#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">delete</span> queue_;<br><span class="hljs-comment">// 重新赋值</span><br>size_ = q.size_;<br>front_ = q.front_;<br>rear_ = q.rear_;<br>queue_ = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_];<br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>queue_[i] = q.queue_[i];<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 析构函数</span><br>~<span class="hljs-built_in">Queue</span>() &#123;<br><span class="hljs-keyword">delete</span>[] queue_;<br>queue_ = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 队列方法：</span><br><span class="hljs-comment">// 1. push：放入元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br>&#123;<br><span class="hljs-built_in">resize</span>();<br>&#125;<br><br><span class="hljs-comment">// 从队尾放置</span><br>queue_[rear_] = val;<br><span class="hljs-comment">// 计算下一个位置</span><br>rear_ = (rear_ + <span class="hljs-number">1</span>) % size_;<br>&#125;<br><br><span class="hljs-comment">// 2. 出队方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>front_ = (front_ + <span class="hljs-number">1</span>) % size_;<br>&#125;<br><br><span class="hljs-comment">// 4. 获取对头</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> queue_[front_];<br>&#125;<br><br><span class="hljs-comment">// 3. 判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> rear_ == front_;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 私密方法：</span><br><span class="hljs-comment">// 1. 扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 扩容 2 倍</span><br><span class="hljs-type">int</span>* tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size_ * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 拷贝值</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = front_; i != rear_; i = (i + <span class="hljs-number">1</span>) % size_)<br>&#123;<br>tmp[index] = queue_[i];<br>index++;<br>&#125;<br><br><span class="hljs-comment">// 清除原先数值</span><br><span class="hljs-keyword">delete</span> queue_;<br><span class="hljs-comment">// 重新赋值</span><br>queue_ = tmp;<br>front_ = <span class="hljs-number">0</span>;<br>rear_ = index++;<br>size_ *= <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (rear_ + <span class="hljs-number">1</span>) % size_ == front_;<br>&#125;<br><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 队列</span><br><span class="hljs-type">int</span>* queue_;<br><span class="hljs-comment">// 对头</span><br><span class="hljs-type">int</span> front_;<br><span class="hljs-comment">// 队尾</span><br><span class="hljs-type">int</span> rear_;<br><span class="hljs-comment">// 队列扩列大小</span><br><span class="hljs-type">int</span> size_;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建对象</span><br>Queue q1;<br>Queue q2;<br><br><span class="hljs-comment">// 放入元素</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>q1.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">20</span>; i &lt; <span class="hljs-number">40</span>; i++)<br>&#123;<br>q2.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br>q1 = q2;<br><br><br><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">while</span> (!q1.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; q1.<span class="hljs-built_in">top</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>q1.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-构造函数的初始化列表"><a href="#5-构造函数的初始化列表" class="headerlink" title="5. 构造函数的初始化列表"></a>5. 构造函数的初始化列表</h2><p>构造函数初始化列表的情况有三种：</p><ol><li>需要初始化的类的成员变量是对象的情况；</li><li>需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；</li><li>子类初始化父类的成员；</li></ol><p><strong>情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数</strong></p><p>如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">int</span> z;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyTest</span>() : <span class="hljs-built_in">test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &#123;       <span class="hljs-comment">// 初始化值</span><br>cout &lt;&lt; <span class="hljs-string">&quot;MyTest&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Test test;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyTest t1;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。</p><p><strong>情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() :<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>) &#123;&#125;           <span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a;             <span class="hljs-comment">//const成员声明</span><br>&#125;;<br><br><span class="hljs-comment">// 或</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> _a) :<span class="hljs-built_in">a</span>(_a) &#123;&#125;      <span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>&amp; a;                 <span class="hljs-comment">//声明</span><br>&#125;<br></code></pre></td></tr></table></figure><p>**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Test</span> (<span class="hljs-type">int</span> x)&#123; int_x = x;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> int_x;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<span class="hljs-keyword">public</span> Test<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Mytest</span>() ：<span class="hljs-built_in">Test</span>(<span class="hljs-number">110</span>) <span class="hljs-comment">//调用父类的构造函数</span><br>    &#123;<br>      <span class="hljs-comment">//Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用</span><br>    &#125;;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Test *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Mytest</span>();<br> p-&gt;<span class="hljs-built_in">show</span>();<br> <br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行顺序：</p><p>在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。</p><h2 id="6-类的各种成员方法及区别"><a href="#6-类的各种成员方法及区别" class="headerlink" title="6. 类的各种成员方法及区别"></a>6. 类的各种成员方法及区别</h2><p>C++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)<br>: <span class="hljs-built_in">year_</span>(year)<br>, <span class="hljs-built_in">month_</span>(month)<br>, <span class="hljs-built_in">day_</span>(day)<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;year：&quot;</span> &lt;&lt; year_ &lt;&lt; <span class="hljs-string">&quot; month：&quot;</span> &lt;&lt; month_ &lt;&lt; <span class="hljs-string">&quot; day：&quot;</span> &lt;&lt; day_ &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> year_;<br><span class="hljs-type">int</span> month_;<br><span class="hljs-type">int</span> day_;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">继承：a kind of，一种</span><br><span class="hljs-comment">组合：a part of，一部分</span><br><span class="hljs-comment">商品日期更像是商品的一部分，应该用组合的方式</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Goods</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Goods</span>(<span class="hljs-type">int</span> id, string name, <span class="hljs-type">int</span> price, <span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day)<br>: <span class="hljs-built_in">date_</span>(year, month, day)<br>, <span class="hljs-built_in">id_</span>(id)<br>, <span class="hljs-built_in">name_</span>(name)<br>, <span class="hljs-built_in">price_</span>(price)<br>&#123;<br>count_++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>date_.<span class="hljs-built_in">show</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;id：&quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; name：&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot; price：&quot;</span> &lt;&lt; price_ &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span><span class="hljs-comment">//静态成员函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> count_;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>Date date_;<br><span class="hljs-type">int</span> id_;<br>string name_;<br><span class="hljs-type">int</span> price_;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count_;<span class="hljs-comment">//静态成员变量的声明</span><br>&#125;;<br><br><span class="hljs-type">int</span> Goods::count_ = <span class="hljs-number">0</span>;<span class="hljs-comment">//静态成员变量的初始化</span><br></code></pre></td></tr></table></figure><h3 id="1-静态成员变量"><a href="#1-静态成员变量" class="headerlink" title="1. 静态成员变量"></a>1. 静态成员变量</h3><p>静态成员变量在类内声明，在类外定义初始化<br>静态成员变量可以用类引用，也可以通过对象引用</p><h3 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2.静态成员函数"></a>2.静态成员函数</h3><p>静态成员函数不能使用普通成员变量，能使用静态成员变量<br>静态成员函数可以通过类调用，也可以通过对象调用</p><h3 id="3-const-成员函数"><a href="#3-const-成员函数" class="headerlink" title="3. const 成员函数"></a>3. const 成员函数</h3><p>一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。<br>const 成员函数既能够被普通对象调用，也能被 const 对象调用</p><h2 id="7-指向类成员的指针"><a href="#7-指向类成员的指针" class="headerlink" title="7. 指向类成员的指针"></a>7. 指向类成员的指针</h2><p>成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。</p><h3 id="1-成员函数指针"><a href="#1-成员函数指针" class="headerlink" title="1. 成员函数指针"></a>1. 成员函数指针</h3><p>在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">成员函数返回类型 （类名::*指针名）（形参）= &amp;类名::成员函数名<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(string s) &#123;<br>name = s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string name;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;lisa&quot;</span>)</span></span>;<br><span class="hljs-comment">// 定义类长远函数指针并赋初始值</span><br><span class="hljs-built_in">void</span>(A::*memp)() = &amp;A::print;<br>(a.*memp)();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png" alt="image.png"></p><p>使用成员函数指着注意两点：</p><p>（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；<br>（2）为成员函数指针赋值时，需要显示使用 <code>&amp;</code> 运算符，不能直接将 “类名 <code>::</code> 成员函数名”赋给成员函数指针。</p><h3 id="2-数据成员指针"><a href="#2-数据成员指针" class="headerlink" title="2. 数据成员指针"></a>2. 数据成员指针</h3><p>一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：</p><ul><li>对象的首地址和该成员变量在对象之内的偏移量。</li><li>数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。</li></ul><p>数据成员指针的定义格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">成员类型 类名::*指针名=&amp;类名::成员名;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">average</span><span class="hljs-params">(Student* objs, <span class="hljs-type">int</span> Student::*pm, <span class="hljs-type">int</span> count)</span> </span>&#123;<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>&#123;<br>result += objs[i].*pm;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(result) / count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Student my[<span class="hljs-number">3</span>] = &#123; &#123;<span class="hljs-number">16</span>, <span class="hljs-number">86</span>&#125;, &#123;<span class="hljs-number">17</span>, <span class="hljs-number">80</span>&#125;, &#123;<span class="hljs-number">18</span>, <span class="hljs-number">58</span>&#125; &#125;;<br><br><span class="hljs-type">double</span> ageAver = <span class="hljs-built_in">average</span>(my, &amp;Student::age, <span class="hljs-number">3</span>);<br><span class="hljs-type">double</span> scoreAver = <span class="hljs-built_in">average</span>(my, &amp;Student::score, <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ageAver = &quot;</span> &lt;&lt; ageAver &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;scoreAver = &quot;</span> &lt;&lt; scoreAver &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png" alt="image.png"></p><p>使用数据成员指针时，需要注意以下几点：</p><p>（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。<br>（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 <code>average()</code> 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的<code>obj.*pm</code> 等同于 <code>*(int*)((char*)(&amp;obj)+pm)</code>，显然，这样书写可读性差，可移植性低且容易出错。<br>（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayClass</span>  &#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ArrayClass</span>()  &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>arr[i]=i;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用数据成员指针作为形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(ArrayClass&amp; arrObj,<span class="hljs-type">int</span> (ArrayClass::* pm)[<span class="hljs-number">5</span>])</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i) &#123;<br>cout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ArrayClass arrObj;<br><span class="hljs-built_in">printArray</span>(arrObj,&amp;ArrayClass::arr);<span class="hljs-comment">//编译出错，提示成员ArrayClass::arr不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。</p><p>要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayClass</span> &#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ArrayClass</span>() &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>arr[i]=i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ArrayClass&amp; arrObj)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用数据成员指针作为形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(ArrayClass&amp; arrObj,<span class="hljs-type">int</span> (ArrayClass::* pm)[<span class="hljs-number">5</span>])</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)<br>cout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ArrayClass&amp; arrObj)</span> </span>&#123;<br><span class="hljs-built_in">printArray</span>(arrObj,&amp;ArrayClass::arr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ArrayClass arrObj;<br><span class="hljs-comment">//printArray(arrObj,&amp;ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问</span><br><span class="hljs-built_in">print</span>(arrObj); <span class="hljs-comment">//通过友元函数调用打印数组函数printArray()来访问私有成员</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00-1.C++ 基本语法</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00-1.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00-1.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><ol><li>C++ 初识</li><li>数据类型</li><li>运算符</li><li>程序流程结构</li><li>数组</li><li>函数</li><li>指针</li><li>结构体</li></ol></blockquote><h2 id="C-初识"><a href="#C-初识" class="headerlink" title="C++ 初识"></a>C++ 初识</h2><h3 id="第一个-C-程序"><a href="#第一个-C-程序" class="headerlink" title="第一个 C++ 程序"></a>第一个 C++ 程序</h3><p>C++ 程序的编写步骤：</p><ol><li><p>创建项目</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011013158.png" alt="image-20221108081122067"></p></li><li><p>创建文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011013173.png" alt="image-20221108081225865"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011013856.png" alt="image-20221108081243617"></p></li><li><p>编写代码</p></li><li><p>运行程序</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在整个程序中，必须只有一个 <code>main</code> 函数入口</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><strong>作用</strong>：在代码中加入一些说明和解释，方面或其他开发人员阅读和后期维护</p><p><strong>两种格式：</strong></p><ol><li><p><strong>单行注释：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 描述信息</span><br></code></pre></td></tr></table></figure><p>通常放在一行代码的上方，或者语句的末尾；</p><p><strong>对该行代码的说明或解释。</strong></p></li><li><p><strong>多行注释：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 详细信息 */</span><br></code></pre></td></tr></table></figure><p>通常放在一行代码的上方</p><p><strong>对该段代码整体做说明</strong></p></li></ol><blockquote><p>编译器在编译代码时，会将注释进行忽略。</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存中的数据。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 数据类型 变量名 = 初始值;</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><strong>Example</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// 定义变量</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014628.png" alt="image-20221108082900620"></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>作用：</strong> 用于记录程序中一些不可更改数据</p><p>C++ 中定义常量有两种方法：</p><ol><li><p><code>#define</code> 宏常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// #define 常量名 常量值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COUNT 10</span><br></code></pre></td></tr></table></figure><p>通常在文件的顶部定义，表示一个常量；并且所有的字符以大写区分</p></li><li><p><code>const</code> 修饰的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// const 数据类型 常量名 = 常量值;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>通常在变量定义前添加关键字 <code>const</code> ，将变量修饰为常量，不可修改。</p></li></ol><p><strong>Example：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-comment">// 定义宏常量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 10</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// 宏常量</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;宏常量：NUM = &quot;</span> &lt;&lt; NUM &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">// const 常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;const n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>作用：</strong> 关键字是 C++ 中预先保留的单词（标识符）</p><p>在定义变量或者常量时，不需要使用关键字</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014806.jpg" alt="img"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014022.jpg" alt="img"></p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><p><strong>作用</strong>： C++ 规定给标识符（变量、常量）命名时的规则：</p><ul><li>标识符不能是关键字</li><li>标识符只能是字符、数字、下划线</li><li>第一个字符必须为字符或下划线</li><li>标识符中字符区分大小写</li></ul><blockquote><p>建议：</p><p>给标识符命名时，采用英文单词并描述该变量在整个程序的意义。</p></blockquote><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++ 中规定了在创建变量和常量时，必须指定出对应的数据类型，否则无法分配内存。</p><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><p><strong>作用</strong>： 整形变量标识的是 <strong>整数类型</strong> 的数据</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short 短整型</td><td>2 字节</td><td>-2^15 ~ 2^15-1</td></tr><tr><td>int 整形</td><td>4 字节</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>long 长整型</td><td>windows 4 字节；linux(32位) 4 字节，Linux(64位) 8 字节</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>long long 长长整形</td><td>8 字节</td><td>-2^63 ~ 2^63-1</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">// int 整形</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// short 短整型</span><br><span class="hljs-type">short</span> b = <span class="hljs-number">10.0</span>;<br><span class="hljs-comment">// long 长整型</span><br><span class="hljs-type">long</span> l = <span class="hljs-number">10000000</span>;<br><span class="hljs-comment">// long long 长长整形</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ll = <span class="hljs-number">12312312312321</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sizeof-关键字"><a href="#sizeof-关键字" class="headerlink" title="sizeof 关键字"></a><code>sizeof</code> 关键字</h3><p><strong>作用：</strong>利用 <code>sizeof</code> 关键字可以 <code>统计数据类型所占内存大小</code></p><p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014891.png" alt="image-20221116092409251"></p><h3 id="实型（浮点型）"><a href="#实型（浮点型）" class="headerlink" title="实型（浮点型）"></a>实型（浮点型）</h3><p><strong>作用</strong>：用于 <code>表示小数</code></p><p>浮点型变量分为两种：</p><ol><li>单精度float </li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 创建命名空间</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">float</span> fl = <span class="hljs-number">3.14f</span>;<br><span class="hljs-type">double</span> dl = <span class="hljs-number">3.14</span>;<br><br>cout &lt;&lt; fl &lt;&lt; endl;<br>cout &lt;&lt; dl &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(fl) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(dl) &lt;&lt; endl;<br><br><span class="hljs-comment">// 科学计数法</span><br><span class="hljs-type">float</span> f2 = <span class="hljs-number">3e2</span>; <span class="hljs-comment">// 3 * 10 ^ 2 </span><br>cout &lt;&lt; <span class="hljs-string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;<br><br><span class="hljs-type">float</span> f3 = <span class="hljs-number">3e-2</span>;  <span class="hljs-comment">// 3 * 0.1 ^ 2</span><br>cout &lt;&lt; <span class="hljs-string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014290.png" alt="image-20221116093650784"></p><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p><strong>作用：</strong>字符型变量用于显示单个字符</p><p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p><blockquote><p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p></blockquote><blockquote><p>注意2：单引号内只能有一个字符，不可以是字符串</p></blockquote><ul><li>C 和 C++ 中字符型变量只占用 <code>1个字节</code>。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的 ASCII 编码放入到存储单元</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>;<br>cout &lt;&lt; ch &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizof(char) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl;<br><br><span class="hljs-comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span><br><span class="hljs-comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span><br><br><span class="hljs-comment">// 强制类型转换</span><br>cout &lt;&lt; (<span class="hljs-type">int</span>)ch &lt;&lt; endl;  <span class="hljs-comment">//查看字符a对应的ASCII码</span><br>ch = <span class="hljs-number">97</span>; <span class="hljs-comment">//可以直接用ASCII给字符型变量赋值</span><br>cout &lt;&lt; ch &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014256.png" alt="image-20221116094646602"></p><p>ASCII码表格：</p><table><thead><tr><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr><td>2</td><td>STX</td><td>34</td><td>“</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr><td>15</td><td>SI</td><td>47</td><td>&#x2F;</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>&#x2F;</td><td>124</td><td>|</td></tr><tr><td>29</td><td>GS</td><td>61</td><td>&#x3D;</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>&#96;</td></tr><tr><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><p>ASCII 码大致由以下<strong>两部分组</strong>成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong> 分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong> 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p><strong>作用：</strong>用于表示一些 <code>不能显示出来的ASCII字符</code></p><p>现阶段我们常用的转义字符有：<code> \n  \\  \t</code></p><table><thead><tr><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td><strong>\n</strong></td><td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td><td><strong>010</strong></td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td><strong>\t</strong></td><td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td><td><strong>009</strong></td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td><strong>\\</strong></td><td><strong>代表一个反斜线字符”&quot;</strong></td><td><strong>092</strong></td></tr><tr><td>&#39;</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>&quot;</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td><td>3位16进制</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;\\&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;\tHello&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p><strong>作用</strong>：用于表示一串字符</p><p><strong>两种风格</strong></p><ol><li><p><strong>C 风格字符串</strong>： &#96;char 变量名[] &#x3D; “字符串值”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;str1[] = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011014070.png" alt="image-20221116101039996"></p><blockquote><p>注意：C 风格的字符串要用双引号括起来</p></blockquote></li><li><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015510.png" alt="image-20221116101609641"></p></li></ol><h3 id="布尔型-Boolean"><a href="#布尔型-Boolean" class="headerlink" title="布尔型 Boolean"></a>布尔型 Boolean</h3><p><strong>作用：</strong>布尔数据类型代表真或假的值 </p><p>bool类型只有两个值：</p><ul><li>true  — 真（本质是1）</li><li>false — 假（本质是0）</li></ul><p><strong>bool类型占<code>1个字节</code>大小</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; flag &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>flag = <span class="hljs-literal">false</span>;<br>cout &lt;&lt; flag &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) &lt;&lt; endl; <span class="hljs-comment">//1</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p><p><strong>关键字：</strong>cin</p><p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-comment">//整型输入</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; a;<br>cout &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">//浮点型输入</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; d;<br>cout &lt;&lt; d &lt;&lt; endl;<br><br><span class="hljs-comment">//字符型输入</span><br><span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; ch;<br>cout &lt;&lt; ch &lt;&lt; endl;<br><br><span class="hljs-comment">//字符串型输入</span><br>string str;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; str;<br>cout &lt;&lt; str &lt;&lt; endl;<br><br><span class="hljs-comment">//布尔类型输入</span><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; flag;<br>cout &lt;&lt; flag &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015799.png" alt="image-20221117091853561"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>作用：</strong>用于执行代码的运算</p><p>本章我们主要讲解以下几类运算符：</p><table><thead><tr><th><strong>运算符类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>算术运算符</td><td>用于处理四则运算</td></tr><tr><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><strong>作用</strong>：用于处理四则运算 </p><p>算术运算符包括以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>&#x2F;</td><td>除</td><td>10 &#x2F; 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a&#x3D;2; b&#x3D;++a;</td><td>a&#x3D;3; b&#x3D;3;</td></tr><tr><td>++</td><td>后置递增</td><td>a&#x3D;2; b&#x3D;a++;</td><td>a&#x3D;3; b&#x3D;2;</td></tr><tr><td>–</td><td>前置递减</td><td>a&#x3D;2; b&#x3D;–a;</td><td>a&#x3D;1; b&#x3D;1;</td></tr><tr><td>–</td><td>后置递减</td><td>a&#x3D;2; b&#x3D;a–;</td><td>a&#x3D;1; b&#x3D;2;</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b1 = <span class="hljs-number">3</span>;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a1 + b1 = &quot;</span> &lt;&lt; a1 + b1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a1 - b1 = &quot;</span> &lt;&lt; a1 - b1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a1 * b1 = &quot;</span> &lt;&lt; a1 * b1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;a1 / b1 = &quot;</span> &lt;&lt; a1 / b1 &lt;&lt; <span class="hljs-built_in">endl</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015161.png" alt="image-20221117092408960"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b2 = <span class="hljs-number">20</span>;<br>cout &lt;&lt; a2 / b2 &lt;&lt; endl;<br><br><span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b3 = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span><br><br><br><span class="hljs-comment">//两个小数可以相除</span><br><span class="hljs-type">double</span> d1 = <span class="hljs-number">0.5</span>;<br><span class="hljs-type">double</span> d2 = <span class="hljs-number">0.25</span>;<br>cout &lt;&lt; d1 / d2 &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：在除法运算中，除数不能为0</p></blockquote><p><strong>取余 %</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b1 = <span class="hljs-number">4</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a1 \% b1 = &quot;</span> &lt;&lt; a1 % b1 &lt;&lt; endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015819.png" alt="image-20221117092652867"></p><blockquote><p>总结：只有整型变量可以进行取模运算</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//递增</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//后置递增</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>a++; <span class="hljs-comment">//等价于a = a + 1</span><br>cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 11</span><br><br><span class="hljs-comment">//前置递增</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>++b;<br>cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">// 11</span><br><br><span class="hljs-comment">//区别</span><br><span class="hljs-comment">//前置递增先对变量进行++，再计算表达式</span><br><span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b2 = ++a2 * <span class="hljs-number">10</span>;<br>cout &lt;&lt; b2 &lt;&lt; endl;<br><br><span class="hljs-comment">//后置递增先计算表达式，后对变量进行++</span><br><span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b3 = a3++ * <span class="hljs-number">10</span>;<br>cout &lt;&lt; b3 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p></blockquote><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><strong>作用：</strong>用于将表达式的值赋给变量</p><p>赋值运算符包括以下几个符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td><td>a&#x3D;2; b&#x3D;3;</td><td>a&#x3D;2; b&#x3D;3;</td></tr><tr><td>+&#x3D;</td><td>加等于</td><td>a&#x3D;0; a+&#x3D;2;</td><td>a&#x3D;2;</td></tr><tr><td>-&#x3D;</td><td>减等于</td><td>a&#x3D;5; a-&#x3D;3;</td><td>a&#x3D;2;</td></tr><tr><td>*&#x3D;</td><td>乘等于</td><td>a&#x3D;2; a*&#x3D;2;</td><td>a&#x3D;4;</td></tr><tr><td>&#x2F;&#x3D;</td><td>除等于</td><td>a&#x3D;4; a&#x2F;&#x3D;2;</td><td>a&#x3D;2;</td></tr><tr><td>%&#x3D;</td><td>模等于</td><td>a&#x3D;3; a%2;</td><td>a&#x3D;1;</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// =</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 将之前的值进行覆盖</span><br>a = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// +=</span><br>a = <span class="hljs-number">10</span>;<br>a += <span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// -=</span><br>a = <span class="hljs-number">10</span>;<br>a -= <span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// *=</span><br>a = <span class="hljs-number">10</span>;<br>a *= <span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// /=</span><br>a = <span class="hljs-number">10</span>;<br>a /= <span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-comment">// %=</span><br>a = <span class="hljs-number">10</span>;<br>a /= <span class="hljs-number">3</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015745.png" alt="image-20221117093437958"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p><p>比较运算符有以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>相等于</td><td>4 &#x3D;&#x3D; 3</td><td>0</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>4 !&#x3D; 3</td><td>1</td></tr><tr><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>4 &lt;&#x3D; 3</td><td>0</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>4 &gt;&#x3D; 1</td><td>1</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="hljs-comment">// 0 </span><br><br>cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="hljs-comment">// 0</span><br><br>cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015886.png" alt="image-20221117093903521"></p><blockquote><p>注意：C和C++ 语言的比较运算中， <code>“真”用数字“1”来表示， “假”用数字“0”来表示。</code></p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p><p>逻辑运算符有以下符号：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真；  如果a为真，则!a为假。</td></tr><tr><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr><td>||</td><td>或</td><td>a || b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 逻辑运算符  --- 非</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;!a = &quot;</span> &lt;&lt; !a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;!!a = &quot;</span> &lt;&lt; !!a &lt;&lt; endl;<br><br><span class="hljs-comment">// 逻辑运算符  --- 与</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a &amp;&amp; b = &quot;</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<br>b = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a &amp;&amp; b = &quot;</span> &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<br><br><span class="hljs-comment">// 逻辑运算符  --- 或</span><br>b = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a || b = &quot;</span> &lt;&lt; (a || b) &lt;&lt; endl;<br>b = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;a || b = &quot;</span> &lt;&lt; (a || b) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015450.png" alt="image-20221117094351669"></p><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：<code>顺序结构、选择结构、循环结构</code></p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p><strong>作用：</strong>执行满足条件的语句</p><p>if语句的三种形式</p><ul><li><p>单行格式if语句</p></li><li><p>多行格式if语句</p></li><li><p>多条件的if语句</p></li></ul><ol><li>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015903.png" alt="image-20221117095050576"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个数值：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;及格了！！！&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015285.png" alt="image-20221117095628640"></p><ol start="2"><li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015777.png" alt="image-20221117095555738"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个数值：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;及格了！！！&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不及格！！！&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011015952.png" alt="image-20221117095543855"></p><ol start="3"><li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016978.png" alt="image-20221117095701724"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入一个数值：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">90</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;优秀&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">80</span> &amp;&amp; score &lt; <span class="hljs-number">90</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;良&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span> &amp;&amp; score &lt; <span class="hljs-number">80</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;还行&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span> &amp;&amp; score &lt; <span class="hljs-number">70</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;及格&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;不及格&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><p>案例需求：</p><ul><li>提示用户输入一个高考考试分数，根据分数做如下判断</li><li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li><li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;<br><br>cin &gt;&gt; score;<br><br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">700</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">650</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三目运算符（三元运算）"><a href="#三目运算符（三元运算）" class="headerlink" title="三目运算符（三元运算）"></a>三目运算符（三元运算）</h4><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br><br>c = a &gt; b ? a : b;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-comment">// C++ 中三目运算符返回的是变量,可以继续赋值</span><br><br>(a &gt; b ? a : b) = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016189.png" alt="image-20221117100240266"></p><blockquote><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p></blockquote><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h4><p><strong>作用：</strong>执行多条件分支语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">switch</span>(表达式)<br>&#123;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>：执行语句;<br>        <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>：执行语句;<br>        <span class="hljs-keyword">break</span>;<br>...<br><span class="hljs-keyword">default</span>:执行语句;<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入电影评分(1~9)：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br><br><span class="hljs-keyword">switch</span> (score)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;经典&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;非常好&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;一般&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;烂片&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016069.png" alt="image-20221122093347680"></p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong><code> while(循环条件)&#123; 循环语句 &#125;</code></p><p><strong>解释：</strong><code>只要循环条件的结果为真，就执行循环语句</code></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016507.png" alt="image-20221122095105512"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>num++;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016148.png" alt="image-20221122095402026"></p><blockquote><p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p></blockquote><p><strong>while循环练习案例：</strong><code>猜数字</code></p><p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">54</span>;<br><span class="hljs-type">int</span> input = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请用户输入一个数值(1~100)：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; input;<br><span class="hljs-keyword">if</span> (input &gt; num)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜大了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input &lt; num)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜小了&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;猜对了&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong> <code>do&#123; 循环语句 &#125; while(循环条件);</code></p><p><strong>注意：</strong>与while的区别在于 <code>do...while会先执行一次循环语句</code>，再判断循环条件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016003.png" alt="image-20221122104401700"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>num++;<br>&#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016730.png" alt="image-20221122104515084"></p><blockquote><p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件</p></blockquote><p><strong>练习案例：水仙花数</strong></p><p><strong>案例描述：</strong>水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身</p><p>例如：1^3 + 5^3+ 3^3 &#x3D; 153</p><p>请利用do…while语句，求出所有3位数中的水仙花数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-comment">// 个位</span><br><span class="hljs-type">int</span> x = a % <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 十位</span><br><span class="hljs-type">int</span> y = a / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 百位</span><br><span class="hljs-type">int</span> z = a / <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// 判断</span><br><span class="hljs-keyword">if</span> ((z * z * z + y * y * y + x * x * x) == a)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;水仙花数：&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br>a++;<br><br>&#125; <span class="hljs-keyword">while</span> (a &lt; <span class="hljs-number">1000</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016849.png" alt="image-20221122105200907"></p><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code> for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>详解：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011016674.png" alt="1541673704101"></p><blockquote><p>注意：for循环中的表达式，要用分号进行分隔</p></blockquote><blockquote><p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p></blockquote><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p><strong>作用：</strong> 在循环体中再嵌套一层循环，解决一些实际问题</p><p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017038.png" alt="image-20221122110631643"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//外层循环执行1次，内层循环执行1轮</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习案例：</strong>乘法口诀表</p><p>案例描述：利用嵌套循环，实现九九乘法表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//外层循环执行1次，内层循环执行1轮</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>&#123;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; i * j &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h3><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><p><strong>作用:</strong> 用于跳出 <code>选择结构</code> 或者 <code>循环结构</code></p><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//1、在switch 语句中使用break</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;1、普通&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;2、中等&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;3、困难&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; num;<br><br><span class="hljs-keyword">switch</span> (num)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>cout &lt;&lt; <span class="hljs-string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//2、在循环语句中用break</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//跳出循环语句</span><br>&#125;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//在嵌套循环语句中使用break，退出内层循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (j == <span class="hljs-number">5</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p><strong>作用：</strong>在 <code>循环语句</code> 中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cout &lt;&lt; i &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：continue并没有使整个循环终止，而break会跳出循环</p></blockquote><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>语法：</strong> <code>goto 标记;</code></p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">goto</span> FLAG;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;2&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;3&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;4&quot;</span> &lt;&lt; endl;<br><br>FLAG:<br><br>cout &lt;&lt; <span class="hljs-string">&quot;5&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><p><strong>特点1：</strong>数组中的每个 <code>数据元素都是相同的数据类型</code></p><p><strong>特点2：</strong>数组是由 <code>连续的内存</code> 位置组成的</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一维数组定义的三种方式：</p><ol><li><code>数据类型  数组名[ 数组长度 ];</code></li><li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li><li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义方式：</span><br><span class="hljs-comment">// 方法一：</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 方法二：</span><br><span class="hljs-comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">// 方法三：</span><br><span class="hljs-type">int</span> arr3[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span> &#125;;<br><br><span class="hljs-comment">// 方法一赋值：</span><br>arr1[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;<br>arr1[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br>arr1[<span class="hljs-number">2</span>] = <span class="hljs-number">11</span>;<br>arr1[<span class="hljs-number">3</span>] = <span class="hljs-number">98</span>;<br><br><span class="hljs-comment">// 利用下标输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;arr1[0] = &quot;</span> &lt;&lt; arr1[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1[1] = &quot;</span> &lt;&lt; arr1[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr1[2] = &quot;</span> &lt;&lt; arr1[<span class="hljs-number">2</span>] &lt;&lt; endl;<br><br><span class="hljs-comment">// 方法二使用循环遍历输出</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] = &quot;</span> &lt;&lt; arr2[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">// 方法三同上</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p></blockquote><blockquote><p>总结2：数组中下标是从0开始索引</p></blockquote><h4 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h4><p>一维数组名称的<strong>用途</strong>：</p><ol><li>可以统计整个数组在内存中的长度</li><li>可以获取数组在内存中的首地址</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//数组名用途</span><br><span class="hljs-comment">//1、可以获取整个数组占用内存空间大小</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><br><span class="hljs-comment">//2、可以通过数组名获取到数组首地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)arr &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;arr[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><span class="hljs-comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017621.png" alt="image-20221123095138478"></p><blockquote><p>注意：数组名是常量，不可以赋值</p></blockquote><blockquote><p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p></blockquote><blockquote><p>总结2：对数组名进行 <code>sizeof</code>，可以获取整个数组占内存空间的大小</p></blockquote><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017972.png" alt="image-20221123095233014"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span> &#125;;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span> - i; i++)<br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - i - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>二维数组定义的四种方式：</p><ol><li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code> 数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li></ol><blockquote><p>建议：以上4种定义方式，利用 <code>第二种更加直观，提高代码的可读性</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//方式1  </span><br><span class="hljs-comment">//数组类型 数组名 [行数][列数]</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)<br>&#123;<br>cout &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//方式2 </span><br><span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">//方式3</span><br><span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span><br><span class="hljs-type">int</span> arr3[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><br><span class="hljs-comment">//方式4 </span><br><span class="hljs-comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span><br><span class="hljs-type">int</span> arr4[][<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span> &#125;;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p></blockquote><h4 id="数组名-1"><a href="#数组名-1" class="headerlink" title="数组名"></a>数组名</h4><ul><li>查看二维数组所占内存空间</li><li>获取二维数组首地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//二维数组数组名</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br>&#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br><br><span class="hljs-comment">//地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017101.png" alt="image-20221124100604875"></p><blockquote><p>总结1：二维数组名就是这个数组的首地址</p></blockquote><blockquote><p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>函数的定义一般主要有5个步骤：</p><p>1、返回值类型 </p><p>2、函数名</p><p>3、参数表列</p><p>4、函数体语句 </p><p>5、return 表达式</p><p><strong>语法：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">返回值类型 函数名 （参数列表）<br>&#123;<br>       函数体语句<br>       <span class="hljs-keyword">return</span>表达式<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> res = <span class="hljs-built_in">Sum</span>(a, b);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;res = &quot;</span> &lt;&lt; res &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> result = x + y;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017902.png" alt="image-20221125100222782"></p><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，<code>如果形参发生，并不会影响实参</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;交换前：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;<br><br><span class="hljs-type">int</span> temp = num1;<br>num1 = num2;<br>num2 = temp;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;交换后：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;<br><br><span class="hljs-comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-built_in">swap</span>(a, b);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 值传递时，形参是修饰不了实参的</p></blockquote><h3 id="常见样式"><a href="#常见样式" class="headerlink" title="常见样式"></a>常见样式</h3><p>常见的函数样式有4种：</p><ol><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//函数常见样式</span><br><span class="hljs-comment">//1、 无参无返</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;this is test01&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//test01(); 函数调用</span><br>&#125;<br><br><span class="hljs-comment">//2、 有参无返</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test02&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//3、无参有返</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test03 &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">//4、有参有返</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test04</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is test04 &quot;</span> &lt;&lt; endl;<br><span class="hljs-type">int</span> sum = a + b;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><ul><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明可以多次，定义只能一次</span><br><span class="hljs-comment">//声明</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-comment">//定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">max</span>(a, b) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数文件分类"><a href="#函数文件分类" class="headerlink" title="函数文件分类"></a>函数文件分类</h3><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol><li>创建后缀名为.h的头文件  </li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//swap.h文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//实现两个数字交换的函数声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//swap.cpp文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swap.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//main函数文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;swap.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;<br><span class="hljs-built_in">swap</span>(a, b);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义整形类型</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 定义一个指针指向 a</span><br><span class="hljs-comment">// 通过 &amp; 获取 a 的内存地址</span><br><span class="hljs-type">int</span>* p = &amp;a;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;&amp;a = &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p  = &quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br><span class="hljs-comment">// 指针的使用</span><br><span class="hljs-comment">// 通过 *（解引用）方式操作指针变量指向内存</span><br>cout &lt;&lt; <span class="hljs-string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017478.png" alt="image-20221128091221466"></p><p>指针变量和普通变量的区别</p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过 “ * “ 操作符，操作指针变量指向的内存空间，这个过程称为<strong>解引用</strong></li></ul><blockquote><p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p></blockquote><blockquote><p>总结2：利用指针可以记录地址</p></blockquote><blockquote><p>总结3：对指针变量解引用，可以操作指针指向的内存</p></blockquote><h3 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span>* p;<br>p = &amp;a; <span class="hljs-comment">//指针指向数据a的地址</span><br><br>cout &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">//* 解引用</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>*) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>*) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>*) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017212.png" alt="image-20221128091452887"></p><blockquote><p>总结：</p><ul><li>所有指针类型在 32 位操作系统下是 4 个字节</li><li>所有指针类型在 64 位操作系统下是 8 个字节</li></ul></blockquote><h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 指向的内存地址编号为 0 的空间</span><br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017588.png" alt="image-20221128094120128"></p><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 指针变量p指向内存地址编号为0x1100的空间</span><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)<span class="hljs-number">0x1100</span>;<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011017208.png" alt="image-20221128094258963"></p><blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p></blockquote><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><p>const修饰指针有三种情况</p><ol><li>const修饰指针   — 常量指针</li><li>const修饰常量   — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// const 修饰的是指针，指针指向可以改，指针指向的值不可以更改</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;a;<br>p1 = &amp;b;<br><span class="hljs-comment">// *p1 = 100; // 报错</span><br><br><span class="hljs-comment">// const 修饰的是常量，指针指向不可以改，指针指向的值可以更改</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p2 = &amp;a;<br><span class="hljs-comment">// p2 = &amp;b; // 错误</span><br>*p2 = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 正确</span><br><br><span class="hljs-comment">// const 既修饰指针又修饰常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p3 = &amp;a;<br><span class="hljs-comment">// p3 = &amp;b;   // 错误</span><br><span class="hljs-comment">// *p3 = 100; // 错误</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p><strong>作用：</strong>利用指针访问数组中元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><br><span class="hljs-type">int</span>* p = arr;  <span class="hljs-comment">//指向数组的指针</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-comment">//利用指针遍历数组</span><br>cout &lt;&lt; *p &lt;&lt; endl;<br>p++;<br>&#125;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap1</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b; <br>b = temp;<br>&#125;<br><span class="hljs-comment">//地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap2</span><span class="hljs-params">(<span class="hljs-type">int</span> * p1, <span class="hljs-type">int</span> *p2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp = *p1;<br>*p1 = *p2;<br>*p2 = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">swap1</span>(a, b); <span class="hljs-comment">// 值传递不会改变实参</span><br><br><span class="hljs-built_in">swap2</span>(&amp;a, &amp;b); <span class="hljs-comment">//地址传递会改变实参</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p></blockquote><h3 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h3><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br><br><span class="hljs-built_in">BubbleSort</span>(arr, len);<br><br><span class="hljs-built_in">printArray</span>(arr, len);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-type">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>] = temp;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>结构体属于用户 <code>自定义的数据类型</code>，允许用户存储不同的数据类型</p><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-comment">// 成员列表</span><br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125; stu3; <span class="hljs-comment">// 结构体变量创建方式 3 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 调用结构体创建变量 1</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> stu1;<br><br>stu1.name = <span class="hljs-string">&quot;Edmond&quot;</span>;<br>stu1.age = <span class="hljs-number">23</span>;<br>stu1.score = <span class="hljs-number">98</span>;<br><br><span class="hljs-comment">// 输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; stu1.age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 结构体变量创建方式 2</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> stu2 = &#123; <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">60</span> &#125;;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; stu2.age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; endl;<br><br>stu3.name = <span class="hljs-string">&quot;王五&quot;</span>;<br>stu3.age = <span class="hljs-number">18</span>;<br>stu3.score = <span class="hljs-number">80</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; stu3.age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011018448.png" alt="image-20221129091853897"></p><blockquote><p>总结1：定义结构体时的关键字是struct，不可省略</p></blockquote><blockquote><p>总结2：创建结构体变量时，关键字struct可以省略</p></blockquote><blockquote><p>总结3：结构体变量利用操作符 ‘’.’’  访问成员</p></blockquote><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p><p><strong>语法：</strong><code> struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-comment">// 成员列表</span><br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> arr[<span class="hljs-number">3</span>] =<br>&#123;<br>&#123;<span class="hljs-string">&quot;zs&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-number">76</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">86</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ww&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">79</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 遍历输出</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011018760.png" alt="image-20221129093327160"></p><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt; </code>可以通过结构体指针访问结构体属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-comment">// 成员列表</span><br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span>, &#125;;<br><span class="hljs-comment">// 定义结构体指针</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span>* ps = &amp;stu;<br><span class="hljs-comment">// 修改</span><br>ps-&gt;score = <span class="hljs-number">98</span>;<br><br><span class="hljs-comment">// 输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; ps-&gt;name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; ps-&gt;age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;分数：&quot;</span> &lt;&lt; ps-&gt;score &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011018354.png" alt="image-20221129095159892"></p><blockquote><p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p></blockquote><h3 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h3><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p><p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-comment">// 成员列表</span><br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125; stu3; <span class="hljs-comment">// 结构体变量创建方式 3</span><br><br><span class="hljs-comment">// 结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br><span class="hljs-type">int</span> id; <span class="hljs-comment">//职工编号</span><br>string name;  <span class="hljs-comment">//教师姓名</span><br><span class="hljs-type">int</span> age;   <span class="hljs-comment">//教师年龄</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> stu; <span class="hljs-comment">//子结构体 学生</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span> t1;<br>t1.id = <span class="hljs-number">10000</span>;<br>t1.name = <span class="hljs-string">&quot;老王&quot;</span>;<br>t1.age = <span class="hljs-number">40</span>;<br><br>t1.stu.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>t1.stu.age = <span class="hljs-number">18</span>;<br>t1.stu.score = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;教师-职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="hljs-string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;辅导学员-姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="hljs-string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011018835.png" alt="image-20221129095852045"></p><blockquote><p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p></blockquote><h3 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h3><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br><span class="hljs-comment">// 成员列表</span><br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStudent</span><span class="hljs-params">(Student stu)</span></span><br><span class="hljs-function"></span>&#123;<br>stu.age = <span class="hljs-number">28</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name <br>&lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age <br>&lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStudent2</span><span class="hljs-params">(Student* stu)</span></span><br><span class="hljs-function"></span>&#123;<br>stu-&gt;age = <span class="hljs-number">32</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name <br>&lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age <br>&lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Student stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-comment">//值传递</span><br><span class="hljs-built_in">printStudent</span>(stu);<br>cout &lt;&lt; <span class="hljs-string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name <br>&lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age <br>&lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;<br><br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">//地址传递</span><br><span class="hljs-built_in">printStudent2</span>(&amp;stu);<br>cout &lt;&lt; <span class="hljs-string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name <br>&lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age <br>&lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202309011018818.png" alt="image-20221129100242417"></p><blockquote><p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h3 id="const-场景"><a href="#const-场景" class="headerlink" title="const 场景"></a>const 场景</h3><p><strong>作用：</strong>用const来防止误操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//学生结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br><span class="hljs-comment">//成员列表</span><br>string name;  <span class="hljs-comment">//姓名</span><br><span class="hljs-type">int</span> age;      <span class="hljs-comment">//年龄</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//分数</span><br>&#125;;<br><br><span class="hljs-comment">//const使用场景</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> student *stu)</span> <span class="hljs-comment">//加const防止函数体中的误操作</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="hljs-string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>student stu = &#123; <span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-built_in">printStudent</span>(&amp;stu);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体案例"><a href="#结构体案例" class="headerlink" title="结构体案例"></a>结构体案例</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p><strong>案例描述：</strong></p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br>string name;<br><span class="hljs-type">int</span> score;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Teacher</span><br>&#123;<br>string name;<br>Student sArray[<span class="hljs-number">5</span>];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">allocateSpace</span><span class="hljs-params">(Teacher tArray[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>string tName = <span class="hljs-string">&quot;教师&quot;</span>;<br>string sName = <span class="hljs-string">&quot;学生&quot;</span>;<br>string nameSeed = <span class="hljs-string">&quot;ABCDE&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>tArray[i].name = tName + nameSeed[i];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br>&#123;<br>tArray[i].sArray[j].name = sName + nameSeed[j];<br>tArray[i].sArray[j].score = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">61</span> + <span class="hljs-number">40</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTeachers</span><span class="hljs-params">(Teacher tArray[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>cout &lt;&lt; tArray[i].name &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="hljs-string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子 头文件 #include &lt;ctime&gt;</span><br>Teacher tArray[<span class="hljs-number">3</span>]; <span class="hljs-comment">//老师数组</span><br><span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(tArray) / <span class="hljs-built_in">sizeof</span>(Teacher);<br><br><span class="hljs-built_in">allocateSpace</span>(tArray, len); <span class="hljs-comment">//创建数据</span><br><span class="hljs-built_in">printTeachers</span>(tArray, len); <span class="hljs-comment">//打印数据</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.C++ 基础精讲</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>本节分为 5 大类：</p><ol><li>形参带默认值的函数</li><li>内联函数inline</li><li>详解函数重载</li><li>const 深入应用</li><li>深入理解 C++ 的 new 和 delete</li></ol><h2 id="1-形参带默认值的函数"><a href="#1-形参带默认值的函数" class="headerlink" title="1. 形参带默认值的函数"></a>1. 形参带默认值的函数</h2><p>在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。</p><p><strong>注意事项：</strong></p><ol><li>在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span></span>; <span class="hljs-comment">//函数声明</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f)</span>  <span class="hljs-comment">//函数定义</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// ....  </span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>没有函数（原型）时，默认参数在函数定义时指定。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有 函数声明</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span>  <span class="hljs-comment">//函数定义</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</li></ol><p>就是说，<strong>函数声明时，必须按照从右向左的顺序，依次给与默认值。</strong></p><p>原因：</p><p>函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 <strong>从指令角度掌握函数调用堆栈详细过程。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3)</span></span>;         <span class="hljs-comment">// 错误, i3未指定默认值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">h</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 错误, i2未指定默认值</span><br></code></pre></td></tr></table></figure><p><strong>普通函数和形参带默认值函数对比：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b  = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>  temp = a + b;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br> <br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br> <br>  ret = <span class="hljs-built_in">sum</span>(a);<span class="hljs-comment">//b 使用默认值</span><br> <br>  ret = <span class="hljs-built_in">sum</span>();<span class="hljs-comment">//都使用默认值</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png" alt="image.png"></p><p>对比1，2 发现：</p><p>2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；</p><p>同理有3，使用默认值是：调用函数减少了 mov 指令。</p><h2 id="2-内联函数-inline"><a href="#2-内联函数-inline" class="headerlink" title="2. 内联函数 inline"></a>2. 内联函数 inline</h2><p><strong>特征：</strong></p><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><p><strong>使用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明1（加 inline，建议使用）</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 声明2（不加 inline）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span> </span>&#123;<span class="hljs-comment">/****/</span>&#125;;<br><br><span class="hljs-comment">// 类内定义，隐式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;         <span class="hljs-comment">// 隐式内联</span><br>&#125;<br><br><span class="hljs-comment">// 类外定义，需要显式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;   <span class="hljs-comment">// 需要显式内联</span><br></code></pre></td></tr></table></figure><p><strong>编译器对 inline 函数的处理步骤：</strong></p><ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><p><strong>内联函数与普通函数的区别？</strong></p><ol><li>内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理</li></ol><p>[[01.理解 C++ 内核]] 中的 <strong>从指令角度掌握函数调用堆栈详细过程</strong> 知道，在调用函数的过程中：</p><p>（1）将函数实数从右向左压栈<br>（2）call指令：<br>        将下一行要执行的代码地址入栈<br>        跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。</p><p>在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令</p><ol start="2"><li><p>内联函数不在生成相应的函数符号</p></li><li><p>inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。</p></li></ol><p>注意：</p><p>（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。</p><p><strong>优缺点：</strong></p><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="3-详解函数重载"><a href="#3-详解函数重载" class="headerlink" title="3. 详解函数重载"></a>3. 详解函数重载</h2><p><strong>函数重载</strong>：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。</p><p>（1）函数重载与函数返回值无关，因为在产生符号时没有返回值<br>（2） 函数重载需要在同一个作用域<br>（3）const 或者 volatile 的时候，是如何影响形参的</p><p><strong>C++ 支持函数重载，而 C 则不支持：</strong></p><p>编译器产生的函数符号规则不同：</p><ul><li>C++ 代码：函数符号包含了函数名和参数列表</li><li>C 代码：函数符号只包含了函数名。</li></ul><p><strong>注意事项：</strong></p><p>** <strong>函数重载需要在同一个作用域下</strong>。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;adf&quot;</span>, <span class="hljs-string">&quot;wew&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png" alt="image.png"></p><p>由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。</p><p><strong>const int 和 int 的重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png" alt="image.png"></p><p>原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png" alt="image.png"></p><p>const int 和 int 在编译器看来都是 int 类型 ，无法完成重载。</p><h3 id="3-1-C-和-C-语言如何相互调用"><a href="#3-1-C-和-C-语言如何相互调用" class="headerlink" title="3.1 C++ 和 C 语言如何相互调用"></a>3.1 C++ 和 C 语言如何相互调用</h3><p>由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten “C”{};</p><h4 id="1-C-调用-C"><a href="#1-C-调用-C" class="headerlink" title="1. C++ 调用 C"></a>1. C++ 调用 C</h4><p>对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字<code>extern &quot;C&quot;</code>，表示采用类c语言的方式解析函数符号。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// add.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ADD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ADD_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// add.c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 + 1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在例子中，<code>main.cpp</code> 为<code>c++</code> 代码，<code>add.c</code> 为 c 语言代码，当 c++ 编译器识别到<code>extern &quot;C&quot;</code> 关键字时，会去寻找 <code>_add_</code> 函数的实现而不是寻找类似<code>_int_add_int_int_</code> 这样带参数信息的函数实现。</p><h4 id="2-C-调用-C"><a href="#2-C-调用-C" class="headerlink" title="2. C 调用 C++"></a>2. C 调用 C++</h4><p>c 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：</p><ol><li>将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；</li><li>对外提供遵循类 c 语言规约的接口函数。例子如下所示：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// printNum.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// printNum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printNum.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; &lt;&lt; <span class="hljs-string">&quot;num is &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-built_in">printNum</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>通过将 <code>_cout_</code>函数封装为类 c 语言规约的接口函数，使得 <code>main.c</code> 中可以成功调用 c++ 函数 <code>_printNum_</code> 。值得注意的是，<code>main.c</code> 不可以直接引入 <code>printNum.h</code>，因为 c 语言不能识别 <code>extern &quot;C&quot;</code> 关键字。可以利用 c++ 预定义宏实现头文件的改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><ol><li>c 语言与 c++ 的相互调用可以通过 <code>extern &quot;C&quot;</code> 关键字实现</li><li>c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 <code>extern &quot;C&quot;</code></li><li>c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 <code>extern &quot;C&quot;</code> 声明的类 c 封装函数</li></ol><h2 id="4-const-深入应用"><a href="#4-const-深入应用" class="headerlink" title="4. const 深入应用"></a>4. const 深入应用</h2><p><strong>const 作用：</strong></p><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><p><strong>const 的指针与引用：</strong></p><ul><li>指针<ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul></li><li>引用<ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;                <span class="hljs-comment">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123; &#125;;        <span class="hljs-comment">// 初始化列表</span><br><br>    <span class="hljs-comment">// const可用于对重载函数的区分</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 普通成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对象</span><br>    A b;                        <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span><br>    <span class="hljs-type">const</span> A a;                  <span class="hljs-comment">// 常对象，只能调用常成员函数</span><br>    <span class="hljs-type">const</span> A *p = &amp;a;            <span class="hljs-comment">// 指针变量，指向常对象</span><br>    <span class="hljs-type">const</span> A &amp;q = a;             <span class="hljs-comment">// 指向常对象的引用</span><br><br>    <span class="hljs-comment">// 指针</span><br>    <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span>* p1 = greeting;                <span class="hljs-comment">// 指针变量，指向字符数组变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;          <span class="hljs-comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;          <span class="hljs-comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;    <span class="hljs-comment">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;           <span class="hljs-comment">// 传递过来的参数在函数内不可变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;         <span class="hljs-comment">// 参数指针所指内容为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;         <span class="hljs-comment">// 参数指针为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;          <span class="hljs-comment">// 引用参数在函数内为常量</span><br><br><span class="hljs-comment">// 函数返回值</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回一个常数</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure><p><strong>宏定义 <code>#define</code> 和 const 常量:</strong></p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h3 id="1-C-和-C-的-const-区别"><a href="#1-C-和-C-的-const-区别" class="headerlink" title="1. C++ 和 C 的 const 区别"></a>1. C++ 和 C 的 const 区别</h3><ul><li><strong>c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png" alt="image.png"></p><p>最终输出为：30、30、30</p><ul><li><strong>C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// const int b;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// a 常量，可以定义数组长度</span><br><span class="hljs-type">int</span> array[a] = &#123;&#125;;<br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png" alt="image.png"></p><p>原因：<strong>const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。</strong></p><h4 id="1-1-Debug-调试"><a href="#1-1-Debug-调试" class="headerlink" title="1.1 Debug 调试"></a>1.1 Debug 调试</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png" alt="image.png"></p><p>执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。</p><p><strong>如果不是立即数，则是常变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = b;<br><br><span class="hljs-comment">// 报错，a是常变量</span><br><span class="hljs-comment">//int array[a] = &#123;&#125;;</span><br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a); <span class="hljs-comment">// 30 30 30</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-const-与指针"><a href="#2-const-与指针" class="headerlink" title="2. const 与指针"></a>2. const 与指针</h3><p>const 修饰的量常出现的错误：</p><p><strong>（1）常量不能再作为左值</strong><br><strong>（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png" alt="image.png"></p><h4 id="2-1-const-和-一级指针"><a href="#2-1-const-和-一级指针" class="headerlink" title="2.1 const 和 一级指针"></a>2.1 const 和 一级指针</h4><p><strong>const 如果右边没有指针*，则const 是不参与类型的</strong></p><p><strong>C++的语言规范：就近原则 const 修饰的是离它最近的类型</strong></p><ol><li><code>const int* p</code>；离 const 最近的类型是 int，所以 const 修饰的是 <code>*p</code> ，所以 <code>*p</code> 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。</li><li><code>int const* p</code>；<code>*</code> 不是类型，离 const 最近的类型为 int，<code>*p</code> 无法修改，同（1）</li><li><code>int* const p</code>；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。</li><li><code>const int* const p</code>；不能修改 p 指向的地址和值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span> ;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<span class="hljs-comment">//p指向的地址的内容不能修改</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>重点：</p><p><strong>const 如果右边没有指针 <code>*</code>，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。</strong></p><p><strong>const 类型转化公式：</strong></p><ul><li><code>const int*</code>  &lt;&#x3D; <code>int*</code> 可以转换</li><li><code>int*</code> &lt;&#x3D; <code>const int*</code> 错误</li></ul></blockquote><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = <span class="hljs-literal">nullptr</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png"></p><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1= &amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;a;<span class="hljs-comment">// const int * &lt;= int *</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = &amp;a;<span class="hljs-comment">// int * &lt;= int *</span><br><span class="hljs-type">int</span> *p4 = p3;<span class="hljs-comment">//p3是int * 类型，因此没有问题</span><br></code></pre></td></tr></table></figure><h4 id="2-2-const-和-二级指针"><a href="#2-2-const-和-二级指针" class="headerlink" title="2.2 const 和 二级指针"></a>2.2 const 和 二级指针</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png" alt="image.png"></p><ul><li><code>const int** q</code>；离 const 最近的类型为 int，修饰的是 <code>**q</code>。</li><li><code>int* const* q</code>；离 const 最近的类型为 <code>int*</code>，修饰的是 <code>*q</code>。</li><li><code>int** const q</code>；离 const 最近的类型为 <code>int**</code>，修饰的是 <code>q</code>，同时 const 右侧没有 <code>*</code> ，q 是 <code>int**</code> 类型。</li></ul><p><strong>转化公式：</strong></p><ul><li><code>int**</code> &lt;&#x3D; <code>const int**</code> 错误</li><li><code>const int **</code> &lt;&#x3D; <code>int **</code> 错误</li></ul><p>const 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；</p><ul><li><code>int**</code> &lt;&#x3D; <code>int* const*</code> 是 const 和一级指针的结合，const 右边修饰的<code>*</code>  （等同于 <code>int *</code>  &lt;&#x3D; <code>const int *</code>  ）错误的</li><li><code>int* const*</code> &lt;&#x3D;<code>int**</code> （等同于<code>const int *</code> &lt;&#x3D; <code>int</code> ）可以的</li></ul><p><strong>要看 const 右边的 * 决定 const 修饰的是类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> ** q = &amp;p;<span class="hljs-comment">//error  </span><br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  const int * *q = &amp;p; 相当于（*）q 即 p的地址，赋值了一个const int * </span><br><span class="hljs-comment">  而p 是int *类型,把常量的地址泄露给普通的指针（p）</span><br><span class="hljs-comment">  修改 const int * p = &amp;a;</span><br><span class="hljs-comment">  */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h3><ol><li>引用是必须初始化的，指针可以不初始化。</li><li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。</li><li>定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。</li></ol><p>引用的错误用法  <code>int &amp;a = 10;</code> 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">int</span> &amp;b = a;<br> <br>  std::cout  &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br>  *p = <span class="hljs-number">20</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br> <br>  b = <span class="hljs-number">30</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png" alt="image.png"></p><p> <strong>反汇编：指针和引用没有区别</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png" alt="image.png"></p><p><code>lea eax,[a]</code>：将 a 的地址拷贝到寄存器 eax 中</p><p><code>mov dword ptr [p],eax</code>：将 eax 中的值拷贝到 p 中。</p><p><strong>反汇编中指针和引用拷贝也是没有区别。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png" alt="指针拷贝 - 1"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png" alt="指针拷贝 - 2"></p><p>对指针和引用赋值，都是一样的：获取地址，然后赋值。</p><h4 id="3-1-引用别名"><a href="#3-1-引用别名" class="headerlink" title="3.1 引用别名"></a>3.1 引用别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> array[<span class="hljs-number">5</span>] = &#123;&#125;;<br>  <span class="hljs-type">int</span> * p = array;<br>  <span class="hljs-built_in">int</span>(&amp;q)[<span class="hljs-number">5</span>] = array;<span class="hljs-comment">//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) </span><br> <br>  std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(array) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(q) &lt;&lt; std::endl;<span class="hljs-comment">//20 5 20</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png" alt="image.png"></p><p>关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 </p><p>站在宏观角度，引用也就是别名，所以不开辟看空间。</p><p>站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。</p><h3 id="4-左值引用"><a href="#4-左值引用" class="headerlink" title="4. 左值引用"></a>4. 左值引用</h3><p>左值：有内存地址，有名字，值可以修改；</p><p>如 <code>int a = 10;</code> <code>int &amp;b =a;</code></p><p><code>int &amp;c =10;</code> &#x2F;&#x2F;错误 20 是右值，20 &#x3D; 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；</p><p>上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = temp;<br></code></pre></td></tr></table></figure><p>根据上述分析，得出如下结论：</p><p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。</p><p>那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p><h3 id="5-右值引用"><a href="#5-右值引用" class="headerlink" title="5. 右值引用"></a>5. 右值引用</h3><p>C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p><ul><li>可以取地址的，有名字的，非临时的就是左值；</li><li>不能取地址的，没有名字的，临时的就是右值；</li></ul><p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。</p><p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。</p><ol><li><strong><code>int &amp;&amp;c = 10;</code>专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c &#x3D; 1;</strong></li></ol><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png" alt="image.png"></p><ol start="2"><li><strong>一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;e = a;<br></code></pre></td></tr></table></figure><h2 id="5-深入理解-C-的-new-和-delete"><a href="#5-深入理解-C-的-new-和-delete" class="headerlink" title="5. 深入理解 C++ 的 new 和 delete"></a>5. 深入理解 C++ 的 new 和 delete</h2><p><strong>New 的不同使用方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1 抛异常new</span><br>    <span class="hljs-type">int</span>* p1;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//分配内存并初始化</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e)<span class="hljs-comment">//判断是否抛异常</span><br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//2 不抛异常new</span><br>    <span class="hljs-type">int</span>* p2 = <span class="hljs-built_in">new</span> (std::nothrow)<span class="hljs-built_in">int</span>();<span class="hljs-comment">//不抛异常</span><br>    <span class="hljs-comment">//3 开辟常量内存</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">40</span>);<span class="hljs-comment">//开辟一个常量</span><br><br>    <span class="hljs-comment">//4 定位new</span><br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* p4 = <span class="hljs-built_in">new</span>(&amp;data) <span class="hljs-built_in">int</span>(<span class="hljs-number">50</span>);<span class="hljs-comment">//在指定地址内存初始化，本身并不开辟内存，只负责初始化</span><br>    <span class="hljs-keyword">delete</span> p1;<br>    <span class="hljs-keyword">delete</span> p2;<br>    <span class="hljs-keyword">delete</span> p3;<br>    <span class="hljs-keyword">delete</span> p4;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-malloc-与-new-的区别"><a href="#1-malloc-与-new-的区别" class="headerlink" title="1. malloc 与 new 的区别"></a>1. malloc 与 new 的区别</h4><ol><li>malloc 按字节开辟内存的；new 开辟内存时需要指定类型；</li><li>malloc 开辟内存返回的都是 <code>void *</code> ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。</li><li>malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。</li><li>malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。</li><li>malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要<code>[]</code>，而数组需要 <code>[]</code>并给上元素个数。</li></ol><h4 id="2-free-和-delete-的区别："><a href="#2-free-和-delete-的区别：" class="headerlink" title="2. free 和 delete 的区别："></a>2. free 和 delete 的区别：</h4><ol><li>free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  </li><li>delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  </li><li>delete 执行其实有两步，先调用析构，再释放；free 只有一步。</li></ol><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png" alt="image.png"></p><p><strong>new 与 delete 其本质也是函数的调用：运算符重载 new  delete</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span><br><span class="hljs-keyword">delete</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// new：</span><br><span class="hljs-comment">// 先调用 operator 开辟内存空间</span><br><span class="hljs-comment">// 然后调用对象的构造函数</span><br><span class="hljs-comment">// operator new 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// operator new[] 实现</span><br><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size)<br>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new[] addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// delete：</span><br><span class="hljs-comment">// 调用 p 指向对象的析构函数</span><br><span class="hljs-comment">// 再调用 operator delete 释放空间</span><br><span class="hljs-comment">// operator delete 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// operator delete[] 实现</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* ptr)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete[] addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">delete</span>[] p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png" alt="image.png"></p><h4 id="5-new-和delete-能够混用吗？"><a href="#5-new-和delete-能够混用吗？" class="headerlink" title="5. new 和delete 能够混用吗？"></a>5. new 和delete 能够混用吗？</h4><p><strong>C++为什么区分单个元素和数组的内存分配和释放呢？</strong></p><p><strong>情况1：int类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span>[]p;<br> <br><span class="hljs-type">int</span> *q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> q;<br></code></pre></td></tr></table></figure><p>能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。</p><p><strong>情况2：类类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>):<span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> ptr;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>单个元素与 <code>delete[]</code> 混用：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-keyword">delete</span>[]p1;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png" alt="报错程序"></p><p>程序崩溃。</p><ul><li><strong>数组与 delete 进行混用</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p2 = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">delete</span> p2;<br></code></pre></td></tr></table></figure><p>程序崩溃。</p><p><strong>分析：</strong></p><p>正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 <code>[]</code> 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 <code>0x100</code>；但是 new 完之后 p2 返回的地址是 <code>0x104</code> 地址，当我们执行 <code>delete[]</code> 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 <code>0x100</code> 开始的 4 字节也释放。</p><p>而 p2 出错是给用户返回的存对象开始的起始地址，<code>delete p2</code> 认为 p2 只是指向了一个对象，只将 <code>Test[0]</code> 对象析构，直接从 <code>0x104 free(p2)</code>，但底层实际是从 <code>0x100</code> 开辟的，因此崩溃。</p><p>而 p1 出错：p1 只是单个元素，从 <code>0x104</code> 开始开辟内存，但是 <code>delete[] p1</code>，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 <code>0x100</code> 释放)因此崩溃。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01.理解 C++ 内核</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<p>本节内容分为三部分：</p><ol><li>掌握进程虚拟地址空间区域划分</li><li>从指令角度掌握函数调用堆栈详细过程</li><li>从编译器角度理解C++代码的编译、链接</li></ol><p>通过了解底层基础，了解 C++ 的如何运行。</p><h2 id="1-掌握进程虚拟地址空间区域划分"><a href="#1-掌握进程虚拟地址空间区域划分" class="headerlink" title="1. 掌握进程虚拟地址空间区域划分"></a>1. 掌握进程虚拟地址空间区域划分</h2><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> gdata2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> gdata3;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata4 = <span class="hljs-number">11</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata5 = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata6;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">13</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> e = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> f;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上述代码，如何得知各个变量存储的位置？</p><h3 id="1-1-虚拟进程视图"><a href="#1-1-虚拟进程视图" class="headerlink" title="1.1 虚拟进程视图"></a>1.1 虚拟进程视图</h3><p>首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。</p><p>这里附上IBM公司关于<strong>虚拟</strong>的解释:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">它存在，你看得见，它是物理的<br>它存在，你看不见，它是透明的<br>它不存在，你看得见，它是虚拟的<br>它不存在，你看不见，它被删除<br></code></pre></td></tr></table></figure><p>这块空间的内容如下图所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png" alt="虚拟进程空间示例图 CN"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png" alt="虚拟进程空间示例图 EN"></p><blockquote><p>补充：<br>x86 32位体系下的4G虚拟地址空间：<br><strong>Linux默认3:1</strong>来分配 user space : kernal space；<br><strong>Windows默认2:2</strong>来分配 user space : kernal space。</p></blockquote><p>Linux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。</p><p>解释：<br>32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 <code>[0, 2^32]</code> ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。<br>64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 <code>[0, 2^64]</code> ，即 4GB * 4GB &#x3D; 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。</p><p><strong>为什么是 4G 内存：</strong></p><p>首先我们研究的体系是：<code>x86 32位Linux环境</code>：<br>Linux操作系统会给当前进程分配一个 <code>2^32</code> 大小的空间，那么，<code>2^32</code> 换算过来就是 4G 了。</p><h3 id="1-2-用户空间（User-Space）"><a href="#1-2-用户空间（User-Space）" class="headerlink" title="1.2 用户空间（User Space）"></a>1.2 用户空间（User Space）</h3><ol><li><p>保留区：<br> 128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 “NULL”，它便不会被引用了，从而避免了野指针。</p></li><li><p>指令段【.text】、只读数据段【.rodata】：<br> 指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。</p><blockquote><p>在C++中，不允许普通指针指向常量字符串，需要使用<code>const</code>：<br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png" alt="示例"></p></blockquote></li><li><p>数据段【.data】：<br> 存放程序中<strong>已初始化且不为0的全局变量或静态变量</strong>。</p></li><li><p>数据段【.bss】：<br> 存放程序中未初始化或者初始化为0的全局变量或静态变量。</p></li><li><p>堆【.heap】：<br> 存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。</p><ul><li>堆用于存放进程<code>运行时动态分配</code>的内存段，可动态扩张或缩减。</li><li>堆中内容是<code>匿名</code>的，无法通过名字进行访问，只能通过<code>指针</code>进行间接访问。</li><li>当进程调用<code>malloc(C)/new(C++)</code>等函数分配内存时，新分配的在堆上<code>动态扩张</code>；当调用<code>free(C)/delete(C++)</code>等函数释放内存时，被释放的内存从堆上<code>动态缩减</code></li><li>分配的堆内存时经过<code>字节对齐</code>的空间，以适合<code>原子操作</code>。</li><li><code>堆管理器</code>通过<code>链表</code>管理每个申请的内存块</li><li>由于堆内存块的申请与释放都是<code>无序</code>的，最终会产生许许多多<code>内存碎片</code>。</li><li>堆的末端由<code>break指针</code>标识，当堆管理器需要更多内存时，可通过<code>系统调用brk和sbrk</code>来<code>移动break指针</code>以扩张堆，一般情况下由系统自动调用。</li></ul></li><li><p>共享库【.dll、.so】：<br> 动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。</p></li><li><p>栈【.stack】：<br> 存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。</p><ul><li><p>栈中存放<code>非静态局部变量</code> <code>函数形参</code> <code>函数返回地址</code>等。</p></li><li><p>栈中内存空间由<code>编译器</code>（静态的）自动分配和释放，行为类似数据结构中的栈结构。</p><blockquote><p>主要用途：</p><ol><li>为函数内部声明的<strong>非静态局部变量</strong>提供存储空间</li><li>记录函数调用过程相关的维护性信息，称为栈帧（stack frame）</li><li>作为<code>临时存储区</code>，用于暂时存放<code>较长的算术表达式部分计算结果</code>，或者运行时调用alloca函数<code>动态分配</code>栈内内存</li></ol></blockquote></li><li><p>栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。</p></li><li><p>查看栈大小：<code>ulimit -s</code>可查看和设置<code>栈的最大值</code>，当程序使用的栈大小超过该值，会发生<code>segmentation fault</code>。</p></li><li><ul><li>栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。</li></ul></li></ul></li><li><p>命令行参数：<br> 保存传递给 main 函数的参数，比如 argc 和 argv。</p></li><li><p>环境变量：<br> 用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。</p></li></ol><h3 id="1-3-进程空间（Kernal-Space）"><a href="#1-3-进程空间（Kernal-Space）" class="headerlink" title="1.3 进程空间（Kernal Space）"></a>1.3 进程空间（Kernal Space）</h3><ol><li><p>内存直接访问区【ZONE_DMA】：<br> 16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。</p></li><li><p>常用区【ZONE_NORMAL】：<br> 892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。</p></li><li><p>高端内存区【ZONE_HIGHMEM】：<br> 128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。</p></li></ol><h3 id="1-4-最终解释"><a href="#1-4-最终解释" class="headerlink" title="1.4 最终解释"></a>1.4 最终解释</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png" alt="image.png"></p><blockquote><p>注意：<br>对于<code>a、b、c以及&#39;&#123;&#39;、&#39;&#125;&#39;</code>来说，是存储在<code>.text</code>指令段的，因为他们生成的都是&#x3D;&#x3D;指令&#x3D;&#x3D;。<br>例如：<br><code>int a = 12</code>：生成汇编指令如下：<code>mov dword ptr[a], 0Ch</code></p></blockquote><h3 id="1-5-好处"><a href="#1-5-好处" class="headerlink" title="1.5 好处"></a>1.5 好处</h3><p><code>数据</code>与<code>代码指令</code>分别开辟空间有以下好处：</p><ol><li>当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。<code>数据区</code>对于进程而言<code>可读可写</code>，<code>代码指令区</code>对于进程而言<code>只读</code>，</li><li>现代CPU一般<code>数据缓存</code>和<code>指令缓存</code>分离，故进程虚拟地址空间中数据与代码指令分离有助于提高<code>CPU缓存命中率</code>。</li><li>若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。</li></ol><p><strong>参考文章：</strong></p><blockquote><p>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1<br>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23<br>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09<br>【4】<a href="https://blog.csdn.net/m0_46308273/article/details/115818195">https://blog.csdn.net/m0_46308273/article/details/115818195</a><br>【5】<a href="https://blog.csdn.net/weixin_45437022/article/details/115409679">https://blog.csdn.net/weixin_45437022/article/details/115409679</a></p></blockquote><h2 id="2-从指令角度掌握函数调用堆栈详细过程"><a href="#2-从指令角度掌握函数调用堆栈详细过程" class="headerlink" title="2. 从指令角度掌握函数调用堆栈详细过程"></a>2. 从指令角度掌握函数调用堆栈详细过程</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png" alt="image.png"><br>栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。</p><p>堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：</p><ul><li>PUSH：将目标内存推入栈顶。</li><li>POP：从栈顶中移除目标。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png" alt="image.png"></p><p>当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 <strong>栈帧</strong> 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）</p><h3 id="2-1-ESP-和-EBP"><a href="#2-1-ESP-和-EBP" class="headerlink" title="2.1 ESP 和 EBP"></a>2.1 ESP 和 EBP</h3><p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p><p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：</p><ul><li>pop ebp;出栈 栈扩大4byte 因为ebp为32位</li><li>push ebp;入栈，栈减少4byte        </li><li>add esp, 0Ch；表示栈减小12byte</li><li>sub esp, 0Ch；表示栈扩大12byte</li></ul><p>ebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数</span><br><span class="hljs-comment">问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>temp = a + b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打断点，调试，查看反汇编：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 00007FF637EE23D0  push        rbp  </span><br><span class="hljs-comment">// 00007FF637EE23D2  push        rdi  </span><br><span class="hljs-comment">// 00007FF637EE23D3  sub         rsp,148h  </span><br><span class="hljs-comment">// 00007FF637EE23DA  lea         rbp,[rsp+20h]  </span><br><span class="hljs-comment">// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  </span><br><span class="hljs-comment">// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 00007FF637EE23EB  mov         dword ptr [a],0Ah  </span><br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 00007FF637EE23F2  mov         dword ptr [b],14h  </span><br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 00007FF637EE23F9  mov         edx,14h  </span><br><span class="hljs-comment">// 00007FF637EE23FE  mov         ecx,0Ah  </span><br><span class="hljs-comment">// 00007FF637EE2403  call        sum (07FF637EE11E5h)  </span><br><span class="hljs-comment">// 00007FF637EE2408  mov         dword ptr [ret],eax  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-comment">// 00007FF637EE240B  lea         rdx,[string &quot;ret:&quot; (07FF637EEAC24h)]  </span><br><span class="hljs-comment">// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  </span><br><span class="hljs-comment">// 00007FF637EE2419  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF637EE108Ch)  </span><br><span class="hljs-comment">// 00007FF637EE241E  mov         edx,dword ptr [ret]  </span><br><span class="hljs-comment">// 00007FF637EE2421  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1168h)]  </span><br><span class="hljs-comment">// 00007FF637EE242A  lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF637EE103Ch)]  </span><br><span class="hljs-comment">// 00007FF637EE2431  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1170h)]  </span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 00007FF637EE243A  xor         eax,eax  </span><br>&#125;<br><span class="hljs-comment">// 00007FF637EE243C  lea         rsp,[rbp+128h]  </span><br><span class="hljs-comment">// 00007FF637EE2443  pop         rdi  </span><br><span class="hljs-comment">// 00007FF637EE2444  pop         rbp  </span><br><span class="hljs-comment">// 00007FF637EE2445  ret </span><br></code></pre></td></tr></table></figure><h3 id="2-2-解析-main-函数"><a href="#2-2-解析-main-函数" class="headerlink" title="2.2  解析 main 函数"></a>2.2  解析 main 函数</h3><p><strong>1. <code>&#123;</code> 会进行入栈操作，<code>&#125;</code> 进行出栈操作</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png" alt="image.png"></p><p>上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。</p><p><strong>为什么这么做呢？</strong></p><p>因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。</p><p>在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</p><p><code>sub esp, 148h；</code>减去的值根据程序而定</p><p>之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</p><p>之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</p><p>在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png" alt="image.png"></p><p>所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数</p><p><strong>2. 函数内部：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png" alt="image.png"></p><ol><li><p><code>int a = 10;</code> 执行一条 mov 指令： </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [a],0Ah<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png" alt="image.png"></p></li><li><p> 同理 <code>int b = 20;</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [b],14h<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png" alt="image.png"></p></li><li><p><code>int ret = sum(a,b);</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Assmbly">00F81896 8B 45 EC             mov         eax,dword ptr [b] <br>00F81899 50                   push        eax     #压栈 b的值<br>00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  <br>00F8189D 51                   push        ecx     #压栈 a的值<br>00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call<br>00F818A3 83 C4 08             add         esp,8  <br>00F818A6 89 45 E0             mov         dword ptr [ret],eax <br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-sum-函数调用后"><a href="#2-3-sum-函数调用后" class="headerlink" title="2.3 sum 函数调用后"></a>2.3 sum 函数调用后</h3><p><strong>函数调用参数的压栈顺序:参数由右向左压入堆栈。</strong></p><p><strong>因此上面对应的是：</strong></p><p>先将b的值压入堆栈，再将a的值压入堆栈</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png" alt="image.png"><br><strong>执行call        sum (0F8108Ch)：</strong></p><p><strong>call函数首先会将下一行执行的地址入栈</strong>：假设下一行指令的地址位0x08124458</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png" alt="image.png"></p><p> <strong>第二步进入函数调用：sum</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png" alt="image.png"></p><p>函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈</p><p>第二步：将新的栈底ebp指向原来的栈顶esp</p><p>第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png" alt="image.png"></p><p>接着执行 <code>int temp = 0;</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         dword ptr [temp],0<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png" alt="image.png"></p><p>temp &#x3D; a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png" alt="image.png"></p><p>接着运行<code>return temp;</code>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         eax,dword ptr [temp]<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png" alt="image.png"></p><p>接着是<code>函数的右括号“&#125;”</code>：</p><p>（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。<br>（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。<br>（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png" alt="image.png"></p><h3 id="2-4-返回-main-函数后"><a href="#2-4-返回-main-函数后" class="headerlink" title="2.4 返回 main 函数后"></a>2.4 返回 main 函数后</h3><p>接着调用函数完毕，回到主函数：<br>利用了<code>PC寄存器</code>，使得程序知道退出sum后运行哪一条指令：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png" alt="image.png"></p><p><code>add         esp,8</code> ,将压栈的a b 形参空间回收</p><p><code>mov         dword ptr [ret],eax</code> 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png" alt="image.png"><br>最后<code>return 0</code>，程序结束</p><h3 id="2-5-栈溢出问题"><a href="#2-5-栈溢出问题" class="headerlink" title="2.5 栈溢出问题"></a>2.5 栈溢出问题</h3><p>出现栈内存溢出的常见原因有2个：</p><ol><li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li><li>局部静态变量体积太大。</li></ol><blockquote><p>第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。<br>检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。</p></blockquote><blockquote><p>   第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"> 即如果函数这样写：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span>* chdata = <span class="hljs-keyword">new</span>[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>   <span class="hljs-keyword">delete</span> []chdata;<br> &#125;<br>是不会出现这个错误的，而这样写则不行：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span> chdata[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br> &#125;<br>大多数情况下都会出现内存溢出的错误,<br></code></pre></td></tr></table></figure><p>解决办法大致说来也有两种：  </p><ol><li>增加栈内存的数目  </li><li>使用堆内存</li></ol><h2 id="3-从编译器角度理解-C-代码的编译、链接"><a href="#3-从编译器角度理解-C-代码的编译、链接" class="headerlink" title="3. 从编译器角度理解 C++ 代码的编译、链接"></a>3. 从编译器角度理解 C++ 代码的编译、链接</h2><p>整个编译过程分为两大步：</p><p>1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件</p><p>2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序</p><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><p>细分为3个阶段：</p><p><strong>1.1）编译预处理</strong></p><p>预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 <code>#include</code>），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 <code>#include</code> 包含的文件代码，进行 <code>#define</code> 宏定义的替换 ， 处理条件编译指令 （<code>#ifndef</code>、 <code>#ifdef</code>、 <code>#endif</code>）等。</p><p>预编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E main.c -o main.i<br></code></pre></td></tr></table></figure><p>主要规则如下：</p><ol><li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义；</li><li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>;</li><li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；</li><li>删除所有的注释：<code>//</code> 和 <code>/**/</code>；</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；</li><li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要使用它们。</li></ol><blockquote><p>注：<br><code>#pragma lib</code>、<code>pragma link</code><br>等命令是在链接过程处理的。</p></blockquote><p>预编译后得到的文件为：<code>.i</code>文件。</p><p><strong>1.2）编译</strong></p><p>通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</p><p>编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -S main.i -o main.s<br></code></pre></td></tr></table></figure><p>编译后得到的文件为：<code>.s</code>文件。</p><p><strong>1.3) 汇编</strong></p><p>汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。</p><p>目标文件由段组成，通常至少有两个段：</p><ol><li>.text：包换主要程序的指令。该段是可读和可执行的，一般不可写</li><li>.data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。</li></ol><p>汇编过程我们可以调用汇编器<code>as</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">as main.s -o main.o  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span>  <br>gcc -c main.s -o mian.o<br></code></pre></td></tr></table></figure><p>这个过程将.s文件转化成.o文件。</p><h3 id="3-2-链接过程"><a href="#3-2-链接过程" class="headerlink" title="3.2 链接过程"></a>3.2 链接过程</h3><p>链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。</p><p><strong>链接的时机</strong>：</p><ul><li>编译时，也就是在源代码被翻译成机器代码时</li><li>加载时，也就是在程序被加载器加载到存储器并执行时</li><li>运行时，由应用程序执行</li></ul><h4 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h4><p><strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p>为了构造可执行文件，<strong>链接器必须完成两个任务：符号解析，重定位</strong></p><ol><li><strong>符号解析：</strong> 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li><li><strong>重定位：</strong> 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li></ol><p>链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png" alt="image.png"></p><p>目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p><h4 id="2-目标文件"><a href="#2-目标文件" class="headerlink" title="2. 目标文件"></a>2. 目标文件</h4><p><strong>三种形式：</strong></p><ol><li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li><li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。</li></ol><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。</p><h4 id="3-可重定位目标文件"><a href="#3-可重定位目标文件" class="headerlink" title="3.  可重定位目标文件"></a>3.  可重定位目标文件</h4><p>一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png" alt="ELF可重定位目标文件"></p><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong> 已编译程序的机器代码。</li><li><strong>.rodata：</strong> 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li><li><strong>.data：</strong> 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li><li><strong>.bss：</strong> 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li><li><strong>.symtab：</strong> 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li><li><strong>.rel.text：</strong> 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li><li><strong>.rel.data：</strong> 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li><strong>.debug：</strong> 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li><li><strong>.line：</strong> 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li><li><strong>.strtab：</strong> 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li></ul><h4 id="4-符号和符号表"><a href="#4-符号和符号表" class="headerlink" title="4. 符号和符号表"></a>4. 符号和符号表</h4><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段</p><p>在链接器的上下文中，有三种不同的符号：</p><p>由m定义并能被其他模块引用的全局符号<br>由其他模块定义并被模块m引用的全局符号<br>只被模块m引用的本地符号</p><p>例如：</p><p><code>main.cpp</code> 内容 和 <code>sum.cpp</code> 内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> gdata;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-type">int</span> data = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = gdata;<br><span class="hljs-type">int</span> b = data;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>g++ -c</strong> 只编译不链接，只生成目标文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png" alt="image.png"></p><p> <strong>objdump -t main.o &#x2F;&#x2F; 输出目标文件的符号表：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png" alt="image.png"></p><ul><li>第一列：段内偏移；</li><li>第二列：符号作用域  : local &#x2F;global；</li><li>第三列：符号类型；</li><li>第四列：符号所在段（<em>UND</em>外部链接符号，未在本目标文件定义）；</li><li>第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；</li><li>第六列：符号名；</li></ul><p>其中 <code>main</code> 定义在 <code>.text</code></p><p>data 是全局变量，且初始化定义在 <code>.data</code> ,也就是 m 定义并能被其他模块引用的全局符号。<br>gdata 和 sum 函数是声明，因此是<em>UNG</em>，也就是由其他模块定义并被模块 m 引用的全局符号。</p><p>第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配</p><p>在 <code>sum.o</code> 中：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png" alt="image.png"></p><p>gdata 是出刷的全局变量 在 <code>.data</code> 中；sum 函数在 <code>.text</code> 中</p><p><code>readelf -h</code> 查看 elf 文件的头文件信息<br>可见目标文件的elf文件，其类型为REL(可重定位文件)。 </p><p><code>objdump -s</code> 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png" alt="image.png"></p><p>有调试信息的：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png" alt="image.png"></p><p>可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。</p><h4 id="5-符号解析"><a href="#5-符号解析" class="headerlink" title="5. 符号解析"></a>5. 符号解析</h4><p>链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（<em>UNG</em>）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）</p><p> <strong>链接器如何解析多重定义的全局符号：</strong></p><p>在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。<br>       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：</p><p>规则1：不允许有多个强符号。<br>规则2：如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><p><strong>链接器如何使用静态库来解析引用：</strong></p><p>在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。</p><blockquote><ol><li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。</li><li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。</li><li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li></ol></blockquote><p>这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。</p><p>另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在命令行上重复库。</p><h4 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6. 重定向"></a>6. 重定向</h4><p>一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位有两步组成：</p><ol><li><strong>重定位节和符号定义</strong>。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用</strong>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<code>重定位条目</code>的可重定位目标模块中的数据结构。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png" alt="image.png"></p><p>链接后：所有的符号都有虚拟地址</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png" alt="image.png"></p><p>汇编中，全局变量和函数都有了地址。</p><h4 id="7-可执行目标文件"><a href="#7-可执行目标文件" class="headerlink" title="7. 可执行目标文件"></a>7. 可执行目标文件</h4><p>可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<code>.text</code> 、<code>.rodata</code> 和 <code>.data</code> 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。</p><p>ELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署流程</title>
    <link href="/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>主要使用技术合集：</strong></p><ol><li>Hexo 博客系统</li><li>Fluid 博客模板</li><li>Obsidian + Github Pages 部署。</li></ol><h2 id="1-Hexo-博客系统"><a href="#1-Hexo-博客系统" class="headerlink" title="1. Hexo 博客系统"></a>1. Hexo 博客系统</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <strong>Markdown</strong>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-1-安装需求"><a href="#1-1-安装需求" class="headerlink" title="1.1 安装需求"></a>1.1 安装需求</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li>Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li><li>Git</li></ul><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>全局安装后即可随时使用</p><h3 id="1-3-创建博客"><a href="#1-3-创建博客" class="headerlink" title="1.3 创建博客"></a>1.3 创建博客</h3><p>安装完成后，就可以在终端使用 <code>hexo</code> 指令了，可以使用以下指令创建一个 hexo 项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo init hexo-blog  <br><span class="hljs-built_in">cd</span> hexo-blog  <br>yarn install<br></code></pre></td></tr></table></figure><p>完成后项目目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.  <br>├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  <br>├── package.json  <br>├── scaffolds # 文章模板  <br>├── source  <br>|   ├── _drafts  <br>|   └── _posts # 你的 markdown 文章就需要存放在此目录下  <br>└── themes # 存放主题源码<br></code></pre></td></tr></table></figure><h2 id="2-配置-Fluid-主题"><a href="#2-配置-Fluid-主题" class="headerlink" title="2. 配置 Fluid 主题"></a>2. 配置 Fluid 主题</h2><ol><li>NPM 安装</li><li>源码安装</li></ol><h3 id="2-1-NPM-安装"><a href="#2-1-NPM-安装" class="headerlink" title="2.1 NPM 安装"></a>2.1 NPM 安装</h3><p>以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，使用 npm 安装只需要执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">yarn add hexo-theme-fluid  <br># 或者  <br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p><h3 id="2-2-源码安装"><a href="#2-2-源码安装" class="headerlink" title="2.2 源码安装"></a>2.2 源码安装</h3><p>源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。</p><p>仍然以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，在项目的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Releases</a> 页面中下载源码文件：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png"></p><p>下载解压后，在 <code>themes</code> 目录下创建一个 <code>fluid</code> 目录，将源码复制到该目录下，如下：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png" alt="image.png"></p><h3 id="2-3-应用主题"><a href="#2-3-应用主题" class="headerlink" title="2.3 应用主题"></a>2.3 应用主题</h3><p>当你安装成功后，需要在 <code>_config.yml</code> 中将使用的主题设置为你下载好的主题，找到 <code>theme</code> 配置项，将其修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions  </span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/  </span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/  </span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="2-4-配置第三方主题"><a href="#2-4-配置第三方主题" class="headerlink" title="2.4 配置第三方主题"></a>2.4 配置第三方主题</h3><p>如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 <code>_config.fluid.yml</code> 文件修改相关配置；</p><p>如果你是以源码方式安装的主题，就不需要创建 <code>_config.fluid.yml</code> 文件了，只需要修改 <code>/themes/fluid/_config.yml</code> 文件中的配置就可以了。</p><blockquote><p>注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档</p></blockquote><h2 id="3-部署-Github-Pages"><a href="#3-部署-Github-Pages" class="headerlink" title="3. 部署 Github Pages"></a>3. 部署 Github Pages</h2><p>然后在 Github 中创建一个新项目仓库，名称必须为 <code>&lt;你的github用户名&gt;.github.io</code>，创建完成后按照指引将你的博客代码上传到 github。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png" alt="image.png"></p><h3 id="3-1-开启-Github-Pages"><a href="#3-1-开启-Github-Pages" class="headerlink" title="3.1 开启 Github Pages"></a>3.1 开启 Github Pages</h3><p>在执行这一步之前，先创建一个没有任何代码的新分支，命名为 <code>gh-pages</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b gh-pages  <br>rm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  <br>git push --set-upstream origin release # 上传 release 分支<br></code></pre></td></tr></table></figure><p>在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 <code>gh-pages</code> 分支：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png" alt="image.png"></p><p>这就意为这你在 <code>gh-pages</code> 上传的任何 html 都可以使用 <code>&lt;你的github用户名&gt;.github.io</code> 这个域名来访问了。</p><p>我们切回 <code>master</code> 分支，之后执行 <code>yarn build</code> 将生成的 <code>public</code> 目录下的文件复制一份，然后重新切回 <code>gh-pages</code> 分支，将刚才复制的内容粘贴到 <code>gh-pages</code> 分支下，并上传代码。如果没有操作失误的话，访问 <code>&lt;你的github用户名&gt;.github.io</code> 即可看到你的博客了。</p><h3 id="3-2-Github-Action-自动部署"><a href="#3-2-Github-Action-自动部署" class="headerlink" title="3.2 Github Action 自动部署"></a>3.2 Github Action 自动部署</h3><p>使用 Github Action 来帮我们做自动化部署。</p><p>Github Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。</p><p>关于 Github Action，详细教程可以查看 <a href="https://docs.github.com/cn/actions">官方文档</a>。按照文档中所描述的，只要我们在代码中添加一层 <code>.github/workflows</code> 目录，并且在目录下创建一个 <code>yml</code> 文件来描述具体的行为，就可以实现开启 Github Action。</p><p>如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 <code>.github/workflows/blog-deploy.yml</code> 文件中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">16.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;16&quot;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br></code></pre></td></tr></table></figure><p>保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png" alt="image.png"></p><p>但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 <a href="https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context">secrets 上下文</a>，即 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code> 这里。</p><p><code>$&#123;&#123; xxx &#125;&#125;</code> 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 <code>secrets.ACCESS_TOKEN</code> 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。</p><p>首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 <code>Setting</code>，进入设置后选择 <code>Developer settings</code>，再选择 <code>Persona access token</code> 就可以看到它了：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png" alt="image.png"></p><p>点击右上角的 <code>Generate new token</code> 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 <code>repo</code> 和 <code>workflow</code> 权限，并将 <code>Expiration</code> 过期时间选为 <code>No expiration</code>：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png" alt="image.png"></p><blockquote><p>这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！</p></blockquote><p>点击 <code>Generate token</code> 按钮后，就会生成一个 <code>ghp</code> 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png" alt="image.png"></p><p>复制该 token 后，进入到博客仓库的设置中，选择 <code>Secrets - Actions</code>，点击 <code>New repository secret</code> 按钮生成一个密钥信息：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png" alt="image.png"></p><p>我们将密钥名称写为 <code>ACCESS_TOKEN</code>，值填入刚才复制的 Github token。</p><blockquote><p>这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 <code>secret</code> 上下文对象所获取到。</p></blockquote><p>至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>Blog</tag>
      
      <tag>Obdidian</tag>
      
      <tag>Github Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
