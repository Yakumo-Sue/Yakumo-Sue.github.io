<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 面向对象</title>
    <link href="/2023/08/04/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/08/04/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/03.C++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>本节分为 7 大类：</p><ol><li>类和对象、this 指针</li><li>构造函数和析构函数</li><li>深拷贝和浅拷贝</li><li>类和对象代码应用实践</li><li>构造函数的初始化列表</li><li>类的各种成员方法及区别</li><li>指向类成员的指针</li></ol><h2 id="1-类和对象、this-指针"><a href="#1-类和对象、this-指针" class="headerlink" title="1. 类和对象、this 指针"></a>1. 类和对象、this 指针</h2>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/00.C++%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ 基础精讲</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/02.C++%20%E5%9F%BA%E7%A1%80%E7%B2%BE%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>本节分为 5 大类：</p><ol><li>形参带默认值的函数</li><li>内联函数inline</li><li>详解函数重载</li><li>const 深入应用</li><li>深入理解 C++ 的 new 和 delete</li></ol><h2 id="1-形参带默认值的函数"><a href="#1-形参带默认值的函数" class="headerlink" title="1. 形参带默认值的函数"></a>1. 形参带默认值的函数</h2><p>在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。</p><p><strong>注意事项：</strong></p><ol><li>在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span></span>; <span class="hljs-comment">//函数声明</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f)</span>  <span class="hljs-comment">//函数定义</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// ....  </span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>没有函数（原型）时，默认参数在函数定义时指定。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有 函数声明</span><br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> f = <span class="hljs-number">1.0</span>)</span>  <span class="hljs-comment">//函数定义</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</li></ol><p>就是说，<strong>函数声明时，必须按照从右向左的顺序，依次给与默认值。</strong></p><p>原因：</p><p>函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 <strong>从指令角度掌握函数调用堆栈详细过程。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 正确</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2 = <span class="hljs-number">2</span>, <span class="hljs-type">int</span> i3)</span></span>;         <span class="hljs-comment">// 错误, i3未指定默认值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">h</span> <span class="hljs-params">(<span class="hljs-type">int</span> i1 = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3 = <span class="hljs-number">3</span>)</span></span>;     <span class="hljs-comment">// 错误, i2未指定默认值</span><br></code></pre></td></tr></table></figure><p><strong>普通函数和形参带默认值函数对比：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b  = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>  temp = a + b;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br> <br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br> <br>  ret = <span class="hljs-built_in">sum</span>(a);<span class="hljs-comment">//b 使用默认值</span><br> <br>  ret = <span class="hljs-built_in">sum</span>();<span class="hljs-comment">//都使用默认值</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png" alt="image.png"></p><p>对比1，2 发现：</p><p>2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；</p><p>同理有3，使用默认值是：调用函数减少了 mov 指令。</p><h2 id="2-内联函数-inline"><a href="#2-内联函数-inline" class="headerlink" title="2. 内联函数 inline"></a>2. 内联函数 inline</h2><p><strong>内联函数与普通函数的区别？</strong></p><ol><li>内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理</li></ol><p>[[01.理解 C++ 内核]] 中的 <strong>从指令角度掌握函数调用堆栈详细过程</strong> 知道，在调用函数的过程中：</p><p>（1）将函数实数从右向左压栈<br>（2）call指令：<br>        将下一行要执行的代码地址入栈<br>        跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。</p><p>在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令</p><ol start="2"><li><p>内联函数不在生成相应的函数符号</p></li><li><p>inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。</p></li></ol><p>注意：</p><p>（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。</p><h2 id="3-详解函数重载"><a href="#3-详解函数重载" class="headerlink" title="3. 详解函数重载"></a>3. 详解函数重载</h2><p><strong>函数重载</strong>：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。</p><p>（1）函数重载与函数返回值无关，因为在产生符号时没有返回值<br>（2） 函数重载需要在同一个作用域<br>（3）const 或者 volatile 的时候，是如何影响形参的</p><p><strong>C++ 支持函数重载，而 C 则不支持：</strong></p><p>编译器产生的函数符号规则不同：</p><ul><li>C++ 代码：函数符号包含了函数名和参数列表</li><li>C 代码：函数符号只包含了函数名。</li></ul><p><strong>注意事项：</strong></p><p>** <strong>函数重载需要在同一个作用域下</strong>。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br><span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;adf&quot;</span>, <span class="hljs-string">&quot;wew&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png" alt="image.png"></p><p>由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。</p><p><strong>const int 和 int 的重载：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a)</span> </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png" alt="image.png"></p><p>原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(b).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png" alt="image.png"></p><p>const int 和 int 在编译器看来都是 int 类型 ，无法完成重载。</p><h3 id="3-1-C-和-C-语言如何相互调用"><a href="#3-1-C-和-C-语言如何相互调用" class="headerlink" title="3.1 C++ 和 C 语言如何相互调用"></a>3.1 C++ 和 C 语言如何相互调用</h3><p>由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten “C”{};</p><h4 id="1-C-调用-C"><a href="#1-C-调用-C" class="headerlink" title="1. C++ 调用 C"></a>1. C++ 调用 C</h4><p>对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字<code>extern &quot;C&quot;</code>，表示采用类c语言的方式解析函数符号。例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// add.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ADD_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ADD_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-comment">// add.c</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;add.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1 + 1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在例子中，<code>main.cpp</code> 为<code>c++</code> 代码，<code>add.c</code> 为 c 语言代码，当 c++ 编译器识别到<code>extern &quot;C&quot;</code> 关键字时，会去寻找 <code>_add_</code> 函数的实现而不是寻找类似<code>_int_add_int_int_</code> 这样带参数信息的函数实现。</p><h4 id="2-C-调用-C"><a href="#2-C-调用-C" class="headerlink" title="2. C 调用 C++"></a>2. C 调用 C++</h4><p>c 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：</p><ol><li>将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；</li><li>对外提供遵循类 c 语言规约的接口函数。例子如下所示：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// printNum.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// printNum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printNum.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; &lt;&lt; <span class="hljs-string">&quot;num is &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">// main.c</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-built_in">printNum</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>通过将 <code>_cout_</code>函数封装为类 c 语言规约的接口函数，使得 <code>main.c</code> 中可以成功调用 c++ 函数 <code>_printNum_</code> 。值得注意的是，<code>main.c</code> 不可以直接引入 <code>printNum.h</code>，因为 c 语言不能识别 <code>extern &quot;C&quot;</code> 关键字。可以利用 c++ 预定义宏实现头文件的改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __PRINTNUM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PRINTNUM_H__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><ol><li>c 语言与 c++ 的相互调用可以通过 <code>extern &quot;C&quot;</code> 关键字实现</li><li>c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 <code>extern &quot;C&quot;</code></li><li>c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 <code>extern &quot;C&quot;</code> 声明的类 c 封装函数</li></ol><h2 id="4-const-深入应用"><a href="#4-const-深入应用" class="headerlink" title="4. const 深入应用"></a>4. const 深入应用</h2><p><strong>const 作用：</strong></p><ol><li>修饰变量，说明该变量不可以被改变；</li><li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li><li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量。</li></ol><p><strong>const 的指针与引用：</strong></p><ul><li>指针<ul><li>指向常量的指针（pointer to const）</li><li>自身是常量的指针（常量指针，const pointer）</li></ul></li><li>引用<ul><li>指向常量的引用（reference to const）</li><li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a;                <span class="hljs-comment">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>) &#123; &#125;;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(x) &#123; &#125;;        <span class="hljs-comment">// 初始化列表</span><br><br>    <span class="hljs-comment">// const可用于对重载函数的区分</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;             <span class="hljs-comment">// 普通成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 对象</span><br>    A b;                        <span class="hljs-comment">// 普通对象，可以调用全部成员函数</span><br>    <span class="hljs-type">const</span> A a;                  <span class="hljs-comment">// 常对象，只能调用常成员函数</span><br>    <span class="hljs-type">const</span> A *p = &amp;a;            <span class="hljs-comment">// 指针变量，指向常对象</span><br>    <span class="hljs-type">const</span> A &amp;q = a;             <span class="hljs-comment">// 指向常对象的引用</span><br><br>    <span class="hljs-comment">// 指针</span><br>    <span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">char</span>* p1 = greeting;                <span class="hljs-comment">// 指针变量，指向字符数组变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p2 = greeting;          <span class="hljs-comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p3 = greeting;          <span class="hljs-comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> p4 = greeting;    <span class="hljs-comment">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> Var)</span></span>;           <span class="hljs-comment">// 传递过来的参数在函数内不可变</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* Var)</span></span>;         <span class="hljs-comment">// 参数指针所指内容为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function3</span><span class="hljs-params">(<span class="hljs-type">char</span>* <span class="hljs-type">const</span> Var)</span></span>;         <span class="hljs-comment">// 参数指针为常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function4</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; Var)</span></span>;          <span class="hljs-comment">// 引用参数在函数内为常量</span><br><br><span class="hljs-comment">// 函数返回值</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">function5</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 返回一个常数</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title">function6</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">function7</span><span class="hljs-params">()</span></span>;     <span class="hljs-comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure><p><strong>宏定义 <code>#define</code> 和 const 常量:</strong></p><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h3 id="1-C-和-C-的-const-区别"><a href="#1-C-和-C-的-const-区别" class="headerlink" title="1. C++ 和 C 的 const 区别"></a>1. C++ 和 C 的 const 区别</h3><ul><li><strong>c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png" alt="image.png"></p><p>最终输出为：30、30、30</p><ul><li><strong>C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化</strong></li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// const int b;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// a 常量，可以定义数组长度</span><br><span class="hljs-type">int</span> array[a] = &#123;&#125;;<br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png" alt="image.png"></p><p>原因：<strong>const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。</strong></p><h4 id="1-1-Debug-调试"><a href="#1-1-Debug-调试" class="headerlink" title="1.1 Debug 调试"></a>1.1 Debug 调试</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png" alt="image.png"></p><p>执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。</p><p><strong>如果不是立即数，则是常变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = b;<br><br><span class="hljs-comment">// 报错，a是常变量</span><br><span class="hljs-comment">//int array[a] = &#123;&#125;;</span><br><br><span class="hljs-type">int</span>* p = (<span class="hljs-type">int</span>*)&amp;a;<br>*p = <span class="hljs-number">30</span>;<br><br>cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; *(&amp;a); <span class="hljs-comment">// 30 30 30</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-const-与指针"><a href="#2-const-与指针" class="headerlink" title="2. const 与指针"></a>2. const 与指针</h3><p>const 修饰的量常出现的错误：</p><p><strong>（1）常量不能再作为左值</strong><br><strong>（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png" alt="image.png"></p><h4 id="2-1-const-和-一级指针"><a href="#2-1-const-和-一级指针" class="headerlink" title="2.1 const 和 一级指针"></a>2.1 const 和 一级指针</h4><p><strong>const 如果右边没有指针*，则const 是不参与类型的</strong></p><p><strong>C++的语言规范：就近原则 const 修饰的是离它最近的类型</strong></p><ol><li><code>const int* p</code>；离 const 最近的类型是 int，所以 const 修饰的是 <code>*p</code> ，所以 <code>*p</code> 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。</li><li><code>int const* p</code>；<code>*</code> 不是类型，离 const 最近的类型为 int，<code>*p</code> 无法修改，同（1）</li><li><code>int* const p</code>；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。</li><li><code>const int* const p</code>；不能修改 p 指向的地址和值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span> ;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<span class="hljs-comment">//p指向的地址的内容不能修改</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>重点：</p><p><strong>const 如果右边没有指针 <code>*</code>，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。</strong></p><p><strong>const 类型转化公式：</strong></p><ul><li><code>const int*</code>  &lt;&#x3D; <code>int*</code> 可以转换</li><li><code>int*</code> &lt;&#x3D; <code>const int*</code> 错误</li></ul></blockquote><p>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p1 = <span class="hljs-literal">nullptr</span>;<br><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png"></p><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p1= &amp;a;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p2 = &amp;a;<span class="hljs-comment">// const int * &lt;= int *</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> p3 = &amp;a;<span class="hljs-comment">// int * &lt;= int *</span><br><span class="hljs-type">int</span> *p4 = p3;<span class="hljs-comment">//p3是int * 类型，因此没有问题</span><br></code></pre></td></tr></table></figure><h4 id="2-2-const-和-二级指针"><a href="#2-2-const-和-二级指针" class="headerlink" title="2.2 const 和 二级指针"></a>2.2 const 和 二级指针</h4><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png" alt="image.png"></p><ul><li><code>const int** q</code>；离 const 最近的类型为 int，修饰的是 <code>**q</code>。</li><li><code>int* const* q</code>；离 const 最近的类型为 <code>int*</code>，修饰的是 <code>*q</code>。</li><li><code>int** const q</code>；离 const 最近的类型为 <code>int**</code>，修饰的是 <code>q</code>，同时 const 右侧没有 <code>*</code> ，q 是 <code>int**</code> 类型。</li></ul><p><strong>转化公式：</strong></p><ul><li><code>int**</code> &lt;&#x3D; <code>const int**</code> 错误</li><li><code>const int **</code> &lt;&#x3D; <code>int **</code> 错误</li></ul><p>const 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；</p><ul><li><code>int**</code> &lt;&#x3D; <code>int* const*</code> 是 const 和一级指针的结合，const 右边修饰的<code>*</code>  （等同于 <code>int *</code>  &lt;&#x3D; <code>const int *</code>  ）错误的</li><li><code>int* const*</code> &lt;&#x3D;<code>int**</code> （等同于<code>const int *</code> &lt;&#x3D; <code>int</code> ）可以的</li></ul><p><strong>要看 const 右边的 * 决定 const 修饰的是类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> ** q = &amp;p;<span class="hljs-comment">//error  </span><br>  <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  const int * *q = &amp;p; 相当于（*）q 即 p的地址，赋值了一个const int * </span><br><span class="hljs-comment">  而p 是int *类型,把常量的地址泄露给普通的指针（p）</span><br><span class="hljs-comment">  修改 const int * p = &amp;a;</span><br><span class="hljs-comment">  */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h3><ol><li>引用是必须初始化的，指针可以不初始化。</li><li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。</li><li>定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。</li></ol><p>引用的错误用法  <code>int &amp;a = 10;</code> 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> * p = &amp;a;<br>  <span class="hljs-type">int</span> &amp;b = a;<br> <br>  std::cout  &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br>  *p = <span class="hljs-number">20</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br> <br>  b = <span class="hljs-number">30</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; (*p);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png" alt="image.png"></p><p> <strong>反汇编：指针和引用没有区别</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png" alt="image.png"></p><p><code>lea eax,[a]</code>：将 a 的地址拷贝到寄存器 eax 中</p><p><code>mov dword ptr [p],eax</code>：将 eax 中的值拷贝到 p 中。</p><p><strong>反汇编中指针和引用拷贝也是没有区别。</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png" alt="指针拷贝 - 1"><br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png" alt="指针拷贝 - 2"></p><p>对指针和引用赋值，都是一样的：获取地址，然后赋值。</p><h4 id="3-1-引用别名"><a href="#3-1-引用别名" class="headerlink" title="3.1 引用别名"></a>3.1 引用别名</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> array[<span class="hljs-number">5</span>] = &#123;&#125;;<br>  <span class="hljs-type">int</span> * p = array;<br>  <span class="hljs-built_in">int</span>(&amp;q)[<span class="hljs-number">5</span>] = array;<span class="hljs-comment">//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) </span><br> <br>  std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(array) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(q) &lt;&lt; std::endl;<span class="hljs-comment">//20 5 20</span><br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png" alt="image.png"></p><p>关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 </p><p>站在宏观角度，引用也就是别名，所以不开辟看空间。</p><p>站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。</p><h3 id="4-左值引用"><a href="#4-左值引用" class="headerlink" title="4. 左值引用"></a>4. 左值引用</h3><p>左值：有内存地址，有名字，值可以修改；</p><p>如 <code>int a = 10;</code> <code>int &amp;b =a;</code></p><p><code>int &amp;c =10;</code> &#x2F;&#x2F;错误 20 是右值，20 &#x3D; 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；</p><p>上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> temp = <span class="hljs-number">10</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;var = temp;<br></code></pre></td></tr></table></figure><p>根据上述分析，得出如下结论：</p><p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。</p><p>那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p><h3 id="5-右值引用"><a href="#5-右值引用" class="headerlink" title="5. 右值引用"></a>5. 右值引用</h3><p>C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p><ul><li>可以取地址的，有名字的，非临时的就是左值；</li><li>不能取地址的，没有名字的，临时的就是右值；</li></ul><p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。</p><p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。</p><ol><li><strong><code>int &amp;&amp;c = 10;</code>专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c &#x3D; 1;</strong></li></ol><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png" alt="image.png"></p><ol start="2"><li><strong>一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp; a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;e = a;<br></code></pre></td></tr></table></figure><h2 id="5-深入理解-C-的-new-和-delete"><a href="#5-深入理解-C-的-new-和-delete" class="headerlink" title="5. 深入理解 C++ 的 new 和 delete"></a>5. 深入理解 C++ 的 new 和 delete</h2><p><strong>New 的不同使用方式：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1 抛异常new</span><br>    <span class="hljs-type">int</span>* p1;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//分配内存并初始化</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_alloc&amp; e)<span class="hljs-comment">//判断是否抛异常</span><br>    &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">//2 不抛异常new</span><br>    <span class="hljs-type">int</span>* p2 = <span class="hljs-built_in">new</span> (std::nothrow)<span class="hljs-built_in">int</span>();<span class="hljs-comment">//不抛异常</span><br>    <span class="hljs-comment">//3 开辟常量内存</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* p3 = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">40</span>);<span class="hljs-comment">//开辟一个常量</span><br><br>    <span class="hljs-comment">//4 定位new</span><br>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* p4 = <span class="hljs-built_in">new</span>(&amp;data) <span class="hljs-built_in">int</span>(<span class="hljs-number">50</span>);<span class="hljs-comment">//在指定地址内存初始化，本身并不开辟内存，只负责初始化</span><br>    <span class="hljs-keyword">delete</span> p1;<br>    <span class="hljs-keyword">delete</span> p2;<br>    <span class="hljs-keyword">delete</span> p3;<br>    <span class="hljs-keyword">delete</span> p4;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-malloc-与-new-的区别"><a href="#1-malloc-与-new-的区别" class="headerlink" title="1. malloc 与 new 的区别"></a>1. malloc 与 new 的区别</h4><ol><li>malloc 按字节开辟内存的；new 开辟内存时需要指定类型；</li><li>malloc 开辟内存返回的都是 <code>void *</code> ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。</li><li>malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。</li><li>malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。</li><li>malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要<code>[]</code>，而数组需要 <code>[]</code>并给上元素个数。</li></ol><h4 id="2-free-和-delete-的区别："><a href="#2-free-和-delete-的区别：" class="headerlink" title="2. free 和 delete 的区别："></a>2. free 和 delete 的区别：</h4><ol><li>free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  </li><li>delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  </li><li>delete 执行其实有两步，先调用析构，再释放；free 只有一步。</li></ol><h4 id="3-解析"><a href="#3-解析" class="headerlink" title="3. 解析"></a>3. 解析</h4><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>反汇编：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png" alt="image.png"></p><p><strong>new 与 delete 其本质也是函数的调用：运算符重载 new  delete</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span><br><span class="hljs-keyword">delete</span> -&gt; <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// new：</span><br><span class="hljs-comment">// 先调用 operator 开辟内存空间</span><br><span class="hljs-comment">// 然后调用对象的构造函数</span><br><span class="hljs-comment">// operator new 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// operator new[] 实现</span><br><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span> size)<br>&#123;<br>    <span class="hljs-comment">// 开辟</span><br>    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size);<br>    <span class="hljs-comment">// 判断</span><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;operator new[] addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// delete：</span><br><span class="hljs-comment">// 调用 p 指向对象的析构函数</span><br><span class="hljs-comment">// 再调用 operator delete 释放空间</span><br><span class="hljs-comment">// operator delete 实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// operator delete[] 实现</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* ptr)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;operator delete[] addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">delete</span> p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">delete</span>[] p;<br>    p = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png" alt="image.png"></p><h4 id="5-new-和delete-能够混用吗？"><a href="#5-new-和delete-能够混用吗？" class="headerlink" title="5. new 和delete 能够混用吗？"></a>5. new 和delete 能够混用吗？</h4><p><strong>C++为什么区分单个元素和数组的内存分配和释放呢？</strong></p><p><strong>情况1：int类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-keyword">delete</span>[]p;<br> <br><span class="hljs-type">int</span> *q = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> q;<br></code></pre></td></tr></table></figure><p>能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。</p><p><strong>情况2：类类型下将其混用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> data = <span class="hljs-number">10</span>):<span class="hljs-built_in">ptr</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(data))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Test</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> ptr;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>单个元素与 <code>delete[]</code> 混用：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br><span class="hljs-keyword">delete</span>[]p1;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png" alt="报错程序"></p><p>程序崩溃。</p><ul><li><strong>数组与 delete 进行混用</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Test *p2 = <span class="hljs-keyword">new</span> Test[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">delete</span> p2;<br></code></pre></td></tr></table></figure><p>程序崩溃。</p><p><strong>分析：</strong></p><p>正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 <code>[]</code> 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 <code>0x100</code>；但是 new 完之后 p2 返回的地址是 <code>0x104</code> 地址，当我们执行 <code>delete[]</code> 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 <code>0x100</code> 开始的 4 字节也释放。</p><p>而 p2 出错是给用户返回的存对象开始的起始地址，<code>delete p2</code> 认为 p2 只是指向了一个对象，只将 <code>Test[0]</code> 对象析构，直接从 <code>0x104 free(p2)</code>，但底层实际是从 <code>0x100</code> 开辟的，因此崩溃。</p><p>而 p1 出错：p1 只是单个元素，从 <code>0x104</code> 开始开辟内存，但是 <code>delete[] p1</code>，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 <code>0x100</code> 释放)因此崩溃。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 C++ 内核</title>
    <link href="/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/"/>
    <url>/2023/08/03/02.C++%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/01.%E7%90%86%E8%A7%A3%20C++%20%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<p>本节内容分为三部分：</p><ol><li>掌握进程虚拟地址空间区域划分</li><li>从指令角度掌握函数调用堆栈详细过程</li><li>从编译器角度理解C++代码的编译、链接</li></ol><p>通过了解底层基础，了解 C++ 的如何运行。</p><h2 id="1-掌握进程虚拟地址空间区域划分"><a href="#1-掌握进程虚拟地址空间区域划分" class="headerlink" title="1. 掌握进程虚拟地址空间区域划分"></a>1. 掌握进程虚拟地址空间区域划分</h2><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> gdata2 = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> gdata3;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata4 = <span class="hljs-number">11</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata5 = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> gdata6;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> c;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> d = <span class="hljs-number">13</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> e = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> f;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上述代码，如何得知各个变量存储的位置？</p><h3 id="1-1-虚拟进程视图"><a href="#1-1-虚拟进程视图" class="headerlink" title="1.1 虚拟进程视图"></a>1.1 虚拟进程视图</h3><p>首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。</p><p>这里附上IBM公司关于<strong>虚拟</strong>的解释:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">它存在，你看得见，它是物理的<br>它存在，你看不见，它是透明的<br>它不存在，你看得见，它是虚拟的<br>它不存在，你看不见，它被删除<br></code></pre></td></tr></table></figure><p>这块空间的内容如下图所示：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png" alt="虚拟进程空间示例图 CN"></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png" alt="虚拟进程空间示例图 EN"></p><blockquote><p>补充：<br>x86 32位体系下的4G虚拟地址空间：<br><strong>Linux默认3:1</strong>来分配 user space : kernal space；<br><strong>Windows默认2:2</strong>来分配 user space : kernal space。</p></blockquote><p>Linux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。</p><p>解释：<br>32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 <code>[0, 2^32]</code> ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。<br>64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 <code>[0, 2^64]</code> ，即 4GB * 4GB &#x3D; 16TB，所以它的寻址范围为 16TB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16TB 。</p><p><strong>为什么是 4G 内存：</strong></p><p>首先我们研究的体系是：<code>x86 32位Linux环境</code>：<br>Linux操作系统会给当前进程分配一个 <code>2^32</code> 大小的空间，那么，<code>2^32</code> 换算过来就是 4G 了。</p><h3 id="1-2-用户空间（User-Space）"><a href="#1-2-用户空间（User-Space）" class="headerlink" title="1.2 用户空间（User Space）"></a>1.2 用户空间（User Space）</h3><ol><li><p>保留区：<br> 128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 “NULL”，它便不会被引用了，从而避免了野指针。</p></li><li><p>指令段【.text】、只读数据段【.rodata】：<br> 指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。</p><blockquote><p>在C++中，不允许普通指针指向常量字符串，需要使用<code>const</code>：<br><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png" alt="示例"></p></blockquote></li><li><p>数据段【.data】：<br> 存放程序中<strong>已初始化且不为0的全局变量或静态变量</strong>。</p></li><li><p>数据段【.bss】：<br> 存放程序中未初始化或者初始化为0的全局变量或静态变量。</p></li><li><p>堆【.heap】：<br> 存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。</p><ul><li>堆用于存放进程<code>运行时动态分配</code>的内存段，可动态扩张或缩减。</li><li>堆中内容是<code>匿名</code>的，无法通过名字进行访问，只能通过<code>指针</code>进行间接访问。</li><li>当进程调用<code>malloc(C)/new(C++)</code>等函数分配内存时，新分配的在堆上<code>动态扩张</code>；当调用<code>free(C)/delete(C++)</code>等函数释放内存时，被释放的内存从堆上<code>动态缩减</code></li><li>分配的堆内存时经过<code>字节对齐</code>的空间，以适合<code>原子操作</code>。</li><li><code>堆管理器</code>通过<code>链表</code>管理每个申请的内存块</li><li>由于堆内存块的申请与释放都是<code>无序</code>的，最终会产生许许多多<code>内存碎片</code>。</li><li>堆的末端由<code>break指针</code>标识，当堆管理器需要更多内存时，可通过<code>系统调用brk和sbrk</code>来<code>移动break指针</code>以扩张堆，一般情况下由系统自动调用。</li></ul></li><li><p>共享库【.dll、.so】：<br> 动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。</p></li><li><p>栈【.stack】：<br> 存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。</p><ul><li><p>栈中存放<code>非静态局部变量</code> <code>函数形参</code> <code>函数返回地址</code>等。</p></li><li><p>栈中内存空间由<code>编译器</code>（静态的）自动分配和释放，行为类似数据结构中的栈结构。</p><blockquote><p>主要用途：</p><ol><li>为函数内部声明的<strong>非静态局部变量</strong>提供存储空间</li><li>记录函数调用过程相关的维护性信息，称为栈帧（stack frame）</li><li>作为<code>临时存储区</code>，用于暂时存放<code>较长的算术表达式部分计算结果</code>，或者运行时调用alloca函数<code>动态分配</code>栈内内存</li></ol></blockquote></li><li><p>栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。</p></li><li><p>查看栈大小：<code>ulimit -s</code>可查看和设置<code>栈的最大值</code>，当程序使用的栈大小超过该值，会发生<code>segmentation fault</code>。</p></li><li><ul><li>栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。</li></ul></li></ul></li><li><p>命令行参数：<br> 保存传递给 main 函数的参数，比如 argc 和 argv。</p></li><li><p>环境变量：<br> 用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。</p></li></ol><h3 id="1-3-进程空间（Kernal-Space）"><a href="#1-3-进程空间（Kernal-Space）" class="headerlink" title="1.3 进程空间（Kernal Space）"></a>1.3 进程空间（Kernal Space）</h3><ol><li><p>内存直接访问区【ZONE_DMA】：<br> 16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。</p></li><li><p>常用区【ZONE_NORMAL】：<br> 892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。</p></li><li><p>高端内存区【ZONE_HIGHMEM】：<br> 128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。</p></li></ol><h3 id="1-4-最终解释"><a href="#1-4-最终解释" class="headerlink" title="1.4 最终解释"></a>1.4 最终解释</h3><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png" alt="image.png"></p><blockquote><p>注意：<br>对于<code>a、b、c以及&#39;&#123;&#39;、&#39;&#125;&#39;</code>来说，是存储在<code>.text</code>指令段的，因为他们生成的都是&#x3D;&#x3D;指令&#x3D;&#x3D;。<br>例如：<br><code>int a = 12</code>：生成汇编指令如下：<code>mov dword ptr[a], 0Ch</code></p></blockquote><h3 id="1-5-好处"><a href="#1-5-好处" class="headerlink" title="1.5 好处"></a>1.5 好处</h3><p><code>数据</code>与<code>代码指令</code>分别开辟空间有以下好处：</p><ol><li>当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。<code>数据区</code>对于进程而言<code>可读可写</code>，<code>代码指令区</code>对于进程而言<code>只读</code>，</li><li>现代CPU一般<code>数据缓存</code>和<code>指令缓存</code>分离，故进程虚拟地址空间中数据与代码指令分离有助于提高<code>CPU缓存命中率</code>。</li><li>若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。</li></ol><p><strong>参考文章：</strong></p><blockquote><p>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1<br>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23<br>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09<br>【4】<a href="https://blog.csdn.net/m0_46308273/article/details/115818195">https://blog.csdn.net/m0_46308273/article/details/115818195</a><br>【5】<a href="https://blog.csdn.net/weixin_45437022/article/details/115409679">https://blog.csdn.net/weixin_45437022/article/details/115409679</a></p></blockquote><h2 id="2-从指令角度掌握函数调用堆栈详细过程"><a href="#2-从指令角度掌握函数调用堆栈详细过程" class="headerlink" title="2. 从指令角度掌握函数调用堆栈详细过程"></a>2. 从指令角度掌握函数调用堆栈详细过程</h2><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png" alt="image.png"><br>栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。</p><p>堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：</p><ul><li>PUSH：将目标内存推入栈顶。</li><li>POP：从栈顶中移除目标。</li></ul><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png" alt="image.png"></p><p>当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 <strong>栈帧</strong> 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）</p><h3 id="2-1-ESP-和-EBP"><a href="#2-1-ESP-和-EBP" class="headerlink" title="2.1 ESP 和 EBP"></a>2.1 ESP 和 EBP</h3><p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p><p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p><p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：</p><ul><li>pop ebp;出栈 栈扩大4byte 因为ebp为32位</li><li>push ebp;入栈，栈减少4byte        </li><li>add esp, 0Ch；表示栈减小12byte</li><li>sub esp, 0Ch；表示栈扩大12byte</li></ul><p>ebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数</span><br><span class="hljs-comment">问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>temp = a + b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>打断点，调试，查看反汇编：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 00007FF637EE23D0  push        rbp  </span><br><span class="hljs-comment">// 00007FF637EE23D2  push        rdi  </span><br><span class="hljs-comment">// 00007FF637EE23D3  sub         rsp,148h  </span><br><span class="hljs-comment">// 00007FF637EE23DA  lea         rbp,[rsp+20h]  </span><br><span class="hljs-comment">// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  </span><br><span class="hljs-comment">// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  </span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 00007FF637EE23EB  mov         dword ptr [a],0Ah  </span><br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">// 00007FF637EE23F2  mov         dword ptr [b],14h  </span><br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 00007FF637EE23F9  mov         edx,14h  </span><br><span class="hljs-comment">// 00007FF637EE23FE  mov         ecx,0Ah  </span><br><span class="hljs-comment">// 00007FF637EE2403  call        sum (07FF637EE11E5h)  </span><br><span class="hljs-comment">// 00007FF637EE2408  mov         dword ptr [ret],eax  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-comment">// 00007FF637EE240B  lea         rdx,[string &quot;ret:&quot; (07FF637EEAC24h)]  </span><br><span class="hljs-comment">// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  </span><br><span class="hljs-comment">// 00007FF637EE2419  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF637EE108Ch)  </span><br><span class="hljs-comment">// 00007FF637EE241E  mov         edx,dword ptr [ret]  </span><br><span class="hljs-comment">// 00007FF637EE2421  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1168h)]  </span><br><span class="hljs-comment">// 00007FF637EE242A  lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF637EE103Ch)]  </span><br><span class="hljs-comment">// 00007FF637EE2431  mov         rcx,rax  </span><br><span class="hljs-comment">// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1170h)]  </span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 00007FF637EE243A  xor         eax,eax  </span><br>&#125;<br><span class="hljs-comment">// 00007FF637EE243C  lea         rsp,[rbp+128h]  </span><br><span class="hljs-comment">// 00007FF637EE2443  pop         rdi  </span><br><span class="hljs-comment">// 00007FF637EE2444  pop         rbp  </span><br><span class="hljs-comment">// 00007FF637EE2445  ret </span><br></code></pre></td></tr></table></figure><h3 id="2-2-解析-main-函数"><a href="#2-2-解析-main-函数" class="headerlink" title="2.2  解析 main 函数"></a>2.2  解析 main 函数</h3><p><strong>1. <code>&#123;</code> 会进行入栈操作，<code>&#125;</code> 进行出栈操作</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png" alt="image.png"></p><p>上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。</p><p><strong>为什么这么做呢？</strong></p><p>因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。</p><p>在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</p><p><code>sub esp, 148h；</code>减去的值根据程序而定</p><p>之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</p><p>之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</p><p>在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png" alt="image.png"></p><p>所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数</p><p><strong>2. 函数内部：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png" alt="image.png"></p><ol><li><p><code>int a = 10;</code> 执行一条 mov 指令： </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [a],0Ah<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png" alt="image.png"></p></li><li><p> 同理 <code>int b = 20;</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">mov         dword ptr [b],14h<br></code></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png" alt="image.png"></p></li><li><p><code>int ret = sum(a,b);</code> 指令：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Assmbly">00F81896 8B 45 EC             mov         eax,dword ptr [b] <br>00F81899 50                   push        eax     #压栈 b的值<br>00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  <br>00F8189D 51                   push        ecx     #压栈 a的值<br>00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call<br>00F818A3 83 C4 08             add         esp,8  <br>00F818A6 89 45 E0             mov         dword ptr [ret],eax <br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-sum-函数调用后"><a href="#2-3-sum-函数调用后" class="headerlink" title="2.3 sum 函数调用后"></a>2.3 sum 函数调用后</h3><p><strong>函数调用参数的压栈顺序:参数由右向左压入堆栈。</strong></p><p><strong>因此上面对应的是：</strong></p><p>先将b的值压入堆栈，再将a的值压入堆栈</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png" alt="image.png"><br><strong>执行call        sum (0F8108Ch)：</strong></p><p><strong>call函数首先会将下一行执行的地址入栈</strong>：假设下一行指令的地址位0x08124458</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png" alt="image.png"></p><p> <strong>第二步进入函数调用：sum</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png" alt="image.png"></p><p>函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈</p><p>第二步：将新的栈底ebp指向原来的栈顶esp</p><p>第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png" alt="image.png"></p><p>接着执行 <code>int temp = 0;</code> 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         dword ptr [temp],0<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png" alt="image.png"></p><p>temp &#x3D; a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png" alt="image.png"></p><p>接着运行<code>return temp;</code>: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov         eax,dword ptr [temp]<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png" alt="image.png"></p><p>接着是<code>函数的右括号“&#125;”</code>：</p><p>（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。<br>（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。<br>（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png" alt="image.png"></p><h3 id="2-4-返回-main-函数后"><a href="#2-4-返回-main-函数后" class="headerlink" title="2.4 返回 main 函数后"></a>2.4 返回 main 函数后</h3><p>接着调用函数完毕，回到主函数：<br>利用了<code>PC寄存器</code>，使得程序知道退出sum后运行哪一条指令：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png" alt="image.png"></p><p><code>add         esp,8</code> ,将压栈的a b 形参空间回收</p><p><code>mov         dword ptr [ret],eax</code> 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png" alt="image.png"><br>最后<code>return 0</code>，程序结束</p><h3 id="2-5-栈溢出问题"><a href="#2-5-栈溢出问题" class="headerlink" title="2.5 栈溢出问题"></a>2.5 栈溢出问题</h3><p>出现栈内存溢出的常见原因有2个：</p><ol><li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li><li>局部静态变量体积太大。</li></ol><blockquote><p>第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。<br>检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。</p></blockquote><blockquote><p>   第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"> 即如果函数这样写：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span>* chdata = <span class="hljs-keyword">new</span>[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>   <span class="hljs-keyword">delete</span> []chdata;<br> &#125;<br>是不会出现这个错误的，而这样写则不行：<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_stack_overflow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-type">char</span> chdata[<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br> &#125;<br>大多数情况下都会出现内存溢出的错误,<br></code></pre></td></tr></table></figure><p>解决办法大致说来也有两种：  </p><ol><li>增加栈内存的数目  </li><li>使用堆内存</li></ol><h2 id="3-从编译器角度理解-C-代码的编译、链接"><a href="#3-从编译器角度理解-C-代码的编译、链接" class="headerlink" title="3. 从编译器角度理解 C++ 代码的编译、链接"></a>3. 从编译器角度理解 C++ 代码的编译、链接</h2><p>整个编译过程分为两大步：</p><p>1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件</p><p>2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序</p><h3 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1 编译"></a>3.1 编译</h3><p>细分为3个阶段：</p><p><strong>1.1）编译预处理</strong></p><p>预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 <code>#include</code>），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 <code>#include</code> 包含的文件代码，进行 <code>#define</code> 宏定义的替换 ， 处理条件编译指令 （<code>#ifndef</code>、 <code>#ifdef</code>、 <code>#endif</code>）等。</p><p>预编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -E main.c -o main.i<br></code></pre></td></tr></table></figure><p>主要规则如下：</p><ol><li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义；</li><li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>;</li><li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；</li><li>删除所有的注释：<code>//</code> 和 <code>/**/</code>；</li><li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；</li><li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要使用它们。</li></ol><blockquote><p>注：<br><code>#pragma lib</code>、<code>pragma link</code><br>等命令是在链接过程处理的。</p></blockquote><p>预编译后得到的文件为：<code>.i</code>文件。</p><p><strong>1.2）编译</strong></p><p>通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</p><p>编译过程相当于如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -S main.i -o main.s<br></code></pre></td></tr></table></figure><p>编译后得到的文件为：<code>.s</code>文件。</p><p><strong>1.3) 汇编</strong></p><p>汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。</p><p>目标文件由段组成，通常至少有两个段：</p><ol><li>.text：包换主要程序的指令。该段是可读和可执行的，一般不可写</li><li>.data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。</li></ol><p>汇编过程我们可以调用汇编器<code>as</code>来完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">as main.s -o main.o  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者：</span>  <br>gcc -c main.s -o mian.o<br></code></pre></td></tr></table></figure><p>这个过程将.s文件转化成.o文件。</p><h3 id="3-2-链接过程"><a href="#3-2-链接过程" class="headerlink" title="3.2 链接过程"></a>3.2 链接过程</h3><p>链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。</p><p><strong>链接的时机</strong>：</p><ul><li>编译时，也就是在源代码被翻译成机器代码时</li><li>加载时，也就是在程序被加载器加载到存储器并执行时</li><li>运行时，由应用程序执行</li></ul><h4 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h4><p><strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p>为了构造可执行文件，<strong>链接器必须完成两个任务：符号解析，重定位</strong></p><ol><li><strong>符号解析：</strong> 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li><li><strong>重定位：</strong> 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li></ol><p>链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png" alt="image.png"></p><p>目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p><h4 id="2-目标文件"><a href="#2-目标文件" class="headerlink" title="2. 目标文件"></a>2. 目标文件</h4><p><strong>三种形式：</strong></p><ol><li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li><li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。</li></ol><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。</p><h4 id="3-可重定位目标文件"><a href="#3-可重定位目标文件" class="headerlink" title="3.  可重定位目标文件"></a>3.  可重定位目标文件</h4><p>一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png" alt="ELF可重定位目标文件"></p><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong> 已编译程序的机器代码。</li><li><strong>.rodata：</strong> 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li><li><strong>.data：</strong> 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li><li><strong>.bss：</strong> 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li><li><strong>.symtab：</strong> 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li><li><strong>.rel.text：</strong> 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li><li><strong>.rel.data：</strong> 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li><li><strong>.debug：</strong> 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li><li><strong>.line：</strong> 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li><li><strong>.strtab：</strong> 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li></ul><h4 id="4-符号和符号表"><a href="#4-符号和符号表" class="headerlink" title="4. 符号和符号表"></a>4. 符号和符号表</h4><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段</p><p>在链接器的上下文中，有三种不同的符号：</p><p>由m定义并能被其他模块引用的全局符号<br>由其他模块定义并被模块m引用的全局符号<br>只被模块m引用的本地符号</p><p>例如：</p><p><code>main.cpp</code> 内容 和 <code>sum.cpp</code> 内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> gdata;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-type">int</span> data = <span class="hljs-number">20</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = gdata;<br><span class="hljs-type">int</span> b = data;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">sum</span>(a, b);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sum.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> gdata = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>g++ -c</strong> 只编译不链接，只生成目标文件</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png" alt="image.png"></p><p> <strong>objdump -t main.o &#x2F;&#x2F; 输出目标文件的符号表：</strong></p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png" alt="image.png"></p><p>第一列：段内偏移；<br>第二列：符号作用域  : local &#x2F;global；<br>第三列：符号类型；<br>第四列：符号所在段（<em>UND</em>外部链接符号，未在本目标文件定义）；<br>第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；<br>第六列：符号名；</p><p>其中main 定义在.text</p><p>data 是全局变量，且初始化定义在.data ,也就是m定义并能被其他模块引用的全局符号。<br>gdata 和 sum 函数是声明，因此是<em>UNG</em>，也就是由其他模块定义并被模块 m 引用的全局符号。</p><p>第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配</p><p>在sum.o中：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png" alt="image.png"></p><p>gdata 是出刷的全局变量 在 .data中；sum 函数在.text中</p><p>readelf -h 查看elf文件的头文件信息<br>可见目标文件的elf文件，其类型为REL(可重定位文件)。 </p><p>objdump -s 显示全部Header信息，还显示他们对应的十六进制文件代码：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png" alt="image.png"></p><p>有调试信息的：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png" alt="image.png"></p><p>可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。</p><h4 id="5-符号解析"><a href="#5-符号解析" class="headerlink" title="5. 符号解析"></a>5. 符号解析</h4><p>链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（<em>UNG</em>）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）</p><p> <strong>链接器如何解析多重定义的全局符号：</strong></p><p>在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。<br>       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：</p><p>规则1：不允许有多个强符号。<br>规则2：如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><p><strong>链接器如何使用静态库来解析引用：</strong></p><p>在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。</p><blockquote><ol><li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。</li><li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。</li><li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li></ol></blockquote><p>这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。</p><p>另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在命令行上重复库。</p><h4 id="6-重定向"><a href="#6-重定向" class="headerlink" title="6. 重定向"></a>6. 重定向</h4><p>一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位有两步组成：</p><ol><li><strong>重定位节和符号定义</strong>。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用</strong>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<code>重定位条目</code>的可重定位目标模块中的数据结构。</li></ol><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png" alt="image.png"></p><p>链接后：所有的符号都有虚拟地址</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png" alt="image.png"></p><p>汇编中，全局变量和函数都有了地址。</p><h4 id="7-可执行目标文件"><a href="#7-可执行目标文件" class="headerlink" title="7. 可执行目标文件"></a>7. 可执行目标文件</h4><p>可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<code>.text</code> 、<code>.rodata</code> 和 <code>.data</code> 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。</p><p>ELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png" alt="image.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署流程</title>
    <link href="/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/08/01/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>主要使用技术合集：</strong></p><ol><li>Hexo 博客系统</li><li>Fluid 博客模板</li><li>Obsidian + Github Pages 部署。</li></ol><h2 id="1-Hexo-博客系统"><a href="#1-Hexo-博客系统" class="headerlink" title="1. Hexo 博客系统"></a>1. Hexo 博客系统</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <strong>Markdown</strong>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-1-安装需求"><a href="#1-1-安装需求" class="headerlink" title="1.1 安装需求"></a>1.1 安装需求</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li>Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li><li>Git</li></ul><h3 id="1-2-安装-Hexo"><a href="#1-2-安装-Hexo" class="headerlink" title="1.2 安装 Hexo"></a>1.2 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>全局安装后即可随时使用</p><h3 id="1-3-创建博客"><a href="#1-3-创建博客" class="headerlink" title="1.3 创建博客"></a>1.3 创建博客</h3><p>安装完成后，就可以在终端使用 <code>hexo</code> 指令了，可以使用以下指令创建一个 hexo 项目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">hexo init hexo-blog  <br><span class="hljs-built_in">cd</span> hexo-blog  <br>yarn install<br></code></pre></td></tr></table></figure><p>完成后项目目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.  <br>├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  <br>├── package.json  <br>├── scaffolds # 文章模板  <br>├── source  <br>|   ├── _drafts  <br>|   └── _posts # 你的 markdown 文章就需要存放在此目录下  <br>└── themes # 存放主题源码<br></code></pre></td></tr></table></figure><h2 id="2-配置-Fluid-主题"><a href="#2-配置-Fluid-主题" class="headerlink" title="2. 配置 Fluid 主题"></a>2. 配置 Fluid 主题</h2><ol><li>NPM 安装</li><li>源码安装</li></ol><h3 id="2-1-NPM-安装"><a href="#2-1-NPM-安装" class="headerlink" title="2.1 NPM 安装"></a>2.1 NPM 安装</h3><p>以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，使用 npm 安装只需要执行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">yarn add hexo-theme-fluid  <br># 或者  <br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p><h3 id="2-2-源码安装"><a href="#2-2-源码安装" class="headerlink" title="2.2 源码安装"></a>2.2 源码安装</h3><p>源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。</p><p>仍然以 <a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a> 主题为例，在项目的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Releases</a> 页面中下载源码文件：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png"></p><p>下载解压后，在 <code>themes</code> 目录下创建一个 <code>fluid</code> 目录，将源码复制到该目录下，如下：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png" alt="image.png"></p><h3 id="2-3-应用主题"><a href="#2-3-应用主题" class="headerlink" title="2.3 应用主题"></a>2.3 应用主题</h3><p>当你安装成功后，需要在 <code>_config.yml</code> 中将使用的主题设置为你下载好的主题，找到 <code>theme</code> 配置项，将其修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions  </span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/  </span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/  </span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h3 id="2-4-配置第三方主题"><a href="#2-4-配置第三方主题" class="headerlink" title="2.4 配置第三方主题"></a>2.4 配置第三方主题</h3><p>如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 <code>_config.fluid.yml</code> 文件修改相关配置；</p><p>如果你是以源码方式安装的主题，就不需要创建 <code>_config.fluid.yml</code> 文件了，只需要修改 <code>/themes/fluid/_config.yml</code> 文件中的配置就可以了。</p><blockquote><p>注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档</p></blockquote><h2 id="3-部署-Github-Pages"><a href="#3-部署-Github-Pages" class="headerlink" title="3. 部署 Github Pages"></a>3. 部署 Github Pages</h2><p>然后在 Github 中创建一个新项目仓库，名称必须为 <code>&lt;你的github用户名&gt;.github.io</code>，创建完成后按照指引将你的博客代码上传到 github。</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png" alt="image.png"></p><h3 id="3-1-开启-Github-Pages"><a href="#3-1-开启-Github-Pages" class="headerlink" title="3.1 开启 Github Pages"></a>3.1 开启 Github Pages</h3><p>在执行这一步之前，先创建一个没有任何代码的新分支，命名为 <code>gh-pages</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b gh-pages  <br>rm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  <br>git push --set-upstream origin release # 上传 release 分支<br></code></pre></td></tr></table></figure><p>在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 <code>gh-pages</code> 分支：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png" alt="image.png"></p><p>这就意为这你在 <code>gh-pages</code> 上传的任何 html 都可以使用 <code>&lt;你的github用户名&gt;.github.io</code> 这个域名来访问了。</p><p>我们切回 <code>master</code> 分支，之后执行 <code>yarn build</code> 将生成的 <code>public</code> 目录下的文件复制一份，然后重新切回 <code>gh-pages</code> 分支，将刚才复制的内容粘贴到 <code>gh-pages</code> 分支下，并上传代码。如果没有操作失误的话，访问 <code>&lt;你的github用户名&gt;.github.io</code> 即可看到你的博客了。</p><h3 id="3-2-Github-Action-自动部署"><a href="#3-2-Github-Action-自动部署" class="headerlink" title="3.2 Github Action 自动部署"></a>3.2 Github Action 自动部署</h3><p>使用 Github Action 来帮我们做自动化部署。</p><p>Github Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。</p><p>关于 Github Action，详细教程可以查看 <a href="https://docs.github.com/cn/actions">官方文档</a>。按照文档中所描述的，只要我们在代码中添加一层 <code>.github/workflows</code> 目录，并且在目录下创建一个 <code>yml</code> 文件来描述具体的行为，就可以实现开启 Github Action。</p><p>如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 <code>.github/workflows/blog-deploy.yml</code> 文件中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># default branch</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">permissions:</span><br>      <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">16.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;16&quot;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.ACCESS_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br></code></pre></td></tr></table></figure><p>保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png" alt="image.png"></p><p>但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 <a href="https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context">secrets 上下文</a>，即 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code> 这里。</p><p><code>$&#123;&#123; xxx &#125;&#125;</code> 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 <code>secrets.ACCESS_TOKEN</code> 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。</p><p>首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 <code>Setting</code>，进入设置后选择 <code>Developer settings</code>，再选择 <code>Persona access token</code> 就可以看到它了：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png" alt="image.png"></p><p>点击右上角的 <code>Generate new token</code> 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 <code>repo</code> 和 <code>workflow</code> 权限，并将 <code>Expiration</code> 过期时间选为 <code>No expiration</code>：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png" alt="image.png"></p><blockquote><p>这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！</p></blockquote><p>点击 <code>Generate token</code> 按钮后，就会生成一个 <code>ghp</code> 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png" alt="image.png"></p><p>复制该 token 后，进入到博客仓库的设置中，选择 <code>Secrets - Actions</code>，点击 <code>New repository secret</code> 按钮生成一个密钥信息：</p><p><img src="https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png" alt="image.png"></p><p>我们将密钥名称写为 <code>ACCESS_TOKEN</code>，值填入刚才复制的 Github token。</p><blockquote><p>这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 <code>secret</code> 上下文对象所获取到。</p></blockquote><p>至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>Blog</tag>
      
      <tag>Obdidian</tag>
      
      <tag>Github Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
