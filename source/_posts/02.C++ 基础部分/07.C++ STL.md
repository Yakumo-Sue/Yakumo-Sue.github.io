---
title: 07.C++ STL
tags: ['C++']
index_img: /img/Blog-Logo/C++_Logo.png
banner_img: /img/Post-Banner/01.blogs/1316853.jpeg
---

本节分为十部分：

1. vector 容器
2. deque 容器
3. list 容器
4. vector、deque、list 对比分析
5. 详解容器适配器
6. 无序关联容器
7. 有序关联容器
8. 迭代器 iterator
9. 函数对象
10. 泛型算法和绑定器

**STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。**

## 1. vector 容器

**vector**：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 

容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。

### 1. 使用方法合集

**语法结构：**

~~~c++
vector<type> TypeName;
~~~

**使用方式：** 使用前包含头文件

~~~c++
#include <vector>
~~~

1. **增加：**

- **`push_back()`**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。
- **`insert(迭代器，迭代器位置)`**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。

2. **删除：**

- **`pop_back()`**：在容器末尾删除一个元素，时间复杂度O(1)。
- **`erase()`**：删除it迭代器指向的元素，时间复杂度O(n)。

3. **查询：**

- **`operator[]`**：数据下标的随机访问`vec[5]`，时间复杂度O(1)。
- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。
- **`find()\for_each`**：泛型算法。
- **`foreach`**：C++11提供的语法糖，通过迭代器iterator来实现的。

4. **常用方法：**

- **`size()`**：返回容器底层有效元素的个数。
- **`empty()`**：判断容器是否为空。
- **`reserve()`**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。
- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。
- **`swap()`**：两个容器进行元素交换。

### 2. 容器使用

1. **对 vector 容器中元素遍历。**

~~~c++
#include <iostream>
// 使用 vector 库
#include <vector>
using namespace std;

int main()
{
	// 定义 vector 
	vector<int> vec;
	int i = 0;
	for (i = 0; i < 20; i++)
	{
		vec.push_back(rand() % 100 + 1);
	}

	// 1. 运算符重载遍历
	int size = vec.size();
	for (int i = 0; i < size; i++)
	{
		cout << vec[i] << " ";
	}
	cout << endl;

	// 2. 迭代器遍历
	auto it = vec.begin();
	for (; it != vec.end(); it++)
	{
		cout << *it << " ";
	}

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png)

2. **把 vec 容器中所有偶数全部删除**

~~~c++
#include <iostream>
// 使用 vector 库
#include <vector>
using namespace std;

int main()
{
	// 定义 vector 
	vector<int> vec;
	int i = 0;
	for (i = 0; i < 20; i++)
	{
		vec.push_back(rand() % 100 + 1);
	}

	auto it1 = vec.begin();
	while (it1 != vec.end())
	{
		if (*it1 % 2 == 0) 
		{
			it1 = vec.erase(it1);
		}
		else
		{
			it1++;
		}
	}

	// 2. 迭代器遍历
	auto it2 = vec.begin();
	for (; it2 != vec.end(); it2++)
	{
		cout << *it2 << " ";
	}

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png)

3. **在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45**

~~~c++
#include <iostream>
// 使用 vector 库
#include <vector>
using namespace std;

int main()
{
	// 定义 vector 
	vector<int> vec;
	int i = 0;
	for (i = 0; i < 20; i++)
	{
		vec.push_back(rand() % 100 + 1);
	}

	//vec的operator[]运算符重载函数进行vector遍历
	int size = vec.size();
	for (int i = 0; i < size; ++i)
	{
		cout << vec[i] << " ";
	}
	cout << endl;

	// 删除
	auto it1 = vec.begin();
	while (it1 != vec.end())
	{
		if (*it1 % 2 == 0) 
		{
			it1 = vec.erase(it1);
		}
		else
		{
			it1++;
		}
	}

	// 迭代器遍历
	auto it2 = vec.begin();
	for (; it2 != vec.end(); it2++)
	{
		cout << *it2 << " ";
	}
	cout << endl;

	// 添加
	for (it2 = vec.begin(); it2 != vec.end(); it2++)
	{
		if (*it2 % 2 != 0)
		{
			it2 = vec.insert(it2, *it2-1);
			++it2;
		}
	}

	it2 = vec.begin();
	for (; it2 != vec.end(); it2++)
	{
		cout << *it2 << " ";
	}
	cout << endl;

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png)

4. **reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。**

默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。

~~~c++
#include <iostream>
// 使用 vector 库
#include <vector>
using namespace std;

int main()
{
	vector<int> vec;// 默认定义的 vector 底层为 0
	vec.reserve(20);// 给 vector 容器预留空间

	cout << "Before，vec.empty()：" << vec.empty() << endl;
	cout << "Before，vec.size()：" << vec.size() << endl;

	for (int i = 0; i < 20; i++)
	{
		vec.push_back(rand() % 100 + 1);
	}

	cout << "After，vec.empty()：" << vec.empty() << endl;
	cout << "After，vec.size()：" << vec.size() << endl;

}
~~~

输出结果: `empty()` 是 1 为空，0 为非空。刚开始为空，`reserve(20)` 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png)

5. **resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。**

`resize()` 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。

~~~c++
#include <iostream>
// 使用 vector 库
#include <vector>
using namespace std;

int main()
{
	vector<int> vec;//默认定义的vector底层为0
	vec.resize(20);

	cout << "Before，vec.empty()：" << vec.empty() << endl;
	cout << "Before，vec.size()：" << vec.size() << endl;

	for (int i = 0; i < 20; i++)
	{
		vec.push_back(rand() % 100 + 1);
	}

	cout << "After，vec.empty()：" << vec.empty() << endl;
	cout << "After，vec.size()：" << vec.size() << endl;

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png)

## 2. deque 容器

**deque：双端队列容器，底层为动态开辟的二维数组。** **

一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 `oldsize/2` 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。

