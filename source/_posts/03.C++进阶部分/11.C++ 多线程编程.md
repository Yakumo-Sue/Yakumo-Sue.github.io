---
title: 11.C++ 多线程编程
tags: ['C++']
index_img: /img/Blog-Logo/C++_Logo.png
banner_img: /img/Post-Banner/01.blogs/1314358.jpg
---

本节分为五部分：

- C++ 11 的 thread 多线程类
- 线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁
- 线程间同步通信 - 生产者消费者模型
- 再谈 lock_guard 和 unique_lock
- 基于 CAS 操作的 atomic 原子类型

**什么是多线程？**

**多线程（multithreading）**：是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。

在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。

**进程与线程：**

进程是正在运行的程序的实例，而线程是是进程中的实际运作单位。

线程是操作系统能够进行**运算调度的最小单位**。被包含在进程之中，是**进程的实际运作单位**。一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发执行多个线程，每个线程会执行不同的任务。

**区别：**

- 一个程序有且只有一个进程，但可以拥有至少一个的线程。
- 不同进程拥有不同的地址空间，互不相关，而不同线程共同拥有相同进程的地址空间。

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221613179.png)

## 1. C++ 11 的 thread 多线程类

C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是`<atomic>` ,`<thread>`,`<mutex>`,`<condition_variable>` 和 `<future>`。

1. `<atomic>`：该头文件主要声明两个类：
	- `std::atomic`
	- `std::atomic_flag`
	另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。
2. `<thread>`：该头文件主要声明一个类：
	- `std::thread`
	- 另外 `std::this_thread` 命名空间也在该头文件中。
3. `<mutex>`：该头文件主要声明了与互斥量（mutex）相关的类：
	- `std::mutex`
	- `std::lock_guard`
	- `std::unique_lock`
	以及其他的类型和函数。
4. `<condition_variable>`：该头文件主要声明了与条件变量相关的类：
	- `std::condition_variable`
	- `std::condition_varible_any`
5. `<future>`：该头文件主要声明了两个 Provider 类和 两个 Futrue 类：
	- `std::promise`：Provider 类
	- `std::package_task`：Provider 类
	- `std::future`：Futrue 类
	- `std::shared_futrue`：Futrue 类
	另外还有一些与之相关的类型和函数：
	- `std::async()` 函数声明在该文件中。

### 1. 开启和关闭线程

在**语言级别**，一般调用 std 名称空间的 thread 类来启动一个线程。 

其对应操作系统层次的一下系统调用：

~~~txt
windows： createThread
linux：   pthread_create
~~~

以下是 thread 类的一个构造函数：

~~~c++
template <class Fn, class... Args>
explicit thread (Fn&& fn, Args&&... args);
~~~

可以看到，其需要一个**线程函数（也可以是类对象和 lambda 表达式）以及这个函数所需要传入的参数**。

1. **引入头文件：**

~~~c++
#include <thread>
~~~

2. **创建线程对象：**

~~~c++
#include <iostream>
#include <thread>
using namespace std;

void threadHadnle1(int time)
{
	// 让子线程睡眠 time 秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread1!" << endl;
}

void threadHadnle2(int time)
{
	// 让子线程睡眠 time 秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread2!" << endl;
}

int main()
{
	// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。
	std::thread t1(threadHadnle1, 2);
	std::thread t2(threadHadnle1, 3);


	cout << "main thread done" << endl;

	return 0;
}
~~~

原因：

主线程运行完成后，查看如果当前进程还有未运行完成的子线程，进程就会异常终止。

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221632970.png)

线程除了站在我们角度上的以名字区分，它还有一个属于自己的 id！通过 `std::thread::get_id()` 便可以获取到该成员对象线程的 id。

~~~c++
cout << "t1 thread: ID = " << t1.get_id() << endl;
~~~

而在线程函数中通过 `std::this_thread::get_id()` 获取线程 id。

~~~c++
cout << "Inside t2 thread: ID = " << std::this_thread::get_id() << endl;
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221643499.png)


3. **终止子线程：**

**t.join()**：创建线程执行线程函数，调用该函数会阻塞当前线程，直到线程执行完 join 才返回；等待t线程结束，当前线程继续往下运行

~~~c++
#include <iostream>
#include <thread>
using namespace std;

void threadHadnle1(int time)
{
	// 让子线程睡眠 time 秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread1!" << endl;
}

void threadHadnle2(int time)
{
	// 让子线程睡眠 time 秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread2!" << endl;
}

int main()
{
	// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。
	std::thread t1(threadHadnle1, 2);
	std::thread t2(threadHadnle1, 3);

	// 终止
	t1.join();
	t2.join();

	cout << "main thread done" << endl;

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221638021.png)

**t.detach()**：detach 调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的 `std::thread` 对象失去对目标线程的关联，无法再通过 `std::thread` 对象取得该线程的控制权，由操作系统负责回收资源；主线程结束，整个进程结束，所有子线程都自动结束了！

~~~c++
#include <iostream>
#include <thread>
using namespace std;

void threadHadnle1(int time)
{
	// 让子线程睡眠 time 秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread1!" << endl;
}

void threadHadnle2(int time)
{
	// 让子线程睡眠 time 秒
	std::this_thread::sleep_for(std::chrono::seconds(time));
	cout << "hello thread2!" << endl;
}

int main()
{
	// 创建一个线程对象，需要传入一个线程函数，新线程就开始运行。
	std::thread t1(threadHadnle1, 2);
	std::thread t2(threadHadnle1, 3);

	// 终止
	t1.detach();
	t2.detach();

	cout << "main thread done" << endl;

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308221639317.png)

**线程如何结束：**

1. 线程函数返回（推荐）
2. 调用 ExitThread 函数，线程自行撤销
3. 同一进程或者另一个进程中调用 TerminateThread 函数
4. ExitProcess 和 TerminateProcess 函数可以终止线程进行

## 2. 线程间互斥 - mutex 互斥锁和 lock_guard 自动释放锁

