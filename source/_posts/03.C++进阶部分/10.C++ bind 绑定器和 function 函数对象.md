---
title: 10.C++ bind 绑定器和 function 函数对象
tags: ['C++']
index_img: /img/Blog-Logo/C++_Logo.png
banner_img: /img/Post-Banner/01.blogs/1314358.jpg
---

本节分为四部分：

1. C++ STL 中的绑定器
2. function 示例和实现
3. bind 和 function 实现线程池
4. lambda 表达式

## 1. C++ STL 中的绑定器
### 1. 介绍绑定器

~~~c++
std::bind1st
// 和
std::bind2nd
~~~

以上两个函数用于将一个 **二元函数对象** 转换为 **一元函数对象** 。

bind 意思为：**绑定**，1st 代表 first；2nd 代表 second，说明如下：

~~~c++
template<typename F, typename T>
std::binder1st<F> bind1st(const F& f, const T& x);

template<typename F, typename T >
std::binder2nd<F> bind2nd( const F& f, const T& x )
~~~

将给定的参数 x 绑定到 二元函数对象 F 的第一个或第二个形参。也就是说，将 x 存储在该包装器中，如果调用该包装器，则将 x 作为 F 的第一个或第二个形参传递。

`bind1st`：相当于操作：`x Operation value` == `operator()` 的第一个形参变量绑定成一个确定的值。
`bind2nd`：相当于操作：`Operation value x` == `operator()` 的第二个形参变量绑定成一个确定的值。

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211548667.png)

### 2. 实例

~~~c++
#include <iostream>
#include <vector>
#include <functional>
#include <algorithm>
#include <ctime>
using namespace std;

// 创建函数
template<typename Container>
void showContainer(Container& con)
{
	// 编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量
	// typename告知编译器后面类型的作用域后面是类型
	typename Container::iterator it = con.begin();
	for (; it != con.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

int main()
{
	// 定义容器
	vector<int> vec;
	srand(time(nullptr));
	
	// 遍历添加
	int i = 0;
	for (i = 0; i < 10; ++i)
	{
		vec.push_back(rand() % 100 + 1);//随机出来的数字，并不是有序的 
	}

	// 初始化状态
	cout << "Init：";
	showContainer(vec);

	// 从大到小排序
	cout << "Sort：";
	sort(vec.begin(), vec.end(), greater<int>());
	showContainer(vec);

	// 把 70 按照顺序插入到 vec 容器当中，找第一个小于 70 的数字
	vector<int>::iterator it = find_if(
		vec.begin(),
		vec.end(),
		bind1st(greater<int>(), 70)
	);
	// auto it1 = find_if(vec.begin(), vec.end(),bind2nd(less<int>(), 70));
	// 判断
	if (it != vec.end())
	{
		vec.insert(it, 70);
	}
	cout << "Insert：";
	showContainer(vec);

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211600501.png)

### 3. 实现原理

1. **`find_if`** 源码：

~~~c++
// FUNCTION TEMPLATE find_if
_EXPORT_STD template <class _InIt, class _Pr>
_NODISCARD _CONSTEXPR20 _InIt find_if(
_InIt _First, 
const _InIt _Last, 
_Pr _Pred
) 
{ 
// find first satisfying _Pred
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}
~~~

其中第三个参数 `_Pred` 是一个一元函数对象

2. **`bind1st`** 源码：

~~~c++
// FUNCTION TEMPLATE bind1st
_EXPORT_STD template <class _Fn, class _Ty>
_NODISCARD binder1st<_Fn> bind1st(
const _Fn& _Func, 
const _Ty& _Left
) 
{
// return a binder1st functor adapter
    typename _Fn::first_argument_type _Val(_Left);
    return binder1st<_Fn>(_Func, _Val);
}
~~~

它是一个函数模板，返回一元函数对象 `binder1st`

3. **`bind2nd`** 源码：

~~~c++
// CLASS TEMPLATE binder1st
template<class _Fn>
	class binder1st
		: public unary_function<
		typename _Fn::second_argument_type,
		typename _Fn::result_type>
{	
// functor adapter _Func(stored, right)
public:
	typedef unary_function<
	typename _Fn::second_argument_type,
	typename _Fn::result_type> _Base;
	typedef typename _Base::argument_type argument_type;
	typedef typename _Base::result_type result_type;
 
	binder1st(
	const _Fn& _Func,
	const typename _Fn::first_argument_type& _Left)
	: op(_Func)
	, value(_Left)
	{	
		// construct from functor and left operand
	}
 
	result_type operator()(const argument_type& _Right) const
	{	
		// apply functor to operands
		return (op(value, _Right));
	}
 
	result_type operator()(argument_type& _Right) const
	{	
		// apply functor to operands
		return (op(value, _Right));
	}
 
protected:
	// the functor to apply
	_Fn op;
	// the left operand
	typename _Fn::first_argument_type value;	
};
~~~

一元函数对象默认构造函数接受两个参数， `op` 和 `value`。赋值运算符接收一个参数，并使用传入的 `op` 和 `vaule` 进行运算：`op(value, _Right)`

### 4. 实现

~~~c++
// bind1st 实现
#include <iostream>
#include <vector>
#include <functional>
#include <algorithm>
#include <ctime>
using namespace std;

// 创建函数
template<typename Container>
void showContainer(Container& con)
{
	// 编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量
	// typename告知编译器后面类型的作用域后面是类型
	typename Container::iterator it = con.begin();
	for (; it != con.end(); it++)
	{
		cout << *it << " ";
	}
	cout << endl;
}

// 实现 find_if
template<typename Iterator, typename Compare>
Iterator my_find_if(Iterator first, Iterator last, Compare comp)
{
	// 遍历这2个迭代器之间的元素，如果满足函数对象的运算，就返回当前迭代器，如果都不满足，返回end()
	for (; first != last; first++)
	{
		// comp.operator()(*first)一元函数对象，因为要从容器拿1个元素和它指定的元素比较
		if (comp(*first))
		{
			// my_find_if 需要 一元函数对象，而在库里面都是二元的
			return first;
		}
	}
	return last;
}

// 实现 bind1st
// 绑定器是函数对象的一个应用
template<class Compare, class T>
class _mybind1st
{
public:
	_mybind1st(Compare comp, T val)
		: _comp(comp)
		, _val(val)
	{
		// 列表初始化
	}

	// 函数对象
	bool operator()(const T& second)
	{
		return _comp(_val, second);
	}

private:
	Compare _comp;
	T _val;
};

// mybind1st(greater<int>(), 70)
template<typename Compare, typename T>
_mybind1st<Compare, T> mybind1st(Compare comp, const T& val)
{
	// 直接使用函数模板，好处是，可以进行类型的推演
	return _mybind1st<Compare, T>(comp, val);
}

int main()
{
	vector<int> vec;
	srand(time(nullptr));
	for (int i = 0; i < 20; ++i)
	{
		vec.push_back(rand() % 100 + 1);
	}
	cout << "Init：";
	showContainer(vec);

	// greater 二元函数对象
	// 大到小排序
	sort(vec.begin(), vec.end(), greater<int>());
	cout << "Sort：";
	showContainer(vec);

	/*
	把70按顺序插入到vec容器当中   找第一个小于70的数字
	operator()(const T &val)
	greater   a > b
	less      a < b
	绑定器 + 二元函数对象 => 一元函数对象
	bind1st: + greater bool operator()(70, const _Ty& _Right)
	bind2nd: + less bool operator()(const _Ty& _Left, 70)
	*/
	vector<int>::iterator it1 = my_find_if(
		vec.begin(), 
		vec.end(),
		mybind1st(greater<int>(), 70)
	);
	// auto it1 = my_find_if(vec.begin(), vec.end(),bind2nd(less<int>(), 70));
	if (it1 != vec.end())
	{
		vec.insert(it1, 70);
	}
	cout << "Insert：";
	showContainer(vec);

	return 0;
}
~~~

![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308211759070.png)

## 2. function 示例和实现

