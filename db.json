{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Blog-Logo/Hexo.png","path":"img/Blog-Logo/Hexo.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/01.blogs/1316853.jpeg","path":"img/Post-Banner/01.blogs/1316853.jpeg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/1316292.jpeg","path":"img/Post-Banner/00.defaults/1316292.jpeg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/1316737.jpeg","path":"img/Post-Banner/00.defaults/1316737.jpeg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/avatar.jpg","path":"img/Post-Banner/00.defaults/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/Learning.jpg","path":"img/Post-Banner/00.defaults/Learning.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/default.png","path":"img/Post-Banner/00.defaults/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Blog-Logo/logo.png","path":"img/Blog-Logo/logo.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Blog-Logo/C++_Logo.png","path":"img/Blog-Logo/C++_Logo.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/Post-Banner/01.blogs/1310700.jpg","path":"img/Post-Banner/01.blogs/1310700.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1690850878644},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688287284000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1688287284000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1688287284000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1688287284000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1688287284000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1688287284000},{"_id":"themes/fluid/README.md","hash":"49f681a203eecfa7127ac22edc13bd3b49693d0a","modified":1688287284000},{"_id":"themes/fluid/README_en.md","hash":"49541d4ec48c4b517c5b3fe17a2e92d87090d007","modified":1688287284000},{"_id":"themes/fluid/_config.yml","hash":"cc55a9d2463a16b6df404b364197fa4c5290416a","modified":1690874912247},{"_id":"themes/fluid/package.json","hash":"41983970c0977b3c626c3f1e3c714cf78ac6a04e","modified":1688287284000},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1688287284000},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1688287284000},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1688287284000},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1688287284000},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1688287284000},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1688287284000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1688287284000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1688287284000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1688287284000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1688287284000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1688287284000},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1688287284000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1688287284000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1688287284000},{"_id":"themes/fluid/layout/index.ejs","hash":"9b4c154462ce78de4c9ea7dd15dce4ca8e8c1cf8","modified":1688287284000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1688287284000},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1688287284000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1688287284000},{"_id":"themes/fluid/layout/post.ejs","hash":"75ab6958d929e92566ca580d0b8bd0eeae10649a","modified":1688287284000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1688287284000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1688287284000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1688287284000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1688287284000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1688287284000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1688287284000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1688287284000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1688287284000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1688287284000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1688287284000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1688287284000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1688287284000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1688287284000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1688287284000},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1688287284000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1688287284000},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1688287284000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1688287284000},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1688287284000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1688287284000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"0047666f996c54017e06668b5242ed8a311ebce0","modified":1688287284000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1688287284000},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1688287284000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1688287284000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1688287284000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1688287284000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1688287284000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1688287284000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"4f68c80bd1395e2f6d11e373116e54de11cb62e8","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"529f3069742b3d338c769ba2d836e7f3c342a09d","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1688287284000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1688287284000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1688287284000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1688287284000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"b2f61b91fffb17d11ad56811f07d52d23f012741","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"8d3ae1ec6660fbb0e563bc08c2f8deefde1f3bf6","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1688287284000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"e413212e5a667d5b8299c4d2a39c4dfa1378d119","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"ecf3488566b374d564ae985c61e08562ba908023","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1688287284000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1688287284000},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1688287284000},{"_id":"public/local-search.xml","hash":"1c6faa4fa05c67896334b705a3c02b8e2d8fea24","modified":1690851286626},{"_id":"public/archives/index.html","hash":"13a6a48ded70f8ea6a49b29801185d8514dd2acd","modified":1690851286626},{"_id":"public/index.html","hash":"0ad4e2dc2eadbf1c83c748259c13f182571e30a7","modified":1690851286626},{"_id":"public/archives/2023/index.html","hash":"60f29358d5a7cb1b9ac52bb490a7fb9ce4f87b82","modified":1690851286626},{"_id":"public/404.html","hash":"2fe861cf2ebd4826dd4e3cf667b6f3cfbb0b968c","modified":1690851286626},{"_id":"public/archives/2023/08/index.html","hash":"8798efeeea0bc380234b2a5ab51a326861ab8682","modified":1690851286626},{"_id":"public/tags/index.html","hash":"c19cd5597ce64d4c75ac505c75ef5d25d9da409f","modified":1690851286626},{"_id":"public/links/index.html","hash":"3d560f00d7ad46ee5863ea2500329eb41b6fd658","modified":1690851286626},{"_id":"public/categories/index.html","hash":"3493f14380a92ef9a3404b97ccebf6ae4213a328","modified":1690851286626},{"_id":"public/2023/08/01/hello-world/index.html","hash":"47b0ef8dc5f9299a8f22edf0877c5889803b4b1c","modified":1690851286626},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1690851286626},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1690851286626},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1690851286626},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1690851286626},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1690851286626},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1690851286626},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1690851286626},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1690851286626},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1690851286626},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1690851286626},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1690851286626},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1690851286626},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1690851286626},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1690851286626},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1690851286626},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1690851286626},{"_id":"public/css/main.css","hash":"526a4522eb54bb51772f51fb98295dc4fe03429f","modified":1690851286626},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1690851286626},{"_id":"source/_posts/博客部署流程.md","hash":"da5d0815dbed06bc293fc0b82bb3c8bd74fcfb31","modified":1690874487889},{"_id":"source/about/index.md","hash":"d888b83f6199e9d433b6927168467e2e8a07c132","modified":1690858130957},{"_id":"themes/fluid/source/img/avatar.jpg","hash":"97e288f919a03fb541e90c450c2ccd1cccdfc9c7","modified":1690855393532},{"_id":"themes/fluid/source/img/logo.png","hash":"1dfbe7ba9fbd39ba5eba6c409fa2981133981b26","modified":1690855369221},{"_id":"themes/fluid/source/img/Learning.jpg","hash":"c8176480228876fb4ad2e356db3ab843daba3d1b","modified":1690855379530},{"_id":"themes/fluid/source/img/1316292.jpeg","hash":"c578f56ee5c408ca8102d5fd7e38ba5a3f195b53","modified":1687736865433},{"_id":"themes/fluid/source/img/1316737.jpeg","hash":"150ffd7286023d7b953553d3bd0a81197cd47e37","modified":1687737426919},{"_id":"themes/fluid/source/img/Blog-Logo/Hexo.png","hash":"c96a69c6e3a14bf85887052e5925225a051e5fd9","modified":1690871880925},{"_id":"themes/fluid/source/img/Blog-Logo/logo.png","hash":"1dfbe7ba9fbd39ba5eba6c409fa2981133981b26","modified":1690855369221},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/avatar.jpg","hash":"97e288f919a03fb541e90c450c2ccd1cccdfc9c7","modified":1690855393532},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1688287284000},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/Learning.jpg","hash":"c8176480228876fb4ad2e356db3ab843daba3d1b","modified":1690855379530},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/1316292.jpeg","hash":"c578f56ee5c408ca8102d5fd7e38ba5a3f195b53","modified":1687736865433},{"_id":"themes/fluid/source/img/Post-Banner/01.blogs/1316853.jpeg","hash":"9016ce7a4acef621762a2d33e059d28f24a9ef91","modified":1690872039819},{"_id":"themes/fluid/source/img/Post-Banner/00.defaults/1316737.jpeg","hash":"150ffd7286023d7b953553d3bd0a81197cd47e37","modified":1687737426919},{"_id":"source/_posts/02.C++ 基础部分/01.理解 C++ 内核.md","hash":"0003e32cdff91b976b80c85f5a3c2812004e9739","modified":1691572435154},{"_id":"themes/fluid/source/img/Blog-Logo/C++_Logo.png","hash":"c81703cd5a19ebdde1fb9ed3e69cc8bd14fa3b86","modified":1691022872233},{"_id":"source/_posts/02.C++ 基础部分/00.C++ 基本语法学习.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1691046534439},{"_id":"source/_posts/02.C++ 基础部分/02.C++ 基础精讲.md","hash":"ab1a9e1e2b893ac97e2050e3e73b76a3e1aebeaa","modified":1691572440085},{"_id":"source/_posts/02.C++ 基础部分/03.C++ 面向对象.md","hash":"4606bd1564d052e482629ce2b4b20955aed0d58b","modified":1691572443254},{"_id":"source/_posts/00.相关知识点/C++ 11 新特性.md","hash":"0010b54595c4bf99875fc6d6449ca1b1d4f3e243","modified":1691395716664},{"_id":"source/_posts/02.C++ 基础部分/06.C++ 继承与多态.md","hash":"aba6290ed72d277a903f949273949949b1d92c77","modified":1691758811193},{"_id":"source/_posts/02.C++ 基础部分/04.C++ 函数模板.md","hash":"eeab43ecb71e4364383ea0f5e33613d2492a143e","modified":1691572447111},{"_id":"source/_posts/02.C++ 基础部分/05.C++ 运算符重载.md","hash":"b9419e091ae76e048459a65e6fec1e356e316f5b","modified":1691657894056},{"_id":"source/_posts/02.C++ 基础部分/07.C++ STL.md","hash":"9f0785c3995ca9b7b6318dfa1eea243a330e550a","modified":1692172883087},{"_id":"source/others/生物学/01. 生物学基础知识.md","hash":"7339cb1bd9f49254a361ef22f3ccf5af2b046138","modified":1691589487234},{"_id":"themes/fluid/source/img/Blog-Logo/biology_logo.jpg","hash":"8a51720bd3de386a31fb383aaa2e498e795efc40","modified":1691588919457},{"_id":"themes/fluid/source/img/Post-Banner/01.blogs/1310700.jpg","hash":"ebb5a51a5599c5c3a3c87866b929ea926f34e126","modified":1691589466329},{"_id":"source/draft/生物学/01. 生物学基础知识.md","hash":"7339cb1bd9f49254a361ef22f3ccf5af2b046138","modified":1691589487234},{"_id":"source/_posts/00.其他/生物学/01. 生物学基础知识.md","hash":"7339cb1bd9f49254a361ef22f3ccf5af2b046138","modified":1691589487234}],"Category":[],"Data":[],"Page":[{"layout":"about","date":"2023-08-01T02:29:36.000Z","_content":"\nFluid ，这是一款 Material Design 风格的 Hexo 主题，以简约的设计帮助你专注于写作。\n\n该主题相较于其他主题的优势：\n\n- 设计遵循简洁至上，同时具有轻快的体验，和优雅的颜值；\n- 提供大量定制化配置项，使每个用户使用该主题都能具有独特的样式；\n- 响应式页面，适配手机、平板等设备；\n- 转载文章；\n\n## 个人技能\n\n- Html + Css + JavaScript + NodeJS + MySQL + React\n- C/C++ + UE\n- 数据结构与算法 + 计算机网络 + 计算机组成原理 + 操作系统\n\n## 项目组\n\n......","source":"about/index.md","raw":"---\nlayout: about\ndate: 2023-08-01 10:29:36\n---\n\nFluid ，这是一款 Material Design 风格的 Hexo 主题，以简约的设计帮助你专注于写作。\n\n该主题相较于其他主题的优势：\n\n- 设计遵循简洁至上，同时具有轻快的体验，和优雅的颜值；\n- 提供大量定制化配置项，使每个用户使用该主题都能具有独特的样式；\n- 响应式页面，适配手机、平板等设备；\n- 转载文章；\n\n## 个人技能\n\n- Html + Css + JavaScript + NodeJS + MySQL + React\n- C/C++ + UE\n- 数据结构与算法 + 计算机网络 + 计算机组成原理 + 操作系统\n\n## 项目组\n\n......","updated":"2023-08-01T02:48:50.957Z","path":"about/index.html","_id":"clkrobmbc0000u0pk12zga84x","title":"","comments":1,"content":"<p>Fluid ，这是一款 Material Design 风格的 Hexo 主题，以简约的设计帮助你专注于写作。</p>\n<p>该主题相较于其他主题的优势：</p>\n<ul>\n<li>设计遵循简洁至上，同时具有轻快的体验，和优雅的颜值；</li>\n<li>提供大量定制化配置项，使每个用户使用该主题都能具有独特的样式；</li>\n<li>响应式页面，适配手机、平板等设备；</li>\n<li>转载文章；</li>\n</ul>\n<h2 id=\"个人技能\"><a href=\"#个人技能\" class=\"headerlink\" title=\"个人技能\"></a>个人技能</h2><ul>\n<li>Html + Css + JavaScript + NodeJS + MySQL + React</li>\n<li>C&#x2F;C++ + UE</li>\n<li>数据结构与算法 + 计算机网络 + 计算机组成原理 + 操作系统</li>\n</ul>\n<h2 id=\"项目组\"><a href=\"#项目组\" class=\"headerlink\" title=\"项目组\"></a>项目组</h2><p>……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Fluid ，这是一款 Material Design 风格的 Hexo 主题，以简约的设计帮助你专注于写作。</p>\n<p>该主题相较于其他主题的优势：</p>\n<ul>\n<li>设计遵循简洁至上，同时具有轻快的体验，和优雅的颜值；</li>\n<li>提供大量定制化配置项，使每个用户使用该主题都能具有独特的样式；</li>\n<li>响应式页面，适配手机、平板等设备；</li>\n<li>转载文章；</li>\n</ul>\n<h2 id=\"个人技能\"><a href=\"#个人技能\" class=\"headerlink\" title=\"个人技能\"></a>个人技能</h2><ul>\n<li>Html + Css + JavaScript + NodeJS + MySQL + React</li>\n<li>C&#x2F;C++ + UE</li>\n<li>数据结构与算法 + 计算机网络 + 计算机组成原理 + 操作系统</li>\n</ul>\n<h2 id=\"项目组\"><a href=\"#项目组\" class=\"headerlink\" title=\"项目组\"></a>项目组</h2><p>……</p>\n"}],"Post":[{"title":"博客部署流程","index_img":"/img/Blog-Logo/Hexo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n**主要使用技术合集：**\n\n1. Hexo 博客系统\n2. Fluid 博客模板\n3. Obsidian + Github Pages 部署。\n\n## 1. Hexo 博客系统\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 **Markdown**（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n### 1.1 安装需求\n\n安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\n- Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）\n- Git\n\n### 1.2 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n~~~cmd\nnpm install -g hexo-cli\n~~~\n\n全局安装后即可随时使用\n\n### 1.3 创建博客\n\n安装完成后，就可以在终端使用 `hexo` 指令了，可以使用以下指令创建一个 hexo 项目：\n\n~~~cmd\nhexo init hexo-blog  \ncd hexo-blog  \nyarn install\n~~~\n\n完成后项目目录如下：\n\n~~~plaintext\n.  \n├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  \n├── package.json  \n├── scaffolds # 文章模板  \n├── source  \n|   ├── _drafts  \n|   └── _posts # 你的 markdown 文章就需要存放在此目录下  \n└── themes # 存放主题源码\n~~~\n\n## 2. 配置 Fluid 主题\n\n1. NPM 安装\n2. 源码安装\n\n### 2.1 NPM 安装\n\n以 [hexo-theme-fluid](https://github.com/fluid-dev/hexo-theme-fluid) 主题为例，使用 npm 安装只需要执行：\n\n~~~cmd\nyarn add hexo-theme-fluid  \n# 或者  \nnpm install --save hexo-theme-fluid\n~~~\n\n然后在博客目录下创建 `_config.fluid.yml`，将主题的 `_config.yml` 内容复制进去。\n\n### 2.2 源码安装\n\n源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。\n\n仍然以 [hexo-theme-fluid](https://github.com/fluid-dev/hexo-theme-fluid) 主题为例，在项目的 [Releases](https://github.com/fluid-dev/hexo-theme-fluid/releases) 页面中下载源码文件：\n\n![](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png)\n\n下载解压后，在 `themes` 目录下创建一个 `fluid` 目录，将源码复制到该目录下，如下：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png)\n\n### 2.3 应用主题\n\n当你安装成功后，需要在 `_config.yml` 中将使用的主题设置为你下载好的主题，找到 `theme` 配置项，将其修改为：\n\n~~~yml\n# Extensions  \n## Plugins: https://hexo.io/plugins/  \n## Themes: https://hexo.io/themes/  \ntheme: fluid\n~~~\n\n### 2.4 配置第三方主题\n\n如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 `_config.fluid.yml` 文件修改相关配置；\n\n如果你是以源码方式安装的主题，就不需要创建 `_config.fluid.yml` 文件了，只需要修改 `/themes/fluid/_config.yml` 文件中的配置就可以了。\n\n> 注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档\n\n## 3. 部署 Github Pages\n\n然后在 Github 中创建一个新项目仓库，名称必须为 `<你的github用户名>.github.io`，创建完成后按照指引将你的博客代码上传到 github。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png)\n\n### 3.1 开启 Github Pages\n\n在执行这一步之前，先创建一个没有任何代码的新分支，命名为 `gh-pages`：\n\n~~~git\ngit checkout -b gh-pages  \nrm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  \ngit push --set-upstream origin release # 上传 release 分支\n~~~\n\n在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 `gh-pages` 分支：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png)\n\n这就意为这你在 `gh-pages` 上传的任何 html 都可以使用 `<你的github用户名>.github.io` 这个域名来访问了。\n\n我们切回 `master` 分支，之后执行 `yarn build` 将生成的 `public` 目录下的文件复制一份，然后重新切回 `gh-pages` 分支，将刚才复制的内容粘贴到 `gh-pages` 分支下，并上传代码。如果没有操作失误的话，访问 `<你的github用户名>.github.io` 即可看到你的博客了。\n\n### 3.2 Github Action 自动部署\n\n使用 Github Action 来帮我们做自动化部署。\n\nGithub Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。\n\n关于 Github Action，详细教程可以查看 [官方文档](https://docs.github.com/cn/actions)。按照文档中所描述的，只要我们在代码中添加一层 `.github/workflows` 目录，并且在目录下创建一个 `yml` 文件来描述具体的行为，就可以实现开启 Github Action。\n\n如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 `.github/workflows/blog-deploy.yml` 文件中：\n\n~~~yml\nname: Deploy to GitHub Pages\n\non:\n  push:\n    branches:\n      - main # default branch\n\njobs:\n  pages:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js 16.x\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"16\"\n\n      - name: Cache NPM dependencies\n        uses: actions/cache@v2\n        with:\n          path: node_modules\n          key: ${{ runner.OS }}-npm-cache\n          restore-keys: |\n            ${{ runner.OS }}-npm-cache\n\n      - name: Install Dependencies\n        run: npm install\n\n      - name: Build\n        run: npm run build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_dir: ./public\n~~~\n\n保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png)\n\n\n但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 [secrets 上下文](https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context)，即 `${{ secrets.ACCESS_TOKEN }}` 这里。\n\n`${{ xxx }}` 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 `secrets.ACCESS_TOKEN` 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。\n\n首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 `Setting`，进入设置后选择 `Developer settings`，再选择 `Persona access token` 就可以看到它了：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png)\n\n点击右上角的 `Generate new token` 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 `repo` 和 `workflow` 权限，并将 `Expiration` 过期时间选为 `No expiration`：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png)\n\n> 这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！\n\n点击 `Generate token` 按钮后，就会生成一个 `ghp` 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png)\n\n复制该 token 后，进入到博客仓库的设置中，选择 `Secrets - Actions`，点击 `New repository secret` 按钮生成一个密钥信息：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png)\n\n我们将密钥名称写为 `ACCESS_TOKEN`，值填入刚才复制的 Github token。\n\n> 这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 `secret` 上下文对象所获取到。\n\n至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。","source":"_posts/博客部署流程.md","raw":"---\ntitle: 博客部署流程\ntags: [Blog, Hexo, Fluid, Obdidian, Github Pages]\nindex_img: /img/Blog-Logo/Hexo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n**主要使用技术合集：**\n\n1. Hexo 博客系统\n2. Fluid 博客模板\n3. Obsidian + Github Pages 部署。\n\n## 1. Hexo 博客系统\n\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 **Markdown**（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n### 1.1 安装需求\n\n安装 Hexo 相当简单，只需要先安装下列应用程序即可：\n\n- Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）\n- Git\n\n### 1.2 安装 Hexo\n\n所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n\n~~~cmd\nnpm install -g hexo-cli\n~~~\n\n全局安装后即可随时使用\n\n### 1.3 创建博客\n\n安装完成后，就可以在终端使用 `hexo` 指令了，可以使用以下指令创建一个 hexo 项目：\n\n~~~cmd\nhexo init hexo-blog  \ncd hexo-blog  \nyarn install\n~~~\n\n完成后项目目录如下：\n\n~~~plaintext\n.  \n├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  \n├── package.json  \n├── scaffolds # 文章模板  \n├── source  \n|   ├── _drafts  \n|   └── _posts # 你的 markdown 文章就需要存放在此目录下  \n└── themes # 存放主题源码\n~~~\n\n## 2. 配置 Fluid 主题\n\n1. NPM 安装\n2. 源码安装\n\n### 2.1 NPM 安装\n\n以 [hexo-theme-fluid](https://github.com/fluid-dev/hexo-theme-fluid) 主题为例，使用 npm 安装只需要执行：\n\n~~~cmd\nyarn add hexo-theme-fluid  \n# 或者  \nnpm install --save hexo-theme-fluid\n~~~\n\n然后在博客目录下创建 `_config.fluid.yml`，将主题的 `_config.yml` 内容复制进去。\n\n### 2.2 源码安装\n\n源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。\n\n仍然以 [hexo-theme-fluid](https://github.com/fluid-dev/hexo-theme-fluid) 主题为例，在项目的 [Releases](https://github.com/fluid-dev/hexo-theme-fluid/releases) 页面中下载源码文件：\n\n![](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png)\n\n下载解压后，在 `themes` 目录下创建一个 `fluid` 目录，将源码复制到该目录下，如下：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png)\n\n### 2.3 应用主题\n\n当你安装成功后，需要在 `_config.yml` 中将使用的主题设置为你下载好的主题，找到 `theme` 配置项，将其修改为：\n\n~~~yml\n# Extensions  \n## Plugins: https://hexo.io/plugins/  \n## Themes: https://hexo.io/themes/  \ntheme: fluid\n~~~\n\n### 2.4 配置第三方主题\n\n如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 `_config.fluid.yml` 文件修改相关配置；\n\n如果你是以源码方式安装的主题，就不需要创建 `_config.fluid.yml` 文件了，只需要修改 `/themes/fluid/_config.yml` 文件中的配置就可以了。\n\n> 注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档\n\n## 3. 部署 Github Pages\n\n然后在 Github 中创建一个新项目仓库，名称必须为 `<你的github用户名>.github.io`，创建完成后按照指引将你的博客代码上传到 github。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png)\n\n### 3.1 开启 Github Pages\n\n在执行这一步之前，先创建一个没有任何代码的新分支，命名为 `gh-pages`：\n\n~~~git\ngit checkout -b gh-pages  \nrm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  \ngit push --set-upstream origin release # 上传 release 分支\n~~~\n\n在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 `gh-pages` 分支：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png)\n\n这就意为这你在 `gh-pages` 上传的任何 html 都可以使用 `<你的github用户名>.github.io` 这个域名来访问了。\n\n我们切回 `master` 分支，之后执行 `yarn build` 将生成的 `public` 目录下的文件复制一份，然后重新切回 `gh-pages` 分支，将刚才复制的内容粘贴到 `gh-pages` 分支下，并上传代码。如果没有操作失误的话，访问 `<你的github用户名>.github.io` 即可看到你的博客了。\n\n### 3.2 Github Action 自动部署\n\n使用 Github Action 来帮我们做自动化部署。\n\nGithub Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。\n\n关于 Github Action，详细教程可以查看 [官方文档](https://docs.github.com/cn/actions)。按照文档中所描述的，只要我们在代码中添加一层 `.github/workflows` 目录，并且在目录下创建一个 `yml` 文件来描述具体的行为，就可以实现开启 Github Action。\n\n如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 `.github/workflows/blog-deploy.yml` 文件中：\n\n~~~yml\nname: Deploy to GitHub Pages\n\non:\n  push:\n    branches:\n      - main # default branch\n\njobs:\n  pages:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: Use Node.js 16.x\n        uses: actions/setup-node@v2\n        with:\n          node-version: \"16\"\n\n      - name: Cache NPM dependencies\n        uses: actions/cache@v2\n        with:\n          path: node_modules\n          key: ${{ runner.OS }}-npm-cache\n          restore-keys: |\n            ${{ runner.OS }}-npm-cache\n\n      - name: Install Dependencies\n        run: npm install\n\n      - name: Build\n        run: npm run build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.ACCESS_TOKEN }}\n          publish_dir: ./public\n~~~\n\n保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png)\n\n\n但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 [secrets 上下文](https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context)，即 `${{ secrets.ACCESS_TOKEN }}` 这里。\n\n`${{ xxx }}` 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 `secrets.ACCESS_TOKEN` 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。\n\n首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 `Setting`，进入设置后选择 `Developer settings`，再选择 `Persona access token` 就可以看到它了：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png)\n\n点击右上角的 `Generate new token` 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 `repo` 和 `workflow` 权限，并将 `Expiration` 过期时间选为 `No expiration`：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png)\n\n> 这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！\n\n点击 `Generate token` 按钮后，就会生成一个 `ghp` 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png)\n\n复制该 token 后，进入到博客仓库的设置中，选择 `Secrets - Actions`，点击 `New repository secret` 按钮生成一个密钥信息：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png)\n\n我们将密钥名称写为 `ACCESS_TOKEN`，值填入刚才复制的 Github token。\n\n> 这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 `secret` 上下文对象所获取到。\n\n至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。","slug":"博客部署流程","published":1,"date":"2023-08-01T00:47:58.644Z","updated":"2023-08-01T07:32:36.376Z","_id":"clkrobmbf0001u0pkc6e72u5t","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>主要使用技术合集：</strong></p>\n<ol>\n<li>Hexo 博客系统</li>\n<li>Fluid 博客模板</li>\n<li>Obsidian + Github Pages 部署。</li>\n</ol>\n<h2 id=\"1-Hexo-博客系统\"><a href=\"#1-Hexo-博客系统\" class=\"headerlink\" title=\"1. Hexo 博客系统\"></a>1. Hexo 博客系统</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <strong>Markdown</strong>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<h3 id=\"1-1-安装需求\"><a href=\"#1-1-安装需求\" class=\"headerlink\" title=\"1.1 安装需求\"></a>1.1 安装需求</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>\n<ul>\n<li>Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li>\n<li>Git</li>\n</ul>\n<h3 id=\"1-2-安装-Hexo\"><a href=\"#1-2-安装-Hexo\" class=\"headerlink\" title=\"1.2 安装 Hexo\"></a>1.2 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">npm install -g hexo-cli<br></code></pre></td></tr></table></figure>\n\n<p>全局安装后即可随时使用</p>\n<h3 id=\"1-3-创建博客\"><a href=\"#1-3-创建博客\" class=\"headerlink\" title=\"1.3 创建博客\"></a>1.3 创建博客</h3><p>安装完成后，就可以在终端使用 <code>hexo</code> 指令了，可以使用以下指令创建一个 hexo 项目：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">hexo init hexo-blog  <br><span class=\"hljs-built_in\">cd</span> hexo-blog  <br>yarn install<br></code></pre></td></tr></table></figure>\n\n<p>完成后项目目录如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">.  <br>├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  <br>├── package.json  <br>├── scaffolds # 文章模板  <br>├── source  <br>|   ├── _drafts  <br>|   └── _posts # 你的 markdown 文章就需要存放在此目录下  <br>└── themes # 存放主题源码<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-配置-Fluid-主题\"><a href=\"#2-配置-Fluid-主题\" class=\"headerlink\" title=\"2. 配置 Fluid 主题\"></a>2. 配置 Fluid 主题</h2><ol>\n<li>NPM 安装</li>\n<li>源码安装</li>\n</ol>\n<h3 id=\"2-1-NPM-安装\"><a href=\"#2-1-NPM-安装\" class=\"headerlink\" title=\"2.1 NPM 安装\"></a>2.1 NPM 安装</h3><p>以 <a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">hexo-theme-fluid</a> 主题为例，使用 npm 安装只需要执行：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">yarn add hexo-theme-fluid  <br># 或者  <br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>\n\n<p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p>\n<h3 id=\"2-2-源码安装\"><a href=\"#2-2-源码安装\" class=\"headerlink\" title=\"2.2 源码安装\"></a>2.2 源码安装</h3><p>源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。</p>\n<p>仍然以 <a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">hexo-theme-fluid</a> 主题为例，在项目的 <a href=\"https://github.com/fluid-dev/hexo-theme-fluid/releases\">Releases</a> 页面中下载源码文件：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png\"></p>\n<p>下载解压后，在 <code>themes</code> 目录下创建一个 <code>fluid</code> 目录，将源码复制到该目录下，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png\" alt=\"image.png\"></p>\n<h3 id=\"2-3-应用主题\"><a href=\"#2-3-应用主题\" class=\"headerlink\" title=\"2.3 应用主题\"></a>2.3 应用主题</h3><p>当你安装成功后，需要在 <code>_config.yml</code> 中将使用的主题设置为你下载好的主题，找到 <code>theme</code> 配置项，将其修改为：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-comment\"># Extensions  </span><br><span class=\"hljs-comment\">## Plugins: https://hexo.io/plugins/  </span><br><span class=\"hljs-comment\">## Themes: https://hexo.io/themes/  </span><br><span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">fluid</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-配置第三方主题\"><a href=\"#2-4-配置第三方主题\" class=\"headerlink\" title=\"2.4 配置第三方主题\"></a>2.4 配置第三方主题</h3><p>如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 <code>_config.fluid.yml</code> 文件修改相关配置；</p>\n<p>如果你是以源码方式安装的主题，就不需要创建 <code>_config.fluid.yml</code> 文件了，只需要修改 <code>/themes/fluid/_config.yml</code> 文件中的配置就可以了。</p>\n<blockquote>\n<p>注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档</p>\n</blockquote>\n<h2 id=\"3-部署-Github-Pages\"><a href=\"#3-部署-Github-Pages\" class=\"headerlink\" title=\"3. 部署 Github Pages\"></a>3. 部署 Github Pages</h2><p>然后在 Github 中创建一个新项目仓库，名称必须为 <code>&lt;你的github用户名&gt;.github.io</code>，创建完成后按照指引将你的博客代码上传到 github。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png\" alt=\"image.png\"></p>\n<h3 id=\"3-1-开启-Github-Pages\"><a href=\"#3-1-开启-Github-Pages\" class=\"headerlink\" title=\"3.1 开启 Github Pages\"></a>3.1 开启 Github Pages</h3><p>在执行这一步之前，先创建一个没有任何代码的新分支，命名为 <code>gh-pages</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">git checkout -b gh-pages  <br>rm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  <br>git push --set-upstream origin release # 上传 release 分支<br></code></pre></td></tr></table></figure>\n\n<p>在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 <code>gh-pages</code> 分支：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png\" alt=\"image.png\"></p>\n<p>这就意为这你在 <code>gh-pages</code> 上传的任何 html 都可以使用 <code>&lt;你的github用户名&gt;.github.io</code> 这个域名来访问了。</p>\n<p>我们切回 <code>master</code> 分支，之后执行 <code>yarn build</code> 将生成的 <code>public</code> 目录下的文件复制一份，然后重新切回 <code>gh-pages</code> 分支，将刚才复制的内容粘贴到 <code>gh-pages</code> 分支下，并上传代码。如果没有操作失误的话，访问 <code>&lt;你的github用户名&gt;.github.io</code> 即可看到你的博客了。</p>\n<h3 id=\"3-2-Github-Action-自动部署\"><a href=\"#3-2-Github-Action-自动部署\" class=\"headerlink\" title=\"3.2 Github Action 自动部署\"></a>3.2 Github Action 自动部署</h3><p>使用 Github Action 来帮我们做自动化部署。</p>\n<p>Github Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。</p>\n<p>关于 Github Action，详细教程可以查看 <a href=\"https://docs.github.com/cn/actions\">官方文档</a>。按照文档中所描述的，只要我们在代码中添加一层 <code>.github/workflows</code> 目录，并且在目录下创建一个 <code>yml</code> 文件来描述具体的行为，就可以实现开启 Github Action。</p>\n<p>如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 <code>.github/workflows/blog-deploy.yml</code> 文件中：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">to</span> <span class=\"hljs-string\">GitHub</span> <span class=\"hljs-string\">Pages</span><br><br><span class=\"hljs-attr\">on:</span><br>  <span class=\"hljs-attr\">push:</span><br>    <span class=\"hljs-attr\">branches:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">main</span> <span class=\"hljs-comment\"># default branch</span><br><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">pages:</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">permissions:</span><br>      <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span><br><br><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Use</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-number\">16.</span><span class=\"hljs-string\">x</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-string\">&quot;16&quot;</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Cache</span> <span class=\"hljs-string\">NPM</span> <span class=\"hljs-string\">dependencies</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/cache@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">node_modules</span><br>          <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">runner.OS</span> <span class=\"hljs-string\">&#125;&#125;-npm-cache</span><br>          <span class=\"hljs-attr\">restore-keys:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Dependencies</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">peaceiris/actions-gh-pages@v3</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">github_token:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.ACCESS_TOKEN</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">publish_dir:</span> <span class=\"hljs-string\">./public</span><br></code></pre></td></tr></table></figure>\n\n<p>保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png\" alt=\"image.png\"></p>\n<p>但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 <a href=\"https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context\">secrets 上下文</a>，即 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code> 这里。</p>\n<p><code>$&#123;&#123; xxx &#125;&#125;</code> 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 <code>secrets.ACCESS_TOKEN</code> 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。</p>\n<p>首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 <code>Setting</code>，进入设置后选择 <code>Developer settings</code>，再选择 <code>Persona access token</code> 就可以看到它了：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png\" alt=\"image.png\"></p>\n<p>点击右上角的 <code>Generate new token</code> 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 <code>repo</code> 和 <code>workflow</code> 权限，并将 <code>Expiration</code> 过期时间选为 <code>No expiration</code>：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！</p>\n</blockquote>\n<p>点击 <code>Generate token</code> 按钮后，就会生成一个 <code>ghp</code> 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png\" alt=\"image.png\"></p>\n<p>复制该 token 后，进入到博客仓库的设置中，选择 <code>Secrets - Actions</code>，点击 <code>New repository secret</code> 按钮生成一个密钥信息：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png\" alt=\"image.png\"></p>\n<p>我们将密钥名称写为 <code>ACCESS_TOKEN</code>，值填入刚才复制的 Github token。</p>\n<blockquote>\n<p>这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 <code>secret</code> 上下文对象所获取到。</p>\n</blockquote>\n<p>至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>主要使用技术合集：</strong></p>\n<ol>\n<li>Hexo 博客系统</li>\n<li>Fluid 博客模板</li>\n<li>Obsidian + Github Pages 部署。</li>\n</ol>\n<h2 id=\"1-Hexo-博客系统\"><a href=\"#1-Hexo-博客系统\" class=\"headerlink\" title=\"1. Hexo 博客系统\"></a>1. Hexo 博客系统</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <strong>Markdown</strong>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<h3 id=\"1-1-安装需求\"><a href=\"#1-1-安装需求\" class=\"headerlink\" title=\"1.1 安装需求\"></a>1.1 安装需求</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>\n<ul>\n<li>Node.js （Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本）</li>\n<li>Git</li>\n</ul>\n<h3 id=\"1-2-安装-Hexo\"><a href=\"#1-2-安装-Hexo\" class=\"headerlink\" title=\"1.2 安装 Hexo\"></a>1.2 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">npm install -g hexo-cli<br></code></pre></td></tr></table></figure>\n\n<p>全局安装后即可随时使用</p>\n<h3 id=\"1-3-创建博客\"><a href=\"#1-3-创建博客\" class=\"headerlink\" title=\"1.3 创建博客\"></a>1.3 创建博客</h3><p>安装完成后，就可以在终端使用 <code>hexo</code> 指令了，可以使用以下指令创建一个 hexo 项目：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">hexo init hexo-blog  <br><span class=\"hljs-built_in\">cd</span> hexo-blog  <br>yarn install<br></code></pre></td></tr></table></figure>\n\n<p>完成后项目目录如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">.  <br>├── _config.yml # 网站的基础配置，文档：https://hexo.io/zh-cn/docs/configuration  <br>├── package.json  <br>├── scaffolds # 文章模板  <br>├── source  <br>|   ├── _drafts  <br>|   └── _posts # 你的 markdown 文章就需要存放在此目录下  <br>└── themes # 存放主题源码<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-配置-Fluid-主题\"><a href=\"#2-配置-Fluid-主题\" class=\"headerlink\" title=\"2. 配置 Fluid 主题\"></a>2. 配置 Fluid 主题</h2><ol>\n<li>NPM 安装</li>\n<li>源码安装</li>\n</ol>\n<h3 id=\"2-1-NPM-安装\"><a href=\"#2-1-NPM-安装\" class=\"headerlink\" title=\"2.1 NPM 安装\"></a>2.1 NPM 安装</h3><p>以 <a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">hexo-theme-fluid</a> 主题为例，使用 npm 安装只需要执行：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">yarn add hexo-theme-fluid  <br># 或者  <br>npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>\n\n<p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p>\n<h3 id=\"2-2-源码安装\"><a href=\"#2-2-源码安装\" class=\"headerlink\" title=\"2.2 源码安装\"></a>2.2 源码安装</h3><p>源码安装是老版本 Hexo 安装主题的方式，如果你项修改主题的源码也可以很方便的直接修改。</p>\n<p>仍然以 <a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">hexo-theme-fluid</a> 主题为例，在项目的 <a href=\"https://github.com/fluid-dev/hexo-theme-fluid/releases\">Releases</a> 页面中下载源码文件：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011507960.png\"></p>\n<p>下载解压后，在 <code>themes</code> 目录下创建一个 <code>fluid</code> 目录，将源码复制到该目录下，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011509213.png\" alt=\"image.png\"></p>\n<h3 id=\"2-3-应用主题\"><a href=\"#2-3-应用主题\" class=\"headerlink\" title=\"2.3 应用主题\"></a>2.3 应用主题</h3><p>当你安装成功后，需要在 <code>_config.yml</code> 中将使用的主题设置为你下载好的主题，找到 <code>theme</code> 配置项，将其修改为：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-comment\"># Extensions  </span><br><span class=\"hljs-comment\">## Plugins: https://hexo.io/plugins/  </span><br><span class=\"hljs-comment\">## Themes: https://hexo.io/themes/  </span><br><span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">fluid</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-配置第三方主题\"><a href=\"#2-4-配置第三方主题\" class=\"headerlink\" title=\"2.4 配置第三方主题\"></a>2.4 配置第三方主题</h3><p>如果你是以 npm 方式安装主题，你需要修改你刚才在博客目录下创建 <code>_config.fluid.yml</code> 文件修改相关配置；</p>\n<p>如果你是以源码方式安装的主题，就不需要创建 <code>_config.fluid.yml</code> 文件了，只需要修改 <code>/themes/fluid/_config.yml</code> 文件中的配置就可以了。</p>\n<blockquote>\n<p>注意：每个主题的配置文件名称都不一样，主题的配置项也不一样，具体需要自行查看你安装主题的说明文档</p>\n</blockquote>\n<h2 id=\"3-部署-Github-Pages\"><a href=\"#3-部署-Github-Pages\" class=\"headerlink\" title=\"3. 部署 Github Pages\"></a>3. 部署 Github Pages</h2><p>然后在 Github 中创建一个新项目仓库，名称必须为 <code>&lt;你的github用户名&gt;.github.io</code>，创建完成后按照指引将你的博客代码上传到 github。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011512358.png\" alt=\"image.png\"></p>\n<h3 id=\"3-1-开启-Github-Pages\"><a href=\"#3-1-开启-Github-Pages\" class=\"headerlink\" title=\"3.1 开启 Github Pages\"></a>3.1 开启 Github Pages</h3><p>在执行这一步之前，先创建一个没有任何代码的新分支，命名为 <code>gh-pages</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">git checkout -b gh-pages  <br>rm -f * # 确定你的当前目录没问题，把握不住删除指令的话就手动删除当前文件加的内容  <br>git push --set-upstream origin release # 上传 release 分支<br></code></pre></td></tr></table></figure>\n\n<p>在项目的设置中找到 Github Pages，并将展示分支设置为刚才创建的 <code>gh-pages</code> 分支：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011513779.png\" alt=\"image.png\"></p>\n<p>这就意为这你在 <code>gh-pages</code> 上传的任何 html 都可以使用 <code>&lt;你的github用户名&gt;.github.io</code> 这个域名来访问了。</p>\n<p>我们切回 <code>master</code> 分支，之后执行 <code>yarn build</code> 将生成的 <code>public</code> 目录下的文件复制一份，然后重新切回 <code>gh-pages</code> 分支，将刚才复制的内容粘贴到 <code>gh-pages</code> 分支下，并上传代码。如果没有操作失误的话，访问 <code>&lt;你的github用户名&gt;.github.io</code> 即可看到你的博客了。</p>\n<h3 id=\"3-2-Github-Action-自动部署\"><a href=\"#3-2-Github-Action-自动部署\" class=\"headerlink\" title=\"3.2 Github Action 自动部署\"></a>3.2 Github Action 自动部署</h3><p>使用 Github Action 来帮我们做自动化部署。</p>\n<p>Github Action 可以实现在一个行为触发之后再执行一些其他的行为，利用这个能力我们就可以实现当我们写完一篇文章后，将代码 Push 到 Github 仓库的这一刻，让 Github 来帮我们完成编译以及部署这个流程，也就是实现持续集成（CI）、持续交付（CD）的这个效果。</p>\n<p>关于 Github Action，详细教程可以查看 <a href=\"https://docs.github.com/cn/actions\">官方文档</a>。按照文档中所描述的，只要我们在代码中添加一层 <code>.github/workflows</code> 目录，并且在目录下创建一个 <code>yml</code> 文件来描述具体的行为，就可以实现开启 Github Action。</p>\n<p>如下是一个编写好的部署 hexo 博客的 yml 文件，你可以将其写入到 <code>.github/workflows/blog-deploy.yml</code> 文件中：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">to</span> <span class=\"hljs-string\">GitHub</span> <span class=\"hljs-string\">Pages</span><br><br><span class=\"hljs-attr\">on:</span><br>  <span class=\"hljs-attr\">push:</span><br>    <span class=\"hljs-attr\">branches:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">main</span> <span class=\"hljs-comment\"># default branch</span><br><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">pages:</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>    <span class=\"hljs-attr\">permissions:</span><br>      <span class=\"hljs-attr\">contents:</span> <span class=\"hljs-string\">write</span><br><br><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Use</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-number\">16.</span><span class=\"hljs-string\">x</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-string\">&quot;16&quot;</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Cache</span> <span class=\"hljs-string\">NPM</span> <span class=\"hljs-string\">dependencies</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/cache@v2</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">node_modules</span><br>          <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">runner.OS</span> <span class=\"hljs-string\">&#125;&#125;-npm-cache</span><br>          <span class=\"hljs-attr\">restore-keys:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class=\"hljs-string\"></span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">Dependencies</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span><br><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">peaceiris/actions-gh-pages@v3</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">github_token:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.ACCESS_TOKEN</span> <span class=\"hljs-string\">&#125;&#125;</span><br>          <span class=\"hljs-attr\">publish_dir:</span> <span class=\"hljs-string\">./public</span><br></code></pre></td></tr></table></figure>\n\n<p>保存后提交代码后，就可以在你的博客的 Github 项目仓库里的 Actions 标签页里找到创建好的 workflow 了，并且当你 push 代码时，这个工作流就会被触发：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011517404.png\" alt=\"image.png\"></p>\n<p>但其实它最终会失败的，因为我们还有一步没有完成。在上面的脚本中使用了一个 Github Action 的 <a href=\"https://docs.github.com/cn/actions/learn-github-actions/contexts#secrets-context\">secrets 上下文</a>，即 <code>$&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125;</code> 这里。</p>\n<p><code>$&#123;&#123; xxx &#125;&#125;</code> 是 Github Action 中的特定模板语法，可以获取到一些 Github 相关的内置的系统变量（姑且这么说吧），但又区区别与 Github Action 的环境变量。我们这里获取的 <code>secrets.ACCESS_TOKEN</code> 是 Github Personal access token，获取这个 token 的目的是为了让当前的 Github Action 工作流有向我们的项目推送代码的权限。</p>\n<p>首先我们要获取这个 Token，你可以在你的用户头像菜单里选择 <code>Setting</code>，进入设置后选择 <code>Developer settings</code>，再选择 <code>Persona access token</code> 就可以看到它了：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518709.png\" alt=\"image.png\"></p>\n<p>点击右上角的 <code>Generate new token</code> 按钮生成新的 Token，填写一个你比较容易区分的备注后，勾选 <code>repo</code> 和 <code>workflow</code> 权限，并将 <code>Expiration</code> 过期时间选为 <code>No expiration</code>：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518481.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>这个 Token 相当重要，千万不能泄露，如过泄露立刻重置该 token ！！！</p>\n</blockquote>\n<p>点击 <code>Generate token</code> 按钮后，就会生成一个 <code>ghp</code> 开头的 token，你需要在此复制该 token（后面不能再查看了，只能重新生成）:</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011518736.png\" alt=\"image.png\"></p>\n<p>复制该 token 后，进入到博客仓库的设置中，选择 <code>Secrets - Actions</code>，点击 <code>New repository secret</code> 按钮生成一个密钥信息：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308011519065.png\" alt=\"image.png\"></p>\n<p>我们将密钥名称写为 <code>ACCESS_TOKEN</code>，值填入刚才复制的 Github token。</p>\n<blockquote>\n<p>这里所新建的 secret 字段，就可以被 Github Action yml 配置中的 <code>secret</code> 上下文对象所获取到。</p>\n</blockquote>\n<p>至此 Github Action 工作流就可以正常使用了，你可以愉快的开始写你的博客啦，你的每次提交 Github Action 都会帮你进行自动部署。</p>\n"},{"title":"01.理解 C++ 内核","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节内容分为三部分：\n\n1. 掌握进程虚拟地址空间区域划分\n2. 从指令角度掌握函数调用堆栈详细过程\n3. 从编译器角度理解C++代码的编译、链接\n\n通过了解底层基础，了解 C++ 的如何运行。\n\n## 1. 掌握进程虚拟地址空间区域划分\n\n代码：\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nint gdata1 = 10;\nint gdata2 = 0;\nint gdata3;\n\nstatic int gdata4 = 11;\nstatic int gdata5 = 0;\nstatic int gdata6;\n\nint main()\n{\n\tint a = 12;\n\tint b = 0;\n\tint c;\n\n\tstatic int d = 13;\n\tstatic int e = 0;\n\tstatic int f;\n\n\treturn 0;\n}\n~~~\n根据上述代码，如何得知各个变量存储的位置？\n\n### 1.1 虚拟进程视图\n\n首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。\n\n这里附上IBM公司关于**虚拟**的解释:\n\n```text\n它存在，你看得见，它是物理的\n它存在，你看不见，它是透明的\n它不存在，你看得见，它是虚拟的\n它不存在，你看不见，它被删除\n```\n\n这块空间的内容如下图所示：\n\n![虚拟进程空间示例图 CN](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png)\n\n![虚拟进程空间示例图 EN](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png)\n\n> 补充：  \n> x86 32位体系下的4G虚拟地址空间：  \n> **Linux默认3:1**来分配 user space : kernal space；  \n> **Windows默认2:2**来分配 user space : kernal space。\n\nLinux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。\n\n解释：\n32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 `[0, 2^32]` ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。\n64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 `[0, 2^64]` ，即 4GB * 4GB = 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。\n\n**为什么是 4G 内存：**\n\n首先我们研究的体系是：`x86 32位Linux环境`：  \nLinux操作系统会给当前进程分配一个 `2^32` 大小的空间，那么，`2^32` 换算过来就是 4G 了。\n\n### 1.2 用户空间（User Space）\n\n1. 保留区：\n\t128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 \"NULL\"，它便不会被引用了，从而避免了野指针。\n\t\n1. 指令段【.text】、只读数据段【.rodata】：\n\t指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。\n\t\n\t> 在C++中，不允许普通指针指向常量字符串，需要使用`const`：\n\t> ![示例](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png)\n3. 数据段【.data】：  \n\t存放程序中**已初始化且不为0的全局变量或静态变量**。\n\n4. 数据段【.bss】：\n\t存放程序中未初始化或者初始化为0的全局变量或静态变量。\n\t\n5. 堆【.heap】：\n\t存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。\n\t- 堆用于存放进程`运行时动态分配`的内存段，可动态扩张或缩减。\n\t- 堆中内容是`匿名`的，无法通过名字进行访问，只能通过`指针`进行间接访问。\n\t- 当进程调用`malloc(C)/new(C++)`等函数分配内存时，新分配的在堆上`动态扩张`；当调用`free(C)/delete(C++)`等函数释放内存时，被释放的内存从堆上`动态缩减`\n\t- 分配的堆内存时经过`字节对齐`的空间，以适合`原子操作`。\n\t- `堆管理器`通过`链表`管理每个申请的内存块\n\t- 由于堆内存块的申请与释放都是`无序`的，最终会产生许许多多`内存碎片`。\n\t- 堆的末端由`break指针`标识，当堆管理器需要更多内存时，可通过`系统调用brk和sbrk`来`移动break指针`以扩张堆，一般情况下由系统自动调用。\n\n6. 共享库【.dll、.so】：\n\t动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。\n\n7. 栈【.stack】：\n\t存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。\n\t- 栈中存放`非静态局部变量` `函数形参` `函数返回地址`等。\n\t- 栈中内存空间由`编译器`（静态的）自动分配和释放，行为类似数据结构中的栈结构。\n\n\t\t> 主要用途：\n\t\t> 1. 为函数内部声明的**非静态局部变量**提供存储空间\n\t\t> 2. 记录函数调用过程相关的维护性信息，称为栈帧（stack frame）\n\t\t> 3. 作为`临时存储区`，用于暂时存放`较长的算术表达式部分计算结果`，或者运行时调用alloca函数`动态分配`栈内内存\n\n\t- 栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。\n\t- 查看栈大小：`ulimit -s`可查看和设置`栈的最大值`，当程序使用的栈大小超过该值，会发生`segmentation fault`。\n\t- - 栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。\n\n\n2. 命令行参数：\n\t保存传递给 main 函数的参数，比如 argc 和 argv。\n\n9. 环境变量：\n\t用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。\n\n### 1.3 进程空间（Kernal Space）\n\n1. 内存直接访问区【ZONE_DMA】：\n\t16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。\n\n2. 常用区【ZONE_NORMAL】：\n\t892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。\n\n3. 高端内存区【ZONE_HIGHMEM】：\n\t128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。\n\n### 1.4 最终解释\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png)\n\n> 注意：  \n> 对于`a、b、c以及'{'、'}'`来说，是存储在`.text`指令段的，因为他们生成的都是==指令==。  \n> 例如：  \n> `int a = 12`：生成汇编指令如下：`mov dword ptr[a], 0Ch`\n\n### 1.5 好处\n\n`数据`与`代码指令`分别开辟空间有以下好处：\n\n1. 当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。`数据区`对于进程而言`可读可写`，`代码指令区`对于进程而言`只读`，\n2. 现代CPU一般`数据缓存`和`指令缓存`分离，故进程虚拟地址空间中数据与代码指令分离有助于提高`CPU缓存命中率`。\n3. 若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。\n\n**参考文章：**\n\n>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1\n>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23\n>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09\n>【4】https://blog.csdn.net/m0_46308273/article/details/115818195\n>【5】https://blog.csdn.net/weixin_45437022/article/details/115409679\n\n## 2. 从指令角度掌握函数调用堆栈详细过程\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png)\n栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。\n\n堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：\n\n- PUSH：将目标内存推入栈顶。\n- POP：从栈顶中移除目标。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png)\n\n当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 **栈帧** 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）\n\n### 2.1 ESP 和 EBP\n\n（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。\n（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。\n\n根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。\n\n在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：\n\n- pop ebp;出栈 栈扩大4byte 因为ebp为32位\n- push ebp;入栈，栈减少4byte        \n- add esp, 0Ch；表示栈减小12byte\n- sub esp, 0Ch；表示栈扩大12byte\n\nebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。\n\n\n**代码：**\n\n~~~c++\n#include<iostream>\nusing namespace std;\n\n/*\n问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数\n问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行\n*/\n\nint sum(int a, int b) {\n\tint temp = 0;\n\ttemp = a + b;\n\treturn temp;\n}\n\nint main() {\n\tint a = 10;\n\tint b = 20;\n\n\tint ret = sum(10, 20);\n\tcout << \"ret:\" << ret << endl;\n\t\n\treturn 0;\n}\n~~~\n\n打断点，调试，查看反汇编：\n\n```C++\nint main() {\n// 00007FF637EE23D0  push        rbp  \n// 00007FF637EE23D2  push        rdi  \n// 00007FF637EE23D3  sub         rsp,148h  \n// 00007FF637EE23DA  lea         rbp,[rsp+20h]  \n// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  \n// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  \n\tint a = 10;\n// 00007FF637EE23EB  mov         dword ptr [a],0Ah  \n\tint b = 20;\n// 00007FF637EE23F2  mov         dword ptr [b],14h  \n\n\tint ret = sum(10, 20);\n// 00007FF637EE23F9  mov         edx,14h  \n// 00007FF637EE23FE  mov         ecx,0Ah  \n// 00007FF637EE2403  call        sum (07FF637EE11E5h)  \n// 00007FF637EE2408  mov         dword ptr [ret],eax  \n\tcout << \"ret:\" << ret << endl;\n// 00007FF637EE240B  lea         rdx,[string \"ret:\" (07FF637EEAC24h)]  \n// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  \n// 00007FF637EE2419  call        std::operator<<<std::char_traits<char> > (07FF637EE108Ch)  \n// 00007FF637EE241E  mov         edx,dword ptr [ret]  \n// 00007FF637EE2421  mov         rcx,rax  \n// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF637EF1168h)]  \n// 00007FF637EE242A  lea         rdx,[std::endl<char,std::char_traits<char> > (07FF637EE103Ch)]  \n// 00007FF637EE2431  mov         rcx,rax  \n// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF637EF1170h)]  \n\n\treturn 0;\n// 00007FF637EE243A  xor         eax,eax  \n}\n// 00007FF637EE243C  lea         rsp,[rbp+128h]  \n// 00007FF637EE2443  pop         rdi  \n// 00007FF637EE2444  pop         rbp  \n// 00007FF637EE2445  ret \n```\n\n### 2.2  解析 main 函数\n\n**1. `{` 会进行入栈操作，`}` 进行出栈操作**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png)\n\n上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。\n\n**为什么这么做呢？**\n\n因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。\n\n在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。\n\n`sub esp, 148h；`减去的值根据程序而定\n\n之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）\n\n之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了\n\n在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png)\n\n所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数\n\n**2. 函数内部：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png)\n\n1. `int a = 10;` 执行一条 mov 指令： \n\t~~~Assembly\n\tmov         dword ptr [a],0Ah\n\t~~~\n\t![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png)\n\n2.  同理 `int b = 20;` 指令：\n\t~~~Assembly\n\tmov         dword ptr [b],14h\n\t~~~\n\t![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png)\n\n3. `int ret = sum(a,b);` 指令：\n\t~~~Assmbly\n\t00F81896 8B 45 EC             mov         eax,dword ptr [b] \n\t00F81899 50                   push        eax     #压栈 b的值\n\t00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  \n\t00F8189D 51                   push        ecx     #压栈 a的值\n\t00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call\n\t00F818A3 83 C4 08             add         esp,8  \n\t00F818A6 89 45 E0             mov         dword ptr [ret],eax \n\t~~~\n\n### 2.3 sum 函数调用后\n\n**函数调用参数的压栈顺序:参数由右向左压入堆栈。**\n\n**因此上面对应的是：**\n\n先将b的值压入堆栈，再将a的值压入堆栈\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png)\n**执行call        sum (0F8108Ch)：**\n\n**call函数首先会将下一行执行的地址入栈**：假设下一行指令的地址位0x08124458\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png)\n\n **第二步进入函数调用：sum**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png)\n\n函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈\n\n第二步：将新的栈底ebp指向原来的栈顶esp\n\n第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png)\n\n接着执行 `int temp = 0;` 指令：\n\n~~~assembly\nmov         dword ptr [temp],0\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png)\n\ntemp = a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png)\n\n接着运行`return temp;`: \n\n~~~assembly\nmov         eax,dword ptr [temp]\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png)\n\n接着是`函数的右括号“}”`：\n\n（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。\n（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。\n（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png)\n\n### 2.4 返回 main 函数后\n\n接着调用函数完毕，回到主函数：  \n利用了`PC寄存器`，使得程序知道退出sum后运行哪一条指令：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png)\n\n`add         esp,8` ,将压栈的a b 形参空间回收\n\n`mov         dword ptr [ret],eax` 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png)\n最后`return 0`，程序结束\n\n### 2.5 栈溢出问题\n\n出现栈内存溢出的常见原因有2个：\n\n1. 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。\n2. 局部静态变量体积太大。\n\n> 第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。\n> 检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。\n\n>    第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组\n\n```C++\n    即如果函数这样写：\n    void test_stack_overflow()\n    {\n      char* chdata = new[2*1024*1024];\n      delete []chdata;\n    }\n   是不会出现这个错误的，而这样写则不行：\n    void test_stack_overflow()\n    {\n      char chdata[2*1024*1024];\n    }\n   大多数情况下都会出现内存溢出的错误,\n```\n\n解决办法大致说来也有两种：  \n\n1. 增加栈内存的数目  \n2. 使用堆内存\n\n## 3. 从编译器角度理解 C++ 代码的编译、链接\n\n整个编译过程分为两大步：\n\n1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件\n\n2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序\n\n### 3.1 编译\n\n细分为3个阶段：\n\n**1.1）编译预处理**\n\n预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 `#include`），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 `#include` 包含的文件代码，进行 `#define` 宏定义的替换 ， 处理条件编译指令 （`#ifndef`、 `#ifdef`、 `#endif`）等。\n\n预编译过程相当于如下命令：\n\n~~~shell\ngcc -E main.c -o main.i\n~~~\n\n主要规则如下：\n\n1. 将所有的 `#define` 删除，并且展开所有的宏定义；\n2. 处理所有条件预编译指令，比如`#if`、`#ifdef`、`#elif`、`#else`、`#endif`;\n4. 处理 `#include` 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；\n5. 删除所有的注释：`//` 和 `/**/`；\n6. 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；\n7. 保留所有的 `#pragma` 编译器指令，因为编译器要使用它们。\n\n> 注：  \n> `#pragma lib`、`pragma link`  \n> 等命令是在链接过程处理的。\n\n预编译后得到的文件为：`.i`文件。\n\n**1.2）编译**\n\n通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。\n\n编译过程相当于如下命令：\n\n~~~shell\ngcc -S main.i -o main.s\n~~~\n\n编译后得到的文件为：`.s`文件。\n\n**1.3) 汇编**\n\n汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。\n\n目标文件由段组成，通常至少有两个段：\n\n1. .text：包换主要程序的指令。该段是可读和可执行的，一般不可写\n2. .data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。\n\n汇编过程我们可以调用汇编器`as`来完成：\n\n~~~shell\nas main.s -o main.o  \n# 或者：  \ngcc -c main.s -o mian.o\n~~~\n\n这个过程将.s文件转化成.o文件。\n\n### 3.2 链接过程\n\n链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。\n\n**链接的时机**：\n\n- 编译时，也就是在源代码被翻译成机器代码时\n- 加载时，也就是在程序被加载器加载到存储器并执行时\n- 运行时，由应用程序执行\n\n#### 1. 静态链接\n\n**静态链接器**以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。\n\n为了构造可执行文件，**链接器必须完成两个任务：符号解析，重定位**\n\n1. **符号解析：** 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。\n2. **重定位：** 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。\n\n链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png)\n\n目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。\n\n#### 2. 目标文件\n\n**三种形式：**\n\n1. **可重定位目标文件**。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。\n2. **可执行目标文件**。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。\n3. **共享目标文件**。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。\n\n编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。\n\n#### 3.  可重定位目标文件\n\n一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。\n\n![ELF可重定位目标文件](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png)\n\n夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：\n\n- **.text：** 已编译程序的机器代码。\n- **.rodata：** 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。\n- **.data：** 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。\n- **.bss：** 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。\n- **.symtab：** 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。\n- **.rel.text：** 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。\n- **.rel.data：** 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。\n- **.debug：** 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。\n- **.line：** 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。\n- **.strtab：** 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。\n\n#### 4. 符号和符号表\n\n每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段\n\n在链接器的上下文中，有三种不同的符号：\n\n由m定义并能被其他模块引用的全局符号\n由其他模块定义并被模块m引用的全局符号\n只被模块m引用的本地符号\n\n例如：\n\n`main.cpp` 内容 和 `sum.cpp` 内容如下：\n\n~~~c++\n// main.cpp\n#include <iostream>\nusing namespace std;\n\nextern int gdata;\nint sum(int, int);\n\nint data = 20;\n\nint main()\n{\n\tint a = gdata;\n\tint b = data;\n\n\tint ret = sum(a, b);\n\n\treturn 0;\n}\n~~~\n\n~~~c++\n// sum.cpp\n#include <iostream>\nusing namespace std;\n\nint gdata = 10;\nint sum(int a, int b)\n{\n\treturn a + b;\n}\n~~~\n\n**g++ -c** 只编译不链接，只生成目标文件\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png)\n\n **objdump -t main.o // 输出目标文件的符号表：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png)\n\n- 第一列：段内偏移；\n- 第二列：符号作用域  : local /global；\n- 第三列：符号类型；\n- 第四列：符号所在段（*UND*外部链接符号，未在本目标文件定义）；\n- 第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；\n- 第六列：符号名；\n\n其中 `main` 定义在 `.text`\n\ndata 是全局变量，且初始化定义在 `.data` ,也就是 m 定义并能被其他模块引用的全局符号。\ngdata 和 sum 函数是声明，因此是*UNG*，也就是由其他模块定义并被模块 m 引用的全局符号。\n\n第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配\n\n在 `sum.o` 中：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png)\n\ngdata 是出刷的全局变量 在 `.data` 中；sum 函数在 `.text` 中\n\n`readelf -h` 查看 elf 文件的头文件信息\n可见目标文件的elf文件，其类型为REL(可重定位文件)。 \n\n`objdump -s` 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png)\n\n有调试信息的：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png)\n\n可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。\n#### 5. 符号解析\n\n链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（*UNG*）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）\n\n **链接器如何解析多重定义的全局符号：**\n\n在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。\n       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：\n\n规则1：不允许有多个强符号。\n规则2：如果有一个强符号和多个弱符号，那么选择强符号。\n规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。\n\n**链接器如何使用静态库来解析引用：**\n\n在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。\n\n> 1. 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。\n> 2. 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。\n> 3. 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。\n\n这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。\n\n另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。\n\n如果需要满足依赖需求，可以在命令行上重复库。\n\n#### 6. 重定向\n一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。\n\n重定位有两步组成：\n\n1. **重定位节和符号定义**。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。\n2. **重定位节中的符号引用**。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为`重定位条目`的可重定位目标模块中的数据结构。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png)\n\n链接后：所有的符号都有虚拟地址\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png)\n\n汇编中，全局变量和函数都有了地址。\n\n#### 7. 可执行目标文件\n\n可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。`.text` 、`.rodata` 和 `.data` 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。\n\nELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png)\n\n","source":"_posts/02.C++ 基础部分/01.理解 C++ 内核.md","raw":"---\ntitle: 01.理解 C++ 内核\ntags: [C++]\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节内容分为三部分：\n\n1. 掌握进程虚拟地址空间区域划分\n2. 从指令角度掌握函数调用堆栈详细过程\n3. 从编译器角度理解C++代码的编译、链接\n\n通过了解底层基础，了解 C++ 的如何运行。\n\n## 1. 掌握进程虚拟地址空间区域划分\n\n代码：\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nint gdata1 = 10;\nint gdata2 = 0;\nint gdata3;\n\nstatic int gdata4 = 11;\nstatic int gdata5 = 0;\nstatic int gdata6;\n\nint main()\n{\n\tint a = 12;\n\tint b = 0;\n\tint c;\n\n\tstatic int d = 13;\n\tstatic int e = 0;\n\tstatic int f;\n\n\treturn 0;\n}\n~~~\n根据上述代码，如何得知各个变量存储的位置？\n\n### 1.1 虚拟进程视图\n\n首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。\n\n这里附上IBM公司关于**虚拟**的解释:\n\n```text\n它存在，你看得见，它是物理的\n它存在，你看不见，它是透明的\n它不存在，你看得见，它是虚拟的\n它不存在，你看不见，它被删除\n```\n\n这块空间的内容如下图所示：\n\n![虚拟进程空间示例图 CN](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png)\n\n![虚拟进程空间示例图 EN](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png)\n\n> 补充：  \n> x86 32位体系下的4G虚拟地址空间：  \n> **Linux默认3:1**来分配 user space : kernal space；  \n> **Windows默认2:2**来分配 user space : kernal space。\n\nLinux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。\n\n解释：\n32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 `[0, 2^32]` ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。\n64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 `[0, 2^64]` ，即 4GB * 4GB = 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。\n\n**为什么是 4G 内存：**\n\n首先我们研究的体系是：`x86 32位Linux环境`：  \nLinux操作系统会给当前进程分配一个 `2^32` 大小的空间，那么，`2^32` 换算过来就是 4G 了。\n\n### 1.2 用户空间（User Space）\n\n1. 保留区：\n\t128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 \"NULL\"，它便不会被引用了，从而避免了野指针。\n\t\n1. 指令段【.text】、只读数据段【.rodata】：\n\t指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。\n\t\n\t> 在C++中，不允许普通指针指向常量字符串，需要使用`const`：\n\t> ![示例](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png)\n3. 数据段【.data】：  \n\t存放程序中**已初始化且不为0的全局变量或静态变量**。\n\n4. 数据段【.bss】：\n\t存放程序中未初始化或者初始化为0的全局变量或静态变量。\n\t\n5. 堆【.heap】：\n\t存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。\n\t- 堆用于存放进程`运行时动态分配`的内存段，可动态扩张或缩减。\n\t- 堆中内容是`匿名`的，无法通过名字进行访问，只能通过`指针`进行间接访问。\n\t- 当进程调用`malloc(C)/new(C++)`等函数分配内存时，新分配的在堆上`动态扩张`；当调用`free(C)/delete(C++)`等函数释放内存时，被释放的内存从堆上`动态缩减`\n\t- 分配的堆内存时经过`字节对齐`的空间，以适合`原子操作`。\n\t- `堆管理器`通过`链表`管理每个申请的内存块\n\t- 由于堆内存块的申请与释放都是`无序`的，最终会产生许许多多`内存碎片`。\n\t- 堆的末端由`break指针`标识，当堆管理器需要更多内存时，可通过`系统调用brk和sbrk`来`移动break指针`以扩张堆，一般情况下由系统自动调用。\n\n6. 共享库【.dll、.so】：\n\t动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。\n\n7. 栈【.stack】：\n\t存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。\n\t- 栈中存放`非静态局部变量` `函数形参` `函数返回地址`等。\n\t- 栈中内存空间由`编译器`（静态的）自动分配和释放，行为类似数据结构中的栈结构。\n\n\t\t> 主要用途：\n\t\t> 1. 为函数内部声明的**非静态局部变量**提供存储空间\n\t\t> 2. 记录函数调用过程相关的维护性信息，称为栈帧（stack frame）\n\t\t> 3. 作为`临时存储区`，用于暂时存放`较长的算术表达式部分计算结果`，或者运行时调用alloca函数`动态分配`栈内内存\n\n\t- 栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。\n\t- 查看栈大小：`ulimit -s`可查看和设置`栈的最大值`，当程序使用的栈大小超过该值，会发生`segmentation fault`。\n\t- - 栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。\n\n\n2. 命令行参数：\n\t保存传递给 main 函数的参数，比如 argc 和 argv。\n\n9. 环境变量：\n\t用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。\n\n### 1.3 进程空间（Kernal Space）\n\n1. 内存直接访问区【ZONE_DMA】：\n\t16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。\n\n2. 常用区【ZONE_NORMAL】：\n\t892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。\n\n3. 高端内存区【ZONE_HIGHMEM】：\n\t128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。\n\n### 1.4 最终解释\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png)\n\n> 注意：  \n> 对于`a、b、c以及'{'、'}'`来说，是存储在`.text`指令段的，因为他们生成的都是==指令==。  \n> 例如：  \n> `int a = 12`：生成汇编指令如下：`mov dword ptr[a], 0Ch`\n\n### 1.5 好处\n\n`数据`与`代码指令`分别开辟空间有以下好处：\n\n1. 当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。`数据区`对于进程而言`可读可写`，`代码指令区`对于进程而言`只读`，\n2. 现代CPU一般`数据缓存`和`指令缓存`分离，故进程虚拟地址空间中数据与代码指令分离有助于提高`CPU缓存命中率`。\n3. 若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。\n\n**参考文章：**\n\n>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1\n>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23\n>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09\n>【4】https://blog.csdn.net/m0_46308273/article/details/115818195\n>【5】https://blog.csdn.net/weixin_45437022/article/details/115409679\n\n## 2. 从指令角度掌握函数调用堆栈详细过程\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png)\n栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。\n\n堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：\n\n- PUSH：将目标内存推入栈顶。\n- POP：从栈顶中移除目标。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png)\n\n当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 **栈帧** 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）\n\n### 2.1 ESP 和 EBP\n\n（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。\n（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。\n\n根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。\n\n在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：\n\n- pop ebp;出栈 栈扩大4byte 因为ebp为32位\n- push ebp;入栈，栈减少4byte        \n- add esp, 0Ch；表示栈减小12byte\n- sub esp, 0Ch；表示栈扩大12byte\n\nebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。\n\n\n**代码：**\n\n~~~c++\n#include<iostream>\nusing namespace std;\n\n/*\n问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数\n问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行\n*/\n\nint sum(int a, int b) {\n\tint temp = 0;\n\ttemp = a + b;\n\treturn temp;\n}\n\nint main() {\n\tint a = 10;\n\tint b = 20;\n\n\tint ret = sum(10, 20);\n\tcout << \"ret:\" << ret << endl;\n\t\n\treturn 0;\n}\n~~~\n\n打断点，调试，查看反汇编：\n\n```C++\nint main() {\n// 00007FF637EE23D0  push        rbp  \n// 00007FF637EE23D2  push        rdi  \n// 00007FF637EE23D3  sub         rsp,148h  \n// 00007FF637EE23DA  lea         rbp,[rsp+20h]  \n// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  \n// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  \n\tint a = 10;\n// 00007FF637EE23EB  mov         dword ptr [a],0Ah  \n\tint b = 20;\n// 00007FF637EE23F2  mov         dword ptr [b],14h  \n\n\tint ret = sum(10, 20);\n// 00007FF637EE23F9  mov         edx,14h  \n// 00007FF637EE23FE  mov         ecx,0Ah  \n// 00007FF637EE2403  call        sum (07FF637EE11E5h)  \n// 00007FF637EE2408  mov         dword ptr [ret],eax  \n\tcout << \"ret:\" << ret << endl;\n// 00007FF637EE240B  lea         rdx,[string \"ret:\" (07FF637EEAC24h)]  \n// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  \n// 00007FF637EE2419  call        std::operator<<<std::char_traits<char> > (07FF637EE108Ch)  \n// 00007FF637EE241E  mov         edx,dword ptr [ret]  \n// 00007FF637EE2421  mov         rcx,rax  \n// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF637EF1168h)]  \n// 00007FF637EE242A  lea         rdx,[std::endl<char,std::char_traits<char> > (07FF637EE103Ch)]  \n// 00007FF637EE2431  mov         rcx,rax  \n// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream<char,std::char_traits<char> >::operator<< (07FF637EF1170h)]  \n\n\treturn 0;\n// 00007FF637EE243A  xor         eax,eax  \n}\n// 00007FF637EE243C  lea         rsp,[rbp+128h]  \n// 00007FF637EE2443  pop         rdi  \n// 00007FF637EE2444  pop         rbp  \n// 00007FF637EE2445  ret \n```\n\n### 2.2  解析 main 函数\n\n**1. `{` 会进行入栈操作，`}` 进行出栈操作**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png)\n\n上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。\n\n**为什么这么做呢？**\n\n因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。\n\n在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。\n\n`sub esp, 148h；`减去的值根据程序而定\n\n之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）\n\n之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了\n\n在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png)\n\n所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数\n\n**2. 函数内部：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png)\n\n1. `int a = 10;` 执行一条 mov 指令： \n\t~~~Assembly\n\tmov         dword ptr [a],0Ah\n\t~~~\n\t![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png)\n\n2.  同理 `int b = 20;` 指令：\n\t~~~Assembly\n\tmov         dword ptr [b],14h\n\t~~~\n\t![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png)\n\n3. `int ret = sum(a,b);` 指令：\n\t~~~Assmbly\n\t00F81896 8B 45 EC             mov         eax,dword ptr [b] \n\t00F81899 50                   push        eax     #压栈 b的值\n\t00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  \n\t00F8189D 51                   push        ecx     #压栈 a的值\n\t00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call\n\t00F818A3 83 C4 08             add         esp,8  \n\t00F818A6 89 45 E0             mov         dword ptr [ret],eax \n\t~~~\n\n### 2.3 sum 函数调用后\n\n**函数调用参数的压栈顺序:参数由右向左压入堆栈。**\n\n**因此上面对应的是：**\n\n先将b的值压入堆栈，再将a的值压入堆栈\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png)\n**执行call        sum (0F8108Ch)：**\n\n**call函数首先会将下一行执行的地址入栈**：假设下一行指令的地址位0x08124458\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png)\n\n **第二步进入函数调用：sum**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png)\n\n函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈\n\n第二步：将新的栈底ebp指向原来的栈顶esp\n\n第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png)\n\n接着执行 `int temp = 0;` 指令：\n\n~~~assembly\nmov         dword ptr [temp],0\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png)\n\ntemp = a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png)\n\n接着运行`return temp;`: \n\n~~~assembly\nmov         eax,dword ptr [temp]\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png)\n\n接着是`函数的右括号“}”`：\n\n（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。\n（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。\n（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png)\n\n### 2.4 返回 main 函数后\n\n接着调用函数完毕，回到主函数：  \n利用了`PC寄存器`，使得程序知道退出sum后运行哪一条指令：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png)\n\n`add         esp,8` ,将压栈的a b 形参空间回收\n\n`mov         dword ptr [ret],eax` 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png)\n最后`return 0`，程序结束\n\n### 2.5 栈溢出问题\n\n出现栈内存溢出的常见原因有2个：\n\n1. 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。\n2. 局部静态变量体积太大。\n\n> 第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。\n> 检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。\n\n>    第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组\n\n```C++\n    即如果函数这样写：\n    void test_stack_overflow()\n    {\n      char* chdata = new[2*1024*1024];\n      delete []chdata;\n    }\n   是不会出现这个错误的，而这样写则不行：\n    void test_stack_overflow()\n    {\n      char chdata[2*1024*1024];\n    }\n   大多数情况下都会出现内存溢出的错误,\n```\n\n解决办法大致说来也有两种：  \n\n1. 增加栈内存的数目  \n2. 使用堆内存\n\n## 3. 从编译器角度理解 C++ 代码的编译、链接\n\n整个编译过程分为两大步：\n\n1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件\n\n2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序\n\n### 3.1 编译\n\n细分为3个阶段：\n\n**1.1）编译预处理**\n\n预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 `#include`），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 `#include` 包含的文件代码，进行 `#define` 宏定义的替换 ， 处理条件编译指令 （`#ifndef`、 `#ifdef`、 `#endif`）等。\n\n预编译过程相当于如下命令：\n\n~~~shell\ngcc -E main.c -o main.i\n~~~\n\n主要规则如下：\n\n1. 将所有的 `#define` 删除，并且展开所有的宏定义；\n2. 处理所有条件预编译指令，比如`#if`、`#ifdef`、`#elif`、`#else`、`#endif`;\n4. 处理 `#include` 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；\n5. 删除所有的注释：`//` 和 `/**/`；\n6. 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；\n7. 保留所有的 `#pragma` 编译器指令，因为编译器要使用它们。\n\n> 注：  \n> `#pragma lib`、`pragma link`  \n> 等命令是在链接过程处理的。\n\n预编译后得到的文件为：`.i`文件。\n\n**1.2）编译**\n\n通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。\n\n编译过程相当于如下命令：\n\n~~~shell\ngcc -S main.i -o main.s\n~~~\n\n编译后得到的文件为：`.s`文件。\n\n**1.3) 汇编**\n\n汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。\n\n目标文件由段组成，通常至少有两个段：\n\n1. .text：包换主要程序的指令。该段是可读和可执行的，一般不可写\n2. .data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。\n\n汇编过程我们可以调用汇编器`as`来完成：\n\n~~~shell\nas main.s -o main.o  \n# 或者：  \ngcc -c main.s -o mian.o\n~~~\n\n这个过程将.s文件转化成.o文件。\n\n### 3.2 链接过程\n\n链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。\n\n**链接的时机**：\n\n- 编译时，也就是在源代码被翻译成机器代码时\n- 加载时，也就是在程序被加载器加载到存储器并执行时\n- 运行时，由应用程序执行\n\n#### 1. 静态链接\n\n**静态链接器**以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。\n\n为了构造可执行文件，**链接器必须完成两个任务：符号解析，重定位**\n\n1. **符号解析：** 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。\n2. **重定位：** 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。\n\n链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png)\n\n目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。\n\n#### 2. 目标文件\n\n**三种形式：**\n\n1. **可重定位目标文件**。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。\n2. **可执行目标文件**。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。\n3. **共享目标文件**。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。\n\n编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。\n\n#### 3.  可重定位目标文件\n\n一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。\n\n![ELF可重定位目标文件](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png)\n\n夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：\n\n- **.text：** 已编译程序的机器代码。\n- **.rodata：** 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。\n- **.data：** 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。\n- **.bss：** 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。\n- **.symtab：** 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。\n- **.rel.text：** 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。\n- **.rel.data：** 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。\n- **.debug：** 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。\n- **.line：** 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。\n- **.strtab：** 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。\n\n#### 4. 符号和符号表\n\n每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段\n\n在链接器的上下文中，有三种不同的符号：\n\n由m定义并能被其他模块引用的全局符号\n由其他模块定义并被模块m引用的全局符号\n只被模块m引用的本地符号\n\n例如：\n\n`main.cpp` 内容 和 `sum.cpp` 内容如下：\n\n~~~c++\n// main.cpp\n#include <iostream>\nusing namespace std;\n\nextern int gdata;\nint sum(int, int);\n\nint data = 20;\n\nint main()\n{\n\tint a = gdata;\n\tint b = data;\n\n\tint ret = sum(a, b);\n\n\treturn 0;\n}\n~~~\n\n~~~c++\n// sum.cpp\n#include <iostream>\nusing namespace std;\n\nint gdata = 10;\nint sum(int a, int b)\n{\n\treturn a + b;\n}\n~~~\n\n**g++ -c** 只编译不链接，只生成目标文件\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png)\n\n **objdump -t main.o // 输出目标文件的符号表：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png)\n\n- 第一列：段内偏移；\n- 第二列：符号作用域  : local /global；\n- 第三列：符号类型；\n- 第四列：符号所在段（*UND*外部链接符号，未在本目标文件定义）；\n- 第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；\n- 第六列：符号名；\n\n其中 `main` 定义在 `.text`\n\ndata 是全局变量，且初始化定义在 `.data` ,也就是 m 定义并能被其他模块引用的全局符号。\ngdata 和 sum 函数是声明，因此是*UNG*，也就是由其他模块定义并被模块 m 引用的全局符号。\n\n第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配\n\n在 `sum.o` 中：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png)\n\ngdata 是出刷的全局变量 在 `.data` 中；sum 函数在 `.text` 中\n\n`readelf -h` 查看 elf 文件的头文件信息\n可见目标文件的elf文件，其类型为REL(可重定位文件)。 \n\n`objdump -s` 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png)\n\n有调试信息的：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png)\n\n可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。\n#### 5. 符号解析\n\n链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（*UNG*）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）\n\n **链接器如何解析多重定义的全局符号：**\n\n在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。\n       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：\n\n规则1：不允许有多个强符号。\n规则2：如果有一个强符号和多个弱符号，那么选择强符号。\n规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。\n\n**链接器如何使用静态库来解析引用：**\n\n在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。\n\n> 1. 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。\n> 2. 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。\n> 3. 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。\n\n这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。\n\n另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。\n\n如果需要满足依赖需求，可以在命令行上重复库。\n\n#### 6. 重定向\n一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。\n\n重定位有两步组成：\n\n1. **重定位节和符号定义**。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。\n2. **重定位节中的符号引用**。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为`重定位条目`的可重定位目标模块中的数据结构。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png)\n\n链接后：所有的符号都有虚拟地址\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png)\n\n汇编中，全局变量和函数都有了地址。\n\n#### 7. 可执行目标文件\n\n可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。`.text` 、`.rodata` 和 `.data` 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。\n\nELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png)\n\n","slug":"02.C++ 基础部分/01.理解 C++ 内核","published":1,"date":"2023-08-03T00:31:11.401Z","updated":"2023-08-09T09:13:55.154Z","_id":"clkufs4140000b0pkgkc45jvo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节内容分为三部分：</p>\n<ol>\n<li>掌握进程虚拟地址空间区域划分</li>\n<li>从指令角度掌握函数调用堆栈详细过程</li>\n<li>从编译器角度理解C++代码的编译、链接</li>\n</ol>\n<p>通过了解底层基础，了解 C++ 的如何运行。</p>\n<h2 id=\"1-掌握进程虚拟地址空间区域划分\"><a href=\"#1-掌握进程虚拟地址空间区域划分\" class=\"headerlink\" title=\"1. 掌握进程虚拟地址空间区域划分\"></a>1. 掌握进程虚拟地址空间区域划分</h2><p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">int</span> gdata1 = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> gdata2 = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-type\">int</span> gdata3;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> gdata4 = <span class=\"hljs-number\">11</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> gdata5 = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> gdata6;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">12</span>;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> c;<br><br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> d = <span class=\"hljs-number\">13</span>;<br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> e = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> f;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>根据上述代码，如何得知各个变量存储的位置？</p>\n<h3 id=\"1-1-虚拟进程视图\"><a href=\"#1-1-虚拟进程视图\" class=\"headerlink\" title=\"1.1 虚拟进程视图\"></a>1.1 虚拟进程视图</h3><p>首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。</p>\n<p>这里附上IBM公司关于<strong>虚拟</strong>的解释:</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">它存在，你看得见，它是物理的<br>它存在，你看不见，它是透明的<br>它不存在，你看得见，它是虚拟的<br>它不存在，你看不见，它被删除<br></code></pre></td></tr></table></figure>\n\n<p>这块空间的内容如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png\" alt=\"虚拟进程空间示例图 CN\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png\" alt=\"虚拟进程空间示例图 EN\"></p>\n<blockquote>\n<p>补充：<br>x86 32位体系下的4G虚拟地址空间：<br><strong>Linux默认3:1</strong>来分配 user space : kernal space；<br><strong>Windows默认2:2</strong>来分配 user space : kernal space。</p>\n</blockquote>\n<p>Linux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。</p>\n<p>解释：<br>32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 <code>[0, 2^32]</code> ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。<br>64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 <code>[0, 2^64]</code> ，即 4GB * 4GB &#x3D; 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。</p>\n<p><strong>为什么是 4G 内存：</strong></p>\n<p>首先我们研究的体系是：<code>x86 32位Linux环境</code>：<br>Linux操作系统会给当前进程分配一个 <code>2^32</code> 大小的空间，那么，<code>2^32</code> 换算过来就是 4G 了。</p>\n<h3 id=\"1-2-用户空间（User-Space）\"><a href=\"#1-2-用户空间（User-Space）\" class=\"headerlink\" title=\"1.2 用户空间（User Space）\"></a>1.2 用户空间（User Space）</h3><ol>\n<li><p>保留区：<br> 128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 “NULL”，它便不会被引用了，从而避免了野指针。</p>\n</li>\n<li><p>指令段【.text】、只读数据段【.rodata】：<br> 指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。</p>\n<blockquote>\n<p>在C++中，不允许普通指针指向常量字符串，需要使用<code>const</code>：<br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png\" alt=\"示例\"></p>\n</blockquote>\n</li>\n<li><p>数据段【.data】：<br> 存放程序中<strong>已初始化且不为0的全局变量或静态变量</strong>。</p>\n</li>\n<li><p>数据段【.bss】：<br> 存放程序中未初始化或者初始化为0的全局变量或静态变量。</p>\n</li>\n<li><p>堆【.heap】：<br> 存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。</p>\n<ul>\n<li>堆用于存放进程<code>运行时动态分配</code>的内存段，可动态扩张或缩减。</li>\n<li>堆中内容是<code>匿名</code>的，无法通过名字进行访问，只能通过<code>指针</code>进行间接访问。</li>\n<li>当进程调用<code>malloc(C)/new(C++)</code>等函数分配内存时，新分配的在堆上<code>动态扩张</code>；当调用<code>free(C)/delete(C++)</code>等函数释放内存时，被释放的内存从堆上<code>动态缩减</code></li>\n<li>分配的堆内存时经过<code>字节对齐</code>的空间，以适合<code>原子操作</code>。</li>\n<li><code>堆管理器</code>通过<code>链表</code>管理每个申请的内存块</li>\n<li>由于堆内存块的申请与释放都是<code>无序</code>的，最终会产生许许多多<code>内存碎片</code>。</li>\n<li>堆的末端由<code>break指针</code>标识，当堆管理器需要更多内存时，可通过<code>系统调用brk和sbrk</code>来<code>移动break指针</code>以扩张堆，一般情况下由系统自动调用。</li>\n</ul>\n</li>\n<li><p>共享库【.dll、.so】：<br> 动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。</p>\n</li>\n<li><p>栈【.stack】：<br> 存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。</p>\n<ul>\n<li><p>栈中存放<code>非静态局部变量</code> <code>函数形参</code> <code>函数返回地址</code>等。</p>\n</li>\n<li><p>栈中内存空间由<code>编译器</code>（静态的）自动分配和释放，行为类似数据结构中的栈结构。</p>\n<blockquote>\n<p>主要用途：</p>\n<ol>\n<li>为函数内部声明的<strong>非静态局部变量</strong>提供存储空间</li>\n<li>记录函数调用过程相关的维护性信息，称为栈帧（stack frame）</li>\n<li>作为<code>临时存储区</code>，用于暂时存放<code>较长的算术表达式部分计算结果</code>，或者运行时调用alloca函数<code>动态分配</code>栈内内存</li>\n</ol>\n</blockquote>\n</li>\n<li><p>栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。</p>\n</li>\n<li><p>查看栈大小：<code>ulimit -s</code>可查看和设置<code>栈的最大值</code>，当程序使用的栈大小超过该值，会发生<code>segmentation fault</code>。</p>\n</li>\n<li><ul>\n<li>栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>命令行参数：<br> 保存传递给 main 函数的参数，比如 argc 和 argv。</p>\n</li>\n<li><p>环境变量：<br> 用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。</p>\n</li>\n</ol>\n<h3 id=\"1-3-进程空间（Kernal-Space）\"><a href=\"#1-3-进程空间（Kernal-Space）\" class=\"headerlink\" title=\"1.3 进程空间（Kernal Space）\"></a>1.3 进程空间（Kernal Space）</h3><ol>\n<li><p>内存直接访问区【ZONE_DMA】：<br> 16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。</p>\n</li>\n<li><p>常用区【ZONE_NORMAL】：<br> 892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。</p>\n</li>\n<li><p>高端内存区【ZONE_HIGHMEM】：<br> 128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。</p>\n</li>\n</ol>\n<h3 id=\"1-4-最终解释\"><a href=\"#1-4-最终解释\" class=\"headerlink\" title=\"1.4 最终解释\"></a>1.4 最终解释</h3><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>注意：<br>对于<code>a、b、c以及&#39;&#123;&#39;、&#39;&#125;&#39;</code>来说，是存储在<code>.text</code>指令段的，因为他们生成的都是&#x3D;&#x3D;指令&#x3D;&#x3D;。<br>例如：<br><code>int a = 12</code>：生成汇编指令如下：<code>mov dword ptr[a], 0Ch</code></p>\n</blockquote>\n<h3 id=\"1-5-好处\"><a href=\"#1-5-好处\" class=\"headerlink\" title=\"1.5 好处\"></a>1.5 好处</h3><p><code>数据</code>与<code>代码指令</code>分别开辟空间有以下好处：</p>\n<ol>\n<li>当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。<code>数据区</code>对于进程而言<code>可读可写</code>，<code>代码指令区</code>对于进程而言<code>只读</code>，</li>\n<li>现代CPU一般<code>数据缓存</code>和<code>指令缓存</code>分离，故进程虚拟地址空间中数据与代码指令分离有助于提高<code>CPU缓存命中率</code>。</li>\n<li>若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。</li>\n</ol>\n<p><strong>参考文章：</strong></p>\n<blockquote>\n<p>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1<br>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23<br>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09<br>【4】<a href=\"https://blog.csdn.net/m0_46308273/article/details/115818195\">https://blog.csdn.net/m0_46308273/article/details/115818195</a><br>【5】<a href=\"https://blog.csdn.net/weixin_45437022/article/details/115409679\">https://blog.csdn.net/weixin_45437022/article/details/115409679</a></p>\n</blockquote>\n<h2 id=\"2-从指令角度掌握函数调用堆栈详细过程\"><a href=\"#2-从指令角度掌握函数调用堆栈详细过程\" class=\"headerlink\" title=\"2. 从指令角度掌握函数调用堆栈详细过程\"></a>2. 从指令角度掌握函数调用堆栈详细过程</h2><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png\" alt=\"image.png\"><br>栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。</p>\n<p>堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：</p>\n<ul>\n<li>PUSH：将目标内存推入栈顶。</li>\n<li>POP：从栈顶中移除目标。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png\" alt=\"image.png\"></p>\n<p>当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 <strong>栈帧</strong> 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）</p>\n<h3 id=\"2-1-ESP-和-EBP\"><a href=\"#2-1-ESP-和-EBP\" class=\"headerlink\" title=\"2.1 ESP 和 EBP\"></a>2.1 ESP 和 EBP</h3><p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p>\n<p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p>\n<p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：</p>\n<ul>\n<li>pop ebp;出栈 栈扩大4byte 因为ebp为32位</li>\n<li>push ebp;入栈，栈减少4byte        </li>\n<li>add esp, 0Ch；表示栈减小12byte</li>\n<li>sub esp, 0Ch；表示栈扩大12byte</li>\n</ul>\n<p>ebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数</span><br><span class=\"hljs-comment\">问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>\ttemp = a + b;<br>\t<span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><br>\t<span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>打断点，调试，查看反汇编：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-comment\">// 00007FF637EE23D0  push        rbp  </span><br><span class=\"hljs-comment\">// 00007FF637EE23D2  push        rdi  </span><br><span class=\"hljs-comment\">// 00007FF637EE23D3  sub         rsp,148h  </span><br><span class=\"hljs-comment\">// 00007FF637EE23DA  lea         rbp,[rsp+20h]  </span><br><span class=\"hljs-comment\">// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  </span><br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-comment\">// 00007FF637EE23EB  mov         dword ptr [a],0Ah  </span><br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-comment\">// 00007FF637EE23F2  mov         dword ptr [b],14h  </span><br><br>\t<span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br><span class=\"hljs-comment\">// 00007FF637EE23F9  mov         edx,14h  </span><br><span class=\"hljs-comment\">// 00007FF637EE23FE  mov         ecx,0Ah  </span><br><span class=\"hljs-comment\">// 00007FF637EE2403  call        sum (07FF637EE11E5h)  </span><br><span class=\"hljs-comment\">// 00007FF637EE2408  mov         dword ptr [ret],eax  </span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class=\"hljs-comment\">// 00007FF637EE240B  lea         rdx,[string &quot;ret:&quot; (07FF637EEAC24h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2419  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF637EE108Ch)  </span><br><span class=\"hljs-comment\">// 00007FF637EE241E  mov         edx,dword ptr [ret]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2421  mov         rcx,rax  </span><br><span class=\"hljs-comment\">// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1168h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE242A  lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF637EE103Ch)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2431  mov         rcx,rax  </span><br><span class=\"hljs-comment\">// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1170h)]  </span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-comment\">// 00007FF637EE243A  xor         eax,eax  </span><br>&#125;<br><span class=\"hljs-comment\">// 00007FF637EE243C  lea         rsp,[rbp+128h]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2443  pop         rdi  </span><br><span class=\"hljs-comment\">// 00007FF637EE2444  pop         rbp  </span><br><span class=\"hljs-comment\">// 00007FF637EE2445  ret </span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-解析-main-函数\"><a href=\"#2-2-解析-main-函数\" class=\"headerlink\" title=\"2.2  解析 main 函数\"></a>2.2  解析 main 函数</h3><p><strong>1. <code>&#123;</code> 会进行入栈操作，<code>&#125;</code> 进行出栈操作</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png\" alt=\"image.png\"></p>\n<p>上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。</p>\n<p><strong>为什么这么做呢？</strong></p>\n<p>因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。</p>\n<p>在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</p>\n<p><code>sub esp, 148h；</code>减去的值根据程序而定</p>\n<p>之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</p>\n<p>之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</p>\n<p>在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png\" alt=\"image.png\"></p>\n<p>所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数</p>\n<p><strong>2. 函数内部：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png\" alt=\"image.png\"></p>\n<ol>\n<li><p><code>int a = 10;</code> 执行一条 mov 指令： </p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Assembly\">mov         dword ptr [a],0Ah<br></code></pre></td></tr></table></figure>\n<p> <img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png\" alt=\"image.png\"></p>\n</li>\n<li><p> 同理 <code>int b = 20;</code> 指令：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Assembly\">mov         dword ptr [b],14h<br></code></pre></td></tr></table></figure>\n<p> <img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png\" alt=\"image.png\"></p>\n</li>\n<li><p><code>int ret = sum(a,b);</code> 指令：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Assmbly\">00F81896 8B 45 EC             mov         eax,dword ptr [b] <br>00F81899 50                   push        eax     #压栈 b的值<br>00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  <br>00F8189D 51                   push        ecx     #压栈 a的值<br>00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call<br>00F818A3 83 C4 08             add         esp,8  <br>00F818A6 89 45 E0             mov         dword ptr [ret],eax <br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"2-3-sum-函数调用后\"><a href=\"#2-3-sum-函数调用后\" class=\"headerlink\" title=\"2.3 sum 函数调用后\"></a>2.3 sum 函数调用后</h3><p><strong>函数调用参数的压栈顺序:参数由右向左压入堆栈。</strong></p>\n<p><strong>因此上面对应的是：</strong></p>\n<p>先将b的值压入堆栈，再将a的值压入堆栈</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png\" alt=\"image.png\"><br><strong>执行call        sum (0F8108Ch)：</strong></p>\n<p><strong>call函数首先会将下一行执行的地址入栈</strong>：假设下一行指令的地址位0x08124458</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png\" alt=\"image.png\"></p>\n<p> <strong>第二步进入函数调用：sum</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png\" alt=\"image.png\"></p>\n<p>函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈</p>\n<p>第二步：将新的栈底ebp指向原来的栈顶esp</p>\n<p>第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png\" alt=\"image.png\"></p>\n<p>接着执行 <code>int temp = 0;</code> 指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">mov         dword ptr [temp],0<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png\" alt=\"image.png\"></p>\n<p>temp &#x3D; a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png\" alt=\"image.png\"></p>\n<p>接着运行<code>return temp;</code>: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">mov         eax,dword ptr [temp]<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png\" alt=\"image.png\"></p>\n<p>接着是<code>函数的右括号“&#125;”</code>：</p>\n<p>（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。<br>（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。<br>（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png\" alt=\"image.png\"></p>\n<h3 id=\"2-4-返回-main-函数后\"><a href=\"#2-4-返回-main-函数后\" class=\"headerlink\" title=\"2.4 返回 main 函数后\"></a>2.4 返回 main 函数后</h3><p>接着调用函数完毕，回到主函数：<br>利用了<code>PC寄存器</code>，使得程序知道退出sum后运行哪一条指令：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png\" alt=\"image.png\"></p>\n<p><code>add         esp,8</code> ,将压栈的a b 形参空间回收</p>\n<p><code>mov         dword ptr [ret],eax</code> 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png\" alt=\"image.png\"><br>最后<code>return 0</code>，程序结束</p>\n<h3 id=\"2-5-栈溢出问题\"><a href=\"#2-5-栈溢出问题\" class=\"headerlink\" title=\"2.5 栈溢出问题\"></a>2.5 栈溢出问题</h3><p>出现栈内存溢出的常见原因有2个：</p>\n<ol>\n<li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li>\n<li>局部静态变量体积太大。</li>\n</ol>\n<blockquote>\n<p>第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。<br>检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。</p>\n</blockquote>\n<blockquote>\n<p>   第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> 即如果函数这样写：<br> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_stack_overflow</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"> </span>&#123;<br>   <span class=\"hljs-type\">char</span>* chdata = <span class=\"hljs-keyword\">new</span>[<span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>];<br>   <span class=\"hljs-keyword\">delete</span> []chdata;<br> &#125;<br>是不会出现这个错误的，而这样写则不行：<br> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_stack_overflow</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"> </span>&#123;<br>   <span class=\"hljs-type\">char</span> chdata[<span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>];<br> &#125;<br>大多数情况下都会出现内存溢出的错误,<br></code></pre></td></tr></table></figure>\n\n<p>解决办法大致说来也有两种：  </p>\n<ol>\n<li>增加栈内存的数目  </li>\n<li>使用堆内存</li>\n</ol>\n<h2 id=\"3-从编译器角度理解-C-代码的编译、链接\"><a href=\"#3-从编译器角度理解-C-代码的编译、链接\" class=\"headerlink\" title=\"3. 从编译器角度理解 C++ 代码的编译、链接\"></a>3. 从编译器角度理解 C++ 代码的编译、链接</h2><p>整个编译过程分为两大步：</p>\n<p>1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件</p>\n<p>2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序</p>\n<h3 id=\"3-1-编译\"><a href=\"#3-1-编译\" class=\"headerlink\" title=\"3.1 编译\"></a>3.1 编译</h3><p>细分为3个阶段：</p>\n<p><strong>1.1）编译预处理</strong></p>\n<p>预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 <code>#include</code>），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 <code>#include</code> 包含的文件代码，进行 <code>#define</code> 宏定义的替换 ， 处理条件编译指令 （<code>#ifndef</code>、 <code>#ifdef</code>、 <code>#endif</code>）等。</p>\n<p>预编译过程相当于如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">gcc -E main.c -o main.i<br></code></pre></td></tr></table></figure>\n\n<p>主要规则如下：</p>\n<ol>\n<li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义；</li>\n<li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>;</li>\n<li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；</li>\n<li>删除所有的注释：<code>//</code> 和 <code>/**/</code>；</li>\n<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；</li>\n<li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要使用它们。</li>\n</ol>\n<blockquote>\n<p>注：<br><code>#pragma lib</code>、<code>pragma link</code><br>等命令是在链接过程处理的。</p>\n</blockquote>\n<p>预编译后得到的文件为：<code>.i</code>文件。</p>\n<p><strong>1.2）编译</strong></p>\n<p>通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</p>\n<p>编译过程相当于如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">gcc -S main.i -o main.s<br></code></pre></td></tr></table></figure>\n\n<p>编译后得到的文件为：<code>.s</code>文件。</p>\n<p><strong>1.3) 汇编</strong></p>\n<p>汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。</p>\n<p>目标文件由段组成，通常至少有两个段：</p>\n<ol>\n<li>.text：包换主要程序的指令。该段是可读和可执行的，一般不可写</li>\n<li>.data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。</li>\n</ol>\n<p>汇编过程我们可以调用汇编器<code>as</code>来完成：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">as main.s -o main.o  <br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">或者：</span>  <br>gcc -c main.s -o mian.o<br></code></pre></td></tr></table></figure>\n\n<p>这个过程将.s文件转化成.o文件。</p>\n<h3 id=\"3-2-链接过程\"><a href=\"#3-2-链接过程\" class=\"headerlink\" title=\"3.2 链接过程\"></a>3.2 链接过程</h3><p>链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。</p>\n<p><strong>链接的时机</strong>：</p>\n<ul>\n<li>编译时，也就是在源代码被翻译成机器代码时</li>\n<li>加载时，也就是在程序被加载器加载到存储器并执行时</li>\n<li>运行时，由应用程序执行</li>\n</ul>\n<h4 id=\"1-静态链接\"><a href=\"#1-静态链接\" class=\"headerlink\" title=\"1. 静态链接\"></a>1. 静态链接</h4><p><strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p>\n<p>为了构造可执行文件，<strong>链接器必须完成两个任务：符号解析，重定位</strong></p>\n<ol>\n<li><strong>符号解析：</strong> 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>\n<li><strong>重定位：</strong> 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>\n</ol>\n<p>链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png\" alt=\"image.png\"></p>\n<p>目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>\n<h4 id=\"2-目标文件\"><a href=\"#2-目标文件\" class=\"headerlink\" title=\"2. 目标文件\"></a>2. 目标文件</h4><p><strong>三种形式：</strong></p>\n<ol>\n<li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>\n<li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li>\n<li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。</li>\n</ol>\n<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。</p>\n<h4 id=\"3-可重定位目标文件\"><a href=\"#3-可重定位目标文件\" class=\"headerlink\" title=\"3.  可重定位目标文件\"></a>3.  可重定位目标文件</h4><p>一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png\" alt=\"ELF可重定位目标文件\"></p>\n<p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p>\n<ul>\n<li><strong>.text：</strong> 已编译程序的机器代码。</li>\n<li><strong>.rodata：</strong> 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li>\n<li><strong>.data：</strong> 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li>\n<li><strong>.bss：</strong> 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li>\n<li><strong>.symtab：</strong> 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li>\n<li><strong>.rel.text：</strong> 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li>\n<li><strong>.rel.data：</strong> 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li>\n<li><strong>.debug：</strong> 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li>\n<li><strong>.line：</strong> 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li>\n<li><strong>.strtab：</strong> 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>\n</ul>\n<h4 id=\"4-符号和符号表\"><a href=\"#4-符号和符号表\" class=\"headerlink\" title=\"4. 符号和符号表\"></a>4. 符号和符号表</h4><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段</p>\n<p>在链接器的上下文中，有三种不同的符号：</p>\n<p>由m定义并能被其他模块引用的全局符号<br>由其他模块定义并被模块m引用的全局符号<br>只被模块m引用的本地符号</p>\n<p>例如：</p>\n<p><code>main.cpp</code> 内容 和 <code>sum.cpp</code> 内容如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// main.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-type\">int</span> gdata;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span>;<br><br><span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">20</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = gdata;<br>\t<span class=\"hljs-type\">int</span> b = data;<br><br>\t<span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(a, b);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// sum.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">int</span> gdata = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>g++ -c</strong> 只编译不链接，只生成目标文件</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png\" alt=\"image.png\"></p>\n<p> <strong>objdump -t main.o &#x2F;&#x2F; 输出目标文件的符号表：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png\" alt=\"image.png\"></p>\n<ul>\n<li>第一列：段内偏移；</li>\n<li>第二列：符号作用域  : local &#x2F;global；</li>\n<li>第三列：符号类型；</li>\n<li>第四列：符号所在段（<em>UND</em>外部链接符号，未在本目标文件定义）；</li>\n<li>第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；</li>\n<li>第六列：符号名；</li>\n</ul>\n<p>其中 <code>main</code> 定义在 <code>.text</code></p>\n<p>data 是全局变量，且初始化定义在 <code>.data</code> ,也就是 m 定义并能被其他模块引用的全局符号。<br>gdata 和 sum 函数是声明，因此是<em>UNG</em>，也就是由其他模块定义并被模块 m 引用的全局符号。</p>\n<p>第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配</p>\n<p>在 <code>sum.o</code> 中：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png\" alt=\"image.png\"></p>\n<p>gdata 是出刷的全局变量 在 <code>.data</code> 中；sum 函数在 <code>.text</code> 中</p>\n<p><code>readelf -h</code> 查看 elf 文件的头文件信息<br>可见目标文件的elf文件，其类型为REL(可重定位文件)。 </p>\n<p><code>objdump -s</code> 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png\" alt=\"image.png\"></p>\n<p>有调试信息的：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png\" alt=\"image.png\"></p>\n<p>可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。</p>\n<h4 id=\"5-符号解析\"><a href=\"#5-符号解析\" class=\"headerlink\" title=\"5. 符号解析\"></a>5. 符号解析</h4><p>链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（<em>UNG</em>）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）</p>\n<p> <strong>链接器如何解析多重定义的全局符号：</strong></p>\n<p>在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。<br>       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：</p>\n<p>规则1：不允许有多个强符号。<br>规则2：如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。</p>\n<p><strong>链接器如何使用静态库来解析引用：</strong></p>\n<p>在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。</p>\n<blockquote>\n<ol>\n<li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。</li>\n<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。</li>\n<li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li>\n</ol>\n</blockquote>\n<p>这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。</p>\n<p>另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。</p>\n<p>如果需要满足依赖需求，可以在命令行上重复库。</p>\n<h4 id=\"6-重定向\"><a href=\"#6-重定向\" class=\"headerlink\" title=\"6. 重定向\"></a>6. 重定向</h4><p>一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。</p>\n<p>重定位有两步组成：</p>\n<ol>\n<li><strong>重定位节和符号定义</strong>。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li>\n<li><strong>重定位节中的符号引用</strong>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<code>重定位条目</code>的可重定位目标模块中的数据结构。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png\" alt=\"image.png\"></p>\n<p>链接后：所有的符号都有虚拟地址</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png\" alt=\"image.png\"></p>\n<p>汇编中，全局变量和函数都有了地址。</p>\n<h4 id=\"7-可执行目标文件\"><a href=\"#7-可执行目标文件\" class=\"headerlink\" title=\"7. 可执行目标文件\"></a>7. 可执行目标文件</h4><p>可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<code>.text</code> 、<code>.rodata</code> 和 <code>.data</code> 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。</p>\n<p>ELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本节内容分为三部分：</p>\n<ol>\n<li>掌握进程虚拟地址空间区域划分</li>\n<li>从指令角度掌握函数调用堆栈详细过程</li>\n<li>从编译器角度理解C++代码的编译、链接</li>\n</ol>\n<p>通过了解底层基础，了解 C++ 的如何运行。</p>\n<h2 id=\"1-掌握进程虚拟地址空间区域划分\"><a href=\"#1-掌握进程虚拟地址空间区域划分\" class=\"headerlink\" title=\"1. 掌握进程虚拟地址空间区域划分\"></a>1. 掌握进程虚拟地址空间区域划分</h2><p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">int</span> gdata1 = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> gdata2 = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-type\">int</span> gdata3;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> gdata4 = <span class=\"hljs-number\">11</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> gdata5 = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> gdata6;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">12</span>;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> c;<br><br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> d = <span class=\"hljs-number\">13</span>;<br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> e = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> f;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>根据上述代码，如何得知各个变量存储的位置？</p>\n<h3 id=\"1-1-虚拟进程视图\"><a href=\"#1-1-虚拟进程视图\" class=\"headerlink\" title=\"1.1 虚拟进程视图\"></a>1.1 虚拟进程视图</h3><p>首先要知道一点，程序由磁盘加载到内存时是不可能直接加载到物理内存当中的，这里的原因以及物理内存和虚拟内存的区别与联系在本篇先不做讨论 本篇接下来所讨论的范围在 x86 体系 32 位 Linux 环境下 Linux 系统会给当前每一个进程分配一个 2^32 位大小(4G)的一块空间，这块空间就叫做进程的虚拟地址空间。</p>\n<p>这里附上IBM公司关于<strong>虚拟</strong>的解释:</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">它存在，你看得见，它是物理的<br>它存在，你看不见，它是透明的<br>它不存在，你看得见，它是虚拟的<br>它不存在，你看不见，它被删除<br></code></pre></td></tr></table></figure>\n\n<p>这块空间的内容如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030903283.png\" alt=\"虚拟进程空间示例图 CN\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030914652.png\" alt=\"虚拟进程空间示例图 EN\"></p>\n<blockquote>\n<p>补充：<br>x86 32位体系下的4G虚拟地址空间：<br><strong>Linux默认3:1</strong>来分配 user space : kernal space；<br><strong>Windows默认2:2</strong>来分配 user space : kernal space。</p>\n</blockquote>\n<p>Linux 中每一个运行的程序（进程），32 位操作系统都会为其分配一个 0 ～ 4GB 的进程虚拟地址空间，64 位操作系统会为其分配一个 0 ～ 16GB 的进程虚拟地址空间。</p>\n<p>解释：<br>32 位操作系统下，一个指针的大小为 32 位即 4 个字节，它所能保存的地址范围为 <code>[0, 2^32]</code> ，所以它的寻址范围为 4GB 大小，所以 32 位操作系统下系统给进程分配的虚拟地址空间大小为 4 GB 。<br>64 位操作系统下，一个指针的大小为 64 位即 8 个字节，它所能保存的地址范围为 <code>[0, 2^64]</code> ，即 4GB * 4GB &#x3D; 16GB，所以它的寻址范围为 16GB 大小，所以 64 位操作系统下系统给进程分配的虚拟地址空间大小为 16GB。</p>\n<p><strong>为什么是 4G 内存：</strong></p>\n<p>首先我们研究的体系是：<code>x86 32位Linux环境</code>：<br>Linux操作系统会给当前进程分配一个 <code>2^32</code> 大小的空间，那么，<code>2^32</code> 换算过来就是 4G 了。</p>\n<h3 id=\"1-2-用户空间（User-Space）\"><a href=\"#1-2-用户空间（User-Space）\" class=\"headerlink\" title=\"1.2 用户空间（User Space）\"></a>1.2 用户空间（User Space）</h3><ol>\n<li><p>保留区：<br> 128M 大小，不可访问，不允许读写。任何普通程序对它的引用都是非法的，一般用来捕捉空指针和小整型值指针引用内存的异常情况。在定义指针时将其初始化为 “NULL”，它便不会被引用了，从而避免了野指针。</p>\n</li>\n<li><p>指令段【.text】、只读数据段【.rodata】：<br> 指令段存放指令，只能读，不能写；只读数据段中存放只读数据，比如字符串常量等，只能读，不能写。</p>\n<blockquote>\n<p>在C++中，不允许普通指针指向常量字符串，需要使用<code>const</code>：<br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030909413.png\" alt=\"示例\"></p>\n</blockquote>\n</li>\n<li><p>数据段【.data】：<br> 存放程序中<strong>已初始化且不为0的全局变量或静态变量</strong>。</p>\n</li>\n<li><p>数据段【.bss】：<br> 存放程序中未初始化或者初始化为0的全局变量或静态变量。</p>\n</li>\n<li><p>堆【.heap】：<br> 存放动态数据，需要程序员手动开辟、释放空间，在程序刚开始运行时，此区域为空，等到程序运行到手动开辟空间的指令时，此区域动态扩张。自下向上增长。</p>\n<ul>\n<li>堆用于存放进程<code>运行时动态分配</code>的内存段，可动态扩张或缩减。</li>\n<li>堆中内容是<code>匿名</code>的，无法通过名字进行访问，只能通过<code>指针</code>进行间接访问。</li>\n<li>当进程调用<code>malloc(C)/new(C++)</code>等函数分配内存时，新分配的在堆上<code>动态扩张</code>；当调用<code>free(C)/delete(C++)</code>等函数释放内存时，被释放的内存从堆上<code>动态缩减</code></li>\n<li>分配的堆内存时经过<code>字节对齐</code>的空间，以适合<code>原子操作</code>。</li>\n<li><code>堆管理器</code>通过<code>链表</code>管理每个申请的内存块</li>\n<li>由于堆内存块的申请与释放都是<code>无序</code>的，最终会产生许许多多<code>内存碎片</code>。</li>\n<li>堆的末端由<code>break指针</code>标识，当堆管理器需要更多内存时，可通过<code>系统调用brk和sbrk</code>来<code>移动break指针</code>以扩张堆，一般情况下由系统自动调用。</li>\n</ul>\n</li>\n<li><p>共享库【.dll、.so】：<br> 动态链接库，程序在运行的过程中，将一些标准库函数映射到这里，比如C标准库函数（fread、fwrite、fopen等）。</p>\n</li>\n<li><p>栈【.stack】：<br> 存放所有函数的活动空间，局部变量；根据程序的运行，调用函数，此区域动态地扩张和收缩。</p>\n<ul>\n<li><p>栈中存放<code>非静态局部变量</code> <code>函数形参</code> <code>函数返回地址</code>等。</p>\n</li>\n<li><p>栈中内存空间由<code>编译器</code>（静态的）自动分配和释放，行为类似数据结构中的栈结构。</p>\n<blockquote>\n<p>主要用途：</p>\n<ol>\n<li>为函数内部声明的<strong>非静态局部变量</strong>提供存储空间</li>\n<li>记录函数调用过程相关的维护性信息，称为栈帧（stack frame）</li>\n<li>作为<code>临时存储区</code>，用于暂时存放<code>较长的算术表达式部分计算结果</code>，或者运行时调用alloca函数<code>动态分配</code>栈内内存</li>\n</ol>\n</blockquote>\n</li>\n<li><p>栈内存增长：栈能够增长到的最大内存容量为RLIMIT_STACK（通常是8M），如果此时栈的大小未达到RLIMIT_STACK，则栈会自动增长至程序运行所需的大小，如果此时栈的大小已经达到RLIMIT_STACK，若再向栈中不断压入数据，会触发页错误。栈的实时大小会在运行时由内核动态调整。</p>\n</li>\n<li><p>查看栈大小：<code>ulimit -s</code>可查看和设置<code>栈的最大值</code>，当程序使用的栈大小超过该值，会发生<code>segmentation fault</code>。</p>\n</li>\n<li><ul>\n<li>栈的增长方向：既可以向高地址增长，也可以向低地址增长，这取决于具体实现，自上而下增长。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>命令行参数：<br> 保存传递给 main 函数的参数，比如 argc 和 argv。</p>\n</li>\n<li><p>环境变量：<br> 用于存放当前的环境变量，在 Linux 下可以用 env 命令查看。</p>\n</li>\n</ol>\n<h3 id=\"1-3-进程空间（Kernal-Space）\"><a href=\"#1-3-进程空间（Kernal-Space）\" class=\"headerlink\" title=\"1.3 进程空间（Kernal Space）\"></a>1.3 进程空间（Kernal Space）</h3><ol>\n<li><p>内存直接访问区【ZONE_DMA】：<br> 16M 大小，不需要经过 CPU 的寄存器，加快了磁盘和内存之间的数据交换。</p>\n</li>\n<li><p>常用区【ZONE_NORMAL】：<br> 892M 大小，内核中最重要的部分，存放页表、页面的映射、PCB。</p>\n</li>\n<li><p>高端内存区【ZONE_HIGHMEM】：<br> 128M 大小，存放大文件的映射，即内存中映射高于 1GB 的物理内存。64 位操作系统没有该段。</p>\n</li>\n</ol>\n<h3 id=\"1-4-最终解释\"><a href=\"#1-4-最终解释\" class=\"headerlink\" title=\"1.4 最终解释\"></a>1.4 最终解释</h3><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308030917571.png\" alt=\"image.png\"></p>\n<blockquote>\n<p>注意：<br>对于<code>a、b、c以及&#39;&#123;&#39;、&#39;&#125;&#39;</code>来说，是存储在<code>.text</code>指令段的，因为他们生成的都是&#x3D;&#x3D;指令&#x3D;&#x3D;。<br>例如：<br><code>int a = 12</code>：生成汇编指令如下：<code>mov dword ptr[a], 0Ch</code></p>\n</blockquote>\n<h3 id=\"1-5-好处\"><a href=\"#1-5-好处\" class=\"headerlink\" title=\"1.5 好处\"></a>1.5 好处</h3><p><code>数据</code>与<code>代码指令</code>分别开辟空间有以下好处：</p>\n<ol>\n<li>当程序被装载后，数据和代码指令分别映射到两个虚拟内存区域。<code>数据区</code>对于进程而言<code>可读可写</code>，<code>代码指令区</code>对于进程而言<code>只读</code>，</li>\n<li>现代CPU一般<code>数据缓存</code>和<code>指令缓存</code>分离，故进程虚拟地址空间中数据与代码指令分离有助于提高<code>CPU缓存命中率</code>。</li>\n<li>若系统中运行多个该程序的副本时，其代码指令相同，故内存中只需要保存一份该程序的代码指令，大大减少了内存的开销，相同的程序的代码指令可以被多个副本进程所共享，但是数据是每个副本进程所独有的。</li>\n</ol>\n<p><strong>参考文章：</strong></p>\n<blockquote>\n<p>【1】Randal E. Bryant. 《深入理解计算机系统》.北京. 机械工业出版社，2016：1<br>【2】寻痴. 虚拟地址空间图解. CSDN. 2021-03-23<br>【3】聪聪菜的睡不着. 【C++】一、虚拟内存布局、编译链接原理等基础概念. CSDN. 2020-07-09<br>【4】<a href=\"https://blog.csdn.net/m0_46308273/article/details/115818195\">https://blog.csdn.net/m0_46308273/article/details/115818195</a><br>【5】<a href=\"https://blog.csdn.net/weixin_45437022/article/details/115409679\">https://blog.csdn.net/weixin_45437022/article/details/115409679</a></p>\n</blockquote>\n<h2 id=\"2-从指令角度掌握函数调用堆栈详细过程\"><a href=\"#2-从指令角度掌握函数调用堆栈详细过程\" class=\"headerlink\" title=\"2. 从指令角度掌握函数调用堆栈详细过程\"></a>2. 从指令角度掌握函数调用堆栈详细过程</h2><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031030058.png\" alt=\"image.png\"><br>栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。</p>\n<p>堆栈是一种具有一定规则的数据结构，我们可以按照一定的规则进行添加和删除数据。它使用的是后进先出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：</p>\n<ul>\n<li>PUSH：将目标内存推入栈顶。</li>\n<li>POP：从栈顶中移除目标。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031033393.png\" alt=\"image.png\"></p>\n<p>当执行一个函数的时候，相关的参数以及局部变量等等都会被记录在ESP、EBP中间的区域。一旦函数执行完毕，相关的 <strong>栈帧</strong> 就会从堆栈中弹出，然后从预先保存好的上下文中进行恢复，以便保持堆栈平衡。CPU必须要知道函数调用完了之后要去哪里执行（pc寄存器指向）</p>\n<h3 id=\"2-1-ESP-和-EBP\"><a href=\"#2-1-ESP-和-EBP\" class=\"headerlink\" title=\"2.1 ESP 和 EBP\"></a>2.1 ESP 和 EBP</h3><p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p>\n<p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p>\n<p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化：</p>\n<ul>\n<li>pop ebp;出栈 栈扩大4byte 因为ebp为32位</li>\n<li>push ebp;入栈，栈减少4byte        </li>\n<li>add esp, 0Ch；表示栈减小12byte</li>\n<li>sub esp, 0Ch；表示栈扩大12byte</li>\n</ul>\n<p>ebp 寄存器的出现则是为了另一个目标，通过固定的地址与偏移量来寻找在栈参数与变量。而这个固定值者存放在 ebp 寄存器中，。但是这个值会在函数的调用过程发生改变。而在函数执行结束之后需要还原，因此，在函数的出栈入栈过程中进行保存。</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">问题1：main函数调用sum，sum执行完后，怎么知道回到哪个函数</span><br><span class=\"hljs-comment\">问题2：sum执行完，回到main函数之后怎么知道从哪一行继续执行</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>\ttemp = a + b;<br>\t<span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><br>\t<span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>打断点，调试，查看反汇编：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br><span class=\"hljs-comment\">// 00007FF637EE23D0  push        rbp  </span><br><span class=\"hljs-comment\">// 00007FF637EE23D2  push        rdi  </span><br><span class=\"hljs-comment\">// 00007FF637EE23D3  sub         rsp,148h  </span><br><span class=\"hljs-comment\">// 00007FF637EE23DA  lea         rbp,[rsp+20h]  </span><br><span class=\"hljs-comment\">// 00007FF637EE23DF  lea         rcx,[__0DD03384_02@Assembly@cpp (07FF637EF3068h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE23E6  call        __CheckForDebuggerJustMyCode (07FF637EE13FCh)  </span><br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-comment\">// 00007FF637EE23EB  mov         dword ptr [a],0Ah  </span><br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-comment\">// 00007FF637EE23F2  mov         dword ptr [b],14h  </span><br><br>\t<span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>);<br><span class=\"hljs-comment\">// 00007FF637EE23F9  mov         edx,14h  </span><br><span class=\"hljs-comment\">// 00007FF637EE23FE  mov         ecx,0Ah  </span><br><span class=\"hljs-comment\">// 00007FF637EE2403  call        sum (07FF637EE11E5h)  </span><br><span class=\"hljs-comment\">// 00007FF637EE2408  mov         dword ptr [ret],eax  </span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ret:&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><span class=\"hljs-comment\">// 00007FF637EE240B  lea         rdx,[string &quot;ret:&quot; (07FF637EEAC24h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2412  mov         rcx,qword ptr [__imp_std::cout (07FF637EF1190h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2419  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (07FF637EE108Ch)  </span><br><span class=\"hljs-comment\">// 00007FF637EE241E  mov         edx,dword ptr [ret]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2421  mov         rcx,rax  </span><br><span class=\"hljs-comment\">// 00007FF637EE2424  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1168h)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE242A  lea         rdx,[std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (07FF637EE103Ch)]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2431  mov         rcx,rax  </span><br><span class=\"hljs-comment\">// 00007FF637EE2434  call        qword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (07FF637EF1170h)]  </span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-comment\">// 00007FF637EE243A  xor         eax,eax  </span><br>&#125;<br><span class=\"hljs-comment\">// 00007FF637EE243C  lea         rsp,[rbp+128h]  </span><br><span class=\"hljs-comment\">// 00007FF637EE2443  pop         rdi  </span><br><span class=\"hljs-comment\">// 00007FF637EE2444  pop         rbp  </span><br><span class=\"hljs-comment\">// 00007FF637EE2445  ret </span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-解析-main-函数\"><a href=\"#2-2-解析-main-函数\" class=\"headerlink\" title=\"2.2  解析 main 函数\"></a>2.2  解析 main 函数</h3><p><strong>1. <code>&#123;</code> 会进行入栈操作，<code>&#125;</code> 进行出栈操作</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031041720.png\" alt=\"image.png\"></p>\n<p>上面两句话的意思是将 ebp 推入栈中，之后让 esp 等于 ebp。</p>\n<p><strong>为什么这么做呢？</strong></p>\n<p>因为 ebp 作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。</p>\n<p>在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</p>\n<p><code>sub esp, 148h；</code>减去的值根据程序而定</p>\n<p>之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</p>\n<p>之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</p>\n<p>在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031043365.png\" alt=\"image.png\"></p>\n<p>所谓有始有终，这是会还原上面保存的寄存器值，之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数</p>\n<p><strong>2. 函数内部：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031047611.png\" alt=\"image.png\"></p>\n<ol>\n<li><p><code>int a = 10;</code> 执行一条 mov 指令： </p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Assembly\">mov         dword ptr [a],0Ah<br></code></pre></td></tr></table></figure>\n<p> <img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031049332.png\" alt=\"image.png\"></p>\n</li>\n<li><p> 同理 <code>int b = 20;</code> 指令：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Assembly\">mov         dword ptr [b],14h<br></code></pre></td></tr></table></figure>\n<p> <img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031050787.png\" alt=\"image.png\"></p>\n</li>\n<li><p><code>int ret = sum(a,b);</code> 指令：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Assmbly\">00F81896 8B 45 EC             mov         eax,dword ptr [b] <br>00F81899 50                   push        eax     #压栈 b的值<br>00F8189A 8B 4D F8             mov         ecx,dword ptr [a]  <br>00F8189D 51                   push        ecx     #压栈 a的值<br>00F8189E E8 E9 F7 FF FF       call        sum (0F8108Ch)   #执行call<br>00F818A3 83 C4 08             add         esp,8  <br>00F818A6 89 45 E0             mov         dword ptr [ret],eax <br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"2-3-sum-函数调用后\"><a href=\"#2-3-sum-函数调用后\" class=\"headerlink\" title=\"2.3 sum 函数调用后\"></a>2.3 sum 函数调用后</h3><p><strong>函数调用参数的压栈顺序:参数由右向左压入堆栈。</strong></p>\n<p><strong>因此上面对应的是：</strong></p>\n<p>先将b的值压入堆栈，再将a的值压入堆栈</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031052077.png\" alt=\"image.png\"><br><strong>执行call        sum (0F8108Ch)：</strong></p>\n<p><strong>call函数首先会将下一行执行的地址入栈</strong>：假设下一行指令的地址位0x08124458</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031053472.png\" alt=\"image.png\"></p>\n<p> <strong>第二步进入函数调用：sum</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031054082.png\" alt=\"image.png\"></p>\n<p>函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈</p>\n<p>第二步：将新的栈底ebp指向原来的栈顶esp</p>\n<p>第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：108h</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031055858.png\" alt=\"image.png\"></p>\n<p>接着执行 <code>int temp = 0;</code> 指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">mov         dword ptr [temp],0<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031056591.png\" alt=\"image.png\"></p>\n<p>temp &#x3D; a + b; 由于a,b的值之前入栈，可以通过 ebp+12 字节找到b的值，ebp+8 字节找到 a 的值，最后将运算结果赋值给 temp</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031057265.png\" alt=\"image.png\"></p>\n<p>接着运行<code>return temp;</code>: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs assembly\">mov         eax,dword ptr [temp]<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031058576.png\" alt=\"image.png\"></p>\n<p>接着是<code>函数的右括号“&#125;”</code>：</p>\n<p>（1）mov esp,ebp  回退栈帧 将栈顶指针指向栈底。<br>（2）pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp。<br>（3） ret  栈顶出栈，并将出栈的内容赋值给pc寄存器，也就是将之前压榨的call sun的下一条指令赋值到pc寄存器执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031059983.png\" alt=\"image.png\"></p>\n<h3 id=\"2-4-返回-main-函数后\"><a href=\"#2-4-返回-main-函数后\" class=\"headerlink\" title=\"2.4 返回 main 函数后\"></a>2.4 返回 main 函数后</h3><p>接着调用函数完毕，回到主函数：<br>利用了<code>PC寄存器</code>，使得程序知道退出sum后运行哪一条指令：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031100556.png\" alt=\"image.png\"></p>\n<p><code>add         esp,8</code> ,将压栈的a b 形参空间回收</p>\n<p><code>mov         dword ptr [ret],eax</code> 在sum中，最后将temp赋值到eax寄存器，这里将eax赋值给ret</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031101001.png\" alt=\"image.png\"><br>最后<code>return 0</code>，程序结束</p>\n<h3 id=\"2-5-栈溢出问题\"><a href=\"#2-5-栈溢出问题\" class=\"headerlink\" title=\"2.5 栈溢出问题\"></a>2.5 栈溢出问题</h3><p>出现栈内存溢出的常见原因有2个：</p>\n<ol>\n<li>函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。</li>\n<li>局部静态变量体积太大。</li>\n</ol>\n<blockquote>\n<p>第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。<br>检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键 Alt+7 调出 call stack 窗口,在窗口中可以看到函数调用的层次关系。</p>\n</blockquote>\n<blockquote>\n<p>   第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> 即如果函数这样写：<br> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_stack_overflow</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"> </span>&#123;<br>   <span class=\"hljs-type\">char</span>* chdata = <span class=\"hljs-keyword\">new</span>[<span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>];<br>   <span class=\"hljs-keyword\">delete</span> []chdata;<br> &#125;<br>是不会出现这个错误的，而这样写则不行：<br> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_stack_overflow</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"> </span>&#123;<br>   <span class=\"hljs-type\">char</span> chdata[<span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">1024</span>*<span class=\"hljs-number\">1024</span>];<br> &#125;<br>大多数情况下都会出现内存溢出的错误,<br></code></pre></td></tr></table></figure>\n\n<p>解决办法大致说来也有两种：  </p>\n<ol>\n<li>增加栈内存的数目  </li>\n<li>使用堆内存</li>\n</ol>\n<h2 id=\"3-从编译器角度理解-C-代码的编译、链接\"><a href=\"#3-从编译器角度理解-C-代码的编译、链接\" class=\"headerlink\" title=\"3. 从编译器角度理解 C++ 代码的编译、链接\"></a>3. 从编译器角度理解 C++ 代码的编译、链接</h2><p>整个编译过程分为两大步：</p>\n<p>1）编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件</p>\n<p>2）连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序</p>\n<h3 id=\"3-1-编译\"><a href=\"#3-1-编译\" class=\"headerlink\" title=\"3.1 编译\"></a>3.1 编译</h3><p>细分为3个阶段：</p>\n<p><strong>1.1）编译预处理</strong></p>\n<p>预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如 <code>#include</code>），这个过程会得到不包含#指令的 .i 文件。这个过程会拷贝 <code>#include</code> 包含的文件代码，进行 <code>#define</code> 宏定义的替换 ， 处理条件编译指令 （<code>#ifndef</code>、 <code>#ifdef</code>、 <code>#endif</code>）等。</p>\n<p>预编译过程相当于如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">gcc -E main.c -o main.i<br></code></pre></td></tr></table></figure>\n\n<p>主要规则如下：</p>\n<ol>\n<li>将所有的 <code>#define</code> 删除，并且展开所有的宏定义；</li>\n<li>处理所有条件预编译指令，比如<code>#if</code>、<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>;</li>\n<li>处理 <code>#include</code> 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件；</li>\n<li>删除所有的注释：<code>//</code> 和 <code>/**/</code>；</li>\n<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号；</li>\n<li>保留所有的 <code>#pragma</code> 编译器指令，因为编译器要使用它们。</li>\n</ol>\n<blockquote>\n<p>注：<br><code>#pragma lib</code>、<code>pragma link</code><br>等命令是在链接过程处理的。</p>\n</blockquote>\n<p>预编译后得到的文件为：<code>.i</code>文件。</p>\n<p><strong>1.2）编译</strong></p>\n<p>通过预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。</p>\n<p>编译过程相当于如下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">gcc -S main.i -o main.s<br></code></pre></td></tr></table></figure>\n\n<p>编译后得到的文件为：<code>.s</code>文件。</p>\n<p><strong>1.3) 汇编</strong></p>\n<p>汇编过程就是把汇编语言翻译成目标机器指令的过程，生成二进制可重定位的目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。</p>\n<p>目标文件由段组成，通常至少有两个段：</p>\n<ol>\n<li>.text：包换主要程序的指令。该段是可读和可执行的，一般不可写</li>\n<li>.data .rodata：存放程序用到的全局变量或静态数据。可读、可写、可执行。</li>\n</ol>\n<p>汇编过程我们可以调用汇编器<code>as</code>来完成：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">as main.s -o main.o  <br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">或者：</span>  <br>gcc -c main.s -o mian.o<br></code></pre></td></tr></table></figure>\n\n<p>这个过程将.s文件转化成.o文件。</p>\n<h3 id=\"3-2-链接过程\"><a href=\"#3-2-链接过程\" class=\"headerlink\" title=\"3.2 链接过程\"></a>3.2 链接过程</h3><p>链接是将各种代码和数据部分收集起来并组合成为一个单一文件的过程，这个文件可被加载（货被拷贝）到存储器并执行。</p>\n<p><strong>链接的时机</strong>：</p>\n<ul>\n<li>编译时，也就是在源代码被翻译成机器代码时</li>\n<li>加载时，也就是在程序被加载器加载到存储器并执行时</li>\n<li>运行时，由应用程序执行</li>\n</ul>\n<h4 id=\"1-静态链接\"><a href=\"#1-静态链接\" class=\"headerlink\" title=\"1. 静态链接\"></a>1. 静态链接</h4><p><strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p>\n<p>为了构造可执行文件，<strong>链接器必须完成两个任务：符号解析，重定位</strong></p>\n<ol>\n<li><strong>符号解析：</strong> 目标文件定义和引用符号。符号解析的目的是将每个符号引用刚好和一个符号定义联系起来。</li>\n<li><strong>重定位：</strong> 编译器和汇编器生成从地址0开始的饿代码和数据节。链接器通过把每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。</li>\n</ol>\n<p>链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器和汇编器已经完成了大部分工作。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031125346.png\" alt=\"image.png\"></p>\n<p>目标文件纯粹是字节快的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包括指导链接器和加载器的数据结构。链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。</p>\n<h4 id=\"2-目标文件\"><a href=\"#2-目标文件\" class=\"headerlink\" title=\"2. 目标文件\"></a>2. 目标文件</h4><p><strong>三种形式：</strong></p>\n<ol>\n<li><strong>可重定位目标文件</strong>。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。</li>\n<li><strong>可执行目标文件</strong>。包含二进制代码和数据，其形式可以被直接拷贝到存储器并执行。</li>\n<li><strong>共享目标文件</strong>。一种特殊类型的可重定位目标文件，可以在加载或者运行地被动态地加载到存储器并链接。</li>\n</ol>\n<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块就是一个字节序列，而一个目标文件就是一个存放在磁盘文件中的目标模块。</p>\n<h4 id=\"3-可重定位目标文件\"><a href=\"#3-可重定位目标文件\" class=\"headerlink\" title=\"3.  可重定位目标文件\"></a>3.  可重定位目标文件</h4><p>一个典型的 ELF 可重定位目标文件的格式。ELF头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或是共享的）、机器类型（如IA32）、节头部表的文件偏移，以及节头部表中的条目大小和数量。不同的节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031131640.png\" alt=\"ELF可重定位目标文件\"></p>\n<p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p>\n<ul>\n<li><strong>.text：</strong> 已编译程序的机器代码。</li>\n<li><strong>.rodata：</strong> 只读数据，比如 printf 语句中的格式串和开关语句的跳转表。</li>\n<li><strong>.data：</strong> 已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。</li>\n<li><strong>.bss：</strong> 未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。</li>\n<li><strong>.symtab：</strong> 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。</li>\n<li><strong>.rel.text：</strong> 一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。</li>\n<li><strong>.rel.data：</strong> 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。</li>\n<li><strong>.debug：</strong> 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才 会得到这张表。</li>\n<li><strong>.line：</strong> 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。</li>\n<li><strong>.strtab：</strong> 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。</li>\n</ul>\n<h4 id=\"4-符号和符号表\"><a href=\"#4-符号和符号表\" class=\"headerlink\" title=\"4. 符号和符号表\"></a>4. 符号和符号表</h4><p>每个可重定位目标模块m都有一个符号表，包含m所定义和引用的符号的信息。符号表产生在汇编阶段，符号表生成虚拟地址在链接阶段</p>\n<p>在链接器的上下文中，有三种不同的符号：</p>\n<p>由m定义并能被其他模块引用的全局符号<br>由其他模块定义并被模块m引用的全局符号<br>只被模块m引用的本地符号</p>\n<p>例如：</p>\n<p><code>main.cpp</code> 内容 和 <code>sum.cpp</code> 内容如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// main.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-type\">int</span> gdata;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span></span>;<br><br><span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">20</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = gdata;<br>\t<span class=\"hljs-type\">int</span> b = data;<br><br>\t<span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(a, b);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// sum.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">int</span> gdata = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>g++ -c</strong> 只编译不链接，只生成目标文件</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031135734.png\" alt=\"image.png\"></p>\n<p> <strong>objdump -t main.o &#x2F;&#x2F; 输出目标文件的符号表：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031136378.png\" alt=\"image.png\"></p>\n<ul>\n<li>第一列：段内偏移；</li>\n<li>第二列：符号作用域  : local &#x2F;global；</li>\n<li>第三列：符号类型；</li>\n<li>第四列：符号所在段（<em>UND</em>外部链接符号，未在本目标文件定义）；</li>\n<li>第五列：符号对应的对象占据的内存空间大小，没有实体对象大小为0，未定义的为0；</li>\n<li>第六列：符号名；</li>\n</ul>\n<p>其中 <code>main</code> 定义在 <code>.text</code></p>\n<p>data 是全局变量，且初始化定义在 <code>.data</code> ,也就是 m 定义并能被其他模块引用的全局符号。<br>gdata 和 sum 函数是声明，因此是<em>UNG</em>，也就是由其他模块定义并被模块 m 引用的全局符号。</p>\n<p>第一列都是 0x0 没有为符号分配虚拟地址，在链接阶段分配</p>\n<p>在 <code>sum.o</code> 中：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031138696.png\" alt=\"image.png\"></p>\n<p>gdata 是出刷的全局变量 在 <code>.data</code> 中；sum 函数在 <code>.text</code> 中</p>\n<p><code>readelf -h</code> 查看 elf 文件的头文件信息<br>可见目标文件的elf文件，其类型为REL(可重定位文件)。 </p>\n<p><code>objdump -s</code> 显示全部 Heade r信息，还显示他们对应的十六进制文件代码：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139885.png\" alt=\"image.png\"></p>\n<p>有调试信息的：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031139339.png\" alt=\"image.png\"></p>\n<p>可以看到符号地址未分配，用0填充；这也是obj文件无法运行的原因之一。</p>\n<h4 id=\"5-符号解析\"><a href=\"#5-符号解析\" class=\"headerlink\" title=\"5. 符号解析\"></a>5. 符号解析</h4><p>链接的步骤一：所有.o文件段的合并（.text  .data .bss合并），符号表合并后，进行符号解析，所有对符号的引用（<em>UNG</em>）都要找到该符号定义的地方。经常见的报错：符号重定义（存在多个相同的）、符号未定义（找不到）</p>\n<p> <strong>链接器如何解析多重定义的全局符号：</strong></p>\n<p>在编译是，编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量时强符号，未初始化的全局变量是弱符号。<br>       根据强弱符号的定义，Unix链接器使用下面的规则来处理多重定义的符号：</p>\n<p>规则1：不允许有多个强符号。<br>规则2：如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3：如果有多个弱符号，那么从这些弱符号中任意选择一个。</p>\n<p><strong>链接器如何使用静态库来解析引用：</strong></p>\n<p>在符号解析的阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的相同顺序来扫描可重定位目标文件和存档文件。在这次扫描中，链接器维持一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D都是空的。</p>\n<blockquote>\n<ol>\n<li>对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器吧f添加到E， 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。</li>\n<li>如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都反复进行这个过程，直到U和D都不再发生变化。在此时，任何不包含在E中的目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。</li>\n<li>如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就好输出一个错误并终止。否则，它会合并和重定位E中的目标文件，从而构建输出的可执行文件。</li>\n</ol>\n</blockquote>\n<p>这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。关于库的一般准则是将它们放在命令行的 结尾。</p>\n<p>另一方面，如果库不是相互独立的，那么它们必须排序，使得对于每个被存档文件的成员外部引用的符号s，在命令行中至少有一个s的定义实在对s的引用之后的。</p>\n<p>如果需要满足依赖需求，可以在命令行上重复库。</p>\n<h4 id=\"6-重定向\"><a href=\"#6-重定向\" class=\"headerlink\" title=\"6. 重定向\"></a>6. 重定向</h4><p>一旦链接器完成了符号解析这一步，它就是把代码中的每个符号引用和确定的一个符号定义（即它的一个输入目标模块中的一个符号表条目）联系起来。在此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。</p>\n<p>重定位有两步组成：</p>\n<ol>\n<li><strong>重定位节和符号定义</strong>。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li>\n<li><strong>重定位节中的符号引用</strong>。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<code>重定位条目</code>的可重定位目标模块中的数据结构。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031143865.png\" alt=\"image.png\"></p>\n<p>链接后：所有的符号都有虚拟地址</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031144871.png\" alt=\"image.png\"></p>\n<p>汇编中，全局变量和函数都有了地址。</p>\n<h4 id=\"7-可执行目标文件\"><a href=\"#7-可执行目标文件\" class=\"headerlink\" title=\"7. 可执行目标文件\"></a>7. 可执行目标文件</h4><p>可执行目标文件的格式类似于可重定位目标文件的格式。ELF头部描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<code>.text</code> 、<code>.rodata</code> 和 <code>.data</code> 节和可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时存储器地址以外。.init节定义了一个小函数，叫做_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位了），所以它不再需要.rel节。</p>\n<p>ELF可执行文件被设计得很容易加载到存储器，可执行文件的连续的片被映射到连续的存储器段。段头部表描述了这种映射关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031146917.png\" alt=\"image.png\"></p>\n"},{"title":"02.C++ 基础精讲","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节分为 5 大类：\n\n1. 形参带默认值的函数\n2. 内联函数inline\n3. 详解函数重载\n4. const 深入应用\n5. 深入理解 C++ 的 new 和 delete\n\n## 1. 形参带默认值的函数\n\n在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。\n\n**注意事项：**\n\n1. 在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。\n\n~~~c++\ndouble sqrt(double f = 1.0); //函数声明\n\ndouble sqrt(double f)  //函数定义\n{\n  // ....  \n}\n~~~\n\n2. 没有函数（原型）时，默认参数在函数定义时指定。\n\n~~~c++\n//没有 函数声明\n \ndouble sqrt(double f = 1.0)  //函数定义\n~~~\n\n3. 在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.\n\n就是说，**函数声明时，必须按照从右向左的顺序，依次给与默认值。**\n\n原因：\n\n函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 **从指令角度掌握函数调用堆栈详细过程。**\n\n~~~c++\nint f (int i1, int i2 = 2, int i3 = 3);     // 正确\nint g (int i1, int i2 = 2, int i3);         // 错误, i3未指定默认值\nint h (int i1 = 1, int i2, int i3 = 3);     // 错误, i2未指定默认值\n~~~\n\n**普通函数和形参带默认值函数对比：**\n\n~~~c++\n#include <iostream>\n \nint sum(int a = 10, int b  = 10)\n{\n  int temp = 0;\n  temp = a + b;\n  return temp;\n}\n \nint main()\n{\n  int a = 10;\n  int b = 20;\n \n  int ret = sum(a, b);\n \n  ret = sum(a);//b 使用默认值\n \n  ret = sum();//都使用默认值\n \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png)\n\n对比1，2 发现：\n\n2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；\n\n同理有3，使用默认值是：调用函数减少了 mov 指令。\n\n## 2. 内联函数 inline\n\n**特征：**\n\n- 相当于把内联函数里面的内容写在调用内联函数处；\n- 相当于不用执行进入函数的步骤，直接执行函数体；\n- 相当于宏，却比宏多了类型检查，真正具有函数特性；\n- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；\n- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。\n\n**使用：**\n\n~~~c++\n// 声明1（加 inline，建议使用）\ninline int functionName(int first, int second,...);\n\n// 声明2（不加 inline）\nint functionName(int first, int second,...);\n\n// 定义\ninline int functionName(int first, int second,...) {/****/};\n\n// 类内定义，隐式内联\nclass A {\n    int doA() { return 0; }         // 隐式内联\n}\n\n// 类外定义，需要显式内联\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // 需要显式内联\n~~~\n\n**编译器对 inline 函数的处理步骤：**\n\n1. 将 inline 函数体复制到 inline 函数调用点处；\n2. 为所用 inline 函数中的局部变量分配内存空间；\n3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；\n4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。\n\n**内联函数与普通函数的区别？**\n\n1. 内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理\n\n[[01.理解 C++ 内核]] 中的 **从指令角度掌握函数调用堆栈详细过程** 知道，在调用函数的过程中：\n\n（1）将函数实数从右向左压栈\n（2）call指令：\n\t\t将下一行要执行的代码地址入栈\n\t\t跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。\n\n在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令\n\n2. 内联函数不在生成相应的函数符号\n\n3. inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。\n\n注意：\n\n（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。\n\n**优缺点：**\n\n优点\n\n1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。\n2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。\n3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。\n4. 内联函数在运行时可调试，而宏定义不可以。\n\n缺点\n\n1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。\n2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。\n3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。\n\n## 3. 详解函数重载\n\n**函数重载**：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。\n\n（1）函数重载与函数返回值无关，因为在产生符号时没有返回值\n（2） 函数重载需要在同一个作用域\n（3）const 或者 volatile 的时候，是如何影响形参的\n\n**C++ 支持函数重载，而 C 则不支持：**\n\n编译器产生的函数符号规则不同：\n\n- C++ 代码：函数符号包含了函数名和参数列表\n- C 代码：函数符号只包含了函数名。\n\n**注意事项：**\n\n** **函数重载需要在同一个作用域下**。**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nbool compare(int a, int b)\n{\n\treturn a > b;\n}\n\nbool compare(double a, double b)\n{\n\treturn a > b;\n}\n\nbool compare(const char* a, const char* b)\n{\n\treturn a > b;\n}\n\nint main()\n{\n\tbool compare(double a, double b);\n\tcompare(\"adf\", \"wew\");\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png)\n\n由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。\n\n**const int 和 int 的重载：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nvoid func(int a) {}\nvoid func(const int a) {}\n\nint main()\n{\n\t// ...\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png)\n\n原因：\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\n\nint main()\n{\n\tint a = 10;\n\tconst int b = 10;\n\n\tstd::cout << typeid(a).name() << std::endl;\n\tstd::cout << typeid(b).name() << std::endl;\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png)\n\nconst int 和 int 在编译器看来都是 int 类型 ，无法完成重载。\n\n### 3.1 C++ 和 C 语言如何相互调用\n\n由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten \"C\"{};\n\n#### 1. C++ 调用 C\n\n对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字`extern \"C\"`，表示采用类c语言的方式解析函数符号。例子如下：\n\n~~~c++\n// add.h\n\n#ifdef __ADD_H__\n#define __ADD_H__\n\nextern \"C\" int add(int a, int b);\n\n#endif\n\n\n// add.c\nint add(int a, int b)\n{\n    return a + b;\n}\n\n// main.cpp\n#include <iostream>\n#include \"add.h\"\nusing namespace std;\n\nint main()\n{\n    cout << \"1 + 1 = \" << add(1, 1) << endl;\n}\n~~~\n\n在例子中，`main.cpp` 为`c++` 代码，`add.c` 为 c 语言代码，当 c++ 编译器识别到`extern \"C\"` 关键字时，会去寻找 `_add_` 函数的实现而不是寻找类似`_int_add_int_int_` 这样带参数信息的函数实现。\n\n#### 2. C 调用 C++\n\nc 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：\n1. 将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；\n2. 对外提供遵循类 c 语言规约的接口函数。例子如下所示：\n\n~~~c++\n// printNum.h\n#ifdef __PRINTNUM_H__\n#define __PRINTNUM_H__\n\nextern \"C\" void printNum(int a);\n\n#endif\n\n// printNum.cpp\n#include <iostream>\n#include \"printNum.h\"\nusing namespace std;\n\nvoid printNum(int a)\n{\n    cout << << \"num is \" << a << endl;\n}\n\n// main.c\nextern void printNum(int a);\n\nprintNum(5);\n~~~\n\n通过将 `_cout_`函数封装为类 c 语言规约的接口函数，使得 `main.c` 中可以成功调用 c++ 函数 `_printNum_` 。值得注意的是，`main.c` 不可以直接引入 `printNum.h`，因为 c 语言不能识别 `extern \"C\"` 关键字。可以利用 c++ 预定义宏实现头文件的改写：\n\n~~~c++\n#ifdef __PRINTNUM_H__\n#define __PRINTNUM_H__\n\n#ifdef __cplusplus\nextern \"C\" { \n#endif\nvoid printNum(int a);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n~~~\n\n#### 3. 总结\n\n\n1. c 语言与 c++ 的相互调用可以通过 `extern \"C\"` 关键字实现\n2. c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 `extern \"C\"`\n3. c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 `extern \"C\"` 声明的类 c 封装函数\n\n## 4. const 深入应用\n\n**const 作用：**\n\n1. 修饰变量，说明该变量不可以被改变；\n2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；\n3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；\n4. 修饰成员函数，说明该成员函数内不能修改成员变量。\n\n**const 的指针与引用：**\n\n- 指针\n    - 指向常量的指针（pointer to const）\n    - 自身是常量的指针（常量指针，const pointer）\n- 引用\n    - 指向常量的引用（reference to const）\n    - 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰\n\n~~~c++\n// 类\nclass A\n{\nprivate:\n    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化\n\npublic:\n    // 构造函数\n    A() : a(0) { };\n    A(int x) : a(x) { };        // 初始化列表\n\n    // const可用于对重载函数的区分\n    int getValue();             // 普通成员函数\n    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值\n};\n\nvoid function()\n{\n    // 对象\n    A b;                        // 普通对象，可以调用全部成员函数\n    const A a;                  // 常对象，只能调用常成员函数\n    const A *p = &a;            // 指针变量，指向常对象\n    const A &q = a;             // 指向常对象的引用\n\n    // 指针\n    char greeting[] = \"Hello\";\n    char* p1 = greeting;                // 指针变量，指向字符数组变量\n    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）\n    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）\n    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量\n}\n\n// 函数\nvoid function1(const int Var);           // 传递过来的参数在函数内不可变\nvoid function2(const char* Var);         // 参数指针所指内容为常量\nvoid function3(char* const Var);         // 参数指针为常量\nvoid function4(const int& Var);          // 引用参数在函数内为常量\n\n// 函数返回值\nconst int function5();      // 返回一个常数\nconst int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();\nint* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();\n~~~\n\n**宏定义 `#define` 和 const 常量:**\n\n|宏定义 #define|const 常量|\n|---|---|\n|宏定义，相当于字符替换|常量声明|\n|预处理器处理|编译器处理|\n|无类型安全检查|有类型安全检查|\n|不分配内存|要分配内存|\n|存储在代码段|存储在数据段|\n|可通过 `#undef` 取消|不可取消|\n\n### 1. C++ 和 C 的 const 区别\n\n- **c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png)\n\n最终输出为：30、30、30\n\n- **C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png)\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t// const int b;\n\tconst int a = 10;\n\t// a 常量，可以定义数组长度\n\tint array[a] = {};\n\n\tint* p = (int*)&a;\n\t*p = 30;\n\n\tcout << a << \" \" << *p << \" \" << *(&a) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png)\n\n原因：**const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。**\n\n#### 1.1 Debug 调试\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png)\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png)\n\n执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。\n\n**如果不是立即数，则是常变量**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint b = 1;\n\tconst int a = b;\n\n\t// 报错，a是常变量\n\t//int array[a] = {};\n\n\tint* p = (int*)&a;\n\t*p = 30;\n\n\tcout << a << \" \" << *p << \" \" << *(&a); // 30 30 30\n\n\treturn 0;\n}\n~~~\n\n### 2. const 与指针\n\nconst 修饰的量常出现的错误：\n\n**（1）常量不能再作为左值**\n**（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png)\n\n#### 2.1 const 和 一级指针\n\n**const 如果右边没有指针*，则const 是不参与类型的**\n\n**C++的语言规范：就近原则 const 修饰的是离它最近的类型**\n\n1. `const int* p`；离 const 最近的类型是 int，所以 const 修饰的是 `*p` ，所以 `*p` 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。\n2. `int const* p`；`*` 不是类型，离 const 最近的类型为 int，`*p` 无法修改，同（1）\n3. `int* const p`；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。\n4. `const int* const p`；不能修改 p 指向的地址和值。\n\n~~~c++\n#include <iostream>\n \nint main()\n{\n  const int a = 10 ;\n  const int * p = &a;//p指向的地址的内容不能修改\n \n  return 0;\n}\n~~~\n\n> 重点：\n> \n> **const 如果右边没有指针 `*`，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。**\n> \n> **const 类型转化公式：**\n> \n> - `const int*`  <= `int*` 可以转换\n> - `int*` <= `const int*` 错误\n\n示例1：\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nint main()\n{\n\tint* p = nullptr;\n\tint* const p1 = nullptr;\n\n\tcout << typeid(p).name() << endl;\n\tcout << typeid(p1).name() << endl;\n\n\treturn 0;\n}\n~~~\n\n![](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png)\n\n示例2：\n\n~~~c++\nint a=10;\nint *p1= &a;\nconst int *p2 = &a;// const int * <= int *\nint *const p3 = &a;// int * <= int *\nint *p4 = p3;//p3是int * 类型，因此没有问题\n~~~\n\n#### 2.2 const 和 二级指针\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png)\n\n- `const int** q`；离 const 最近的类型为 int，修饰的是 `**q`。\n- `int* const* q`；离 const 最近的类型为 `int*`，修饰的是 `*q`。\n- `int** const q`；离 const 最近的类型为 `int**`，修饰的是 `q`，同时 const 右侧没有 `*` ，q 是 `int**` 类型。\n\n**转化公式：**\n\n- `int**` <= `const int**` 错误\n- `const int **` <= `int **` 错误\n\nconst 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；\n\n- `int**` <= `int* const*` 是 const 和一级指针的结合，const 右边修饰的`*`  （等同于 `int *`  <= `const int *`  ）错误的\n- `int* const*` <=`int**` （等同于`const int *` <= `int` ）可以的\n\n**要看 const 右边的 * 决定 const 修饰的是类型**\n\n~~~c++\n#include <iostream>\n#include <typeinfo.h>\n\nint main()\n{\n  int a = 10;\n  int * p = &a;\n  const int ** q = &p;//error  \n  \n  /*\n  const int * *q = &p; 相当于（*）q 即 p的地址，赋值了一个const int * \n  而p 是int *类型,把常量的地址泄露给普通的指针（p）\n  修改 const int * p = &a;\n  */\n  \n  return 0;\n}\n~~~\n\n### 3. 引用\n\n1. 引用是必须初始化的，指针可以不初始化。\n2. 引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。\n3. 定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。\n\n引用的错误用法  `int &a = 10;` 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；\n\n~~~c++\n#include <iostream>\n#include <typeinfo.h>\nint main()\n{\n  int a = 10;\n  int * p = &a;\n  int &b = a;\n \n  std::cout  << a << \" \" << b << \" \" << (*p) << std::endl;\n \n  *p = 20;\n  std::cout << a << \" \" << b << \" \" << (*p) << std::endl;\n \n \n  b = 30;\n  std::cout << a << \" \" << b << \" \" << (*p);\n  return 0;\n}\n~~~\n\n输出：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png)\n\n **反汇编：指针和引用没有区别**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png)\n\n`lea eax,[a]`：将 a 的地址拷贝到寄存器 eax 中\n\n`mov dword ptr [p],eax`：将 eax 中的值拷贝到 p 中。\n\n**反汇编中指针和引用拷贝也是没有区别。**\n\n![指针拷贝 - 1](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png)\n![指针拷贝 - 2](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png)\n\n对指针和引用赋值，都是一样的：获取地址，然后赋值。\n\n#### 3.1 引用别名\n\n~~~c++\n#include <iostream>\n#include <typeinfo.h>\n\nint main()\n{\n  int array[5] = {};\n  int * p = array;\n  int(&q)[5] = array;//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) \n \n  std::cout << sizeof(array) << \"\\n\" << sizeof(p) << \"\\n\" << sizeof(q) << std::endl;//20 5 20\n \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png)\n\n关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 \n\n站在宏观角度，引用也就是别名，所以不开辟看空间。\n\n站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。\n\n### 4. 左值引用\n\n左值：有内存地址，有名字，值可以修改；\n\n如 `int a = 10;` `int &b =a;`\n\n`int &c =10;` //错误 20 是右值，20 = 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；\n\n上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：\n\n~~~c++\nconst int &var = 10;\n~~~\n\n使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：\n\n~~~c++\nconst int temp = 10; \nconst int &var = temp;\n~~~\n\n根据上述分析，得出如下结论：\n\n左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；\n但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。\n\n那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。\n\n### 5. 右值引用\n\nC++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：\n\n- 可以取地址的，有名字的，非临时的就是左值；\n- 不能取地址的，没有名字的，临时的就是右值；\n\n可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。\n\n从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。\n\n1. **`int &&c = 10;`专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c = 1;**\n\n反汇编：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png)\n\n2. **一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值**\n\n~~~c++\nint && a = 1;\na = 10;\nint &e = a;\n~~~\n\n## 5. 深入理解 C++ 的 new 和 delete\n\n**New 的不同使用方式：**\n\n~~~c++\n#include <iostream>\n#include <new>\n\nint main()\n{\n    //1 抛异常new\n    int* p1;\n    try\n    {\n        p1 = new int(2);//分配内存并初始化\n    }\n    catch (const std::bad_alloc& e)//判断是否抛异常\n    {\n\n    }\n\n    //2 不抛异常new\n    int* p2 = new (std::nothrow)int();//不抛异常\n    //3 开辟常量内存\n    const int* p3 = new const int(40);//开辟一个常量\n\n    //4 定位new\n    int data = 0;\n    int* p4 = new(&data) int(50);//在指定地址内存初始化，本身并不开辟内存，只负责初始化\n    delete p1;\n    delete p2;\n    delete p3;\n    delete p4;\n\n    return 0;\n}\n~~~\n\n#### 1. malloc 与 new 的区别\n\n1. malloc 按字节开辟内存的；new 开辟内存时需要指定类型；\n2. malloc 开辟内存返回的都是 `void *` ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。\n3. malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。\n4. malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。\n5. malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要`[]`，而数组需要 `[]`并给上元素个数。\n\n#### 2. free 和 delete 的区别：\n\n1. free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  \n2. delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  \n3. delete 执行其实有两步，先调用析构，再释放；free 只有一步。\n\n#### 3. 解析\n\n代码：\n\n~~~c++\n#include <iostream>\n\nint main() \n{\n    int* p = new int;\n    delete p;\n    p = nullptr;\n\n    return 0;\n}\n~~~\n\n反汇编：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png)\n\n**new 与 delete 其本质也是函数的调用：运算符重载 new  delete**\n\n~~~c++\nnew -> operator new\ndelete -> operator delete\n~~~\n\n#### 4. 实现\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// new：\n// 先调用 operator 开辟内存空间\n// 然后调用对象的构造函数\n// operator new 实现\nvoid* operator new(size_t size)\n{\n    // 开辟\n    void* p = malloc(size);\n    // 判断\n    if (p == nullptr)\n    {\n        throw bad_alloc();\n    }\n\n    cout << \"operator new addr:\" << p << endl;\n\n    return p;\n}\n\n// operator new[] 实现\nvoid* operator new[](size_t size)\n{\n    // 开辟\n    void* p = malloc(size);\n    // 判断\n    if (p == nullptr)\n    {\n        throw bad_alloc();\n    }\n\n    cout << \"operator new[] addr:\" << p << endl;\n\n    return p;\n}\n\n// delete：\n// 调用 p 指向对象的析构函数\n// 再调用 operator delete 释放空间\n// operator delete 实现\nvoid operator delete(void* ptr)\n{\n    cout << \"operator delete addr: \" << ptr << endl;\n    free(ptr);\n}\n\n// operator delete[] 实现\nvoid operator delete[](void* ptr)\n{\n    cout << \"operator delete[] addr: \" << ptr << endl;\n    free(ptr);\n}\n\n// 使用\nint main()\n{\n    int* p = new int(5);\n    delete p;\n    p = nullptr;\n\n    p = new int[5];\n    delete[] p;\n    p = nullptr;\n\n    return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png)\n\n#### 5. new 和delete 能够混用吗？\n\n**C++为什么区分单个元素和数组的内存分配和释放呢？**\n\n**情况1：int类型下将其混用**\n\n```c++\nint *p = new int;\ndelete[]p;\n \nint *q = new int[10];\ndelete q;\n```\n\n能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。\n\n**情况2：类类型下将其混用**\n\n~~~c++\nclass Test\n{\npublic:\n\tTest(int data = 10):ptr(new int(data))\n\t{\n\t\tcout << \"Test()\" << endl;\n\t}\n\t~Test()\n\t{\n\t\tdelete ptr;\n\t\tcout << \"~Test()\" << endl;\n\t}\nprivate:\n\tint *ptr;\n};\n~~~\n\n- **单个元素与 `delete[]` 混用：**\n\n~~~c++\nTest *p1 = new Test();\ndelete[]p1;\n~~~\n\n![报错程序](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png)\n\n程序崩溃。\n\n- **数组与 delete 进行混用**\n\n~~~c++\nTest *p2 = new Test[5];\ndelete p2;\n~~~\n\n程序崩溃。\n\n**分析：**\n\n正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 `[]` 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 `0x100`；但是 new 完之后 p2 返回的地址是 `0x104` 地址，当我们执行 `delete[]` 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 `0x100` 开始的 4 字节也释放。\n\n而 p2 出错是给用户返回的存对象开始的起始地址，`delete p2` 认为 p2 只是指向了一个对象，只将 `Test[0]` 对象析构，直接从 `0x104 free(p2)`，但底层实际是从 `0x100` 开辟的，因此崩溃。\n\n而 p1 出错：p1 只是单个元素，从 `0x104` 开始开辟内存，但是 `delete[] p1`，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 `0x100` 释放)因此崩溃。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png)\n\n","source":"_posts/02.C++ 基础部分/02.C++ 基础精讲.md","raw":"---\ntitle: 02.C++ 基础精讲\ntags: [C++]\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节分为 5 大类：\n\n1. 形参带默认值的函数\n2. 内联函数inline\n3. 详解函数重载\n4. const 深入应用\n5. 深入理解 C++ 的 new 和 delete\n\n## 1. 形参带默认值的函数\n\n在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。\n\n**注意事项：**\n\n1. 在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。\n\n~~~c++\ndouble sqrt(double f = 1.0); //函数声明\n\ndouble sqrt(double f)  //函数定义\n{\n  // ....  \n}\n~~~\n\n2. 没有函数（原型）时，默认参数在函数定义时指定。\n\n~~~c++\n//没有 函数声明\n \ndouble sqrt(double f = 1.0)  //函数定义\n~~~\n\n3. 在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.\n\n就是说，**函数声明时，必须按照从右向左的顺序，依次给与默认值。**\n\n原因：\n\n函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 **从指令角度掌握函数调用堆栈详细过程。**\n\n~~~c++\nint f (int i1, int i2 = 2, int i3 = 3);     // 正确\nint g (int i1, int i2 = 2, int i3);         // 错误, i3未指定默认值\nint h (int i1 = 1, int i2, int i3 = 3);     // 错误, i2未指定默认值\n~~~\n\n**普通函数和形参带默认值函数对比：**\n\n~~~c++\n#include <iostream>\n \nint sum(int a = 10, int b  = 10)\n{\n  int temp = 0;\n  temp = a + b;\n  return temp;\n}\n \nint main()\n{\n  int a = 10;\n  int b = 20;\n \n  int ret = sum(a, b);\n \n  ret = sum(a);//b 使用默认值\n \n  ret = sum();//都使用默认值\n \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png)\n\n对比1，2 发现：\n\n2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；\n\n同理有3，使用默认值是：调用函数减少了 mov 指令。\n\n## 2. 内联函数 inline\n\n**特征：**\n\n- 相当于把内联函数里面的内容写在调用内联函数处；\n- 相当于不用执行进入函数的步骤，直接执行函数体；\n- 相当于宏，却比宏多了类型检查，真正具有函数特性；\n- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；\n- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。\n\n**使用：**\n\n~~~c++\n// 声明1（加 inline，建议使用）\ninline int functionName(int first, int second,...);\n\n// 声明2（不加 inline）\nint functionName(int first, int second,...);\n\n// 定义\ninline int functionName(int first, int second,...) {/****/};\n\n// 类内定义，隐式内联\nclass A {\n    int doA() { return 0; }         // 隐式内联\n}\n\n// 类外定义，需要显式内联\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // 需要显式内联\n~~~\n\n**编译器对 inline 函数的处理步骤：**\n\n1. 将 inline 函数体复制到 inline 函数调用点处；\n2. 为所用 inline 函数中的局部变量分配内存空间；\n3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；\n4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。\n\n**内联函数与普通函数的区别？**\n\n1. 内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理\n\n[[01.理解 C++ 内核]] 中的 **从指令角度掌握函数调用堆栈详细过程** 知道，在调用函数的过程中：\n\n（1）将函数实数从右向左压栈\n（2）call指令：\n\t\t将下一行要执行的代码地址入栈\n\t\t跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。\n\n在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令\n\n2. 内联函数不在生成相应的函数符号\n\n3. inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。\n\n注意：\n\n（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。\n\n**优缺点：**\n\n优点\n\n1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。\n2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。\n3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。\n4. 内联函数在运行时可调试，而宏定义不可以。\n\n缺点\n\n1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。\n2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。\n3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。\n\n## 3. 详解函数重载\n\n**函数重载**：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。\n\n（1）函数重载与函数返回值无关，因为在产生符号时没有返回值\n（2） 函数重载需要在同一个作用域\n（3）const 或者 volatile 的时候，是如何影响形参的\n\n**C++ 支持函数重载，而 C 则不支持：**\n\n编译器产生的函数符号规则不同：\n\n- C++ 代码：函数符号包含了函数名和参数列表\n- C 代码：函数符号只包含了函数名。\n\n**注意事项：**\n\n** **函数重载需要在同一个作用域下**。**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nbool compare(int a, int b)\n{\n\treturn a > b;\n}\n\nbool compare(double a, double b)\n{\n\treturn a > b;\n}\n\nbool compare(const char* a, const char* b)\n{\n\treturn a > b;\n}\n\nint main()\n{\n\tbool compare(double a, double b);\n\tcompare(\"adf\", \"wew\");\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png)\n\n由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。\n\n**const int 和 int 的重载：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nvoid func(int a) {}\nvoid func(const int a) {}\n\nint main()\n{\n\t// ...\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png)\n\n原因：\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\n\nint main()\n{\n\tint a = 10;\n\tconst int b = 10;\n\n\tstd::cout << typeid(a).name() << std::endl;\n\tstd::cout << typeid(b).name() << std::endl;\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png)\n\nconst int 和 int 在编译器看来都是 int 类型 ，无法完成重载。\n\n### 3.1 C++ 和 C 语言如何相互调用\n\n由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten \"C\"{};\n\n#### 1. C++ 调用 C\n\n对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字`extern \"C\"`，表示采用类c语言的方式解析函数符号。例子如下：\n\n~~~c++\n// add.h\n\n#ifdef __ADD_H__\n#define __ADD_H__\n\nextern \"C\" int add(int a, int b);\n\n#endif\n\n\n// add.c\nint add(int a, int b)\n{\n    return a + b;\n}\n\n// main.cpp\n#include <iostream>\n#include \"add.h\"\nusing namespace std;\n\nint main()\n{\n    cout << \"1 + 1 = \" << add(1, 1) << endl;\n}\n~~~\n\n在例子中，`main.cpp` 为`c++` 代码，`add.c` 为 c 语言代码，当 c++ 编译器识别到`extern \"C\"` 关键字时，会去寻找 `_add_` 函数的实现而不是寻找类似`_int_add_int_int_` 这样带参数信息的函数实现。\n\n#### 2. C 调用 C++\n\nc 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：\n1. 将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；\n2. 对外提供遵循类 c 语言规约的接口函数。例子如下所示：\n\n~~~c++\n// printNum.h\n#ifdef __PRINTNUM_H__\n#define __PRINTNUM_H__\n\nextern \"C\" void printNum(int a);\n\n#endif\n\n// printNum.cpp\n#include <iostream>\n#include \"printNum.h\"\nusing namespace std;\n\nvoid printNum(int a)\n{\n    cout << << \"num is \" << a << endl;\n}\n\n// main.c\nextern void printNum(int a);\n\nprintNum(5);\n~~~\n\n通过将 `_cout_`函数封装为类 c 语言规约的接口函数，使得 `main.c` 中可以成功调用 c++ 函数 `_printNum_` 。值得注意的是，`main.c` 不可以直接引入 `printNum.h`，因为 c 语言不能识别 `extern \"C\"` 关键字。可以利用 c++ 预定义宏实现头文件的改写：\n\n~~~c++\n#ifdef __PRINTNUM_H__\n#define __PRINTNUM_H__\n\n#ifdef __cplusplus\nextern \"C\" { \n#endif\nvoid printNum(int a);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n~~~\n\n#### 3. 总结\n\n\n1. c 语言与 c++ 的相互调用可以通过 `extern \"C\"` 关键字实现\n2. c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 `extern \"C\"`\n3. c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 `extern \"C\"` 声明的类 c 封装函数\n\n## 4. const 深入应用\n\n**const 作用：**\n\n1. 修饰变量，说明该变量不可以被改变；\n2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；\n3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；\n4. 修饰成员函数，说明该成员函数内不能修改成员变量。\n\n**const 的指针与引用：**\n\n- 指针\n    - 指向常量的指针（pointer to const）\n    - 自身是常量的指针（常量指针，const pointer）\n- 引用\n    - 指向常量的引用（reference to const）\n    - 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰\n\n~~~c++\n// 类\nclass A\n{\nprivate:\n    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化\n\npublic:\n    // 构造函数\n    A() : a(0) { };\n    A(int x) : a(x) { };        // 初始化列表\n\n    // const可用于对重载函数的区分\n    int getValue();             // 普通成员函数\n    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值\n};\n\nvoid function()\n{\n    // 对象\n    A b;                        // 普通对象，可以调用全部成员函数\n    const A a;                  // 常对象，只能调用常成员函数\n    const A *p = &a;            // 指针变量，指向常对象\n    const A &q = a;             // 指向常对象的引用\n\n    // 指针\n    char greeting[] = \"Hello\";\n    char* p1 = greeting;                // 指针变量，指向字符数组变量\n    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）\n    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）\n    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量\n}\n\n// 函数\nvoid function1(const int Var);           // 传递过来的参数在函数内不可变\nvoid function2(const char* Var);         // 参数指针所指内容为常量\nvoid function3(char* const Var);         // 参数指针为常量\nvoid function4(const int& Var);          // 引用参数在函数内为常量\n\n// 函数返回值\nconst int function5();      // 返回一个常数\nconst int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();\nint* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();\n~~~\n\n**宏定义 `#define` 和 const 常量:**\n\n|宏定义 #define|const 常量|\n|---|---|\n|宏定义，相当于字符替换|常量声明|\n|预处理器处理|编译器处理|\n|无类型安全检查|有类型安全检查|\n|不分配内存|要分配内存|\n|存储在代码段|存储在数据段|\n|可通过 `#undef` 取消|不可取消|\n\n### 1. C++ 和 C 的 const 区别\n\n- **c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png)\n\n最终输出为：30、30、30\n\n- **C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png)\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t// const int b;\n\tconst int a = 10;\n\t// a 常量，可以定义数组长度\n\tint array[a] = {};\n\n\tint* p = (int*)&a;\n\t*p = 30;\n\n\tcout << a << \" \" << *p << \" \" << *(&a) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png)\n\n原因：**const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。**\n\n#### 1.1 Debug 调试\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png)\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png)\n\n执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。\n\n**如果不是立即数，则是常变量**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint b = 1;\n\tconst int a = b;\n\n\t// 报错，a是常变量\n\t//int array[a] = {};\n\n\tint* p = (int*)&a;\n\t*p = 30;\n\n\tcout << a << \" \" << *p << \" \" << *(&a); // 30 30 30\n\n\treturn 0;\n}\n~~~\n\n### 2. const 与指针\n\nconst 修饰的量常出现的错误：\n\n**（1）常量不能再作为左值**\n**（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png)\n\n#### 2.1 const 和 一级指针\n\n**const 如果右边没有指针*，则const 是不参与类型的**\n\n**C++的语言规范：就近原则 const 修饰的是离它最近的类型**\n\n1. `const int* p`；离 const 最近的类型是 int，所以 const 修饰的是 `*p` ，所以 `*p` 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。\n2. `int const* p`；`*` 不是类型，离 const 最近的类型为 int，`*p` 无法修改，同（1）\n3. `int* const p`；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。\n4. `const int* const p`；不能修改 p 指向的地址和值。\n\n~~~c++\n#include <iostream>\n \nint main()\n{\n  const int a = 10 ;\n  const int * p = &a;//p指向的地址的内容不能修改\n \n  return 0;\n}\n~~~\n\n> 重点：\n> \n> **const 如果右边没有指针 `*`，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。**\n> \n> **const 类型转化公式：**\n> \n> - `const int*`  <= `int*` 可以转换\n> - `int*` <= `const int*` 错误\n\n示例1：\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nint main()\n{\n\tint* p = nullptr;\n\tint* const p1 = nullptr;\n\n\tcout << typeid(p).name() << endl;\n\tcout << typeid(p1).name() << endl;\n\n\treturn 0;\n}\n~~~\n\n![](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png)\n\n示例2：\n\n~~~c++\nint a=10;\nint *p1= &a;\nconst int *p2 = &a;// const int * <= int *\nint *const p3 = &a;// int * <= int *\nint *p4 = p3;//p3是int * 类型，因此没有问题\n~~~\n\n#### 2.2 const 和 二级指针\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png)\n\n- `const int** q`；离 const 最近的类型为 int，修饰的是 `**q`。\n- `int* const* q`；离 const 最近的类型为 `int*`，修饰的是 `*q`。\n- `int** const q`；离 const 最近的类型为 `int**`，修饰的是 `q`，同时 const 右侧没有 `*` ，q 是 `int**` 类型。\n\n**转化公式：**\n\n- `int**` <= `const int**` 错误\n- `const int **` <= `int **` 错误\n\nconst 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；\n\n- `int**` <= `int* const*` 是 const 和一级指针的结合，const 右边修饰的`*`  （等同于 `int *`  <= `const int *`  ）错误的\n- `int* const*` <=`int**` （等同于`const int *` <= `int` ）可以的\n\n**要看 const 右边的 * 决定 const 修饰的是类型**\n\n~~~c++\n#include <iostream>\n#include <typeinfo.h>\n\nint main()\n{\n  int a = 10;\n  int * p = &a;\n  const int ** q = &p;//error  \n  \n  /*\n  const int * *q = &p; 相当于（*）q 即 p的地址，赋值了一个const int * \n  而p 是int *类型,把常量的地址泄露给普通的指针（p）\n  修改 const int * p = &a;\n  */\n  \n  return 0;\n}\n~~~\n\n### 3. 引用\n\n1. 引用是必须初始化的，指针可以不初始化。\n2. 引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。\n3. 定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。\n\n引用的错误用法  `int &a = 10;` 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；\n\n~~~c++\n#include <iostream>\n#include <typeinfo.h>\nint main()\n{\n  int a = 10;\n  int * p = &a;\n  int &b = a;\n \n  std::cout  << a << \" \" << b << \" \" << (*p) << std::endl;\n \n  *p = 20;\n  std::cout << a << \" \" << b << \" \" << (*p) << std::endl;\n \n \n  b = 30;\n  std::cout << a << \" \" << b << \" \" << (*p);\n  return 0;\n}\n~~~\n\n输出：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png)\n\n **反汇编：指针和引用没有区别**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png)\n\n`lea eax,[a]`：将 a 的地址拷贝到寄存器 eax 中\n\n`mov dword ptr [p],eax`：将 eax 中的值拷贝到 p 中。\n\n**反汇编中指针和引用拷贝也是没有区别。**\n\n![指针拷贝 - 1](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png)\n![指针拷贝 - 2](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png)\n\n对指针和引用赋值，都是一样的：获取地址，然后赋值。\n\n#### 3.1 引用别名\n\n~~~c++\n#include <iostream>\n#include <typeinfo.h>\n\nint main()\n{\n  int array[5] = {};\n  int * p = array;\n  int(&q)[5] = array;//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) \n \n  std::cout << sizeof(array) << \"\\n\" << sizeof(p) << \"\\n\" << sizeof(q) << std::endl;//20 5 20\n \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png)\n\n关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 \n\n站在宏观角度，引用也就是别名，所以不开辟看空间。\n\n站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。\n\n### 4. 左值引用\n\n左值：有内存地址，有名字，值可以修改；\n\n如 `int a = 10;` `int &b =a;`\n\n`int &c =10;` //错误 20 是右值，20 = 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；\n\n上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：\n\n~~~c++\nconst int &var = 10;\n~~~\n\n使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：\n\n~~~c++\nconst int temp = 10; \nconst int &var = temp;\n~~~\n\n根据上述分析，得出如下结论：\n\n左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；\n但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。\n\n那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。\n\n### 5. 右值引用\n\nC++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：\n\n- 可以取地址的，有名字的，非临时的就是左值；\n- 不能取地址的，没有名字的，临时的就是右值；\n\n可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。\n\n从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。\n\n1. **`int &&c = 10;`专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c = 1;**\n\n反汇编：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png)\n\n2. **一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值**\n\n~~~c++\nint && a = 1;\na = 10;\nint &e = a;\n~~~\n\n## 5. 深入理解 C++ 的 new 和 delete\n\n**New 的不同使用方式：**\n\n~~~c++\n#include <iostream>\n#include <new>\n\nint main()\n{\n    //1 抛异常new\n    int* p1;\n    try\n    {\n        p1 = new int(2);//分配内存并初始化\n    }\n    catch (const std::bad_alloc& e)//判断是否抛异常\n    {\n\n    }\n\n    //2 不抛异常new\n    int* p2 = new (std::nothrow)int();//不抛异常\n    //3 开辟常量内存\n    const int* p3 = new const int(40);//开辟一个常量\n\n    //4 定位new\n    int data = 0;\n    int* p4 = new(&data) int(50);//在指定地址内存初始化，本身并不开辟内存，只负责初始化\n    delete p1;\n    delete p2;\n    delete p3;\n    delete p4;\n\n    return 0;\n}\n~~~\n\n#### 1. malloc 与 new 的区别\n\n1. malloc 按字节开辟内存的；new 开辟内存时需要指定类型；\n2. malloc 开辟内存返回的都是 `void *` ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。\n3. malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。\n4. malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。\n5. malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要`[]`，而数组需要 `[]`并给上元素个数。\n\n#### 2. free 和 delete 的区别：\n\n1. free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  \n2. delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  \n3. delete 执行其实有两步，先调用析构，再释放；free 只有一步。\n\n#### 3. 解析\n\n代码：\n\n~~~c++\n#include <iostream>\n\nint main() \n{\n    int* p = new int;\n    delete p;\n    p = nullptr;\n\n    return 0;\n}\n~~~\n\n反汇编：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png)\n\n**new 与 delete 其本质也是函数的调用：运算符重载 new  delete**\n\n~~~c++\nnew -> operator new\ndelete -> operator delete\n~~~\n\n#### 4. 实现\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// new：\n// 先调用 operator 开辟内存空间\n// 然后调用对象的构造函数\n// operator new 实现\nvoid* operator new(size_t size)\n{\n    // 开辟\n    void* p = malloc(size);\n    // 判断\n    if (p == nullptr)\n    {\n        throw bad_alloc();\n    }\n\n    cout << \"operator new addr:\" << p << endl;\n\n    return p;\n}\n\n// operator new[] 实现\nvoid* operator new[](size_t size)\n{\n    // 开辟\n    void* p = malloc(size);\n    // 判断\n    if (p == nullptr)\n    {\n        throw bad_alloc();\n    }\n\n    cout << \"operator new[] addr:\" << p << endl;\n\n    return p;\n}\n\n// delete：\n// 调用 p 指向对象的析构函数\n// 再调用 operator delete 释放空间\n// operator delete 实现\nvoid operator delete(void* ptr)\n{\n    cout << \"operator delete addr: \" << ptr << endl;\n    free(ptr);\n}\n\n// operator delete[] 实现\nvoid operator delete[](void* ptr)\n{\n    cout << \"operator delete[] addr: \" << ptr << endl;\n    free(ptr);\n}\n\n// 使用\nint main()\n{\n    int* p = new int(5);\n    delete p;\n    p = nullptr;\n\n    p = new int[5];\n    delete[] p;\n    p = nullptr;\n\n    return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png)\n\n#### 5. new 和delete 能够混用吗？\n\n**C++为什么区分单个元素和数组的内存分配和释放呢？**\n\n**情况1：int类型下将其混用**\n\n```c++\nint *p = new int;\ndelete[]p;\n \nint *q = new int[10];\ndelete q;\n```\n\n能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。\n\n**情况2：类类型下将其混用**\n\n~~~c++\nclass Test\n{\npublic:\n\tTest(int data = 10):ptr(new int(data))\n\t{\n\t\tcout << \"Test()\" << endl;\n\t}\n\t~Test()\n\t{\n\t\tdelete ptr;\n\t\tcout << \"~Test()\" << endl;\n\t}\nprivate:\n\tint *ptr;\n};\n~~~\n\n- **单个元素与 `delete[]` 混用：**\n\n~~~c++\nTest *p1 = new Test();\ndelete[]p1;\n~~~\n\n![报错程序](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png)\n\n程序崩溃。\n\n- **数组与 delete 进行混用**\n\n~~~c++\nTest *p2 = new Test[5];\ndelete p2;\n~~~\n\n程序崩溃。\n\n**分析：**\n\n正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 `[]` 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 `0x100`；但是 new 完之后 p2 返回的地址是 `0x104` 地址，当我们执行 `delete[]` 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 `0x100` 开始的 4 字节也释放。\n\n而 p2 出错是给用户返回的存对象开始的起始地址，`delete p2` 认为 p2 只是指向了一个对象，只将 `Test[0]` 对象析构，直接从 `0x104 free(p2)`，但底层实际是从 `0x100` 开辟的，因此崩溃。\n\n而 p1 出错：p1 只是单个元素，从 `0x104` 开始开辟内存，但是 `delete[] p1`，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 `0x100` 释放)因此崩溃。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png)\n\n","slug":"02.C++ 基础部分/02.C++ 基础精讲","published":1,"date":"2023-08-03T07:05:00.959Z","updated":"2023-08-09T09:14:00.085Z","_id":"clkuty8ua0000ncpkgjf774pk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节分为 5 大类：</p>\n<ol>\n<li>形参带默认值的函数</li>\n<li>内联函数inline</li>\n<li>详解函数重载</li>\n<li>const 深入应用</li>\n<li>深入理解 C++ 的 new 和 delete</li>\n</ol>\n<h2 id=\"1-形参带默认值的函数\"><a href=\"#1-形参带默认值的函数\" class=\"headerlink\" title=\"1. 形参带默认值的函数\"></a>1. 形参带默认值的函数</h2><p>在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。</p>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li>在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> f = <span class=\"hljs-number\">1.0</span>)</span></span>; <span class=\"hljs-comment\">//函数声明</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> f)</span>  <span class=\"hljs-comment\">//函数定义</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">// ....  </span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>没有函数（原型）时，默认参数在函数定义时指定。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//没有 函数声明</span><br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> f = <span class=\"hljs-number\">1.0</span>)</span>  <span class=\"hljs-comment\">//函数定义</span></span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</li>\n</ol>\n<p>就是说，<strong>函数声明时，必须按照从右向左的顺序，依次给与默认值。</strong></p>\n<p>原因：</p>\n<p>函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 <strong>从指令角度掌握函数调用堆栈详细过程。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">f</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i1, <span class=\"hljs-type\">int</span> i2 = <span class=\"hljs-number\">2</span>, <span class=\"hljs-type\">int</span> i3 = <span class=\"hljs-number\">3</span>)</span></span>;     <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i1, <span class=\"hljs-type\">int</span> i2 = <span class=\"hljs-number\">2</span>, <span class=\"hljs-type\">int</span> i3)</span></span>;         <span class=\"hljs-comment\">// 错误, i3未指定默认值</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">h</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i1 = <span class=\"hljs-number\">1</span>, <span class=\"hljs-type\">int</span> i2, <span class=\"hljs-type\">int</span> i3 = <span class=\"hljs-number\">3</span>)</span></span>;     <span class=\"hljs-comment\">// 错误, i2未指定默认值</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>普通函数和形参带默认值函数对比：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>, <span class=\"hljs-type\">int</span> b  = <span class=\"hljs-number\">10</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>  temp = a + b;<br>  <span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>  <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br> <br>  <span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(a, b);<br> <br>  ret = <span class=\"hljs-built_in\">sum</span>(a);<span class=\"hljs-comment\">//b 使用默认值</span><br> <br>  ret = <span class=\"hljs-built_in\">sum</span>();<span class=\"hljs-comment\">//都使用默认值</span><br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png\" alt=\"image.png\"></p>\n<p>对比1，2 发现：</p>\n<p>2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；</p>\n<p>同理有3，使用默认值是：调用函数减少了 mov 指令。</p>\n<h2 id=\"2-内联函数-inline\"><a href=\"#2-内联函数-inline\" class=\"headerlink\" title=\"2. 内联函数 inline\"></a>2. 内联函数 inline</h2><p><strong>特征：</strong></p>\n<ul>\n<li>相当于把内联函数里面的内容写在调用内联函数处；</li>\n<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>\n<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>\n<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>\n<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 声明1（加 inline，建议使用）</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> first, <span class=\"hljs-type\">int</span> second,...)</span></span>;<br><br><span class=\"hljs-comment\">// 声明2（不加 inline）</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> first, <span class=\"hljs-type\">int</span> second,...)</span></span>;<br><br><span class=\"hljs-comment\">// 定义</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> first, <span class=\"hljs-type\">int</span> second,...)</span> </span>&#123;<span class=\"hljs-comment\">/****/</span>&#125;;<br><br><span class=\"hljs-comment\">// 类内定义，隐式内联</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">doA</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; &#125;         <span class=\"hljs-comment\">// 隐式内联</span><br>&#125;<br><br><span class=\"hljs-comment\">// 类外定义，需要显式内联</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">doA</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">A::doA</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; &#125;   <span class=\"hljs-comment\">// 需要显式内联</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>编译器对 inline 函数的处理步骤：</strong></p>\n<ol>\n<li>将 inline 函数体复制到 inline 函数调用点处；</li>\n<li>为所用 inline 函数中的局部变量分配内存空间；</li>\n<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>\n<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>\n</ol>\n<p><strong>内联函数与普通函数的区别？</strong></p>\n<ol>\n<li>内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理</li>\n</ol>\n<p>[[01.理解 C++ 内核]] 中的 <strong>从指令角度掌握函数调用堆栈详细过程</strong> 知道，在调用函数的过程中：</p>\n<p>（1）将函数实数从右向左压栈<br>（2）call指令：<br>        将下一行要执行的代码地址入栈<br>        跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。</p>\n<p>在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令</p>\n<ol start=\"2\">\n<li><p>内联函数不在生成相应的函数符号</p>\n</li>\n<li><p>inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。</p>\n</li>\n</ol>\n<p>注意：</p>\n<p>（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。</p>\n<p><strong>优缺点：</strong></p>\n<p>优点</p>\n<ol>\n<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>\n<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>\n<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>\n<li>内联函数在运行时可调试，而宏定义不可以。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>\n<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>\n<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>\n</ol>\n<h2 id=\"3-详解函数重载\"><a href=\"#3-详解函数重载\" class=\"headerlink\" title=\"3. 详解函数重载\"></a>3. 详解函数重载</h2><p><strong>函数重载</strong>：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。</p>\n<p>（1）函数重载与函数返回值无关，因为在产生符号时没有返回值<br>（2） 函数重载需要在同一个作用域<br>（3）const 或者 volatile 的时候，是如何影响形参的</p>\n<p><strong>C++ 支持函数重载，而 C 则不支持：</strong></p>\n<p>编译器产生的函数符号规则不同：</p>\n<ul>\n<li>C++ 代码：函数符号包含了函数名和参数列表</li>\n<li>C 代码：函数符号只包含了函数名。</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<p>** <strong>函数重载需要在同一个作用域下</strong>。**</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)</span></span>;<br>\t<span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-string\">&quot;adf&quot;</span>, <span class=\"hljs-string\">&quot;wew&quot;</span>);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png\" alt=\"image.png\"></p>\n<p>由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。</p>\n<p><strong>const int 和 int 的重载：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span> </span>&#123;&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a)</span> </span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// ...</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png\" alt=\"image.png\"></p>\n<p>原因：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">10</span>;<br><br>\tstd::cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(a).<span class=\"hljs-built_in\">name</span>() &lt;&lt; std::endl;<br>\tstd::cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(b).<span class=\"hljs-built_in\">name</span>() &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png\" alt=\"image.png\"></p>\n<p>const int 和 int 在编译器看来都是 int 类型 ，无法完成重载。</p>\n<h3 id=\"3-1-C-和-C-语言如何相互调用\"><a href=\"#3-1-C-和-C-语言如何相互调用\" class=\"headerlink\" title=\"3.1 C++ 和 C 语言如何相互调用\"></a>3.1 C++ 和 C 语言如何相互调用</h3><p>由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten “C”{};</p>\n<h4 id=\"1-C-调用-C\"><a href=\"#1-C-调用-C\" class=\"headerlink\" title=\"1. C++ 调用 C\"></a>1. C++ 调用 C</h4><p>对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字<code>extern &quot;C&quot;</code>，表示采用类c语言的方式解析函数符号。例子如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// add.h</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __ADD_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __ADD_H__</span><br><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><br><span class=\"hljs-comment\">// add.c</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-comment\">// main.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;add.h&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;1 + 1 = &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在例子中，<code>main.cpp</code> 为<code>c++</code> 代码，<code>add.c</code> 为 c 语言代码，当 c++ 编译器识别到<code>extern &quot;C&quot;</code> 关键字时，会去寻找 <code>_add_</code> 函数的实现而不是寻找类似<code>_int_add_int_int_</code> 这样带参数信息的函数实现。</p>\n<h4 id=\"2-C-调用-C\"><a href=\"#2-C-调用-C\" class=\"headerlink\" title=\"2. C 调用 C++\"></a>2. C 调用 C++</h4><p>c 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：</p>\n<ol>\n<li>将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；</li>\n<li>对外提供遵循类 c 语言规约的接口函数。例子如下所示：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// printNum.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __PRINTNUM_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __PRINTNUM_H__</span><br><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">// printNum.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;printNum.h&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; &lt;&lt; <span class=\"hljs-string\">&quot;num is &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-comment\">// main.c</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span>;<br><br><span class=\"hljs-built_in\">printNum</span>(<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></table></figure>\n\n<p>通过将 <code>_cout_</code>函数封装为类 c 语言规约的接口函数，使得 <code>main.c</code> 中可以成功调用 c++ 函数 <code>_printNum_</code> 。值得注意的是，<code>main.c</code> 不可以直接引入 <code>printNum.h</code>，因为 c 语言不能识别 <code>extern &quot;C&quot;</code> 关键字。可以利用 c++ 预定义宏实现头文件的改写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __PRINTNUM_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __PRINTNUM_H__</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __cplusplus</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> &#123; <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __cplusplus</span><br>&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h4><ol>\n<li>c 语言与 c++ 的相互调用可以通过 <code>extern &quot;C&quot;</code> 关键字实现</li>\n<li>c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 <code>extern &quot;C&quot;</code></li>\n<li>c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 <code>extern &quot;C&quot;</code> 声明的类 c 封装函数</li>\n</ol>\n<h2 id=\"4-const-深入应用\"><a href=\"#4-const-深入应用\" class=\"headerlink\" title=\"4. const 深入应用\"></a>4. const 深入应用</h2><p><strong>const 作用：</strong></p>\n<ol>\n<li>修饰变量，说明该变量不可以被改变；</li>\n<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>\n<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>\n<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>\n</ol>\n<p><strong>const 的指针与引用：</strong></p>\n<ul>\n<li>指针<ul>\n<li>指向常量的指针（pointer to const）</li>\n<li>自身是常量的指针（常量指针，const pointer）</li>\n</ul>\n</li>\n<li>引用<ul>\n<li>指向常量的引用（reference to const）</li>\n<li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a;                <span class=\"hljs-comment\">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数</span><br>    <span class=\"hljs-built_in\">A</span>() : <span class=\"hljs-built_in\">a</span>(<span class=\"hljs-number\">0</span>) &#123; &#125;;<br>    <span class=\"hljs-built_in\">A</span>(<span class=\"hljs-type\">int</span> x) : <span class=\"hljs-built_in\">a</span>(x) &#123; &#125;;        <span class=\"hljs-comment\">// 初始化列表</span><br><br>    <span class=\"hljs-comment\">// const可用于对重载函数的区分</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getValue</span><span class=\"hljs-params\">()</span></span>;             <span class=\"hljs-comment\">// 普通成员函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getValue</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;       <span class=\"hljs-comment\">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 对象</span><br>    A b;                        <span class=\"hljs-comment\">// 普通对象，可以调用全部成员函数</span><br>    <span class=\"hljs-type\">const</span> A a;                  <span class=\"hljs-comment\">// 常对象，只能调用常成员函数</span><br>    <span class=\"hljs-type\">const</span> A *p = &amp;a;            <span class=\"hljs-comment\">// 指针变量，指向常对象</span><br>    <span class=\"hljs-type\">const</span> A &amp;q = a;             <span class=\"hljs-comment\">// 指向常对象的引用</span><br><br>    <span class=\"hljs-comment\">// 指针</span><br>    <span class=\"hljs-type\">char</span> greeting[] = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    <span class=\"hljs-type\">char</span>* p1 = greeting;                <span class=\"hljs-comment\">// 指针变量，指向字符数组变量</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p2 = greeting;          <span class=\"hljs-comment\">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class=\"hljs-type\">char</span>* <span class=\"hljs-type\">const</span> p3 = greeting;          <span class=\"hljs-comment\">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-type\">const</span> p4 = greeting;    <span class=\"hljs-comment\">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class=\"hljs-comment\">// 函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> Var)</span></span>;           <span class=\"hljs-comment\">// 传递过来的参数在函数内不可变</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* Var)</span></span>;         <span class=\"hljs-comment\">// 参数指针所指内容为常量</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* <span class=\"hljs-type\">const</span> Var)</span></span>;         <span class=\"hljs-comment\">// 参数指针为常量</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function4</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>&amp; Var)</span></span>;          <span class=\"hljs-comment\">// 引用参数在函数内为常量</span><br><br><span class=\"hljs-comment\">// 函数返回值</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">function5</span><span class=\"hljs-params\">()</span></span>;      <span class=\"hljs-comment\">// 返回一个常数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* <span class=\"hljs-title\">function6</span><span class=\"hljs-params\">()</span></span>;     <span class=\"hljs-comment\">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> <span class=\"hljs-title\">function7</span><span class=\"hljs-params\">()</span></span>;     <span class=\"hljs-comment\">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>宏定义 <code>#define</code> 和 const 常量:</strong></p>\n<table>\n<thead>\n<tr>\n<th>宏定义 #define</th>\n<th>const 常量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>宏定义，相当于字符替换</td>\n<td>常量声明</td>\n</tr>\n<tr>\n<td>预处理器处理</td>\n<td>编译器处理</td>\n</tr>\n<tr>\n<td>无类型安全检查</td>\n<td>有类型安全检查</td>\n</tr>\n<tr>\n<td>不分配内存</td>\n<td>要分配内存</td>\n</tr>\n<tr>\n<td>存储在代码段</td>\n<td>存储在数据段</td>\n</tr>\n<tr>\n<td>可通过 <code>#undef</code> 取消</td>\n<td>不可取消</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-C-和-C-的-const-区别\"><a href=\"#1-C-和-C-的-const-区别\" class=\"headerlink\" title=\"1. C++ 和 C 的 const 区别\"></a>1. C++ 和 C 的 const 区别</h3><ul>\n<li><strong>c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png\" alt=\"image.png\"></p>\n<p>最终输出为：30、30、30</p>\n<ul>\n<li><strong>C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png\" alt=\"image.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// const int b;</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-comment\">// a 常量，可以定义数组长度</span><br>\t<span class=\"hljs-type\">int</span> array[a] = &#123;&#125;;<br><br>\t<span class=\"hljs-type\">int</span>* p = (<span class=\"hljs-type\">int</span>*)&amp;a;<br>\t*p = <span class=\"hljs-number\">30</span>;<br><br>\tcout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *(&amp;a) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png\" alt=\"image.png\"></p>\n<p>原因：<strong>const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。</strong></p>\n<h4 id=\"1-1-Debug-调试\"><a href=\"#1-1-Debug-调试\" class=\"headerlink\" title=\"1.1 Debug 调试\"></a>1.1 Debug 调试</h4><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png\" alt=\"image.png\"><br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png\" alt=\"image.png\"></p>\n<p>执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。</p>\n<p><strong>如果不是立即数，则是常变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = b;<br><br>\t<span class=\"hljs-comment\">// 报错，a是常变量</span><br>\t<span class=\"hljs-comment\">//int array[a] = &#123;&#125;;</span><br><br>\t<span class=\"hljs-type\">int</span>* p = (<span class=\"hljs-type\">int</span>*)&amp;a;<br>\t*p = <span class=\"hljs-number\">30</span>;<br><br>\tcout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *(&amp;a); <span class=\"hljs-comment\">// 30 30 30</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-const-与指针\"><a href=\"#2-const-与指针\" class=\"headerlink\" title=\"2. const 与指针\"></a>2. const 与指针</h3><p>const 修饰的量常出现的错误：</p>\n<p><strong>（1）常量不能再作为左值</strong><br><strong>（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png\" alt=\"image.png\"></p>\n<h4 id=\"2-1-const-和-一级指针\"><a href=\"#2-1-const-和-一级指针\" class=\"headerlink\" title=\"2.1 const 和 一级指针\"></a>2.1 const 和 一级指针</h4><p><strong>const 如果右边没有指针*，则const 是不参与类型的</strong></p>\n<p><strong>C++的语言规范：就近原则 const 修饰的是离它最近的类型</strong></p>\n<ol>\n<li><code>const int* p</code>；离 const 最近的类型是 int，所以 const 修饰的是 <code>*p</code> ，所以 <code>*p</code> 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。</li>\n<li><code>int const* p</code>；<code>*</code> 不是类型，离 const 最近的类型为 int，<code>*p</code> 无法修改，同（1）</li>\n<li><code>int* const p</code>；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。</li>\n<li><code>const int* const p</code>；不能修改 p 指向的地址和值。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span> ;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> * p = &amp;a;<span class=\"hljs-comment\">//p指向的地址的内容不能修改</span><br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重点：</p>\n<p><strong>const 如果右边没有指针 <code>*</code>，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。</strong></p>\n<p><strong>const 类型转化公式：</strong></p>\n<ul>\n<li><code>const int*</code>  &lt;&#x3D; <code>int*</code> 可以转换</li>\n<li><code>int*</code> &lt;&#x3D; <code>const int*</code> 错误</li>\n</ul>\n</blockquote>\n<p>示例1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>* p = <span class=\"hljs-literal\">nullptr</span>;<br>\t<span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p1 = <span class=\"hljs-literal\">nullptr</span>;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(p).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(p1).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png\"></p>\n<p>示例2：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a=<span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> *p1= &amp;a;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p2 = &amp;a;<span class=\"hljs-comment\">// const int * &lt;= int *</span><br><span class=\"hljs-type\">int</span> *<span class=\"hljs-type\">const</span> p3 = &amp;a;<span class=\"hljs-comment\">// int * &lt;= int *</span><br><span class=\"hljs-type\">int</span> *p4 = p3;<span class=\"hljs-comment\">//p3是int * 类型，因此没有问题</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-const-和-二级指针\"><a href=\"#2-2-const-和-二级指针\" class=\"headerlink\" title=\"2.2 const 和 二级指针\"></a>2.2 const 和 二级指针</h4><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png\" alt=\"image.png\"></p>\n<ul>\n<li><code>const int** q</code>；离 const 最近的类型为 int，修饰的是 <code>**q</code>。</li>\n<li><code>int* const* q</code>；离 const 最近的类型为 <code>int*</code>，修饰的是 <code>*q</code>。</li>\n<li><code>int** const q</code>；离 const 最近的类型为 <code>int**</code>，修饰的是 <code>q</code>，同时 const 右侧没有 <code>*</code> ，q 是 <code>int**</code> 类型。</li>\n</ul>\n<p><strong>转化公式：</strong></p>\n<ul>\n<li><code>int**</code> &lt;&#x3D; <code>const int**</code> 错误</li>\n<li><code>const int **</code> &lt;&#x3D; <code>int **</code> 错误</li>\n</ul>\n<p>const 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；</p>\n<ul>\n<li><code>int**</code> &lt;&#x3D; <code>int* const*</code> 是 const 和一级指针的结合，const 右边修饰的<code>*</code>  （等同于 <code>int *</code>  &lt;&#x3D; <code>const int *</code>  ）错误的</li>\n<li><code>int* const*</code> &lt;&#x3D;<code>int**</code> （等同于<code>const int *</code> &lt;&#x3D; <code>int</code> ）可以的</li>\n</ul>\n<p><strong>要看 const 右边的 * 决定 const 修饰的是类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>  <span class=\"hljs-type\">int</span> * p = &amp;a;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> ** q = &amp;p;<span class=\"hljs-comment\">//error  </span><br>  <br>  <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">  const int * *q = &amp;p; 相当于（*）q 即 p的地址，赋值了一个const int * </span><br><span class=\"hljs-comment\">  而p 是int *类型,把常量的地址泄露给普通的指针（p）</span><br><span class=\"hljs-comment\">  修改 const int * p = &amp;a;</span><br><span class=\"hljs-comment\">  */</span><br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-引用\"><a href=\"#3-引用\" class=\"headerlink\" title=\"3. 引用\"></a>3. 引用</h3><ol>\n<li>引用是必须初始化的，指针可以不初始化。</li>\n<li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。</li>\n<li>定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。</li>\n</ol>\n<p>引用的错误用法  <code>int &amp;a = 10;</code> 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>  <span class=\"hljs-type\">int</span> * p = &amp;a;<br>  <span class=\"hljs-type\">int</span> &amp;b = a;<br> <br>  std::cout  &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br>  *p = <span class=\"hljs-number\">20</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br> <br>  b = <span class=\"hljs-number\">30</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; (*p);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png\" alt=\"image.png\"></p>\n<p> <strong>反汇编：指针和引用没有区别</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png\" alt=\"image.png\"></p>\n<p><code>lea eax,[a]</code>：将 a 的地址拷贝到寄存器 eax 中</p>\n<p><code>mov dword ptr [p],eax</code>：将 eax 中的值拷贝到 p 中。</p>\n<p><strong>反汇编中指针和引用拷贝也是没有区别。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png\" alt=\"指针拷贝 - 1\"><br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png\" alt=\"指针拷贝 - 2\"></p>\n<p>对指针和引用赋值，都是一样的：获取地址，然后赋值。</p>\n<h4 id=\"3-1-引用别名\"><a href=\"#3-1-引用别名\" class=\"headerlink\" title=\"3.1 引用别名\"></a>3.1 引用别名</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> array[<span class=\"hljs-number\">5</span>] = &#123;&#125;;<br>  <span class=\"hljs-type\">int</span> * p = array;<br>  <span class=\"hljs-built_in\">int</span>(&amp;q)[<span class=\"hljs-number\">5</span>] = array;<span class=\"hljs-comment\">//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) </span><br> <br>  std::cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(array) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(p) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(q) &lt;&lt; std::endl;<span class=\"hljs-comment\">//20 5 20</span><br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png\" alt=\"image.png\"></p>\n<p>关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 </p>\n<p>站在宏观角度，引用也就是别名，所以不开辟看空间。</p>\n<p>站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。</p>\n<h3 id=\"4-左值引用\"><a href=\"#4-左值引用\" class=\"headerlink\" title=\"4. 左值引用\"></a>4. 左值引用</h3><p>左值：有内存地址，有名字，值可以修改；</p>\n<p>如 <code>int a = 10;</code> <code>int &amp;b =a;</code></p>\n<p><code>int &amp;c =10;</code> &#x2F;&#x2F;错误 20 是右值，20 &#x3D; 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；</p>\n<p>上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;var = <span class=\"hljs-number\">10</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">10</span>; <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;var = temp;<br></code></pre></td></tr></table></figure>\n\n<p>根据上述分析，得出如下结论：</p>\n<p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。</p>\n<p>那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p>\n<h3 id=\"5-右值引用\"><a href=\"#5-右值引用\" class=\"headerlink\" title=\"5. 右值引用\"></a>5. 右值引用</h3><p>C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p>\n<ul>\n<li>可以取地址的，有名字的，非临时的就是左值；</li>\n<li>不能取地址的，没有名字的，临时的就是右值；</li>\n</ul>\n<p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。</p>\n<p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。</p>\n<ol>\n<li><strong><code>int &amp;&amp;c = 10;</code>专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c &#x3D; 1;</strong></li>\n</ol>\n<p>反汇编：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> &amp;&amp; a = <span class=\"hljs-number\">1</span>;<br>a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> &amp;e = a;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-深入理解-C-的-new-和-delete\"><a href=\"#5-深入理解-C-的-new-和-delete\" class=\"headerlink\" title=\"5. 深入理解 C++ 的 new 和 delete\"></a>5. 深入理解 C++ 的 new 和 delete</h2><p><strong>New 的不同使用方式：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;new&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//1 抛异常new</span><br>    <span class=\"hljs-type\">int</span>* p1;<br>    <span class=\"hljs-keyword\">try</span><br>    &#123;<br>        p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//分配内存并初始化</span><br>    &#125;<br>    <span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">const</span> std::bad_alloc&amp; e)<span class=\"hljs-comment\">//判断是否抛异常</span><br>    &#123;<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">//2 不抛异常new</span><br>    <span class=\"hljs-type\">int</span>* p2 = <span class=\"hljs-built_in\">new</span> (std::nothrow)<span class=\"hljs-built_in\">int</span>();<span class=\"hljs-comment\">//不抛异常</span><br>    <span class=\"hljs-comment\">//3 开辟常量内存</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* p3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">40</span>);<span class=\"hljs-comment\">//开辟一个常量</span><br><br>    <span class=\"hljs-comment\">//4 定位new</span><br>    <span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span>* p4 = <span class=\"hljs-built_in\">new</span>(&amp;data) <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">50</span>);<span class=\"hljs-comment\">//在指定地址内存初始化，本身并不开辟内存，只负责初始化</span><br>    <span class=\"hljs-keyword\">delete</span> p1;<br>    <span class=\"hljs-keyword\">delete</span> p2;<br>    <span class=\"hljs-keyword\">delete</span> p3;<br>    <span class=\"hljs-keyword\">delete</span> p4;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-malloc-与-new-的区别\"><a href=\"#1-malloc-与-new-的区别\" class=\"headerlink\" title=\"1. malloc 与 new 的区别\"></a>1. malloc 与 new 的区别</h4><ol>\n<li>malloc 按字节开辟内存的；new 开辟内存时需要指定类型；</li>\n<li>malloc 开辟内存返回的都是 <code>void *</code> ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。</li>\n<li>malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。</li>\n<li>malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。</li>\n<li>malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要<code>[]</code>，而数组需要 <code>[]</code>并给上元素个数。</li>\n</ol>\n<h4 id=\"2-free-和-delete-的区别：\"><a href=\"#2-free-和-delete-的区别：\" class=\"headerlink\" title=\"2. free 和 delete 的区别：\"></a>2. free 和 delete 的区别：</h4><ol>\n<li>free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  </li>\n<li>delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  </li>\n<li>delete 执行其实有两步，先调用析构，再释放；free 只有一步。</li>\n</ol>\n<h4 id=\"3-解析\"><a href=\"#3-解析\" class=\"headerlink\" title=\"3. 解析\"></a>3. 解析</h4><p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    p = <span class=\"hljs-literal\">nullptr</span>;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>反汇编：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png\" alt=\"image.png\"></p>\n<p><strong>new 与 delete 其本质也是函数的调用：运算符重载 new  delete</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">new</span> -&gt; <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span><br><span class=\"hljs-keyword\">delete</span> -&gt; <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-实现\"><a href=\"#4-实现\" class=\"headerlink\" title=\"4. 实现\"></a>4. 实现</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// new：</span><br><span class=\"hljs-comment\">// 先调用 operator 开辟内存空间</span><br><span class=\"hljs-comment\">// 然后调用对象的构造函数</span><br><span class=\"hljs-comment\">// operator new 实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 开辟</span><br>    <span class=\"hljs-type\">void</span>* p = <span class=\"hljs-built_in\">malloc</span>(size);<br>    <span class=\"hljs-comment\">// 判断</span><br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator new addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">// operator new[] 实现</span><br><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span>[](<span class=\"hljs-type\">size_t</span> size)<br>&#123;<br>    <span class=\"hljs-comment\">// 开辟</span><br>    <span class=\"hljs-type\">void</span>* p = <span class=\"hljs-built_in\">malloc</span>(size);<br>    <span class=\"hljs-comment\">// 判断</span><br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator new[] addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">// delete：</span><br><span class=\"hljs-comment\">// 调用 p 指向对象的析构函数</span><br><span class=\"hljs-comment\">// 再调用 operator delete 释放空间</span><br><span class=\"hljs-comment\">// operator delete 实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ptr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator delete addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">free</span>(ptr);<br>&#125;<br><br><span class=\"hljs-comment\">// operator delete[] 实现</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span>[](<span class=\"hljs-type\">void</span>* ptr)<br>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator delete[] addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">free</span>(ptr);<br>&#125;<br><br><span class=\"hljs-comment\">// 使用</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">5</span>);<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    p = <span class=\"hljs-literal\">nullptr</span>;<br><br>    p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">5</span>];<br>    <span class=\"hljs-keyword\">delete</span>[] p;<br>    p = <span class=\"hljs-literal\">nullptr</span>;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png\" alt=\"image.png\"></p>\n<h4 id=\"5-new-和delete-能够混用吗？\"><a href=\"#5-new-和delete-能够混用吗？\" class=\"headerlink\" title=\"5. new 和delete 能够混用吗？\"></a>5. new 和delete 能够混用吗？</h4><p><strong>C++为什么区分单个元素和数组的内存分配和释放呢？</strong></p>\n<p><strong>情况1：int类型下将其混用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;<br><span class=\"hljs-keyword\">delete</span>[]p;<br> <br><span class=\"hljs-type\">int</span> *q = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">10</span>];<br><span class=\"hljs-keyword\">delete</span> q;<br></code></pre></td></tr></table></figure>\n\n<p>能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。</p>\n<p><strong>情况2：类类型下将其混用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>):<span class=\"hljs-built_in\">ptr</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(data))<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span> ptr;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>单个元素与 <code>delete[]</code> 混用：</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Test *p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Test</span>();<br><span class=\"hljs-keyword\">delete</span>[]p1;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png\" alt=\"报错程序\"></p>\n<p>程序崩溃。</p>\n<ul>\n<li><strong>数组与 delete 进行混用</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Test *p2 = <span class=\"hljs-keyword\">new</span> Test[<span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">delete</span> p2;<br></code></pre></td></tr></table></figure>\n\n<p>程序崩溃。</p>\n<p><strong>分析：</strong></p>\n<p>正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 <code>[]</code> 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 <code>0x100</code>；但是 new 完之后 p2 返回的地址是 <code>0x104</code> 地址，当我们执行 <code>delete[]</code> 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 <code>0x100</code> 开始的 4 字节也释放。</p>\n<p>而 p2 出错是给用户返回的存对象开始的起始地址，<code>delete p2</code> 认为 p2 只是指向了一个对象，只将 <code>Test[0]</code> 对象析构，直接从 <code>0x104 free(p2)</code>，但底层实际是从 <code>0x100</code> 开辟的，因此崩溃。</p>\n<p>而 p1 出错：p1 只是单个元素，从 <code>0x104</code> 开始开辟内存，但是 <code>delete[] p1</code>，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 <code>0x100</code> 释放)因此崩溃。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本节分为 5 大类：</p>\n<ol>\n<li>形参带默认值的函数</li>\n<li>内联函数inline</li>\n<li>详解函数重载</li>\n<li>const 深入应用</li>\n<li>深入理解 C++ 的 new 和 delete</li>\n</ol>\n<h2 id=\"1-形参带默认值的函数\"><a href=\"#1-形参带默认值的函数\" class=\"headerlink\" title=\"1. 形参带默认值的函数\"></a>1. 形参带默认值的函数</h2><p>在 C++ 中，声明一个函数时，可以为函数的参数指定默认值。当调用有默认参数值的函数时，可以不写出参数，这时就相当于以默认值作为参数调用该函数。</p>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li>在有函数声明（原型）时，默认参数可以放在函数声明或定义中，但是只能放在二者之一。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> f = <span class=\"hljs-number\">1.0</span>)</span></span>; <span class=\"hljs-comment\">//函数声明</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> f)</span>  <span class=\"hljs-comment\">//函数定义</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">// ....  </span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>没有函数（原型）时，默认参数在函数定义时指定。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//没有 函数声明</span><br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> f = <span class=\"hljs-number\">1.0</span>)</span>  <span class=\"hljs-comment\">//函数定义</span></span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在具有多个参数的函数中指定默认值时,默认参数都必须出现在不默认参数的右边,一旦某个参数开始指定默认值,它右边的所有参数都必须指定默认值.</li>\n</ol>\n<p>就是说，<strong>函数声明时，必须按照从右向左的顺序，依次给与默认值。</strong></p>\n<p>原因：</p>\n<p>函数形参的压栈过程是从右向左。详细请看：[[01.理解 C++ 内核]] 的 <strong>从指令角度掌握函数调用堆栈详细过程。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">f</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i1, <span class=\"hljs-type\">int</span> i2 = <span class=\"hljs-number\">2</span>, <span class=\"hljs-type\">int</span> i3 = <span class=\"hljs-number\">3</span>)</span></span>;     <span class=\"hljs-comment\">// 正确</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i1, <span class=\"hljs-type\">int</span> i2 = <span class=\"hljs-number\">2</span>, <span class=\"hljs-type\">int</span> i3)</span></span>;         <span class=\"hljs-comment\">// 错误, i3未指定默认值</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">h</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i1 = <span class=\"hljs-number\">1</span>, <span class=\"hljs-type\">int</span> i2, <span class=\"hljs-type\">int</span> i3 = <span class=\"hljs-number\">3</span>)</span></span>;     <span class=\"hljs-comment\">// 错误, i2未指定默认值</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>普通函数和形参带默认值函数对比：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>, <span class=\"hljs-type\">int</span> b  = <span class=\"hljs-number\">10</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">0</span>;<br>  temp = a + b;<br>  <span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>  <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br> <br>  <span class=\"hljs-type\">int</span> ret = <span class=\"hljs-built_in\">sum</span>(a, b);<br> <br>  ret = <span class=\"hljs-built_in\">sum</span>(a);<span class=\"hljs-comment\">//b 使用默认值</span><br> <br>  ret = <span class=\"hljs-built_in\">sum</span>();<span class=\"hljs-comment\">//都使用默认值</span><br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031520415.png\" alt=\"image.png\"></p>\n<p>对比1，2 发现：</p>\n<p>2 中 b 使用默认值，因此将 b 的值拷贝到寄存器后压栈，而是直接将常量0ah(10) 压栈，减少了此寄存器拷贝；</p>\n<p>同理有3，使用默认值是：调用函数减少了 mov 指令。</p>\n<h2 id=\"2-内联函数-inline\"><a href=\"#2-内联函数-inline\" class=\"headerlink\" title=\"2. 内联函数 inline\"></a>2. 内联函数 inline</h2><p><strong>特征：</strong></p>\n<ul>\n<li>相当于把内联函数里面的内容写在调用内联函数处；</li>\n<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>\n<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>\n<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>\n<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 声明1（加 inline，建议使用）</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> first, <span class=\"hljs-type\">int</span> second,...)</span></span>;<br><br><span class=\"hljs-comment\">// 声明2（不加 inline）</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> first, <span class=\"hljs-type\">int</span> second,...)</span></span>;<br><br><span class=\"hljs-comment\">// 定义</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">functionName</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> first, <span class=\"hljs-type\">int</span> second,...)</span> </span>&#123;<span class=\"hljs-comment\">/****/</span>&#125;;<br><br><span class=\"hljs-comment\">// 类内定义，隐式内联</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">doA</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; &#125;         <span class=\"hljs-comment\">// 隐式内联</span><br>&#125;<br><br><span class=\"hljs-comment\">// 类外定义，需要显式内联</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">doA</span><span class=\"hljs-params\">()</span></span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">A::doA</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; &#125;   <span class=\"hljs-comment\">// 需要显式内联</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>编译器对 inline 函数的处理步骤：</strong></p>\n<ol>\n<li>将 inline 函数体复制到 inline 函数调用点处；</li>\n<li>为所用 inline 函数中的局部变量分配内存空间；</li>\n<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>\n<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>\n</ol>\n<p><strong>内联函数与普通函数的区别？</strong></p>\n<ol>\n<li>内联函数；在编译过程中，就没有函数调用开销。在函数的调用点直接将函数的代码进行展开处理</li>\n</ol>\n<p>[[01.理解 C++ 内核]] 中的 <strong>从指令角度掌握函数调用堆栈详细过程</strong> 知道，在调用函数的过程中：</p>\n<p>（1）将函数实数从右向左压栈<br>（2）call指令：<br>        将下一行要执行的代码地址入栈<br>        跳转到函数入口：首先push ebp,将栈底指针入栈，然后给函数开辟栈帧函数执行结束后，栈帧回退。</p>\n<p>在函数调用中，有大量的函数调用开销。如果封装的函数内容简单，函数调用的开销大于函数指令的执行时间，那么就可以使用内联函数（需要大量调用，且指令简单）。在调用点展开内联函数指令</p>\n<ol start=\"2\">\n<li><p>内联函数不在生成相应的函数符号</p>\n</li>\n<li><p>inline 只是建议编译器把这个函数处理成内联函数，具体会由编译器处理觉得是否展开成内联函数。</p>\n</li>\n</ol>\n<p>注意：</p>\n<p>（1）如果用vs调试Debug，不会将函数展开成内联.release版本可以。</p>\n<p><strong>优缺点：</strong></p>\n<p>优点</p>\n<ol>\n<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>\n<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>\n<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>\n<li>内联函数在运行时可调试，而宏定义不可以。</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>\n<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>\n<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>\n</ol>\n<h2 id=\"3-详解函数重载\"><a href=\"#3-详解函数重载\" class=\"headerlink\" title=\"3. 详解函数重载\"></a>3. 详解函数重载</h2><p><strong>函数重载</strong>：一组函数，其中函数名相同，参数列表的个数或者类型不同，那么这一组函数就称作函数重载。函数重载发生在编译时期。</p>\n<p>（1）函数重载与函数返回值无关，因为在产生符号时没有返回值<br>（2） 函数重载需要在同一个作用域<br>（3）const 或者 volatile 的时候，是如何影响形参的</p>\n<p><strong>C++ 支持函数重载，而 C 则不支持：</strong></p>\n<p>编译器产生的函数符号规则不同：</p>\n<ul>\n<li>C++ 代码：函数符号包含了函数名和参数列表</li>\n<li>C 代码：函数符号只包含了函数名。</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<p>** <strong>函数重载需要在同一个作用域下</strong>。**</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)</span></span>;<br>\t<span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-string\">&quot;adf&quot;</span>, <span class=\"hljs-string\">&quot;wew&quot;</span>);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031530000.png\" alt=\"image.png\"></p>\n<p>由于在局部作用域声明了新的 compare，导致无法重载外部作用域的 compare。</p>\n<p><strong>const int 和 int 的重载：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span> </span>&#123;&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a)</span> </span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// ...</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031534968.png\" alt=\"image.png\"></p>\n<p>原因：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">10</span>;<br><br>\tstd::cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(a).<span class=\"hljs-built_in\">name</span>() &lt;&lt; std::endl;<br>\tstd::cout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(b).<span class=\"hljs-built_in\">name</span>() &lt;&lt; std::endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308031536065.png\" alt=\"image.png\"></p>\n<p>const int 和 int 在编译器看来都是 int 类型 ，无法完成重载。</p>\n<h3 id=\"3-1-C-和-C-语言如何相互调用\"><a href=\"#3-1-C-和-C-语言如何相互调用\" class=\"headerlink\" title=\"3.1 C++ 和 C 语言如何相互调用\"></a>3.1 C++ 和 C 语言如何相互调用</h3><p>由于 C++ 和 C 语言的编译器生成的函数符号不同，在 C++ 使用 c 语言需要使用exten “C”{};</p>\n<h4 id=\"1-C-调用-C\"><a href=\"#1-C-调用-C\" class=\"headerlink\" title=\"1. C++ 调用 C\"></a>1. C++ 调用 C</h4><p>对于c++，由于c++的编译器对c语言兼容，因此在c++中调用c语言编写的函数，只需要在函数声明前面加上关键字<code>extern &quot;C&quot;</code>，表示采用类c语言的方式解析函数符号。例子如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// add.h</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __ADD_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __ADD_H__</span><br><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><br><span class=\"hljs-comment\">// add.c</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-comment\">// main.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;add.h&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;1 + 1 = &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在例子中，<code>main.cpp</code> 为<code>c++</code> 代码，<code>add.c</code> 为 c 语言代码，当 c++ 编译器识别到<code>extern &quot;C&quot;</code> 关键字时，会去寻找 <code>_add_</code> 函数的实现而不是寻找类似<code>_int_add_int_int_</code> 这样带参数信息的函数实现。</p>\n<h4 id=\"2-C-调用-C\"><a href=\"#2-C-调用-C\" class=\"headerlink\" title=\"2. C 调用 C++\"></a>2. C 调用 C++</h4><p>c 语言调用 c++ 代码却并不容易，原因是 c 语言并不兼容 c++。就算 c 语言可以调用 c++，也会因为无法识别 c++ 新定义的符号而编译报错。因此，为了实现 c 语言调用 c++ 函数，必须实现以下两个步骤：</p>\n<ol>\n<li>将 c++ 相关函数封装为静态库或动态库（因为调用库函数时编译器并不知道里面执行的是什么语言）；</li>\n<li>对外提供遵循类 c 语言规约的接口函数。例子如下所示：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// printNum.h</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __PRINTNUM_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __PRINTNUM_H__</span><br><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">// printNum.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;printNum.h&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; &lt;&lt; <span class=\"hljs-string\">&quot;num is &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-comment\">// main.c</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span>;<br><br><span class=\"hljs-built_in\">printNum</span>(<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></table></figure>\n\n<p>通过将 <code>_cout_</code>函数封装为类 c 语言规约的接口函数，使得 <code>main.c</code> 中可以成功调用 c++ 函数 <code>_printNum_</code> 。值得注意的是，<code>main.c</code> 不可以直接引入 <code>printNum.h</code>，因为 c 语言不能识别 <code>extern &quot;C&quot;</code> 关键字。可以利用 c++ 预定义宏实现头文件的改写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __PRINTNUM_H__</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __PRINTNUM_H__</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __cplusplus</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> &#123; <br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printNum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span>;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> __cplusplus</span><br>&#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h4><ol>\n<li>c 语言与 c++ 的相互调用可以通过 <code>extern &quot;C&quot;</code> 关键字实现</li>\n<li>c++ 中调用 c 代码，只须在 c++ 中为 c 代码函数声明之前加上 <code>extern &quot;C&quot;</code></li>\n<li>c 语言调用 c++ 代码，则需要将 c++ 代码编译成静态库或动态库，然后对外提供用 <code>extern &quot;C&quot;</code> 声明的类 c 封装函数</li>\n</ol>\n<h2 id=\"4-const-深入应用\"><a href=\"#4-const-深入应用\" class=\"headerlink\" title=\"4. const 深入应用\"></a>4. const 深入应用</h2><p><strong>const 作用：</strong></p>\n<ol>\n<li>修饰变量，说明该变量不可以被改变；</li>\n<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>\n<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>\n<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>\n</ol>\n<p><strong>const 的指针与引用：</strong></p>\n<ul>\n<li>指针<ul>\n<li>指向常量的指针（pointer to const）</li>\n<li>自身是常量的指针（常量指针，const pointer）</li>\n</ul>\n</li>\n<li>引用<ul>\n<li>指向常量的引用（reference to const）</li>\n<li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a;                <span class=\"hljs-comment\">// 常对象成员，可以使用初始化列表或者类内初始化</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数</span><br>    <span class=\"hljs-built_in\">A</span>() : <span class=\"hljs-built_in\">a</span>(<span class=\"hljs-number\">0</span>) &#123; &#125;;<br>    <span class=\"hljs-built_in\">A</span>(<span class=\"hljs-type\">int</span> x) : <span class=\"hljs-built_in\">a</span>(x) &#123; &#125;;        <span class=\"hljs-comment\">// 初始化列表</span><br><br>    <span class=\"hljs-comment\">// const可用于对重载函数的区分</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getValue</span><span class=\"hljs-params\">()</span></span>;             <span class=\"hljs-comment\">// 普通成员函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getValue</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;       <span class=\"hljs-comment\">// 常成员函数，不得修改类中的任何数据成员的值</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 对象</span><br>    A b;                        <span class=\"hljs-comment\">// 普通对象，可以调用全部成员函数</span><br>    <span class=\"hljs-type\">const</span> A a;                  <span class=\"hljs-comment\">// 常对象，只能调用常成员函数</span><br>    <span class=\"hljs-type\">const</span> A *p = &amp;a;            <span class=\"hljs-comment\">// 指针变量，指向常对象</span><br>    <span class=\"hljs-type\">const</span> A &amp;q = a;             <span class=\"hljs-comment\">// 指向常对象的引用</span><br><br>    <span class=\"hljs-comment\">// 指针</span><br>    <span class=\"hljs-type\">char</span> greeting[] = <span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>    <span class=\"hljs-type\">char</span>* p1 = greeting;                <span class=\"hljs-comment\">// 指针变量，指向字符数组变量</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p2 = greeting;          <span class=\"hljs-comment\">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span><br>    <span class=\"hljs-type\">char</span>* <span class=\"hljs-type\">const</span> p3 = greeting;          <span class=\"hljs-comment\">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-type\">const</span> p4 = greeting;    <span class=\"hljs-comment\">// 自身是常量的指针，指向字符数组常量</span><br>&#125;<br><br><span class=\"hljs-comment\">// 函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> Var)</span></span>;           <span class=\"hljs-comment\">// 传递过来的参数在函数内不可变</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* Var)</span></span>;         <span class=\"hljs-comment\">// 参数指针所指内容为常量</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* <span class=\"hljs-type\">const</span> Var)</span></span>;         <span class=\"hljs-comment\">// 参数指针为常量</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function4</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>&amp; Var)</span></span>;          <span class=\"hljs-comment\">// 引用参数在函数内为常量</span><br><br><span class=\"hljs-comment\">// 函数返回值</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">function5</span><span class=\"hljs-params\">()</span></span>;      <span class=\"hljs-comment\">// 返回一个常数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* <span class=\"hljs-title\">function6</span><span class=\"hljs-params\">()</span></span>;     <span class=\"hljs-comment\">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> <span class=\"hljs-title\">function7</span><span class=\"hljs-params\">()</span></span>;     <span class=\"hljs-comment\">// 返回一个指向变量的常指针，使用：int* const p = function7();</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>宏定义 <code>#define</code> 和 const 常量:</strong></p>\n<table>\n<thead>\n<tr>\n<th>宏定义 #define</th>\n<th>const 常量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>宏定义，相当于字符替换</td>\n<td>常量声明</td>\n</tr>\n<tr>\n<td>预处理器处理</td>\n<td>编译器处理</td>\n</tr>\n<tr>\n<td>无类型安全检查</td>\n<td>有类型安全检查</td>\n</tr>\n<tr>\n<td>不分配内存</td>\n<td>要分配内存</td>\n</tr>\n<tr>\n<td>存储在代码段</td>\n<td>存储在数据段</td>\n</tr>\n<tr>\n<td>可通过 <code>#undef</code> 取消</td>\n<td>不可取消</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-C-和-C-的-const-区别\"><a href=\"#1-C-和-C-的-const-区别\" class=\"headerlink\" title=\"1. C++ 和 C 的 const 区别\"></a>1. C++ 和 C 的 const 区别</h3><ul>\n<li><strong>c语言中，const修饰的值，可以不用初始化，不叫常量，叫做常变量；</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040846520.png\" alt=\"image.png\"></p>\n<p>最终输出为：30、30、30</p>\n<ul>\n<li><strong>C++中： const 定义的类型必须初始化，否则报错，c 语言中可以不初始化</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040849898.png\" alt=\"image.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// const int b;</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-comment\">// a 常量，可以定义数组长度</span><br>\t<span class=\"hljs-type\">int</span> array[a] = &#123;&#125;;<br><br>\t<span class=\"hljs-type\">int</span>* p = (<span class=\"hljs-type\">int</span>*)&amp;a;<br>\t*p = <span class=\"hljs-number\">30</span>;<br><br>\tcout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *(&amp;a) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040851384.png\" alt=\"image.png\"></p>\n<p>原因：<strong>const 的编译方式不同，C 语言中，const 就是当作一个变量来编译生成指令的。C++ 中，如果 const 赋值是一个立即数，所有出现 const 常量名字的地方，都被常量的初始化所替换。</strong></p>\n<h4 id=\"1-1-Debug-调试\"><a href=\"#1-1-Debug-调试\" class=\"headerlink\" title=\"1.1 Debug 调试\"></a>1.1 Debug 调试</h4><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040857151.png\" alt=\"image.png\"><br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040900294.png\" alt=\"image.png\"></p>\n<p>执行完第9行后 a 的内存中的值变成 1e 也即 30；但是本来出现 a 的地方在编译期已经被替换成 10，因此输出 a 依然是 10。</p>\n<p><strong>如果不是立即数，则是常变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = b;<br><br>\t<span class=\"hljs-comment\">// 报错，a是常变量</span><br>\t<span class=\"hljs-comment\">//int array[a] = &#123;&#125;;</span><br><br>\t<span class=\"hljs-type\">int</span>* p = (<span class=\"hljs-type\">int</span>*)&amp;a;<br>\t*p = <span class=\"hljs-number\">30</span>;<br><br>\tcout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; *(&amp;a); <span class=\"hljs-comment\">// 30 30 30</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-const-与指针\"><a href=\"#2-const-与指针\" class=\"headerlink\" title=\"2. const 与指针\"></a>2. const 与指针</h3><p>const 修饰的量常出现的错误：</p>\n<p><strong>（1）常量不能再作为左值</strong><br><strong>（2）不能把常量的地址泄露给一个普通的指针或者普通的引用变量</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040908264.png\" alt=\"image.png\"></p>\n<h4 id=\"2-1-const-和-一级指针\"><a href=\"#2-1-const-和-一级指针\" class=\"headerlink\" title=\"2.1 const 和 一级指针\"></a>2.1 const 和 一级指针</h4><p><strong>const 如果右边没有指针*，则const 是不参与类型的</strong></p>\n<p><strong>C++的语言规范：就近原则 const 修饰的是离它最近的类型</strong></p>\n<ol>\n<li><code>const int* p</code>；离 const 最近的类型是 int，所以 const 修饰的是 <code>*p</code> ，所以 <code>*p</code> 无法修改值；可以指向任意 int 的内存，但是不能通过指针简介修改内存的值。</li>\n<li><code>int const* p</code>；<code>*</code> 不是类型，离 const 最近的类型为 int，<code>*p</code> 无法修改，同（1）</li>\n<li><code>int* const p</code>；离 const 最近的类型为（int*），const 修饰的是 p，所以不能改变 p 指向的地址，但是可以修改 p 指向的地址的内容。</li>\n<li><code>const int* const p</code>；不能修改 p 指向的地址和值。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span> ;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> * p = &amp;a;<span class=\"hljs-comment\">//p指向的地址的内容不能修改</span><br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重点：</p>\n<p><strong>const 如果右边没有指针 <code>*</code>，则 const 是不参与类型的，仅表示 const 修饰的是一个常量，不能作为左值。</strong></p>\n<p><strong>const 类型转化公式：</strong></p>\n<ul>\n<li><code>const int*</code>  &lt;&#x3D; <code>int*</code> 可以转换</li>\n<li><code>int*</code> &lt;&#x3D; <code>const int*</code> 错误</li>\n</ul>\n</blockquote>\n<p>示例1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>* p = <span class=\"hljs-literal\">nullptr</span>;<br>\t<span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p1 = <span class=\"hljs-literal\">nullptr</span>;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(p).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(p1).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040921787.png\"></p>\n<p>示例2：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a=<span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> *p1= &amp;a;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p2 = &amp;a;<span class=\"hljs-comment\">// const int * &lt;= int *</span><br><span class=\"hljs-type\">int</span> *<span class=\"hljs-type\">const</span> p3 = &amp;a;<span class=\"hljs-comment\">// int * &lt;= int *</span><br><span class=\"hljs-type\">int</span> *p4 = p3;<span class=\"hljs-comment\">//p3是int * 类型，因此没有问题</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-const-和-二级指针\"><a href=\"#2-2-const-和-二级指针\" class=\"headerlink\" title=\"2.2 const 和 二级指针\"></a>2.2 const 和 二级指针</h4><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040928871.png\" alt=\"image.png\"></p>\n<ul>\n<li><code>const int** q</code>；离 const 最近的类型为 int，修饰的是 <code>**q</code>。</li>\n<li><code>int* const* q</code>；离 const 最近的类型为 <code>int*</code>，修饰的是 <code>*q</code>。</li>\n<li><code>int** const q</code>；离 const 最近的类型为 <code>int**</code>，修饰的是 <code>q</code>，同时 const 右侧没有 <code>*</code> ，q 是 <code>int**</code> 类型。</li>\n</ul>\n<p><strong>转化公式：</strong></p>\n<ul>\n<li><code>int**</code> &lt;&#x3D; <code>const int**</code> 错误</li>\n<li><code>const int **</code> &lt;&#x3D; <code>int **</code> 错误</li>\n</ul>\n<p>const 与二级指针结合的时候，两边必须同时有 const 或没有 const 才能转换；</p>\n<ul>\n<li><code>int**</code> &lt;&#x3D; <code>int* const*</code> 是 const 和一级指针的结合，const 右边修饰的<code>*</code>  （等同于 <code>int *</code>  &lt;&#x3D; <code>const int *</code>  ）错误的</li>\n<li><code>int* const*</code> &lt;&#x3D;<code>int**</code> （等同于<code>const int *</code> &lt;&#x3D; <code>int</code> ）可以的</li>\n</ul>\n<p><strong>要看 const 右边的 * 决定 const 修饰的是类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>  <span class=\"hljs-type\">int</span> * p = &amp;a;<br>  <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> ** q = &amp;p;<span class=\"hljs-comment\">//error  </span><br>  <br>  <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">  const int * *q = &amp;p; 相当于（*）q 即 p的地址，赋值了一个const int * </span><br><span class=\"hljs-comment\">  而p 是int *类型,把常量的地址泄露给普通的指针（p）</span><br><span class=\"hljs-comment\">  修改 const int * p = &amp;a;</span><br><span class=\"hljs-comment\">  */</span><br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-引用\"><a href=\"#3-引用\" class=\"headerlink\" title=\"3. 引用\"></a>3. 引用</h3><ol>\n<li>引用是必须初始化的，指针可以不初始化。</li>\n<li>引用只有一级引用，没有多级引用；指针可以有一级指针，也可以用多级指针。</li>\n<li>定义一个引用变量和定义一个指针变量，其汇编指令是一样的；通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的。</li>\n</ol>\n<p>引用的错误用法  <code>int &amp;a = 10;</code> 由下面的反汇编可以知道，引用的汇编代码第一步是将引用对象的地址拷贝到寄存器中，10是常量；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo.h&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>  <span class=\"hljs-type\">int</span> * p = &amp;a;<br>  <span class=\"hljs-type\">int</span> &amp;b = a;<br> <br>  std::cout  &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br>  *p = <span class=\"hljs-number\">20</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; (*p) &lt;&lt; std::endl;<br> <br> <br>  b = <span class=\"hljs-number\">30</span>;<br>  std::cout &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; (*p);<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040938550.png\" alt=\"image.png\"></p>\n<p> <strong>反汇编：指针和引用没有区别</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040939184.png\" alt=\"image.png\"></p>\n<p><code>lea eax,[a]</code>：将 a 的地址拷贝到寄存器 eax 中</p>\n<p><code>mov dword ptr [p],eax</code>：将 eax 中的值拷贝到 p 中。</p>\n<p><strong>反汇编中指针和引用拷贝也是没有区别。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941767.png\" alt=\"指针拷贝 - 1\"><br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308040941833.png\" alt=\"指针拷贝 - 2\"></p>\n<p>对指针和引用赋值，都是一样的：获取地址，然后赋值。</p>\n<h4 id=\"3-1-引用别名\"><a href=\"#3-1-引用别名\" class=\"headerlink\" title=\"3.1 引用别名\"></a>3.1 引用别名</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-type\">int</span> array[<span class=\"hljs-number\">5</span>] = &#123;&#125;;<br>  <span class=\"hljs-type\">int</span> * p = array;<br>  <span class=\"hljs-built_in\">int</span>(&amp;q)[<span class=\"hljs-number\">5</span>] = array;<span class=\"hljs-comment\">//定义一个引用指向数组:引用即别名  sizeof(q) =  sizeof(array) </span><br> <br>  std::cout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(array) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(p) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(q) &lt;&lt; std::endl;<span class=\"hljs-comment\">//20 5 20</span><br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041039869.png\" alt=\"image.png\"></p>\n<p>关于定义一个引用类型，到底需不需要开辟内存空间，我认为是需要的，上面的汇编代码中，引用和指针的汇编是一模一样的；C++ 中只有 const 类型的数据，要求必须初始化。而引用也必须要初始化，所以引用是指针，还应该是 const 修饰的常指针。 一经声明不可改变。 </p>\n<p>站在宏观角度，引用也就是别名，所以不开辟看空间。</p>\n<p>站在微观的角度，引用至少要保存一个指针，所以一定要开辟空间。站在底层实现的角度，站在 C++ 对于 C 实现包装的角度，引用就是指针。那么既然是指针至少要占用 4 个字节空间。</p>\n<h3 id=\"4-左值引用\"><a href=\"#4-左值引用\" class=\"headerlink\" title=\"4. 左值引用\"></a>4. 左值引用</h3><p>左值：有内存地址，有名字，值可以修改；</p>\n<p>如 <code>int a = 10;</code> <code>int &amp;b =a;</code></p>\n<p><code>int &amp;c =10;</code> &#x2F;&#x2F;错误 20 是右值，20 &#x3D; 40 是错误的，其值不能修改，没内存，没名字，是一个立即数；</p>\n<p>上述代码是无法编译通过的，因为 10 无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;var = <span class=\"hljs-number\">10</span>;<br></code></pre></td></tr></table></figure>\n\n<p>使用常引用来引用常量数字 10，因为此刻内存上产生了临时变量保存了 10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> temp = <span class=\"hljs-number\">10</span>; <br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> &amp;var = temp;<br></code></pre></td></tr></table></figure>\n\n<p>根据上述分析，得出如下结论：</p>\n<p>左值引用要求右边的值必须能够取地址，如果无法取地址，可以用常引用；<br>但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被 const 修饰成常量引用了。</p>\n<p>那么 C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。</p>\n<h3 id=\"5-右值引用\"><a href=\"#5-右值引用\" class=\"headerlink\" title=\"5. 右值引用\"></a>5. 右值引用</h3><p>C++ 对于左值和右值没有标准定义，但是有一个被广泛认同的说法：</p>\n<ul>\n<li>可以取地址的，有名字的，非临时的就是左值；</li>\n<li>不能取地址的，没有名字的，临时的就是右值；</li>\n</ul>\n<p>可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const 对象等都是左值。</p>\n<p>从本质上理解，创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及 const 对象)。</p>\n<ol>\n<li><strong><code>int &amp;&amp;c = 10;</code>专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量   c &#x3D; 1;</strong></li>\n</ol>\n<p>反汇编：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041045338.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>一个右值引用变量，本身是一个左值,只能用左值引用来引用它；不能用一个右值引用变量来引用一个左值</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> &amp;&amp; a = <span class=\"hljs-number\">1</span>;<br>a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> &amp;e = a;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-深入理解-C-的-new-和-delete\"><a href=\"#5-深入理解-C-的-new-和-delete\" class=\"headerlink\" title=\"5. 深入理解 C++ 的 new 和 delete\"></a>5. 深入理解 C++ 的 new 和 delete</h2><p><strong>New 的不同使用方式：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;new&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//1 抛异常new</span><br>    <span class=\"hljs-type\">int</span>* p1;<br>    <span class=\"hljs-keyword\">try</span><br>    &#123;<br>        p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//分配内存并初始化</span><br>    &#125;<br>    <span class=\"hljs-built_in\">catch</span> (<span class=\"hljs-type\">const</span> std::bad_alloc&amp; e)<span class=\"hljs-comment\">//判断是否抛异常</span><br>    &#123;<br><br>    &#125;<br><br>    <span class=\"hljs-comment\">//2 不抛异常new</span><br>    <span class=\"hljs-type\">int</span>* p2 = <span class=\"hljs-built_in\">new</span> (std::nothrow)<span class=\"hljs-built_in\">int</span>();<span class=\"hljs-comment\">//不抛异常</span><br>    <span class=\"hljs-comment\">//3 开辟常量内存</span><br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* p3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">40</span>);<span class=\"hljs-comment\">//开辟一个常量</span><br><br>    <span class=\"hljs-comment\">//4 定位new</span><br>    <span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span>* p4 = <span class=\"hljs-built_in\">new</span>(&amp;data) <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">50</span>);<span class=\"hljs-comment\">//在指定地址内存初始化，本身并不开辟内存，只负责初始化</span><br>    <span class=\"hljs-keyword\">delete</span> p1;<br>    <span class=\"hljs-keyword\">delete</span> p2;<br>    <span class=\"hljs-keyword\">delete</span> p3;<br>    <span class=\"hljs-keyword\">delete</span> p4;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"1-malloc-与-new-的区别\"><a href=\"#1-malloc-与-new-的区别\" class=\"headerlink\" title=\"1. malloc 与 new 的区别\"></a>1. malloc 与 new 的区别</h4><ol>\n<li>malloc 按字节开辟内存的；new 开辟内存时需要指定类型；</li>\n<li>malloc 开辟内存返回的都是 <code>void *</code> ，new 相当于运算符重载函数，返回值自动转为指定的类型的指针。</li>\n<li>malloc 只负责开辟内存空间，new 不仅仅也有 malloc 功能，还可以进行数据的初始化。</li>\n<li>malloc 开辟内存失败返回 nullptr 指针；new 抛出的是 bad_alloc 类型的异常。</li>\n<li>malloc 开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要<code>[]</code>，而数组需要 <code>[]</code>并给上元素个数。</li>\n</ol>\n<h4 id=\"2-free-和-delete-的区别：\"><a href=\"#2-free-和-delete-的区别：\" class=\"headerlink\" title=\"2. free 和 delete 的区别：\"></a>2. free 和 delete 的区别：</h4><ol>\n<li>free 不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。  </li>\n<li>delete 释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。  </li>\n<li>delete 执行其实有两步，先调用析构，再释放；free 只有一步。</li>\n</ol>\n<h4 id=\"3-解析\"><a href=\"#3-解析\" class=\"headerlink\" title=\"3. 解析\"></a>3. 解析</h4><p>代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    p = <span class=\"hljs-literal\">nullptr</span>;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>反汇编：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041343548.png\" alt=\"image.png\"></p>\n<p><strong>new 与 delete 其本质也是函数的调用：运算符重载 new  delete</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">new</span> -&gt; <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span><br><span class=\"hljs-keyword\">delete</span> -&gt; <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-实现\"><a href=\"#4-实现\" class=\"headerlink\" title=\"4. 实现\"></a>4. 实现</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// new：</span><br><span class=\"hljs-comment\">// 先调用 operator 开辟内存空间</span><br><span class=\"hljs-comment\">// 然后调用对象的构造函数</span><br><span class=\"hljs-comment\">// operator new 实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// 开辟</span><br>    <span class=\"hljs-type\">void</span>* p = <span class=\"hljs-built_in\">malloc</span>(size);<br>    <span class=\"hljs-comment\">// 判断</span><br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator new addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">// operator new[] 实现</span><br><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span>[](<span class=\"hljs-type\">size_t</span> size)<br>&#123;<br>    <span class=\"hljs-comment\">// 开辟</span><br>    <span class=\"hljs-type\">void</span>* p = <span class=\"hljs-built_in\">malloc</span>(size);<br>    <span class=\"hljs-comment\">// 判断</span><br>    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">bad_alloc</span>();<br>    &#125;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator new[] addr:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br><br><span class=\"hljs-comment\">// delete：</span><br><span class=\"hljs-comment\">// 调用 p 指向对象的析构函数</span><br><span class=\"hljs-comment\">// 再调用 operator delete 释放空间</span><br><span class=\"hljs-comment\">// operator delete 实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ptr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator delete addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">free</span>(ptr);<br>&#125;<br><br><span class=\"hljs-comment\">// operator delete[] 实现</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span>[](<span class=\"hljs-type\">void</span>* ptr)<br>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;operator delete[] addr: &quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">free</span>(ptr);<br>&#125;<br><br><span class=\"hljs-comment\">// 使用</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">5</span>);<br>    <span class=\"hljs-keyword\">delete</span> p;<br>    p = <span class=\"hljs-literal\">nullptr</span>;<br><br>    p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">5</span>];<br>    <span class=\"hljs-keyword\">delete</span>[] p;<br>    p = <span class=\"hljs-literal\">nullptr</span>;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041355889.png\" alt=\"image.png\"></p>\n<h4 id=\"5-new-和delete-能够混用吗？\"><a href=\"#5-new-和delete-能够混用吗？\" class=\"headerlink\" title=\"5. new 和delete 能够混用吗？\"></a>5. new 和delete 能够混用吗？</h4><p><strong>C++为什么区分单个元素和数组的内存分配和释放呢？</strong></p>\n<p><strong>情况1：int类型下将其混用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;<br><span class=\"hljs-keyword\">delete</span>[]p;<br> <br><span class=\"hljs-type\">int</span> *q = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">10</span>];<br><span class=\"hljs-keyword\">delete</span> q;<br></code></pre></td></tr></table></figure>\n\n<p>能够混用。对于整型来说，没有构造函数与析构函数，针对于 int 类型，new 与 delete 功能只剩下 malloc 与 free 功能，可以将其混用。</p>\n<p><strong>情况2：类类型下将其混用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>):<span class=\"hljs-built_in\">ptr</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(data))<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span> ptr;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> *ptr;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>单个元素与 <code>delete[]</code> 混用：</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Test *p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Test</span>();<br><span class=\"hljs-keyword\">delete</span>[]p1;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041406079.png\" alt=\"报错程序\"></p>\n<p>程序崩溃。</p>\n<ul>\n<li><strong>数组与 delete 进行混用</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Test *p2 = <span class=\"hljs-keyword\">new</span> Test[<span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">delete</span> p2;<br></code></pre></td></tr></table></figure>\n\n<p>程序崩溃。</p>\n<p><strong>分析：</strong></p>\n<p>正常情况下，每一个 Test 对象有一个整型成员变量，这里分配了 5 个 Test 对象。delete 时先调用析构函数，this 指针将正确的对象的地址传入析构函数中，加了 <code>[]</code> 表示有好几个对象，有一个数组其中每一个对象都要进行析构。但 delete 真正执行指令时，底层是 malloc 按字节开辟，并不知道是否开辟了 5 个 Test 对象的数组，因此还要再多开辟一个 4 字节来存储对象的个数，假设它的地址是 <code>0x100</code>；但是 new 完之后 p2 返回的地址是 <code>0x104</code> 地址，当我们执行 <code>delete[]</code> 时，会到 4 字节来取一下对象的个数，将知道了是 5 个并将这块内存平均分为 5 份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将 <code>0x100</code> 开始的 4 字节也释放。</p>\n<p>而 p2 出错是给用户返回的存对象开始的起始地址，<code>delete p2</code> 认为 p2 只是指向了一个对象，只将 <code>Test[0]</code> 对象析构，直接从 <code>0x104 free(p2)</code>，但底层实际是从 <code>0x100</code> 开辟的，因此崩溃。</p>\n<p>而 p1 出错：p1 只是单个元素，从 <code>0x104</code> 开始开辟内存，但是 <code>delete[] p1</code>，里面并没有那么多元素，最后还释放了 4 个字节的存储对象个数的内存(即从 <code>0x100</code> 释放)因此崩溃。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041405849.png\" alt=\"image.png\"></p>\n"},{"_content":"","source":"_posts/02.C++ 基础部分/00.C++ 基本语法学习.md","raw":"","slug":"02.C++ 基础部分/00.C++ 基本语法学习","published":1,"date":"2023-08-03T07:08:54.439Z","updated":"2023-08-03T07:08:54.439Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clkuty8uf0001ncpk9kdpehq2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"03.C++ 面向对象","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节分为 7 大类：\n\n1. 类和对象、this 指针\n2. 构造函数和析构函数\n3. 深拷贝和浅拷贝\n4. 类和对象代码应用实践\n5. 构造函数的初始化列表\n6. 类的各种成员方法及区别\n7. 指向类成员的指针\n\n## 1. 类和对象、this 指针\n\nC 语言是**面向过程**的，关注的是过程。分析出求解问题的步骤，通过函数调用**逐步**解决问题。\n\nC++ 是基于**面向对象**的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的**交互**完成。\n\n### 1. 类的引入\n\nC语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nstruct Student\n{\n\tvoid SetStudentInfo(const char* name, const char* gender, int age)\n\t{\n\t\tstrcpy(_name, name);\n\t\tstrcpy(_gender, gender);\n\t\t_age = age;\n\t}\n\tvoid PrintStudentInfo()\n\t{\n\t\tcout << \"name = \" << _name << endl;\n\t\tcout << \"gender = \" << _gender << endl;\n\t\tcout << \"age = \" << _age << endl;\n\t}\n\n\tchar _name[20];\n\tchar _gender[3];\n\tint _age;\n};\n\nint main()\n{\n\tStudent s;\n\ts.SetStudentInfo(\"Peter\", \"男\", 18);\n\ts.PrintStudentInfo();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png)\n\n上面结构体的定义，在 C++ 中更喜欢用`class`来代替。\n\n### 2. 类的定义\n\n语法结构：\n\n~~~c++\nclass className {\n // 类体：由成员函数和成员变量组成\n\n}; // 要注意后面的分号\n~~~\n\n- `class`为定义类的关键字\n- `ClassName`为类的名字\n- `{}`中为类的主体\n- 注意类定义结束时后面分号。\n\n类中的元素称为**类的成员**，类中的数据称为**类的属性**或者**成员变量**。 类中的函数称为**类的方法**或者**成员函数**。\n\n类的两种定义方式：\n\n1. 声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。\n2. 声明放在.h文件中，类的定义放在`cpp`文件中。推荐使用！\n\n### 3. 类的访问限定符及封装\n\n1. **访问限定符：**\n\n`C++`实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。\n\n访问限定符说明：\n\n1. `public` 修饰的成员在类外可以直接被访问\n2. `protected` 和 `private` 修饰的成员在类外不能直接被访问(此处 `protected` 和 `private` 是类似的)\n3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止\n4. `class` 的默认访问权限为 `private`，`struct` 为 `public` (因为 `struct` 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别\n\n> - 问：C++ 中 `struct` 和 `class` 的区别是什么？\n> - 答：C++ 需要兼容 C 语言，所以 C++ 中 `struct` 可以当成结构体去使用。另外 C++ 中 `struct` 还可以用来定义类。 和 `class` 是定义类是一样的，区别是 `struct` 的成员默认访问方式是 `public`，`class` 的成员默认访问方式是 `private`。\n\n2. **封装**\n\n面向对象的三大特性：**封装**、**继承**、**多态**。\n\n在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。\n\n> 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。\n\n封装本质上是一种管理：\n\n使用类数据和方法都封装到一下。 不想给别人看到的，使用 `protected` / `private` 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。\n\n### 4. 类的作用域\n\n类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用`::`作用域解析符指明成员属于哪个类域。\n\n~~~c++\nclass Person{\n\tpublic:\n\t\tvoid PrintPersonInfo();\n\tprivate:\n\t\tchar _name[20];\n\t\tchar _gender[3];\n\t\tint _age;\n};\n\n// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域\nvoid Person::PrintPersonInfo(){\n\tcout<<_name<<\" \"<<_gender<<\" \"<<_age<<endl;\n}\n~~~\n\n### 5. 类的实例化\n\n**用类类型创建对象的过程**，称为类的实例化。\n\n1. 类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。\n2. 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。\n3. 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间\n\n### 6. 类对象模型\n\n**如何计算类对象的大小**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A \n{\npublic:\n\tvoid PrintA()\n\t{\n\t\tcout << _a << endl;\n\t}\n\nprivate:\n\tchar _a;\n};\n\nint main()\n{\n\tcout << sizeof(A) << endl;\n\n\treturn 0;\n}\n~~~\n\n类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。\n\n~~~c++\nclass A1 {\n\tpublic:\n\t\tvoid f1(){}\n\tprivate:\n\t\tint _a;\n};\n\n// 类中仅有成员函数\nclass A2 {\n\tpublic:\n\t\tvoid f2() {}\n};\n\n// 类中什么都没有---空类\nclass A3{};\n~~~\n\n解：\n\n~~~c++\nsizeof(A1) :4\nsizeof(A2) :1\nsizeof(A3) :1\n~~~\n\n结论：\n\n一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 **一个字节** 来唯一标识这个类。\n\n### 7. this 指针\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Date {\npublic:\n\tvoid Display() {\n\t\tcout << _year << \"-\" << _month << \"-\" << _day << endl;\n\t}\n\tvoid SetDate(int year, int month, int day) {\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\nprivate:\n\tint _year; // 年\n\tint _month; // 月\n\tint _day; // 日\n};\n\nint main() {\n\tDate d1, d2;\n\n\td1.SetDate(2018, 5, 1);\n\td2.SetDate(2018, 7, 1);\n\n\td1.Display();\n\td2.Display();\n\n\treturn 0;\n}\n~~~\n\n对于上述类，有这样的一个问题： `Date` 类中有 `SetDate` 与 `Display` 两个成员函数，函数体中没有关于不同对象的区分，那当 `s1` 调用 `SetDate` 函数时，该函数是如何知道应该设置 `s1` 对象，而不是设置 `s2` 对象呢？\n\nC++ 中通过引入 `this` 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\n### 8. this 指针特性\n\n- `this`指针的类型：`类类型* const`。\n- 只能在“成员函数”的内部使用。\n- `this`指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给`this`形参。所以对象中不存储`this`指针。\n- `this`指针是成员函数第一个隐含的指针形参，一般情况由编译器通过`ecx`寄存器自动传递，不需要用户传递。\n\n## 2. 构造函数和析构函数\n\n### 1. 构造函数\n\n- 因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。\n- C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。\n- 构造函数没有返回值，名字与类名相同。\n\n**注意事项：**\n\n1. 类的构造函数支持函数重载。\n2. 类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。\n3. 类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。\n4. 使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。\n5. 构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 `int a = 10;` 这是初始化 )，赋值是数据成员定义之后进行的( 像 `int b; b = 12;` 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。\n\n~~~c++\nclass Test {\npublic:\n    Test(int nn, double dd, char cc) \n        : d(dd), n(nn), c(cc) \n    {\n        n = 10;\n        d = 3.4;\n        c = 'b';\n    }\n\n    void show() const {\n        cout << n << \" \" << d << \" \" << c << endl;\n    }\n\nprivate:\n    int n;\n    double d;\n    char c;\n};\n\nTest test(2, 2.1, 'a');\ntest.show();\n// 运行结果：10 3.4 b\n// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果\n~~~\n\n6. 初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致\n7. 类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作\n\n~~~c++\nclass Test {\npublic:\n    Test(int& nn, const double dd) \n        : d(dd), n(nn)\n    { }\n\n    void show() const {\n        cout << n << \" \" << d << endl;\n    }\n\nprivate:\n    int& n;\n    const double d;\n};\n\nint n = 5;\nTest test(n, 3.5);\ntest.show();\n// 运行结果：5 3.5\n~~~\n\n### 2. 析构函数\n\n- 形式是构造函数名字前面加一个 “~”\n- 析构函数只有一个没有重载\n- 析构函数也没有形参\n- 析构函数是在对象生命周期结束时自动调用的，它负责清理工作\n- 与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用\n\n## 3. 深拷贝和浅拷贝\n\n在了解拷贝前，我们需要先知道 **拷贝构造函数** 的本质\n\n- 拷贝构造本质上也是构造函数\n- 参数是所在类的常引用的构造函数\n- 类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝\n\n~~~c++\n// ====== 浅拷贝示例代码 ======\nclass Test {\npublic:\n    Test(int nn, double dd) \n        : n(nn), d(dd)\n    { }\n\n    Test(const Test& t) // 定义拷贝构造函数\n        : n(t.n), d(t.d)\n    { }\n\n    void show() const {\n        cout << n << \" \" << d << endl;\n    }\n\nprivate:\n    int n;\n    double d;\n};\n\n// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数\nTest t(5, 2.5); // 实例化一个对象\nTest test1(t);  // 用对象t初始化另一个对象，调用拷贝构造函数\nTest test2 = t; // 通过重载的 \"=\" 初始化对象，调用拷贝构造函数\nTest* test3 = new Test(t);  // 调用拷贝构造函数初始化对象\ndelete test3;\n~~~\n\n- 浅拷贝方式对于一般的数据成员是\"OK\"的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是\"OK\"的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题\n- 针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用\n\n~~~c++\n// ====== 浅拷贝 ======\nclass Test {\npublic:\n    Test(int n) \n    : p(new int(n))\n    { }\n\n    Test(const Test& t) \n        : p(t.p)\n    { }\n\n    ~Test() {\n        delete p;\n    }\n\nprivate:\n    int* p;\n};\n\nTest t(10);\nTest test(t);\n// 程序运行出错，重复释放内存\n\n// ====== 深拷贝 ======\nclass Test {\npublic:\n    Test(int n)\n        : p(new int(n))\n    { }\n\n    Test(const Test& t) \n        : p(new int(*t.p))\n    { }\n\n    ~Test() {\n        delete p;\n    }\n\nprivate:\n    int* p;\n};\n\nTest t(10);\nTest test(t);\n// 程序正常运行\n~~~\n\n### 1. 浅拷贝和深拷贝原理\n\n拷贝就是 **复制**，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。\n\n对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：\n\n- 第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。\n- 第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。\n\n拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。\n\n**总结**：\n\n- **浅拷贝**：位拷贝，拷贝构造函数，赋值重载\n\t多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏\n\n- **深拷贝**：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。\n\n简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n\n### 2. 浅拷贝和深拷贝实现\n\n~~~c++\n// --- 浅拷贝实现 ---\n#include <iostream>\nusing namespace std;\n\nclass Light\n{\npublic:\n\t// 构造函数\n\tLight() : a(0), b(0) {};\n\tLight(int A, int B) : a(A), b(B) {};\n\n\tvoid show()\n\t{\n\t\tcout << \"a = \" << this->a << endl;\n\t\tcout << \"b = \" << this->b << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\n\tLight obj1(a, b);\n\tLight obj2 = obj1;\n\n\tobj2.show();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png)\n\n**实现 String 类来了解 深拷贝：**\n\n~~~c++\n// --- 深拷贝实现 ---\n#include <iostream>\n#include <new>\nusing namespace std;\n\nclass String\n{\npublic:\n\t// 构造函数\n\tString(const char* str = nullptr)\n\t{\n\t\tcout << \" 默认构造函数:\" << endl;\n\t\tif (str)\n\t\t{\n\t\t\t// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，\n\t\t\t// 直到碰到第一个字符串结束符'\\0'为止，然后返回计数器值(长度不包含'\\0')\n\t\t\tdata_ = new char[strlen(str) + 1];\n\t\t\t// strcpy把含有'\\0'结束符的字符串复制到另一个地址空间\n\t\t\tstrcpy(data_, str);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata_ = new char[1];//new 数组类型 与delete []对应\n\t\t\t*data_ = 0;\n\t\t}\n\t}\n\t\n\t// 拷贝构造函数\n\tString(const String& str)\n\t{\n\t\tcout << \"拷贝构造：\" << endl;\n\t\tdata_ = new char[strlen(str.data_) + 1];\n\t\tstrcpy(data_, str.data_);\n\t}\n\n\t// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左\n    // 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败\n\tString& operator=(const String& str)\n\t{\n\t\tcout << \"赋值重载：\" << endl;\n\t\tif (this == &str)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\n\t\tdelete[] data_;\n\n\t\tdata_ = new char[strlen(str.data_) + 1];\n\t\tstrcpy(data_, str.data_);\n\t\treturn *this;\n\t}\n\n\t// 析构函数\n\t// 释放内存\n\t~String() {\n\t\tdelete[] data_;\n\t\tdata_ = nullptr;\n\t}\n\nprotected:\nprivate:\n\tchar* data_ = nullptr;\n};\n\n\nint main()\n{\n\tString s1;//默认构造函数\n\tString s2(\"123\");//默认构造函数\n\tString s3 = s2;//拷贝构造函数\n\tString s4 = \"hello\";//默认构造函数\n\tString s5(s4);//拷贝构造函数   是构造过程发生\n\tString s6;\n\ts6 = s5;//=重载  是赋值，左右两边的对象都已经存在\n\n\treturn 0;\n}\n~~~\n\n## 4. 类和对象代码应用实践\n\n**实现：循环队列**\n\n当队列空时，条件就是 `front = rear`，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png)\n\n由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 `(rear+1) %QueueSize == front` (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。\n\n比如：QueueSize = 5，当 front=0，而 rear=4, (4+1) %5 = 0，所以此时队列满。再比如，front = 2而rear =1。(1 + 1) %5 = 2，所以此时 队列也是满的。而对于下图, front = 2而rear= 0, (0+1) %5 = 1，1!=2,所以此时队列并没有满。\n\n另外，当 `rear > front` 时，此时队列的长度为 `rear—front`。但当rear < front时，队列长度分为两段，一段是 `QueueSize-front`，另一段是0 + rear，加在一起，队列长度为 `rear-front + QueueSize`\n\n因此通用的计算队列长度公式为：\n\n~~~text\n(rear — front + QueueSize) % QueueSize\n~~~\n\n**总结：**\n\n- 队空条件：front == rear\n- 队满条件：(rear+1) %QueueSize == front\n- 队列长度：(rear—front + QueueSize) % QueueSize\n\n**实现：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Queue\n{\npublic:\n\t// 初始化构造\n\tQueue(int size = 20) {\n\t\t// 创建队列\n\t\tqueue_ = new int[size];\n\t\t// 初始化值\n\t\tfront_ = 0;\n\t\trear_ = 0;\n\t\tsize_ = size;\n\t}\n\n\t// 拷贝构造\n\tQueue(const Queue* queue) {\n\t\t// 传值\n\t\tsize_ = queue->size_;\n\t\tfront_ = queue->front_;\n\t\trear_ = queue->rear_;\n\t\tqueue_ = new int[size_];\n\n\t\t// 扩展\n\t\tint i = 0;\n\t\tfor (i = front_; i != rear_; i = (i + 1) % size_)\n\t\t{\n\t\t\tqueue_[i] = queue_[i];\n\t\t}\n\t}\n\n\t// 复制重构\n\tQueue& operator=(const Queue& q) {\n\t\tcout << \"operator=\" << endl;\n\t\tif (this == &q)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 清空\n\t\tdelete queue_;\n\t\t// 重新赋值\n\t\tsize_ = q.size_;\n\t\tfront_ = q.front_;\n\t\trear_ = q.rear_;\n\t\tqueue_ = new int[size_];\n\n\t\t// 扩展\n\t\tint i = 0;\n\t\tfor (i = front_; i != rear_; i = (i + 1) % size_)\n\t\t{\n\t\t\tqueue_[i] = q.queue_[i];\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\t// 析构函数\n\t~Queue() {\n\t\tdelete[] queue_;\n\t\tqueue_ = nullptr;\n\t}\n\n\t// 队列方法：\n\t// 1. push：放入元素\n\tvoid push(int val) {\n\t\tif (full())\n\t\t{\n\t\t\tresize();\n\t\t}\n\n\t\t// 从队尾放置\n\t\tqueue_[rear_] = val;\n\t\t// 计算下一个位置\n\t\trear_ = (rear_ + 1) % size_;\n\t}\n\n\t// 2. 出队方法\n\tvoid pop() {\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfront_ = (front_ + 1) % size_;\n\t}\n\n\t// 4. 获取对头\n\tint top() {\n\t\treturn queue_[front_];\n\t}\n\n\t// 3. 判断是否为空\n\tbool empty() {\n\t\treturn rear_ == front_;\n\t}\n\nprivate:\n\t// 私密方法：\n\t// 1. 扩容\n\tvoid resize()\n\t{\n\t\t// 扩容 2 倍\n\t\tint* tmp = new int[size_ * 2];\n\t\tint index = 0;\n\t\t// 拷贝值\n\t\tint i = 0;\n\t\tfor (i = front_; i != rear_; i = (i + 1) % size_)\n\t\t{\n\t\t\ttmp[index] = queue_[i];\n\t\t\tindex++;\n\t\t}\n\n\t\t// 清除原先数值\n\t\tdelete queue_;\n\t\t// 重新赋值\n\t\tqueue_ = tmp;\n\t\tfront_ = 0;\n\t\trear_ = index++;\n\t\tsize_ *= 2;\n\t}\n\n\t// 2. 是否已满\n\tbool full()\n\t{\n\t\treturn (rear_ + 1) % size_ == front_;\n\t}\n\n\nprivate:\n\t// 队列\n\tint* queue_;\n\t// 对头\n\tint front_;\n\t// 队尾\n\tint rear_;\n\t// 队列扩列大小\n\tint size_;\n};\n\n\nint main()\n{\n\t// 创建对象\n\tQueue q1;\n\tQueue q2;\n\n\t// 放入元素\n\tint i = 0;\n\tfor (i = 0; i < 20; i++) {\n\t\tq1.push(i);\n\t}\n\tfor (i = 20; i < 40; i++)\n\t{\n\t\tq2.push(i);\n\t}\n\n\tq1 = q2;\n\n\n\t// 获取元素\n\twhile (!q1.empty())\n\t{\n\t\tcout << q1.top() << \" \";\n\t\tq1.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n## 5. 构造函数的初始化列表\n\n构造函数初始化列表的情况有三种：\n\n1. 需要初始化的类的成员变量是对象的情况；\n2. 需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；\n3. 子类初始化父类的成员；\n\n**情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数**\n\n如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest(int, int, int) {\n\t\tcout << \"Test\" << endl;\n\t}\n\nprivate:\n\tint x;\n\tint y;\n\tint z;\n};\n\nclass MyTest\n{\npublic:\n\tMyTest() : test(1, 2, 3) {       // 初始化值\n\t\tcout << \"MyTest\" << endl;\n\t}\n\nprivate:\n\tTest test;\n};\n\nint main()\n{\n\tMyTest t1;\n\n\treturn 0;\n}\n~~~\n\n因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。\n\n**情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量**\n\n~~~c++\nclass Test\n{\npublic:\n\tTest() :a(10) {}           //初始化\nprivate:\n\tconst int a;             //const成员声明\n};\n\n// 或\n\nclass Test\n{\npublic:\n\tTest(int _a) :a(_a) {}      //初始化\nprivate:\n\tint& a;                 //声明\n}\n~~~\n\n**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\npublic:\n    Test(){};\n    Test (int x){ int_x = x;};\n    void show(){cout<< int_x << endl;}\nprivate:\n    int int_x;\n};\n \nclass Mytest:public Test\n{\npublic:\n    Mytest() ：Test(110) //调用父类的构造函数\n    {\n      //Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用\n    };\n};\n \nint main()\n{\n Test *p = new Mytest();\n p->show();\n \n return 0;\n}\n~~~\n\n执行顺序：\n\n在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。\n\n## 6. 类的各种成员方法及区别\n\nC++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。\n\n~~~c++\nclass Date\n{\npublic:\n\tDate(int year, int month, int day)\n\t\t: year_(year)\n\t\t, month_(month)\n\t\t, day_(day)\n\t{\n\t}\n\tvoid show() const\n\t{\n\t\tcout << \"year：\" << year_ << \" month：\" << month_ << \" day：\" << day_ << \" \";\n\t}\nprivate:\n\tint year_;\n\tint month_;\n\tint day_;\n};\n\n/*\n\t继承：a kind of，一种\n\t组合：a part of，一部分\n\t商品日期更像是商品的一部分，应该用组合的方式\n*/\n\nclass Goods\n{\npublic:\n\tGoods(int id, string name, int price, int year, int month, int day)\n\t\t: date_(year, month, day)\n\t\t, id_(id)\n\t\t, name_(name)\n\t\t, price_(price)\n\t{\n\t\tcount_++;\n\t}\n\tvoid show()\tconst \t\n\t{\n\t\tdate_.show();\n\t\tcout << \"id：\" << id_ << \" name：\" << name_ << \" price：\" << price_ << endl;\n\t}\n\tstatic int getCount()\t\t//静态成员函数\n\t{\n\t\treturn count_;\n\t}\nprivate:\n\tDate date_;\n\tint id_;\n\tstring name_;\n\tint price_;\n\tstatic int count_;\t\t//静态成员变量的声明\n};\n\nint Goods::count_ = 0;\t\t//静态成员变量的初始化\n~~~\n\n### 1. 静态成员变量\n\n静态成员变量在类内声明，在类外定义初始化\n静态成员变量可以用类引用，也可以通过对象引用\n\n### 2.静态成员函数\n\n静态成员函数不能使用普通成员变量，能使用静态成员变量\n静态成员函数可以通过类调用，也可以通过对象调用\n\n### 3. const 成员函数\n\n一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。\nconst 成员函数既能够被普通对象调用，也能被 const 对象调用\n\n## 7. 指向类成员的指针\n\n成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。\n\n### 1. 成员函数指针\n\n在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：\n\n~~~c++\n成员函数返回类型 （类名::*指针名）（形参）= &类名::成员函数名\n~~~\n\n**示例：**\n\n~~~c++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA(string s) {\n\t\tname = s;\n\t}\n\n\tvoid print() {\n\t\tcout << \"name = \" << name << endl;\n\t}\n\t\nprivate:\n\tstring name;\n\n};\n\nint main()\n{\n\tA a(\"lisa\");\n\t// 定义类长远函数指针并赋初始值\n\tvoid(A::*memp)() = &A::print;\n\t(a.*memp)();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png)\n\n使用成员函数指着注意两点：\n\n（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；  \n（2）为成员函数指针赋值时，需要显示使用 `&` 运算符，不能直接将 “类名 `::` 成员函数名”赋给成员函数指针。\n\n### 2. 数据成员指针\n\n一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：\n\n- 对象的首地址和该成员变量在对象之内的偏移量。\n- 数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。\n\n数据成员指针的定义格式：\n\n~~~c++\n成员类型 类名::*指针名=&类名::成员名;\n~~~\n\n**示例：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Student {\npublic:\n\tint age;\n\tint score;\n};\n\ndouble average(Student* objs, int Student::*pm, int count) {\n\tint result = 0;\n\tint i = 0;\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tresult += objs[i].*pm;\n\t}\n\n\treturn double(result) / count;\n}\n\nint main()\n{\n\tStudent my[3] = { {16, 86}, {17, 80}, {18, 58} };\n\n\tdouble ageAver = average(my, &Student::age, 3);\n\tdouble scoreAver = average(my, &Student::score, 3);\n\n\tcout << \"ageAver = \" << ageAver << endl;\n\tcout << \"scoreAver = \" << scoreAver << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png)\n\n使用数据成员指针时，需要注意以下几点：\n\n（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。\n（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 `average()` 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的`obj.*pm` 等同于 `*(int*)((char*)(&obj)+pm)`，显然，这样书写可读性差，可移植性低且容易出错。\n（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass ArrayClass  {\n\tint arr[5];\npublic:\n\tArrayClass()  {\n\t\tfor(int i=0;i<5;++i)\n\t\t\tarr[i]=i;\n\t}\n};\n\n// 使用数据成员指针作为形参\nvoid printArray(ArrayClass& arrObj,int (ArrayClass::* pm)[5]) {\n\tfor(int i=0;i<5;++i) {\n\t\tcout<<(arrObj.*pm)[i]<<\" \";\n\t}\n}\n\nint main() {\n\tArrayClass arrObj;\n\tprintArray(arrObj,&ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问\n}\n~~~\n\n以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。\n\n要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass ArrayClass {\nint arr[5];\npublic:\n\tArrayClass() {\n\t\tfor(int i=0;i<5;++i)\n\t\t\tarr[i]=i;\n\t}\n\n\tfriend void print(ArrayClass& arrObj);\n};\n\n// 使用数据成员指针作为形参\nvoid printArray(ArrayClass& arrObj,int (ArrayClass::* pm)[5]) {\n\tfor(int i=0;i<5;++i)\n\t\tcout<<(arrObj.*pm)[i]<<\" \";\n}\n\n// 定义友元函数\nvoid print(ArrayClass& arrObj) {\n\tprintArray(arrObj,&ArrayClass::arr);\n}\n\nint main() {\n\tArrayClass arrObj;\n\t//printArray(arrObj,&ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问\n\tprint(arrObj); //通过友元函数调用打印数组函数printArray()来访问私有成员\n}\n~~~\n\n","source":"_posts/02.C++ 基础部分/03.C++ 面向对象.md","raw":"---\ntitle: 03.C++ 面向对象\ntags: [C++]\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节分为 7 大类：\n\n1. 类和对象、this 指针\n2. 构造函数和析构函数\n3. 深拷贝和浅拷贝\n4. 类和对象代码应用实践\n5. 构造函数的初始化列表\n6. 类的各种成员方法及区别\n7. 指向类成员的指针\n\n## 1. 类和对象、this 指针\n\nC 语言是**面向过程**的，关注的是过程。分析出求解问题的步骤，通过函数调用**逐步**解决问题。\n\nC++ 是基于**面向对象**的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的**交互**完成。\n\n### 1. 类的引入\n\nC语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nstruct Student\n{\n\tvoid SetStudentInfo(const char* name, const char* gender, int age)\n\t{\n\t\tstrcpy(_name, name);\n\t\tstrcpy(_gender, gender);\n\t\t_age = age;\n\t}\n\tvoid PrintStudentInfo()\n\t{\n\t\tcout << \"name = \" << _name << endl;\n\t\tcout << \"gender = \" << _gender << endl;\n\t\tcout << \"age = \" << _age << endl;\n\t}\n\n\tchar _name[20];\n\tchar _gender[3];\n\tint _age;\n};\n\nint main()\n{\n\tStudent s;\n\ts.SetStudentInfo(\"Peter\", \"男\", 18);\n\ts.PrintStudentInfo();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png)\n\n上面结构体的定义，在 C++ 中更喜欢用`class`来代替。\n\n### 2. 类的定义\n\n语法结构：\n\n~~~c++\nclass className {\n // 类体：由成员函数和成员变量组成\n\n}; // 要注意后面的分号\n~~~\n\n- `class`为定义类的关键字\n- `ClassName`为类的名字\n- `{}`中为类的主体\n- 注意类定义结束时后面分号。\n\n类中的元素称为**类的成员**，类中的数据称为**类的属性**或者**成员变量**。 类中的函数称为**类的方法**或者**成员函数**。\n\n类的两种定义方式：\n\n1. 声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。\n2. 声明放在.h文件中，类的定义放在`cpp`文件中。推荐使用！\n\n### 3. 类的访问限定符及封装\n\n1. **访问限定符：**\n\n`C++`实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。\n\n访问限定符说明：\n\n1. `public` 修饰的成员在类外可以直接被访问\n2. `protected` 和 `private` 修饰的成员在类外不能直接被访问(此处 `protected` 和 `private` 是类似的)\n3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止\n4. `class` 的默认访问权限为 `private`，`struct` 为 `public` (因为 `struct` 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别\n\n> - 问：C++ 中 `struct` 和 `class` 的区别是什么？\n> - 答：C++ 需要兼容 C 语言，所以 C++ 中 `struct` 可以当成结构体去使用。另外 C++ 中 `struct` 还可以用来定义类。 和 `class` 是定义类是一样的，区别是 `struct` 的成员默认访问方式是 `public`，`class` 的成员默认访问方式是 `private`。\n\n2. **封装**\n\n面向对象的三大特性：**封装**、**继承**、**多态**。\n\n在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。\n\n> 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。\n\n封装本质上是一种管理：\n\n使用类数据和方法都封装到一下。 不想给别人看到的，使用 `protected` / `private` 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。\n\n### 4. 类的作用域\n\n类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用`::`作用域解析符指明成员属于哪个类域。\n\n~~~c++\nclass Person{\n\tpublic:\n\t\tvoid PrintPersonInfo();\n\tprivate:\n\t\tchar _name[20];\n\t\tchar _gender[3];\n\t\tint _age;\n};\n\n// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域\nvoid Person::PrintPersonInfo(){\n\tcout<<_name<<\" \"<<_gender<<\" \"<<_age<<endl;\n}\n~~~\n\n### 5. 类的实例化\n\n**用类类型创建对象的过程**，称为类的实例化。\n\n1. 类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。\n2. 一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。\n3. 做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间\n\n### 6. 类对象模型\n\n**如何计算类对象的大小**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A \n{\npublic:\n\tvoid PrintA()\n\t{\n\t\tcout << _a << endl;\n\t}\n\nprivate:\n\tchar _a;\n};\n\nint main()\n{\n\tcout << sizeof(A) << endl;\n\n\treturn 0;\n}\n~~~\n\n类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。\n\n~~~c++\nclass A1 {\n\tpublic:\n\t\tvoid f1(){}\n\tprivate:\n\t\tint _a;\n};\n\n// 类中仅有成员函数\nclass A2 {\n\tpublic:\n\t\tvoid f2() {}\n};\n\n// 类中什么都没有---空类\nclass A3{};\n~~~\n\n解：\n\n~~~c++\nsizeof(A1) :4\nsizeof(A2) :1\nsizeof(A3) :1\n~~~\n\n结论：\n\n一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 **一个字节** 来唯一标识这个类。\n\n### 7. this 指针\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Date {\npublic:\n\tvoid Display() {\n\t\tcout << _year << \"-\" << _month << \"-\" << _day << endl;\n\t}\n\tvoid SetDate(int year, int month, int day) {\n\t\t_year = year;\n\t\t_month = month;\n\t\t_day = day;\n\t}\n\nprivate:\n\tint _year; // 年\n\tint _month; // 月\n\tint _day; // 日\n};\n\nint main() {\n\tDate d1, d2;\n\n\td1.SetDate(2018, 5, 1);\n\td2.SetDate(2018, 7, 1);\n\n\td1.Display();\n\td2.Display();\n\n\treturn 0;\n}\n~~~\n\n对于上述类，有这样的一个问题： `Date` 类中有 `SetDate` 与 `Display` 两个成员函数，函数体中没有关于不同对象的区分，那当 `s1` 调用 `SetDate` 函数时，该函数是如何知道应该设置 `s1` 对象，而不是设置 `s2` 对象呢？\n\nC++ 中通过引入 `this` 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。\n\n### 8. this 指针特性\n\n- `this`指针的类型：`类类型* const`。\n- 只能在“成员函数”的内部使用。\n- `this`指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给`this`形参。所以对象中不存储`this`指针。\n- `this`指针是成员函数第一个隐含的指针形参，一般情况由编译器通过`ecx`寄存器自动传递，不需要用户传递。\n\n## 2. 构造函数和析构函数\n\n### 1. 构造函数\n\n- 因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。\n- C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。\n- 构造函数没有返回值，名字与类名相同。\n\n**注意事项：**\n\n1. 类的构造函数支持函数重载。\n2. 类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。\n3. 类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。\n4. 使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。\n5. 构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 `int a = 10;` 这是初始化 )，赋值是数据成员定义之后进行的( 像 `int b; b = 12;` 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。\n\n~~~c++\nclass Test {\npublic:\n    Test(int nn, double dd, char cc) \n        : d(dd), n(nn), c(cc) \n    {\n        n = 10;\n        d = 3.4;\n        c = 'b';\n    }\n\n    void show() const {\n        cout << n << \" \" << d << \" \" << c << endl;\n    }\n\nprivate:\n    int n;\n    double d;\n    char c;\n};\n\nTest test(2, 2.1, 'a');\ntest.show();\n// 运行结果：10 3.4 b\n// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果\n~~~\n\n6. 初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致\n7. 类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作\n\n~~~c++\nclass Test {\npublic:\n    Test(int& nn, const double dd) \n        : d(dd), n(nn)\n    { }\n\n    void show() const {\n        cout << n << \" \" << d << endl;\n    }\n\nprivate:\n    int& n;\n    const double d;\n};\n\nint n = 5;\nTest test(n, 3.5);\ntest.show();\n// 运行结果：5 3.5\n~~~\n\n### 2. 析构函数\n\n- 形式是构造函数名字前面加一个 “~”\n- 析构函数只有一个没有重载\n- 析构函数也没有形参\n- 析构函数是在对象生命周期结束时自动调用的，它负责清理工作\n- 与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用\n\n## 3. 深拷贝和浅拷贝\n\n在了解拷贝前，我们需要先知道 **拷贝构造函数** 的本质\n\n- 拷贝构造本质上也是构造函数\n- 参数是所在类的常引用的构造函数\n- 类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝\n\n~~~c++\n// ====== 浅拷贝示例代码 ======\nclass Test {\npublic:\n    Test(int nn, double dd) \n        : n(nn), d(dd)\n    { }\n\n    Test(const Test& t) // 定义拷贝构造函数\n        : n(t.n), d(t.d)\n    { }\n\n    void show() const {\n        cout << n << \" \" << d << endl;\n    }\n\nprivate:\n    int n;\n    double d;\n};\n\n// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数\nTest t(5, 2.5); // 实例化一个对象\nTest test1(t);  // 用对象t初始化另一个对象，调用拷贝构造函数\nTest test2 = t; // 通过重载的 \"=\" 初始化对象，调用拷贝构造函数\nTest* test3 = new Test(t);  // 调用拷贝构造函数初始化对象\ndelete test3;\n~~~\n\n- 浅拷贝方式对于一般的数据成员是\"OK\"的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是\"OK\"的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题\n- 针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用\n\n~~~c++\n// ====== 浅拷贝 ======\nclass Test {\npublic:\n    Test(int n) \n    : p(new int(n))\n    { }\n\n    Test(const Test& t) \n        : p(t.p)\n    { }\n\n    ~Test() {\n        delete p;\n    }\n\nprivate:\n    int* p;\n};\n\nTest t(10);\nTest test(t);\n// 程序运行出错，重复释放内存\n\n// ====== 深拷贝 ======\nclass Test {\npublic:\n    Test(int n)\n        : p(new int(n))\n    { }\n\n    Test(const Test& t) \n        : p(new int(*t.p))\n    { }\n\n    ~Test() {\n        delete p;\n    }\n\nprivate:\n    int* p;\n};\n\nTest t(10);\nTest test(t);\n// 程序正常运行\n~~~\n\n### 1. 浅拷贝和深拷贝原理\n\n拷贝就是 **复制**，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。\n\n对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：\n\n- 第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。\n- 第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。\n\n拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。\n\n**总结**：\n\n- **浅拷贝**：位拷贝，拷贝构造函数，赋值重载\n\t多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏\n\n- **深拷贝**：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。\n\n简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n\n### 2. 浅拷贝和深拷贝实现\n\n~~~c++\n// --- 浅拷贝实现 ---\n#include <iostream>\nusing namespace std;\n\nclass Light\n{\npublic:\n\t// 构造函数\n\tLight() : a(0), b(0) {};\n\tLight(int A, int B) : a(A), b(B) {};\n\n\tvoid show()\n\t{\n\t\tcout << \"a = \" << this->a << endl;\n\t\tcout << \"b = \" << this->b << endl;\n\t}\n\nprivate:\n\tint a;\n\tint b;\n};\n\n\nint main()\n{\n\tint a = 10;\n\tint b = 20;\n\n\tLight obj1(a, b);\n\tLight obj2 = obj1;\n\n\tobj2.show();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png)\n\n**实现 String 类来了解 深拷贝：**\n\n~~~c++\n// --- 深拷贝实现 ---\n#include <iostream>\n#include <new>\nusing namespace std;\n\nclass String\n{\npublic:\n\t// 构造函数\n\tString(const char* str = nullptr)\n\t{\n\t\tcout << \" 默认构造函数:\" << endl;\n\t\tif (str)\n\t\t{\n\t\t\t// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，\n\t\t\t// 直到碰到第一个字符串结束符'\\0'为止，然后返回计数器值(长度不包含'\\0')\n\t\t\tdata_ = new char[strlen(str) + 1];\n\t\t\t// strcpy把含有'\\0'结束符的字符串复制到另一个地址空间\n\t\t\tstrcpy(data_, str);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata_ = new char[1];//new 数组类型 与delete []对应\n\t\t\t*data_ = 0;\n\t\t}\n\t}\n\t\n\t// 拷贝构造函数\n\tString(const String& str)\n\t{\n\t\tcout << \"拷贝构造：\" << endl;\n\t\tdata_ = new char[strlen(str.data_) + 1];\n\t\tstrcpy(data_, str.data_);\n\t}\n\n\t// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左\n    // 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败\n\tString& operator=(const String& str)\n\t{\n\t\tcout << \"赋值重载：\" << endl;\n\t\tif (this == &str)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\n\t\tdelete[] data_;\n\n\t\tdata_ = new char[strlen(str.data_) + 1];\n\t\tstrcpy(data_, str.data_);\n\t\treturn *this;\n\t}\n\n\t// 析构函数\n\t// 释放内存\n\t~String() {\n\t\tdelete[] data_;\n\t\tdata_ = nullptr;\n\t}\n\nprotected:\nprivate:\n\tchar* data_ = nullptr;\n};\n\n\nint main()\n{\n\tString s1;//默认构造函数\n\tString s2(\"123\");//默认构造函数\n\tString s3 = s2;//拷贝构造函数\n\tString s4 = \"hello\";//默认构造函数\n\tString s5(s4);//拷贝构造函数   是构造过程发生\n\tString s6;\n\ts6 = s5;//=重载  是赋值，左右两边的对象都已经存在\n\n\treturn 0;\n}\n~~~\n\n## 4. 类和对象代码应用实践\n\n**实现：循环队列**\n\n当队列空时，条件就是 `front = rear`，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png)\n\n由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 `(rear+1) %QueueSize == front` (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。\n\n比如：QueueSize = 5，当 front=0，而 rear=4, (4+1) %5 = 0，所以此时队列满。再比如，front = 2而rear =1。(1 + 1) %5 = 2，所以此时 队列也是满的。而对于下图, front = 2而rear= 0, (0+1) %5 = 1，1!=2,所以此时队列并没有满。\n\n另外，当 `rear > front` 时，此时队列的长度为 `rear—front`。但当rear < front时，队列长度分为两段，一段是 `QueueSize-front`，另一段是0 + rear，加在一起，队列长度为 `rear-front + QueueSize`\n\n因此通用的计算队列长度公式为：\n\n~~~text\n(rear — front + QueueSize) % QueueSize\n~~~\n\n**总结：**\n\n- 队空条件：front == rear\n- 队满条件：(rear+1) %QueueSize == front\n- 队列长度：(rear—front + QueueSize) % QueueSize\n\n**实现：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Queue\n{\npublic:\n\t// 初始化构造\n\tQueue(int size = 20) {\n\t\t// 创建队列\n\t\tqueue_ = new int[size];\n\t\t// 初始化值\n\t\tfront_ = 0;\n\t\trear_ = 0;\n\t\tsize_ = size;\n\t}\n\n\t// 拷贝构造\n\tQueue(const Queue* queue) {\n\t\t// 传值\n\t\tsize_ = queue->size_;\n\t\tfront_ = queue->front_;\n\t\trear_ = queue->rear_;\n\t\tqueue_ = new int[size_];\n\n\t\t// 扩展\n\t\tint i = 0;\n\t\tfor (i = front_; i != rear_; i = (i + 1) % size_)\n\t\t{\n\t\t\tqueue_[i] = queue_[i];\n\t\t}\n\t}\n\n\t// 复制重构\n\tQueue& operator=(const Queue& q) {\n\t\tcout << \"operator=\" << endl;\n\t\tif (this == &q)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 清空\n\t\tdelete queue_;\n\t\t// 重新赋值\n\t\tsize_ = q.size_;\n\t\tfront_ = q.front_;\n\t\trear_ = q.rear_;\n\t\tqueue_ = new int[size_];\n\n\t\t// 扩展\n\t\tint i = 0;\n\t\tfor (i = front_; i != rear_; i = (i + 1) % size_)\n\t\t{\n\t\t\tqueue_[i] = q.queue_[i];\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\t// 析构函数\n\t~Queue() {\n\t\tdelete[] queue_;\n\t\tqueue_ = nullptr;\n\t}\n\n\t// 队列方法：\n\t// 1. push：放入元素\n\tvoid push(int val) {\n\t\tif (full())\n\t\t{\n\t\t\tresize();\n\t\t}\n\n\t\t// 从队尾放置\n\t\tqueue_[rear_] = val;\n\t\t// 计算下一个位置\n\t\trear_ = (rear_ + 1) % size_;\n\t}\n\n\t// 2. 出队方法\n\tvoid pop() {\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfront_ = (front_ + 1) % size_;\n\t}\n\n\t// 4. 获取对头\n\tint top() {\n\t\treturn queue_[front_];\n\t}\n\n\t// 3. 判断是否为空\n\tbool empty() {\n\t\treturn rear_ == front_;\n\t}\n\nprivate:\n\t// 私密方法：\n\t// 1. 扩容\n\tvoid resize()\n\t{\n\t\t// 扩容 2 倍\n\t\tint* tmp = new int[size_ * 2];\n\t\tint index = 0;\n\t\t// 拷贝值\n\t\tint i = 0;\n\t\tfor (i = front_; i != rear_; i = (i + 1) % size_)\n\t\t{\n\t\t\ttmp[index] = queue_[i];\n\t\t\tindex++;\n\t\t}\n\n\t\t// 清除原先数值\n\t\tdelete queue_;\n\t\t// 重新赋值\n\t\tqueue_ = tmp;\n\t\tfront_ = 0;\n\t\trear_ = index++;\n\t\tsize_ *= 2;\n\t}\n\n\t// 2. 是否已满\n\tbool full()\n\t{\n\t\treturn (rear_ + 1) % size_ == front_;\n\t}\n\n\nprivate:\n\t// 队列\n\tint* queue_;\n\t// 对头\n\tint front_;\n\t// 队尾\n\tint rear_;\n\t// 队列扩列大小\n\tint size_;\n};\n\n\nint main()\n{\n\t// 创建对象\n\tQueue q1;\n\tQueue q2;\n\n\t// 放入元素\n\tint i = 0;\n\tfor (i = 0; i < 20; i++) {\n\t\tq1.push(i);\n\t}\n\tfor (i = 20; i < 40; i++)\n\t{\n\t\tq2.push(i);\n\t}\n\n\tq1 = q2;\n\n\n\t// 获取元素\n\twhile (!q1.empty())\n\t{\n\t\tcout << q1.top() << \" \";\n\t\tq1.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n## 5. 构造函数的初始化列表\n\n构造函数初始化列表的情况有三种：\n\n1. 需要初始化的类的成员变量是对象的情况；\n2. 需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；\n3. 子类初始化父类的成员；\n\n**情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数**\n\n如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\npublic:\n\tTest(int, int, int) {\n\t\tcout << \"Test\" << endl;\n\t}\n\nprivate:\n\tint x;\n\tint y;\n\tint z;\n};\n\nclass MyTest\n{\npublic:\n\tMyTest() : test(1, 2, 3) {       // 初始化值\n\t\tcout << \"MyTest\" << endl;\n\t}\n\nprivate:\n\tTest test;\n};\n\nint main()\n{\n\tMyTest t1;\n\n\treturn 0;\n}\n~~~\n\n因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。\n\n**情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量**\n\n~~~c++\nclass Test\n{\npublic:\n\tTest() :a(10) {}           //初始化\nprivate:\n\tconst int a;             //const成员声明\n};\n\n// 或\n\nclass Test\n{\npublic:\n\tTest(int _a) :a(_a) {}      //初始化\nprivate:\n\tint& a;                 //声明\n}\n~~~\n\n**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Test\n{\npublic:\n    Test(){};\n    Test (int x){ int_x = x;};\n    void show(){cout<< int_x << endl;}\nprivate:\n    int int_x;\n};\n \nclass Mytest:public Test\n{\npublic:\n    Mytest() ：Test(110) //调用父类的构造函数\n    {\n      //Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用\n    };\n};\n \nint main()\n{\n Test *p = new Mytest();\n p->show();\n \n return 0;\n}\n~~~\n\n执行顺序：\n\n在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。\n\n## 6. 类的各种成员方法及区别\n\nC++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。\n\n~~~c++\nclass Date\n{\npublic:\n\tDate(int year, int month, int day)\n\t\t: year_(year)\n\t\t, month_(month)\n\t\t, day_(day)\n\t{\n\t}\n\tvoid show() const\n\t{\n\t\tcout << \"year：\" << year_ << \" month：\" << month_ << \" day：\" << day_ << \" \";\n\t}\nprivate:\n\tint year_;\n\tint month_;\n\tint day_;\n};\n\n/*\n\t继承：a kind of，一种\n\t组合：a part of，一部分\n\t商品日期更像是商品的一部分，应该用组合的方式\n*/\n\nclass Goods\n{\npublic:\n\tGoods(int id, string name, int price, int year, int month, int day)\n\t\t: date_(year, month, day)\n\t\t, id_(id)\n\t\t, name_(name)\n\t\t, price_(price)\n\t{\n\t\tcount_++;\n\t}\n\tvoid show()\tconst \t\n\t{\n\t\tdate_.show();\n\t\tcout << \"id：\" << id_ << \" name：\" << name_ << \" price：\" << price_ << endl;\n\t}\n\tstatic int getCount()\t\t//静态成员函数\n\t{\n\t\treturn count_;\n\t}\nprivate:\n\tDate date_;\n\tint id_;\n\tstring name_;\n\tint price_;\n\tstatic int count_;\t\t//静态成员变量的声明\n};\n\nint Goods::count_ = 0;\t\t//静态成员变量的初始化\n~~~\n\n### 1. 静态成员变量\n\n静态成员变量在类内声明，在类外定义初始化\n静态成员变量可以用类引用，也可以通过对象引用\n\n### 2.静态成员函数\n\n静态成员函数不能使用普通成员变量，能使用静态成员变量\n静态成员函数可以通过类调用，也可以通过对象调用\n\n### 3. const 成员函数\n\n一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。\nconst 成员函数既能够被普通对象调用，也能被 const 对象调用\n\n## 7. 指向类成员的指针\n\n成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。\n\n### 1. 成员函数指针\n\n在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：\n\n~~~c++\n成员函数返回类型 （类名::*指针名）（形参）= &类名::成员函数名\n~~~\n\n**示例：**\n\n~~~c++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA(string s) {\n\t\tname = s;\n\t}\n\n\tvoid print() {\n\t\tcout << \"name = \" << name << endl;\n\t}\n\t\nprivate:\n\tstring name;\n\n};\n\nint main()\n{\n\tA a(\"lisa\");\n\t// 定义类长远函数指针并赋初始值\n\tvoid(A::*memp)() = &A::print;\n\t(a.*memp)();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png)\n\n使用成员函数指着注意两点：\n\n（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；  \n（2）为成员函数指针赋值时，需要显示使用 `&` 运算符，不能直接将 “类名 `::` 成员函数名”赋给成员函数指针。\n\n### 2. 数据成员指针\n\n一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：\n\n- 对象的首地址和该成员变量在对象之内的偏移量。\n- 数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。\n\n数据成员指针的定义格式：\n\n~~~c++\n成员类型 类名::*指针名=&类名::成员名;\n~~~\n\n**示例：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Student {\npublic:\n\tint age;\n\tint score;\n};\n\ndouble average(Student* objs, int Student::*pm, int count) {\n\tint result = 0;\n\tint i = 0;\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tresult += objs[i].*pm;\n\t}\n\n\treturn double(result) / count;\n}\n\nint main()\n{\n\tStudent my[3] = { {16, 86}, {17, 80}, {18, 58} };\n\n\tdouble ageAver = average(my, &Student::age, 3);\n\tdouble scoreAver = average(my, &Student::score, 3);\n\n\tcout << \"ageAver = \" << ageAver << endl;\n\tcout << \"scoreAver = \" << scoreAver << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png)\n\n使用数据成员指针时，需要注意以下几点：\n\n（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。\n（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 `average()` 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的`obj.*pm` 等同于 `*(int*)((char*)(&obj)+pm)`，显然，这样书写可读性差，可移植性低且容易出错。\n（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass ArrayClass  {\n\tint arr[5];\npublic:\n\tArrayClass()  {\n\t\tfor(int i=0;i<5;++i)\n\t\t\tarr[i]=i;\n\t}\n};\n\n// 使用数据成员指针作为形参\nvoid printArray(ArrayClass& arrObj,int (ArrayClass::* pm)[5]) {\n\tfor(int i=0;i<5;++i) {\n\t\tcout<<(arrObj.*pm)[i]<<\" \";\n\t}\n}\n\nint main() {\n\tArrayClass arrObj;\n\tprintArray(arrObj,&ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问\n}\n~~~\n\n以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。\n\n要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass ArrayClass {\nint arr[5];\npublic:\n\tArrayClass() {\n\t\tfor(int i=0;i<5;++i)\n\t\t\tarr[i]=i;\n\t}\n\n\tfriend void print(ArrayClass& arrObj);\n};\n\n// 使用数据成员指针作为形参\nvoid printArray(ArrayClass& arrObj,int (ArrayClass::* pm)[5]) {\n\tfor(int i=0;i<5;++i)\n\t\tcout<<(arrObj.*pm)[i]<<\" \";\n}\n\n// 定义友元函数\nvoid print(ArrayClass& arrObj) {\n\tprintArray(arrObj,&ArrayClass::arr);\n}\n\nint main() {\n\tArrayClass arrObj;\n\t//printArray(arrObj,&ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问\n\tprint(arrObj); //通过友元函数调用打印数组函数printArray()来访问私有成员\n}\n~~~\n\n","slug":"02.C++ 基础部分/03.C++ 面向对象","published":1,"date":"2023-08-04T06:09:27.166Z","updated":"2023-08-09T09:14:03.254Z","_id":"clkw6w7mw0000acpk88orduw7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节分为 7 大类：</p>\n<ol>\n<li>类和对象、this 指针</li>\n<li>构造函数和析构函数</li>\n<li>深拷贝和浅拷贝</li>\n<li>类和对象代码应用实践</li>\n<li>构造函数的初始化列表</li>\n<li>类的各种成员方法及区别</li>\n<li>指向类成员的指针</li>\n</ol>\n<h2 id=\"1-类和对象、this-指针\"><a href=\"#1-类和对象、this-指针\" class=\"headerlink\" title=\"1. 类和对象、this 指针\"></a>1. 类和对象、this 指针</h2><p>C 语言是<strong>面向过程</strong>的，关注的是过程。分析出求解问题的步骤，通过函数调用<strong>逐步</strong>解决问题。</p>\n<p>C++ 是基于<strong>面向对象</strong>的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的<strong>交互</strong>完成。</p>\n<h3 id=\"1-类的引入\"><a href=\"#1-类的引入\" class=\"headerlink\" title=\"1. 类的引入\"></a>1. 类的引入</h3><p>C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Student</span><br>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetStudentInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* gender, <span class=\"hljs-type\">int</span> age)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(_name, name);<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(_gender, gender);<br>\t\t_age = age;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintStudentInfo</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;name = &quot;</span> &lt;&lt; _name &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;gender = &quot;</span> &lt;&lt; _gender &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;age = &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-type\">char</span> _name[<span class=\"hljs-number\">20</span>];<br>\t<span class=\"hljs-type\">char</span> _gender[<span class=\"hljs-number\">3</span>];<br>\t<span class=\"hljs-type\">int</span> _age;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tStudent s;<br>\ts.<span class=\"hljs-built_in\">SetStudentInfo</span>(<span class=\"hljs-string\">&quot;Peter&quot;</span>, <span class=\"hljs-string\">&quot;男&quot;</span>, <span class=\"hljs-number\">18</span>);<br>\ts.<span class=\"hljs-built_in\">PrintStudentInfo</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png\" alt=\"image.png\"></p>\n<p>上面结构体的定义，在 C++ 中更喜欢用<code>class</code>来代替。</p>\n<h3 id=\"2-类的定义\"><a href=\"#2-类的定义\" class=\"headerlink\" title=\"2. 类的定义\"></a>2. 类的定义</h3><p>语法结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">className</span> &#123;<br> <span class=\"hljs-comment\">// 类体：由成员函数和成员变量组成</span><br><br>&#125;; <span class=\"hljs-comment\">// 要注意后面的分号</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>class</code>为定义类的关键字</li>\n<li><code>ClassName</code>为类的名字</li>\n<li><code>&#123;&#125;</code>中为类的主体</li>\n<li>注意类定义结束时后面分号。</li>\n</ul>\n<p>类中的元素称为<strong>类的成员</strong>，类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>。 类中的函数称为<strong>类的方法</strong>或者<strong>成员函数</strong>。</p>\n<p>类的两种定义方式：</p>\n<ol>\n<li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</li>\n<li>声明放在.h文件中，类的定义放在<code>cpp</code>文件中。推荐使用！</li>\n</ol>\n<h3 id=\"3-类的访问限定符及封装\"><a href=\"#3-类的访问限定符及封装\" class=\"headerlink\" title=\"3. 类的访问限定符及封装\"></a>3. 类的访问限定符及封装</h3><ol>\n<li><strong>访问限定符：</strong></li>\n</ol>\n<p><code>C++</code>实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。</p>\n<p>访问限定符说明：</p>\n<ol>\n<li><code>public</code> 修饰的成员在类外可以直接被访问</li>\n<li><code>protected</code> 和 <code>private</code> 修饰的成员在类外不能直接被访问(此处 <code>protected</code> 和 <code>private</code> 是类似的)</li>\n<li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li>\n<li><code>class</code> 的默认访问权限为 <code>private</code>，<code>struct</code> 为 <code>public</code> (因为 <code>struct</code> 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</li>\n</ol>\n<blockquote>\n<ul>\n<li>问：C++ 中 <code>struct</code> 和 <code>class</code> 的区别是什么？</li>\n<li>答：C++ 需要兼容 C 语言，所以 C++ 中 <code>struct</code> 可以当成结构体去使用。另外 C++ 中 <code>struct</code> 还可以用来定义类。 和 <code>class</code> 是定义类是一样的，区别是 <code>struct</code> 的成员默认访问方式是 <code>public</code>，<code>class</code> 的成员默认访问方式是 <code>private</code>。</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li><strong>封装</strong></li>\n</ol>\n<p>面向对象的三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p>\n<p>在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。</p>\n<blockquote>\n<p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p>\n</blockquote>\n<p>封装本质上是一种管理：</p>\n<p>使用类数据和方法都封装到一下。 不想给别人看到的，使用 <code>protected</code> &#x2F; <code>private</code> 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p>\n<h3 id=\"4-类的作用域\"><a href=\"#4-类的作用域\" class=\"headerlink\" title=\"4. 类的作用域\"></a>4. 类的作用域</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用<code>::</code>作用域解析符指明成员属于哪个类域。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintPersonInfo</span><span class=\"hljs-params\">()</span></span>;<br>\t<span class=\"hljs-keyword\">private</span>:<br>\t\t<span class=\"hljs-type\">char</span> _name[<span class=\"hljs-number\">20</span>];<br>\t\t<span class=\"hljs-type\">char</span> _gender[<span class=\"hljs-number\">3</span>];<br>\t\t<span class=\"hljs-type\">int</span> _age;<br>&#125;;<br><br><span class=\"hljs-comment\">// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Person::PrintPersonInfo</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tcout&lt;&lt;_name&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>&lt;&lt;_gender&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>&lt;&lt;_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-类的实例化\"><a href=\"#5-类的实例化\" class=\"headerlink\" title=\"5. 类的实例化\"></a>5. 类的实例化</h3><p><strong>用类类型创建对象的过程</strong>，称为类的实例化。</p>\n<ol>\n<li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。</li>\n<li>一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。</li>\n<li>做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li>\n</ol>\n<h3 id=\"6-类对象模型\"><a href=\"#6-类对象模型\" class=\"headerlink\" title=\"6. 类对象模型\"></a>6. 类对象模型</h3><p><strong>如何计算类对象的大小</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> <br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; _a &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span> _a;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(A) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A1</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f1</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">private</span>:<br>\t\t<span class=\"hljs-type\">int</span> _a;<br>&#125;;<br><br><span class=\"hljs-comment\">// 类中仅有成员函数</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A2</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 类中什么都没有---空类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A3</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">sizeof</span>(A1) :<span class=\"hljs-number\">4</span><br><span class=\"hljs-built_in\">sizeof</span>(A2) :<span class=\"hljs-number\">1</span><br><span class=\"hljs-built_in\">sizeof</span>(A3) :<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>结论：</p>\n<p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 <strong>一个字节</strong> 来唯一标识这个类。</p>\n<h3 id=\"7-this-指针\"><a href=\"#7-this-指针\" class=\"headerlink\" title=\"7. this 指针\"></a>7. this 指针</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Date</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Display</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; _year &lt;&lt; <span class=\"hljs-string\">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class=\"hljs-string\">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetDate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)</span> </span>&#123;<br>\t\t_year = year;<br>\t\t_month = month;<br>\t\t_day = day;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _year; <span class=\"hljs-comment\">// 年</span><br>\t<span class=\"hljs-type\">int</span> _month; <span class=\"hljs-comment\">// 月</span><br>\t<span class=\"hljs-type\">int</span> _day; <span class=\"hljs-comment\">// 日</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tDate d1, d2;<br><br>\td1.<span class=\"hljs-built_in\">SetDate</span>(<span class=\"hljs-number\">2018</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>);<br>\td2.<span class=\"hljs-built_in\">SetDate</span>(<span class=\"hljs-number\">2018</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>);<br><br>\td1.<span class=\"hljs-built_in\">Display</span>();<br>\td2.<span class=\"hljs-built_in\">Display</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于上述类，有这样的一个问题： <code>Date</code> 类中有 <code>SetDate</code> 与 <code>Display</code> 两个成员函数，函数体中没有关于不同对象的区分，那当 <code>s1</code> 调用 <code>SetDate</code> 函数时，该函数是如何知道应该设置 <code>s1</code> 对象，而不是设置 <code>s2</code> 对象呢？</p>\n<p>C++ 中通过引入 <code>this</code> 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p>\n<h3 id=\"8-this-指针特性\"><a href=\"#8-this-指针特性\" class=\"headerlink\" title=\"8. this 指针特性\"></a>8. this 指针特性</h3><ul>\n<li><code>this</code>指针的类型：<code>类类型* const</code>。</li>\n<li>只能在“成员函数”的内部使用。</li>\n<li><code>this</code>指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给<code>this</code>形参。所以对象中不存储<code>this</code>指针。</li>\n<li><code>this</code>指针是成员函数第一个隐含的指针形参，一般情况由编译器通过<code>ecx</code>寄存器自动传递，不需要用户传递。</li>\n</ul>\n<h2 id=\"2-构造函数和析构函数\"><a href=\"#2-构造函数和析构函数\" class=\"headerlink\" title=\"2. 构造函数和析构函数\"></a>2. 构造函数和析构函数</h2><h3 id=\"1-构造函数\"><a href=\"#1-构造函数\" class=\"headerlink\" title=\"1. 构造函数\"></a>1. 构造函数</h3><ul>\n<li>因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。</li>\n<li>C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。</li>\n<li>构造函数没有返回值，名字与类名相同。</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li>类的构造函数支持函数重载。</li>\n<li>类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。</li>\n<li>类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。</li>\n<li>使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。</li>\n<li>构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 <code>int a = 10;</code> 这是初始化 )，赋值是数据成员定义之后进行的( 像 <code>int b; b = 12;</code> 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> nn, <span class=\"hljs-type\">double</span> dd, <span class=\"hljs-type\">char</span> cc) <br>        : <span class=\"hljs-built_in\">d</span>(dd), <span class=\"hljs-built_in\">n</span>(nn), <span class=\"hljs-built_in\">c</span>(cc) <br>    &#123;<br>        n = <span class=\"hljs-number\">10</span>;<br>        d = <span class=\"hljs-number\">3.4</span>;<br>        c = <span class=\"hljs-string\">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> n;<br>    <span class=\"hljs-type\">double</span> d;<br>    <span class=\"hljs-type\">char</span> c;<br>&#125;;<br><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2.1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>)</span></span>;<br>test.<span class=\"hljs-built_in\">show</span>();<br><span class=\"hljs-comment\">// 运行结果：10 3.4 b</span><br><span class=\"hljs-comment\">// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致</li>\n<li>类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span>&amp; nn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> dd) <br>        : <span class=\"hljs-built_in\">d</span>(dd), <span class=\"hljs-built_in\">n</span>(nn)<br>    &#123; &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span>&amp; n;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> d;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(n, <span class=\"hljs-number\">3.5</span>)</span></span>;<br>test.<span class=\"hljs-built_in\">show</span>();<br><span class=\"hljs-comment\">// 运行结果：5 3.5</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-析构函数\"><a href=\"#2-析构函数\" class=\"headerlink\" title=\"2. 析构函数\"></a>2. 析构函数</h3><ul>\n<li>形式是构造函数名字前面加一个 “~”</li>\n<li>析构函数只有一个没有重载</li>\n<li>析构函数也没有形参</li>\n<li>析构函数是在对象生命周期结束时自动调用的，它负责清理工作</li>\n<li>与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用</li>\n</ul>\n<h2 id=\"3-深拷贝和浅拷贝\"><a href=\"#3-深拷贝和浅拷贝\" class=\"headerlink\" title=\"3. 深拷贝和浅拷贝\"></a>3. 深拷贝和浅拷贝</h2><p>在了解拷贝前，我们需要先知道 <strong>拷贝构造函数</strong> 的本质</p>\n<ul>\n<li>拷贝构造本质上也是构造函数</li>\n<li>参数是所在类的常引用的构造函数</li>\n<li>类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ====== 浅拷贝示例代码 ======</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> nn, <span class=\"hljs-type\">double</span> dd) <br>        : <span class=\"hljs-built_in\">n</span>(nn), <span class=\"hljs-built_in\">d</span>(dd)<br>    &#123; &#125;<br><br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp; t) <span class=\"hljs-comment\">// 定义拷贝构造函数</span><br>        : <span class=\"hljs-built_in\">n</span>(t.n), <span class=\"hljs-built_in\">d</span>(t.d)<br>    &#123; &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> n;<br>    <span class=\"hljs-type\">double</span> d;<br>&#125;;<br><br><span class=\"hljs-comment\">// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数</span><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2.5</span>)</span></span>; <span class=\"hljs-comment\">// 实例化一个对象</span><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">(t)</span></span>;  <span class=\"hljs-comment\">// 用对象t初始化另一个对象，调用拷贝构造函数</span><br>Test test2 = t; <span class=\"hljs-comment\">// 通过重载的 &quot;=&quot; 初始化对象，调用拷贝构造函数</span><br>Test* test3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Test</span>(t);  <span class=\"hljs-comment\">// 调用拷贝构造函数初始化对象</span><br><span class=\"hljs-keyword\">delete</span> test3;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>浅拷贝方式对于一般的数据成员是”OK”的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是”OK”的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题</li>\n<li>针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ====== 浅拷贝 ======</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> n) <br>    : <span class=\"hljs-built_in\">p</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(n))<br>    &#123; &#125;<br><br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp; t) <br>        : <span class=\"hljs-built_in\">p</span>(t.p)<br>    &#123; &#125;<br><br>    ~<span class=\"hljs-built_in\">Test</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span>* p;<br>&#125;;<br><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(t)</span></span>;<br><span class=\"hljs-comment\">// 程序运行出错，重复释放内存</span><br><br><span class=\"hljs-comment\">// ====== 深拷贝 ======</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> n)<br>        : <span class=\"hljs-built_in\">p</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(n))<br>    &#123; &#125;<br><br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp; t) <br>        : <span class=\"hljs-built_in\">p</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(*t.p))<br>    &#123; &#125;<br><br>    ~<span class=\"hljs-built_in\">Test</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span>* p;<br>&#125;;<br><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(t)</span></span>;<br><span class=\"hljs-comment\">// 程序正常运行</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-浅拷贝和深拷贝原理\"><a href=\"#1-浅拷贝和深拷贝原理\" class=\"headerlink\" title=\"1. 浅拷贝和深拷贝原理\"></a>1. 浅拷贝和深拷贝原理</h3><p>拷贝就是 <strong>复制</strong>，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。</p>\n<p>对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：</p>\n<ul>\n<li>第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。</li>\n<li>第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。</li>\n</ul>\n<p>拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。</p>\n<p><strong>总结</strong>：</p>\n<ul>\n<li><p><strong>浅拷贝</strong>：位拷贝，拷贝构造函数，赋值重载<br>  多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏</p>\n</li>\n<li><p><strong>深拷贝</strong>：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。</p>\n</li>\n</ul>\n<p>简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p>\n<h3 id=\"2-浅拷贝和深拷贝实现\"><a href=\"#2-浅拷贝和深拷贝实现\" class=\"headerlink\" title=\"2. 浅拷贝和深拷贝实现\"></a>2. 浅拷贝和深拷贝实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// --- 浅拷贝实现 ---</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Light</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">Light</span>() : <span class=\"hljs-built_in\">a</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">b</span>(<span class=\"hljs-number\">0</span>) &#123;&#125;;<br>\t<span class=\"hljs-built_in\">Light</span>(<span class=\"hljs-type\">int</span> A, <span class=\"hljs-type\">int</span> B) : <span class=\"hljs-built_in\">a</span>(A), <span class=\"hljs-built_in\">b</span>(B) &#123;&#125;;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;a = &quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span>-&gt;a &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;b = &quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span>-&gt;b &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> a;<br>\t<span class=\"hljs-type\">int</span> b;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><br>\t<span class=\"hljs-function\">Light <span class=\"hljs-title\">obj1</span><span class=\"hljs-params\">(a, b)</span></span>;<br>\tLight obj2 = obj1;<br><br>\tobj2.<span class=\"hljs-built_in\">show</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png\" alt=\"image.png\"></p>\n<p><strong>实现 String 类来了解 深拷贝：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// --- 深拷贝实现 ---</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;new&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str = <span class=\"hljs-literal\">nullptr</span>)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot; 默认构造函数:&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (str)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，</span><br>\t\t\t<span class=\"hljs-comment\">// 直到碰到第一个字符串结束符&#x27;\\0&#x27;为止，然后返回计数器值(长度不包含&#x27;\\0&#x27;)</span><br>\t\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str) + <span class=\"hljs-number\">1</span>];<br>\t\t\t<span class=\"hljs-comment\">// strcpy把含有&#x27;\\0&#x27;结束符的字符串复制到另一个地址空间</span><br>\t\t\t<span class=\"hljs-built_in\">strcpy</span>(data_, str);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//new 数组类型 与delete []对应</span><br>\t\t\t*data_ = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t<span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;拷贝构造：&quot;</span> &lt;&lt; endl;<br>\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str.data_) + <span class=\"hljs-number\">1</span>];<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(data_, str.data_);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左</span><br>    <span class=\"hljs-comment\">// 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败</span><br>\tString&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; str)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;赋值重载：&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">delete</span>[] data_;<br><br>\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str.data_) + <span class=\"hljs-number\">1</span>];<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(data_, str.data_);<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t<span class=\"hljs-comment\">// 释放内存</span><br>\t~<span class=\"hljs-built_in\">String</span>() &#123;<br>\t\t<span class=\"hljs-keyword\">delete</span>[] data_;<br>\t\tdata_ = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* data_ = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tString s1;<span class=\"hljs-comment\">//默认构造函数</span><br>\t<span class=\"hljs-function\">String <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;123&quot;</span>)</span></span>;<span class=\"hljs-comment\">//默认构造函数</span><br>\tString s3 = s2;<span class=\"hljs-comment\">//拷贝构造函数</span><br>\tString s4 = <span class=\"hljs-string\">&quot;hello&quot;</span>;<span class=\"hljs-comment\">//默认构造函数</span><br>\t<span class=\"hljs-function\">String <span class=\"hljs-title\">s5</span><span class=\"hljs-params\">(s4)</span></span>;<span class=\"hljs-comment\">//拷贝构造函数   是构造过程发生</span><br>\tString s6;<br>\ts6 = s5;<span class=\"hljs-comment\">//=重载  是赋值，左右两边的对象都已经存在</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-类和对象代码应用实践\"><a href=\"#4-类和对象代码应用实践\" class=\"headerlink\" title=\"4. 类和对象代码应用实践\"></a>4. 类和对象代码应用实践</h2><p><strong>实现：循环队列</strong></p>\n<p>当队列空时，条件就是 <code>front = rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png\" alt=\"image.png\"></p>\n<p>由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 <code>(rear+1) %QueueSize == front</code> (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。</p>\n<p>比如：QueueSize &#x3D; 5，当 front&#x3D;0，而 rear&#x3D;4, (4+1) %5 &#x3D; 0，所以此时队列满。再比如，front &#x3D; 2而rear &#x3D;1。(1 + 1) %5 &#x3D; 2，所以此时 队列也是满的。而对于下图, front &#x3D; 2而rear&#x3D; 0, (0+1) %5 &#x3D; 1，1!&#x3D;2,所以此时队列并没有满。</p>\n<p>另外，当 <code>rear &gt; front</code> 时，此时队列的长度为 <code>rear—front</code>。但当rear &lt; front时，队列长度分为两段，一段是 <code>QueueSize-front</code>，另一段是0 + rear，加在一起，队列长度为 <code>rear-front + QueueSize</code></p>\n<p>因此通用的计算队列长度公式为：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">(rear — front + QueueSize) % QueueSize<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<ul>\n<li>队空条件：front &#x3D;&#x3D; rear</li>\n<li>队满条件：(rear+1) %QueueSize &#x3D;&#x3D; front</li>\n<li>队列长度：(rear—front + QueueSize) % QueueSize</li>\n</ul>\n<p><strong>实现：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 初始化构造</span><br>\t<span class=\"hljs-built_in\">Queue</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">20</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 创建队列</span><br>\t\tqueue_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size];<br>\t\t<span class=\"hljs-comment\">// 初始化值</span><br>\t\tfront_ = <span class=\"hljs-number\">0</span>;<br>\t\trear_ = <span class=\"hljs-number\">0</span>;<br>\t\tsize_ = size;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 拷贝构造</span><br>\t<span class=\"hljs-built_in\">Queue</span>(<span class=\"hljs-type\">const</span> Queue* queue) &#123;<br>\t\t<span class=\"hljs-comment\">// 传值</span><br>\t\tsize_ = queue-&gt;size_;<br>\t\tfront_ = queue-&gt;front_;<br>\t\trear_ = queue-&gt;rear_;<br>\t\tqueue_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size_];<br><br>\t\t<span class=\"hljs-comment\">// 扩展</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = front_; i != rear_; i = (i + <span class=\"hljs-number\">1</span>) % size_)<br>\t\t&#123;<br>\t\t\tqueue_[i] = queue_[i];<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 复制重构</span><br>\tQueue&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Queue&amp; q) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;q)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-keyword\">delete</span> queue_;<br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tsize_ = q.size_;<br>\t\tfront_ = q.front_;<br>\t\trear_ = q.rear_;<br>\t\tqueue_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size_];<br><br>\t\t<span class=\"hljs-comment\">// 扩展</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = front_; i != rear_; i = (i + <span class=\"hljs-number\">1</span>) % size_)<br>\t\t&#123;<br>\t\t\tqueue_[i] = q.queue_[i];<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">Queue</span>() &#123;<br>\t\t<span class=\"hljs-keyword\">delete</span>[] queue_;<br>\t\tqueue_ = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 队列方法：</span><br>\t<span class=\"hljs-comment\">// 1. push：放入元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">resize</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 从队尾放置</span><br>\t\tqueue_[rear_] = val;<br>\t\t<span class=\"hljs-comment\">// 计算下一个位置</span><br>\t\trear_ = (rear_ + <span class=\"hljs-number\">1</span>) % size_;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. 出队方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br><br>\t\tfront_ = (front_ + <span class=\"hljs-number\">1</span>) % size_;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4. 获取对头</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> queue_[front_];<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 3. 判断是否为空</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> rear_ == front_;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 私密方法：</span><br>\t<span class=\"hljs-comment\">// 1. 扩容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">resize</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 扩容 2 倍</span><br>\t\t<span class=\"hljs-type\">int</span>* tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size_ * <span class=\"hljs-number\">2</span>];<br>\t\t<span class=\"hljs-type\">int</span> index = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-comment\">// 拷贝值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = front_; i != rear_; i = (i + <span class=\"hljs-number\">1</span>) % size_)<br>\t\t&#123;<br>\t\t\ttmp[index] = queue_[i];<br>\t\t\tindex++;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清除原先数值</span><br>\t\t<span class=\"hljs-keyword\">delete</span> queue_;<br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tqueue_ = tmp;<br>\t\tfront_ = <span class=\"hljs-number\">0</span>;<br>\t\trear_ = index++;<br>\t\tsize_ *= <span class=\"hljs-number\">2</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. 是否已满</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (rear_ + <span class=\"hljs-number\">1</span>) % size_ == front_;<br>\t&#125;<br><br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 队列</span><br>\t<span class=\"hljs-type\">int</span>* queue_;<br>\t<span class=\"hljs-comment\">// 对头</span><br>\t<span class=\"hljs-type\">int</span> front_;<br>\t<span class=\"hljs-comment\">// 队尾</span><br>\t<span class=\"hljs-type\">int</span> rear_;<br>\t<span class=\"hljs-comment\">// 队列扩列大小</span><br>\t<span class=\"hljs-type\">int</span> size_;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建对象</span><br>\tQueue q1;<br>\tQueue q2;<br><br>\t<span class=\"hljs-comment\">// 放入元素</span><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++) &#123;<br>\t\tq1.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">20</span>; i &lt; <span class=\"hljs-number\">40</span>; i++)<br>\t&#123;<br>\t\tq2.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\tq1 = q2;<br><br><br>\t<span class=\"hljs-comment\">// 获取元素</span><br>\t<span class=\"hljs-keyword\">while</span> (!q1.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; q1.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tq1.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-构造函数的初始化列表\"><a href=\"#5-构造函数的初始化列表\" class=\"headerlink\" title=\"5. 构造函数的初始化列表\"></a>5. 构造函数的初始化列表</h2><p>构造函数初始化列表的情况有三种：</p>\n<ol>\n<li>需要初始化的类的成员变量是对象的情况；</li>\n<li>需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；</li>\n<li>子类初始化父类的成员；</li>\n</ol>\n<p><strong>情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数</strong></p>\n<p>如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> x;<br>\t<span class=\"hljs-type\">int</span> y;<br>\t<span class=\"hljs-type\">int</span> z;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyTest</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">MyTest</span>() : <span class=\"hljs-built_in\">test</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;       <span class=\"hljs-comment\">// 初始化值</span><br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;MyTest&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tTest test;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tMyTest t1;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。</p>\n<p><strong>情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>() :<span class=\"hljs-built_in\">a</span>(<span class=\"hljs-number\">10</span>) &#123;&#125;           <span class=\"hljs-comment\">//初始化</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a;             <span class=\"hljs-comment\">//const成员声明</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 或</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> _a) :<span class=\"hljs-built_in\">a</span>(_a) &#123;&#125;      <span class=\"hljs-comment\">//初始化</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span>&amp; a;                 <span class=\"hljs-comment\">//声明</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>()&#123;&#125;;<br>    <span class=\"hljs-built_in\">Test</span> (<span class=\"hljs-type\">int</span> x)&#123; int_x = x;&#125;;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> int_x;<br>&#125;;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mytest</span>:<span class=\"hljs-keyword\">public</span> Test<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Mytest</span>() ：<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-number\">110</span>) <span class=\"hljs-comment\">//调用父类的构造函数</span><br>    &#123;<br>      <span class=\"hljs-comment\">//Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用</span><br>    &#125;;<br>&#125;;<br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br> Test *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Mytest</span>();<br> p-&gt;<span class=\"hljs-built_in\">show</span>();<br> <br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>执行顺序：</p>\n<p>在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。</p>\n<h2 id=\"6-类的各种成员方法及区别\"><a href=\"#6-类的各种成员方法及区别\" class=\"headerlink\" title=\"6. 类的各种成员方法及区别\"></a>6. 类的各种成员方法及区别</h2><p>C++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Date</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)<br>\t\t: <span class=\"hljs-built_in\">year_</span>(year)<br>\t\t, <span class=\"hljs-built_in\">month_</span>(month)<br>\t\t, <span class=\"hljs-built_in\">day_</span>(day)<br>\t&#123;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;year：&quot;</span> &lt;&lt; year_ &lt;&lt; <span class=\"hljs-string\">&quot; month：&quot;</span> &lt;&lt; month_ &lt;&lt; <span class=\"hljs-string\">&quot; day：&quot;</span> &lt;&lt; day_ &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> year_;<br>\t<span class=\"hljs-type\">int</span> month_;<br>\t<span class=\"hljs-type\">int</span> day_;<br>&#125;;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t继承：a kind of，一种</span><br><span class=\"hljs-comment\">\t组合：a part of，一部分</span><br><span class=\"hljs-comment\">\t商品日期更像是商品的一部分，应该用组合的方式</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Goods</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Goods</span>(<span class=\"hljs-type\">int</span> id, string name, <span class=\"hljs-type\">int</span> price, <span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)<br>\t\t: <span class=\"hljs-built_in\">date_</span>(year, month, day)<br>\t\t, <span class=\"hljs-built_in\">id_</span>(id)<br>\t\t, <span class=\"hljs-built_in\">name_</span>(name)<br>\t\t, <span class=\"hljs-built_in\">price_</span>(price)<br>\t&#123;<br>\t\tcount_++;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span>\t<span class=\"hljs-type\">const</span> \t</span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tdate_.<span class=\"hljs-built_in\">show</span>();<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;id：&quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot; name：&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"hljs-string\">&quot; price：&quot;</span> &lt;&lt; price_ &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getCount</span><span class=\"hljs-params\">()</span>\t\t<span class=\"hljs-comment\">//静态成员函数</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> count_;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tDate date_;<br>\t<span class=\"hljs-type\">int</span> id_;<br>\tstring name_;<br>\t<span class=\"hljs-type\">int</span> price_;<br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> count_;\t\t<span class=\"hljs-comment\">//静态成员变量的声明</span><br>&#125;;<br><br><span class=\"hljs-type\">int</span> Goods::count_ = <span class=\"hljs-number\">0</span>;\t\t<span class=\"hljs-comment\">//静态成员变量的初始化</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-静态成员变量\"><a href=\"#1-静态成员变量\" class=\"headerlink\" title=\"1. 静态成员变量\"></a>1. 静态成员变量</h3><p>静态成员变量在类内声明，在类外定义初始化<br>静态成员变量可以用类引用，也可以通过对象引用</p>\n<h3 id=\"2-静态成员函数\"><a href=\"#2-静态成员函数\" class=\"headerlink\" title=\"2.静态成员函数\"></a>2.静态成员函数</h3><p>静态成员函数不能使用普通成员变量，能使用静态成员变量<br>静态成员函数可以通过类调用，也可以通过对象调用</p>\n<h3 id=\"3-const-成员函数\"><a href=\"#3-const-成员函数\" class=\"headerlink\" title=\"3. const 成员函数\"></a>3. const 成员函数</h3><p>一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。<br>const 成员函数既能够被普通对象调用，也能被 const 对象调用</p>\n<h2 id=\"7-指向类成员的指针\"><a href=\"#7-指向类成员的指针\" class=\"headerlink\" title=\"7. 指向类成员的指针\"></a>7. 指向类成员的指针</h2><p>成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。</p>\n<h3 id=\"1-成员函数指针\"><a href=\"#1-成员函数指针\" class=\"headerlink\" title=\"1. 成员函数指针\"></a>1. 成员函数指针</h3><p>在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">成员函数返回类型 （类名::*指针名）（形参）= &amp;类名::成员函数名<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>(string s) &#123;<br>\t\tname = s;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>\t&#125;<br>\t<br><span class=\"hljs-keyword\">private</span>:<br>\tstring name;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;lisa&quot;</span>)</span></span>;<br>\t<span class=\"hljs-comment\">// 定义类长远函数指针并赋初始值</span><br>\t<span class=\"hljs-built_in\">void</span>(A::*memp)() = &amp;A::print;<br>\t(a.*memp)();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png\" alt=\"image.png\"></p>\n<p>使用成员函数指着注意两点：</p>\n<p>（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；<br>（2）为成员函数指针赋值时，需要显示使用 <code>&amp;</code> 运算符，不能直接将 “类名 <code>::</code> 成员函数名”赋给成员函数指针。</p>\n<h3 id=\"2-数据成员指针\"><a href=\"#2-数据成员指针\" class=\"headerlink\" title=\"2. 数据成员指针\"></a>2. 数据成员指针</h3><p>一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：</p>\n<ul>\n<li>对象的首地址和该成员变量在对象之内的偏移量。</li>\n<li>数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。</li>\n</ul>\n<p>数据成员指针的定义格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">成员类型 类名::*指针名=&amp;类名::成员名;<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-type\">int</span> age;<br>\t<span class=\"hljs-type\">int</span> score;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(Student* objs, <span class=\"hljs-type\">int</span> Student::*pm, <span class=\"hljs-type\">int</span> count)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> result = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; count; i++)<br>\t&#123;<br>\t\tresult += objs[i].*pm;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">double</span>(result) / count;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tStudent my[<span class=\"hljs-number\">3</span>] = &#123; &#123;<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">86</span>&#125;, &#123;<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">80</span>&#125;, &#123;<span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">58</span>&#125; &#125;;<br><br>\t<span class=\"hljs-type\">double</span> ageAver = <span class=\"hljs-built_in\">average</span>(my, &amp;Student::age, <span class=\"hljs-number\">3</span>);<br>\t<span class=\"hljs-type\">double</span> scoreAver = <span class=\"hljs-built_in\">average</span>(my, &amp;Student::score, <span class=\"hljs-number\">3</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ageAver = &quot;</span> &lt;&lt; ageAver &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;scoreAver = &quot;</span> &lt;&lt; scoreAver &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png\" alt=\"image.png\"></p>\n<p>使用数据成员指针时，需要注意以下几点：</p>\n<p>（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。<br>（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 <code>average()</code> 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的<code>obj.*pm</code> 等同于 <code>*(int*)((char*)(&amp;obj)+pm)</code>，显然，这样书写可读性差，可移植性低且容易出错。<br>（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayClass</span>  &#123;<br>\t<span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">ArrayClass</span>()  &#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i)<br>\t\t\tarr[i]=i;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 使用数据成员指针作为形参</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printArray</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj,<span class=\"hljs-type\">int</span> (ArrayClass::* pm)[<span class=\"hljs-number\">5</span>])</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i) &#123;<br>\t\tcout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tArrayClass arrObj;<br>\t<span class=\"hljs-built_in\">printArray</span>(arrObj,&amp;ArrayClass::arr);<span class=\"hljs-comment\">//编译出错，提示成员ArrayClass::arr不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。</p>\n<p>要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayClass</span> &#123;<br><span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">ArrayClass</span>() &#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i)<br>\t\t\tarr[i]=i;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj)</span></span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 使用数据成员指针作为形参</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printArray</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj,<span class=\"hljs-type\">int</span> (ArrayClass::* pm)[<span class=\"hljs-number\">5</span>])</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i)<br>\t\tcout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 定义友元函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj)</span> </span>&#123;<br>\t<span class=\"hljs-built_in\">printArray</span>(arrObj,&amp;ArrayClass::arr);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tArrayClass arrObj;<br>\t<span class=\"hljs-comment\">//printArray(arrObj,&amp;ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问</span><br>\t<span class=\"hljs-built_in\">print</span>(arrObj); <span class=\"hljs-comment\">//通过友元函数调用打印数组函数printArray()来访问私有成员</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>本节分为 7 大类：</p>\n<ol>\n<li>类和对象、this 指针</li>\n<li>构造函数和析构函数</li>\n<li>深拷贝和浅拷贝</li>\n<li>类和对象代码应用实践</li>\n<li>构造函数的初始化列表</li>\n<li>类的各种成员方法及区别</li>\n<li>指向类成员的指针</li>\n</ol>\n<h2 id=\"1-类和对象、this-指针\"><a href=\"#1-类和对象、this-指针\" class=\"headerlink\" title=\"1. 类和对象、this 指针\"></a>1. 类和对象、this 指针</h2><p>C 语言是<strong>面向过程</strong>的，关注的是过程。分析出求解问题的步骤，通过函数调用<strong>逐步</strong>解决问题。</p>\n<p>C++ 是基于<strong>面向对象</strong>的，关注的是对象，将一件事情拆分成不同的对象，靠对象之间的<strong>交互</strong>完成。</p>\n<h3 id=\"1-类的引入\"><a href=\"#1-类的引入\" class=\"headerlink\" title=\"1. 类的引入\"></a>1. 类的引入</h3><p>C语言中，结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Student</span><br>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetStudentInfo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* gender, <span class=\"hljs-type\">int</span> age)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(_name, name);<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(_gender, gender);<br>\t\t_age = age;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintStudentInfo</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;name = &quot;</span> &lt;&lt; _name &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;gender = &quot;</span> &lt;&lt; _gender &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;age = &quot;</span> &lt;&lt; _age &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-type\">char</span> _name[<span class=\"hljs-number\">20</span>];<br>\t<span class=\"hljs-type\">char</span> _gender[<span class=\"hljs-number\">3</span>];<br>\t<span class=\"hljs-type\">int</span> _age;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tStudent s;<br>\ts.<span class=\"hljs-built_in\">SetStudentInfo</span>(<span class=\"hljs-string\">&quot;Peter&quot;</span>, <span class=\"hljs-string\">&quot;男&quot;</span>, <span class=\"hljs-number\">18</span>);<br>\ts.<span class=\"hljs-built_in\">PrintStudentInfo</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308041550105.png\" alt=\"image.png\"></p>\n<p>上面结构体的定义，在 C++ 中更喜欢用<code>class</code>来代替。</p>\n<h3 id=\"2-类的定义\"><a href=\"#2-类的定义\" class=\"headerlink\" title=\"2. 类的定义\"></a>2. 类的定义</h3><p>语法结构：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">className</span> &#123;<br> <span class=\"hljs-comment\">// 类体：由成员函数和成员变量组成</span><br><br>&#125;; <span class=\"hljs-comment\">// 要注意后面的分号</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>class</code>为定义类的关键字</li>\n<li><code>ClassName</code>为类的名字</li>\n<li><code>&#123;&#125;</code>中为类的主体</li>\n<li>注意类定义结束时后面分号。</li>\n</ul>\n<p>类中的元素称为<strong>类的成员</strong>，类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>。 类中的函数称为<strong>类的方法</strong>或者<strong>成员函数</strong>。</p>\n<p>类的两种定义方式：</p>\n<ol>\n<li>声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</li>\n<li>声明放在.h文件中，类的定义放在<code>cpp</code>文件中。推荐使用！</li>\n</ol>\n<h3 id=\"3-类的访问限定符及封装\"><a href=\"#3-类的访问限定符及封装\" class=\"headerlink\" title=\"3. 类的访问限定符及封装\"></a>3. 类的访问限定符及封装</h3><ol>\n<li><strong>访问限定符：</strong></li>\n</ol>\n<p><code>C++</code>实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。</p>\n<p>访问限定符说明：</p>\n<ol>\n<li><code>public</code> 修饰的成员在类外可以直接被访问</li>\n<li><code>protected</code> 和 <code>private</code> 修饰的成员在类外不能直接被访问(此处 <code>protected</code> 和 <code>private</code> 是类似的)</li>\n<li>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</li>\n<li><code>class</code> 的默认访问权限为 <code>private</code>，<code>struct</code> 为 <code>public</code> (因为 <code>struct</code> 兼容 C) 注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</li>\n</ol>\n<blockquote>\n<ul>\n<li>问：C++ 中 <code>struct</code> 和 <code>class</code> 的区别是什么？</li>\n<li>答：C++ 需要兼容 C 语言，所以 C++ 中 <code>struct</code> 可以当成结构体去使用。另外 C++ 中 <code>struct</code> 还可以用来定义类。 和 <code>class</code> 是定义类是一样的，区别是 <code>struct</code> 的成员默认访问方式是 <code>public</code>，<code>class</code> 的成员默认访问方式是 <code>private</code>。</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li><strong>封装</strong></li>\n</ol>\n<p>面向对象的三大特性：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>。</p>\n<p>在类和对象阶段，我们只研究类的封装特性，接下来讨论封装。</p>\n<blockquote>\n<p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p>\n</blockquote>\n<p>封装本质上是一种管理：</p>\n<p>使用类数据和方法都封装到一下。 不想给别人看到的，使用 <code>protected</code> &#x2F; <code>private</code> 把成员封装起来。开放一些共有的成员函数对成员合理的访问。所以封装本质是一种管理。</p>\n<h3 id=\"4-类的作用域\"><a href=\"#4-类的作用域\" class=\"headerlink\" title=\"4. 类的作用域\"></a>4. 类的作用域</h3><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外定义成员，需要使用<code>::</code>作用域解析符指明成员属于哪个类域。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span>&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintPersonInfo</span><span class=\"hljs-params\">()</span></span>;<br>\t<span class=\"hljs-keyword\">private</span>:<br>\t\t<span class=\"hljs-type\">char</span> _name[<span class=\"hljs-number\">20</span>];<br>\t\t<span class=\"hljs-type\">char</span> _gender[<span class=\"hljs-number\">3</span>];<br>\t\t<span class=\"hljs-type\">int</span> _age;<br>&#125;;<br><br><span class=\"hljs-comment\">// 这里需要指定 PrintPersonInfo 是属于 Person 这个类域</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Person::PrintPersonInfo</span><span class=\"hljs-params\">()</span></span>&#123;<br>\tcout&lt;&lt;_name&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>&lt;&lt;_gender&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>&lt;&lt;_age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-类的实例化\"><a href=\"#5-类的实例化\" class=\"headerlink\" title=\"5. 类的实例化\"></a>5. 类的实例化</h3><p><strong>用类类型创建对象的过程</strong>，称为类的实例化。</p>\n<ol>\n<li>类只是一个模型一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它。</li>\n<li>一个类可以实例化出多个对象，实例化出的对象 占用实际的物理空间，存储类成员变量。</li>\n<li>做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li>\n</ol>\n<h3 id=\"6-类对象模型\"><a href=\"#6-类对象模型\" class=\"headerlink\" title=\"6. 类对象模型\"></a>6. 类对象模型</h3><p><strong>如何计算类对象的大小</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> <br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; _a &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span> _a;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(A) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大 小？ 类中既有成员，又有成员函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A1</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f1</span><span class=\"hljs-params\">()</span></span>&#123;&#125;<br>\t<span class=\"hljs-keyword\">private</span>:<br>\t\t<span class=\"hljs-type\">int</span> _a;<br>&#125;;<br><br><span class=\"hljs-comment\">// 类中仅有成员函数</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A2</span> &#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 类中什么都没有---空类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A3</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>解：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">sizeof</span>(A1) :<span class=\"hljs-number\">4</span><br><span class=\"hljs-built_in\">sizeof</span>(A2) :<span class=\"hljs-number\">1</span><br><span class=\"hljs-built_in\">sizeof</span>(A3) :<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>结论：</p>\n<p>一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类 <strong>一个字节</strong> 来唯一标识这个类。</p>\n<h3 id=\"7-this-指针\"><a href=\"#7-this-指针\" class=\"headerlink\" title=\"7. this 指针\"></a>7. this 指针</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Date</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Display</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; _year &lt;&lt; <span class=\"hljs-string\">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class=\"hljs-string\">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetDate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)</span> </span>&#123;<br>\t\t_year = year;<br>\t\t_month = month;<br>\t\t_day = day;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _year; <span class=\"hljs-comment\">// 年</span><br>\t<span class=\"hljs-type\">int</span> _month; <span class=\"hljs-comment\">// 月</span><br>\t<span class=\"hljs-type\">int</span> _day; <span class=\"hljs-comment\">// 日</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tDate d1, d2;<br><br>\td1.<span class=\"hljs-built_in\">SetDate</span>(<span class=\"hljs-number\">2018</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>);<br>\td2.<span class=\"hljs-built_in\">SetDate</span>(<span class=\"hljs-number\">2018</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>);<br><br>\td1.<span class=\"hljs-built_in\">Display</span>();<br>\td2.<span class=\"hljs-built_in\">Display</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于上述类，有这样的一个问题： <code>Date</code> 类中有 <code>SetDate</code> 与 <code>Display</code> 两个成员函数，函数体中没有关于不同对象的区分，那当 <code>s1</code> 调用 <code>SetDate</code> 函数时，该函数是如何知道应该设置 <code>s1</code> 对象，而不是设置 <code>s2</code> 对象呢？</p>\n<p>C++ 中通过引入 <code>this</code> 指针解决该问题，即：C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p>\n<h3 id=\"8-this-指针特性\"><a href=\"#8-this-指针特性\" class=\"headerlink\" title=\"8. this 指针特性\"></a>8. this 指针特性</h3><ul>\n<li><code>this</code>指针的类型：<code>类类型* const</code>。</li>\n<li>只能在“成员函数”的内部使用。</li>\n<li><code>this</code>指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给<code>this</code>形参。所以对象中不存储<code>this</code>指针。</li>\n<li><code>this</code>指针是成员函数第一个隐含的指针形参，一般情况由编译器通过<code>ecx</code>寄存器自动传递，不需要用户传递。</li>\n</ul>\n<h2 id=\"2-构造函数和析构函数\"><a href=\"#2-构造函数和析构函数\" class=\"headerlink\" title=\"2. 构造函数和析构函数\"></a>2. 构造函数和析构函数</h2><h3 id=\"1-构造函数\"><a href=\"#1-构造函数\" class=\"headerlink\" title=\"1. 构造函数\"></a>1. 构造函数</h3><ul>\n<li>因只有对象创建时，才会分配空间，类中非静态数据成员不能够在类内直接初始化或赋值，C++ 提供了构造函数对类的数据成员进行初始化，或者是赋值。</li>\n<li>C++ 中类的默认构造函数是一个空函数，什么也不做，如果用户在类中声明了构造函数，默认构造函数就不再起作用了。</li>\n<li>构造函数没有返回值，名字与类名相同。</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ol>\n<li>类的构造函数支持函数重载。</li>\n<li>类的构造函数一般作为类的公有(public)成员函数，在创建对象时可成功调用构造函数，若作为私有(private)或(protected)成员函数，在类外创建对象时是无法访问的。</li>\n<li>类的构造函数有形参时可指定默认值，用法跟普通函数设置默认值一样，形参可全部指定默认值，也可部分默认值，部分有默认值也是从右向左连续指定，随意给形参指定默认值会报错，这与普通的函数给形参指定默认值用法一致。</li>\n<li>使用没有形参的构造函数时，定义对象时不需要加括号，使用有形参的构造函数，如果形参全部有默认值，也可以不传参数，也是不用加括号。</li>\n<li>构造函数除了对数据成员进行赋值外，还可以利用初始化列表对数据成员进行初始化，参数列表只需要在定义的时候写上就行了，初始化和赋值的区别在于，初始化是数据成员在定义的时候完成的( 像 <code>int a = 10;</code> 这是初始化 )，赋值是数据成员定义之后进行的( 像 <code>int b; b = 12;</code> 这是赋值 )，在重载的情况中，执行哪个构造函数就执行哪个初始化列表。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> nn, <span class=\"hljs-type\">double</span> dd, <span class=\"hljs-type\">char</span> cc) <br>        : <span class=\"hljs-built_in\">d</span>(dd), <span class=\"hljs-built_in\">n</span>(nn), <span class=\"hljs-built_in\">c</span>(cc) <br>    &#123;<br>        n = <span class=\"hljs-number\">10</span>;<br>        d = <span class=\"hljs-number\">3.4</span>;<br>        c = <span class=\"hljs-string\">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; d &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> n;<br>    <span class=\"hljs-type\">double</span> d;<br>    <span class=\"hljs-type\">char</span> c;<br>&#125;;<br><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2.1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>)</span></span>;<br>test.<span class=\"hljs-built_in\">show</span>();<br><span class=\"hljs-comment\">// 运行结果：10 3.4 b</span><br><span class=\"hljs-comment\">// 构造函数可以理解为，定义时先用参数列表对数据成员进行初始化，然后又对数据成员进行赋值，最后的值是赋值的结果</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>初始化列表顺序对数据初始化的顺序是没有影响的，数据初始化的顺序与类中声明的顺序一致</li>\n<li>类中数据成员有引用或者是 const 类型必须进行初始化，这两种类型不支持赋值操作</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span>&amp; nn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> dd) <br>        : <span class=\"hljs-built_in\">d</span>(dd), <span class=\"hljs-built_in\">n</span>(nn)<br>    &#123; &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span>&amp; n;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> d;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">5</span>;<br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(n, <span class=\"hljs-number\">3.5</span>)</span></span>;<br>test.<span class=\"hljs-built_in\">show</span>();<br><span class=\"hljs-comment\">// 运行结果：5 3.5</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-析构函数\"><a href=\"#2-析构函数\" class=\"headerlink\" title=\"2. 析构函数\"></a>2. 析构函数</h3><ul>\n<li>形式是构造函数名字前面加一个 “~”</li>\n<li>析构函数只有一个没有重载</li>\n<li>析构函数也没有形参</li>\n<li>析构函数是在对象生命周期结束时自动调用的，它负责清理工作</li>\n<li>与构造函数相同，类中都包含一个默认的析构函数，若类中声明了析构函数，默认的析构函数就失去了作用</li>\n</ul>\n<h2 id=\"3-深拷贝和浅拷贝\"><a href=\"#3-深拷贝和浅拷贝\" class=\"headerlink\" title=\"3. 深拷贝和浅拷贝\"></a>3. 深拷贝和浅拷贝</h2><p>在了解拷贝前，我们需要先知道 <strong>拷贝构造函数</strong> 的本质</p>\n<ul>\n<li>拷贝构造本质上也是构造函数</li>\n<li>参数是所在类的常引用的构造函数</li>\n<li>类中默认的拷贝构造函数，实现的是逐个复制非静态成员(成员的复制称为浅复制)值，复制的是成员的值，这种类中默认的拷贝构造函数实现的过程被称为浅拷贝</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ====== 浅拷贝示例代码 ======</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> nn, <span class=\"hljs-type\">double</span> dd) <br>        : <span class=\"hljs-built_in\">n</span>(nn), <span class=\"hljs-built_in\">d</span>(dd)<br>    &#123; &#125;<br><br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp; t) <span class=\"hljs-comment\">// 定义拷贝构造函数</span><br>        : <span class=\"hljs-built_in\">n</span>(t.n), <span class=\"hljs-built_in\">d</span>(t.d)<br>    &#123; &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        cout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> n;<br>    <span class=\"hljs-type\">double</span> d;<br>&#125;;<br><br><span class=\"hljs-comment\">// 调用：实例化一个对象，并用这个对象去初始化另一个对象时就会调用类的拷贝构造函数</span><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2.5</span>)</span></span>; <span class=\"hljs-comment\">// 实例化一个对象</span><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">(t)</span></span>;  <span class=\"hljs-comment\">// 用对象t初始化另一个对象，调用拷贝构造函数</span><br>Test test2 = t; <span class=\"hljs-comment\">// 通过重载的 &quot;=&quot; 初始化对象，调用拷贝构造函数</span><br>Test* test3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Test</span>(t);  <span class=\"hljs-comment\">// 调用拷贝构造函数初始化对象</span><br><span class=\"hljs-keyword\">delete</span> test3;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>浅拷贝方式对于一般的数据成员是”OK”的，当遇到实例化对象时在构造函数中为其申请了堆区的空间，在析构函数中对申请的堆区空间进行释放，不调用拷贝构造函数也是”OK”的，但系统默认的拷贝构造函数进行的是浅拷贝，它会把指针的值也同样复制给另一个对象的同一个成员，这样两个对象同时指向的是一块堆区空间，在对象生命周期结束时，它们都会调用各自的析构函数释放同一块空间，这就导致了空间的重复释放，这是浅拷贝存在的问题</li>\n<li>针对浅拷贝存在的问题，出现了深拷贝来解决这个问题，在深拷贝构造函数中，它不是再进行简单的给指针变量复制地址，而是给指针变量同样申请一块空间，这样在对象生命周期结束的时候调用析构函数就不会出现重复释放空间的问题了，这就是深拷贝的主要作用</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// ====== 浅拷贝 ======</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> n) <br>    : <span class=\"hljs-built_in\">p</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(n))<br>    &#123; &#125;<br><br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp; t) <br>        : <span class=\"hljs-built_in\">p</span>(t.p)<br>    &#123; &#125;<br><br>    ~<span class=\"hljs-built_in\">Test</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span>* p;<br>&#125;;<br><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(t)</span></span>;<br><span class=\"hljs-comment\">// 程序运行出错，重复释放内存</span><br><br><span class=\"hljs-comment\">// ====== 深拷贝 ======</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> n)<br>        : <span class=\"hljs-built_in\">p</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(n))<br>    &#123; &#125;<br><br>    <span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp; t) <br>        : <span class=\"hljs-built_in\">p</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(*t.p))<br>    &#123; &#125;<br><br>    ~<span class=\"hljs-built_in\">Test</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span> p;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span>* p;<br>&#125;;<br><br><span class=\"hljs-function\">Test <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(t)</span></span>;<br><span class=\"hljs-comment\">// 程序正常运行</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-浅拷贝和深拷贝原理\"><a href=\"#1-浅拷贝和深拷贝原理\" class=\"headerlink\" title=\"1. 浅拷贝和深拷贝原理\"></a>1. 浅拷贝和深拷贝原理</h3><p>拷贝就是 <strong>复制</strong>，创建副本。假设有对象A，A有属性t1、t2。那么，通过拷贝 A 得到 B，那么 B 应该有属性 t1、t2，且A、B两个对象的每个属性，都应该是相同的。</p>\n<p>对于基本类型的属性 t1，拷贝是没有疑义的。简单将值复制一份，就达到了拷贝的效果。而对于引用类型的属性 t2 来说，拷贝就有了两层含义：</p>\n<ul>\n<li>第一层是，只是将 t2 引用的地址复制一份给 B 的 t2，确实达到了属性相同的效果，可以理解为实现了拷贝，但是事实上，两个对象中的属性 t2 对应的是同一个对象。在 B 对象上对 t2 所指向的对象进行操作，就会影响到 A 对象中的 t2 的值。</li>\n<li>第二层是，将 A 的 t2 所指向的对象，假设为 o1，完整复制一份，假设为 o2，将新的 o2 的地址给 B 的 t2。也达到了复制的效果，且对 B 的 t2 所指向的 o2 进行操作，不会影响到 A 的 t2 所指向的 o1。</li>\n</ul>\n<p>拷贝的两层含义，对应了浅拷贝和深拷贝的概念，做了第一层，就是浅拷贝，做到第二层，就是深拷贝。</p>\n<p><strong>总结</strong>：</p>\n<ul>\n<li><p><strong>浅拷贝</strong>：位拷贝，拷贝构造函数，赋值重载<br>  多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏</p>\n</li>\n<li><p><strong>深拷贝</strong>：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符。</p>\n</li>\n</ul>\n<p>简而言之：深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p>\n<h3 id=\"2-浅拷贝和深拷贝实现\"><a href=\"#2-浅拷贝和深拷贝实现\" class=\"headerlink\" title=\"2. 浅拷贝和深拷贝实现\"></a>2. 浅拷贝和深拷贝实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// --- 浅拷贝实现 ---</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Light</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">Light</span>() : <span class=\"hljs-built_in\">a</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">b</span>(<span class=\"hljs-number\">0</span>) &#123;&#125;;<br>\t<span class=\"hljs-built_in\">Light</span>(<span class=\"hljs-type\">int</span> A, <span class=\"hljs-type\">int</span> B) : <span class=\"hljs-built_in\">a</span>(A), <span class=\"hljs-built_in\">b</span>(B) &#123;&#125;;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;a = &quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span>-&gt;a &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;b = &quot;</span> &lt;&lt; <span class=\"hljs-keyword\">this</span>-&gt;b &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> a;<br>\t<span class=\"hljs-type\">int</span> b;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br>\t<span class=\"hljs-type\">int</span> b = <span class=\"hljs-number\">20</span>;<br><br>\t<span class=\"hljs-function\">Light <span class=\"hljs-title\">obj1</span><span class=\"hljs-params\">(a, b)</span></span>;<br>\tLight obj2 = obj1;<br><br>\tobj2.<span class=\"hljs-built_in\">show</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308072222418.png\" alt=\"image.png\"></p>\n<p><strong>实现 String 类来了解 深拷贝：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// --- 深拷贝实现 ---</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;new&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* str = <span class=\"hljs-literal\">nullptr</span>)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot; 默认构造函数:&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (str)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// strlen从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，</span><br>\t\t\t<span class=\"hljs-comment\">// 直到碰到第一个字符串结束符&#x27;\\0&#x27;为止，然后返回计数器值(长度不包含&#x27;\\0&#x27;)</span><br>\t\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str) + <span class=\"hljs-number\">1</span>];<br>\t\t\t<span class=\"hljs-comment\">// strcpy把含有&#x27;\\0&#x27;结束符的字符串复制到另一个地址空间</span><br>\t\t\t<span class=\"hljs-built_in\">strcpy</span>(data_, str);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//new 数组类型 与delete []对应</span><br>\t\t\t*data_ = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\t<br>\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t<span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;拷贝构造：&quot;</span> &lt;&lt; endl;<br>\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str.data_) + <span class=\"hljs-number\">1</span>];<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(data_, str.data_);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 赋值重载  返回 *this 用以支持连续赋值 s1 = s2 = s3;赋值过程从右向左</span><br>    <span class=\"hljs-comment\">// 先执行 s2.operator=(s3) 如果返回void 导致，s1.operator=(void )导致失败</span><br>\tString&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; str)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;赋值重载：&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">delete</span>[] data_;<br><br>\t\tdata_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str.data_) + <span class=\"hljs-number\">1</span>];<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(data_, str.data_);<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t<span class=\"hljs-comment\">// 释放内存</span><br>\t~<span class=\"hljs-built_in\">String</span>() &#123;<br>\t\t<span class=\"hljs-keyword\">delete</span>[] data_;<br>\t\tdata_ = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* data_ = <span class=\"hljs-literal\">nullptr</span>;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tString s1;<span class=\"hljs-comment\">//默认构造函数</span><br>\t<span class=\"hljs-function\">String <span class=\"hljs-title\">s2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;123&quot;</span>)</span></span>;<span class=\"hljs-comment\">//默认构造函数</span><br>\tString s3 = s2;<span class=\"hljs-comment\">//拷贝构造函数</span><br>\tString s4 = <span class=\"hljs-string\">&quot;hello&quot;</span>;<span class=\"hljs-comment\">//默认构造函数</span><br>\t<span class=\"hljs-function\">String <span class=\"hljs-title\">s5</span><span class=\"hljs-params\">(s4)</span></span>;<span class=\"hljs-comment\">//拷贝构造函数   是构造过程发生</span><br>\tString s6;<br>\ts6 = s5;<span class=\"hljs-comment\">//=重载  是赋值，左右两边的对象都已经存在</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4-类和对象代码应用实践\"><a href=\"#4-类和对象代码应用实践\" class=\"headerlink\" title=\"4. 类和对象代码应用实践\"></a>4. 类和对象代码应用实践</h2><p><strong>实现：循环队列</strong></p>\n<p>当队列空时，条件就是 <code>front = rear</code>，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。 如下图所示，我们就认为此队列已经满了</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080817183.png\" alt=\"image.png\"></p>\n<p>由于 rear 可能比 front 大，也可能比 front 小，所以尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的最大尺寸QueueSize，那么队列满的条件是 <code>(rear+1) %QueueSize == front</code> (取模“%的目的就是为了整合 rear 与 front 大小为一个问题)。</p>\n<p>比如：QueueSize &#x3D; 5，当 front&#x3D;0，而 rear&#x3D;4, (4+1) %5 &#x3D; 0，所以此时队列满。再比如，front &#x3D; 2而rear &#x3D;1。(1 + 1) %5 &#x3D; 2，所以此时 队列也是满的。而对于下图, front &#x3D; 2而rear&#x3D; 0, (0+1) %5 &#x3D; 1，1!&#x3D;2,所以此时队列并没有满。</p>\n<p>另外，当 <code>rear &gt; front</code> 时，此时队列的长度为 <code>rear—front</code>。但当rear &lt; front时，队列长度分为两段，一段是 <code>QueueSize-front</code>，另一段是0 + rear，加在一起，队列长度为 <code>rear-front + QueueSize</code></p>\n<p>因此通用的计算队列长度公式为：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">(rear — front + QueueSize) % QueueSize<br></code></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<ul>\n<li>队空条件：front &#x3D;&#x3D; rear</li>\n<li>队满条件：(rear+1) %QueueSize &#x3D;&#x3D; front</li>\n<li>队列长度：(rear—front + QueueSize) % QueueSize</li>\n</ul>\n<p><strong>实现：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 初始化构造</span><br>\t<span class=\"hljs-built_in\">Queue</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">20</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 创建队列</span><br>\t\tqueue_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size];<br>\t\t<span class=\"hljs-comment\">// 初始化值</span><br>\t\tfront_ = <span class=\"hljs-number\">0</span>;<br>\t\trear_ = <span class=\"hljs-number\">0</span>;<br>\t\tsize_ = size;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 拷贝构造</span><br>\t<span class=\"hljs-built_in\">Queue</span>(<span class=\"hljs-type\">const</span> Queue* queue) &#123;<br>\t\t<span class=\"hljs-comment\">// 传值</span><br>\t\tsize_ = queue-&gt;size_;<br>\t\tfront_ = queue-&gt;front_;<br>\t\trear_ = queue-&gt;rear_;<br>\t\tqueue_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size_];<br><br>\t\t<span class=\"hljs-comment\">// 扩展</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = front_; i != rear_; i = (i + <span class=\"hljs-number\">1</span>) % size_)<br>\t\t&#123;<br>\t\t\tqueue_[i] = queue_[i];<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 复制重构</span><br>\tQueue&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Queue&amp; q) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;q)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-keyword\">delete</span> queue_;<br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tsize_ = q.size_;<br>\t\tfront_ = q.front_;<br>\t\trear_ = q.rear_;<br>\t\tqueue_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size_];<br><br>\t\t<span class=\"hljs-comment\">// 扩展</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = front_; i != rear_; i = (i + <span class=\"hljs-number\">1</span>) % size_)<br>\t\t&#123;<br>\t\t\tqueue_[i] = q.queue_[i];<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">Queue</span>() &#123;<br>\t\t<span class=\"hljs-keyword\">delete</span>[] queue_;<br>\t\tqueue_ = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 队列方法：</span><br>\t<span class=\"hljs-comment\">// 1. push：放入元素</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">resize</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 从队尾放置</span><br>\t\tqueue_[rear_] = val;<br>\t\t<span class=\"hljs-comment\">// 计算下一个位置</span><br>\t\trear_ = (rear_ + <span class=\"hljs-number\">1</span>) % size_;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. 出队方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br><br>\t\tfront_ = (front_ + <span class=\"hljs-number\">1</span>) % size_;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4. 获取对头</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> queue_[front_];<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 3. 判断是否为空</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> rear_ == front_;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 私密方法：</span><br>\t<span class=\"hljs-comment\">// 1. 扩容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">resize</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 扩容 2 倍</span><br>\t\t<span class=\"hljs-type\">int</span>* tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[size_ * <span class=\"hljs-number\">2</span>];<br>\t\t<span class=\"hljs-type\">int</span> index = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-comment\">// 拷贝值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = front_; i != rear_; i = (i + <span class=\"hljs-number\">1</span>) % size_)<br>\t\t&#123;<br>\t\t\ttmp[index] = queue_[i];<br>\t\t\tindex++;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清除原先数值</span><br>\t\t<span class=\"hljs-keyword\">delete</span> queue_;<br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tqueue_ = tmp;<br>\t\tfront_ = <span class=\"hljs-number\">0</span>;<br>\t\trear_ = index++;<br>\t\tsize_ *= <span class=\"hljs-number\">2</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. 是否已满</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (rear_ + <span class=\"hljs-number\">1</span>) % size_ == front_;<br>\t&#125;<br><br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 队列</span><br>\t<span class=\"hljs-type\">int</span>* queue_;<br>\t<span class=\"hljs-comment\">// 对头</span><br>\t<span class=\"hljs-type\">int</span> front_;<br>\t<span class=\"hljs-comment\">// 队尾</span><br>\t<span class=\"hljs-type\">int</span> rear_;<br>\t<span class=\"hljs-comment\">// 队列扩列大小</span><br>\t<span class=\"hljs-type\">int</span> size_;<br>&#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建对象</span><br>\tQueue q1;<br>\tQueue q2;<br><br>\t<span class=\"hljs-comment\">// 放入元素</span><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++) &#123;<br>\t\tq1.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">20</span>; i &lt; <span class=\"hljs-number\">40</span>; i++)<br>\t&#123;<br>\t\tq2.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\tq1 = q2;<br><br><br>\t<span class=\"hljs-comment\">// 获取元素</span><br>\t<span class=\"hljs-keyword\">while</span> (!q1.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; q1.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tq1.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-构造函数的初始化列表\"><a href=\"#5-构造函数的初始化列表\" class=\"headerlink\" title=\"5. 构造函数的初始化列表\"></a>5. 构造函数的初始化列表</h2><p>构造函数初始化列表的情况有三种：</p>\n<ol>\n<li>需要初始化的类的成员变量是对象的情况；</li>\n<li>需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量；</li>\n<li>子类初始化父类的成员；</li>\n</ol>\n<p><strong>情况1：类的成员变量是对象，并且这个对象只有含参数的构造函数，没有无参数的构造函数</strong></p>\n<p>如果有一个类的成员变量，它本身是一个类的对象，而且这个成员变量需要带参数的构造函数进行初始化，这时要对这个类的成员变量进行初始化，就必须调用这个类的成员变量的带参数的构造函数，如果没有初始化列表，那么将无法完成这一步，出现报错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> x;<br>\t<span class=\"hljs-type\">int</span> y;<br>\t<span class=\"hljs-type\">int</span> z;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyTest</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">MyTest</span>() : <span class=\"hljs-built_in\">test</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) &#123;       <span class=\"hljs-comment\">// 初始化值</span><br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;MyTest&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tTest test;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tMyTest t1;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>因为 Test 有了显示的带参数的构造函数，那么它是无法依靠编译器生成无参构造函数的，所以没有三个 int 型数据，就无法创建 Test 的对象。Test 类对象是 MyTest 的成员，想要初始化这个对象 test，那就只能用成员初始化列表，没有其它办法将参数传递给 Test 类构造函数。</p>\n<p><strong>情况2：需要初始化的类的成员变量由 const 修饰的或初始化的类的引用成员变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>() :<span class=\"hljs-built_in\">a</span>(<span class=\"hljs-number\">10</span>) &#123;&#125;           <span class=\"hljs-comment\">//初始化</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a;             <span class=\"hljs-comment\">//const成员声明</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 或</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">int</span> _a) :<span class=\"hljs-built_in\">a</span>(_a) &#123;&#125;      <span class=\"hljs-comment\">//初始化</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span>&amp; a;                 <span class=\"hljs-comment\">//声明</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>**情况3：子类初始化父类的成员变量，需要在(并且也只能在)参数初始化列表中显示调用父类的构造函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Test</span>()&#123;&#125;;<br>    <span class=\"hljs-built_in\">Test</span> (<span class=\"hljs-type\">int</span> x)&#123; int_x = x;&#125;;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span>&#123;cout&lt;&lt; int_x &lt;&lt; endl;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> int_x;<br>&#125;;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Mytest</span>:<span class=\"hljs-keyword\">public</span> Test<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Mytest</span>() ：<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-number\">110</span>) <span class=\"hljs-comment\">//调用父类的构造函数</span><br>    &#123;<br>      <span class=\"hljs-comment\">//Test(110);       //  构造函数只能在初始化列表中被显示调用，不能在构造函数内部被显示调用</span><br>    &#125;;<br>&#125;;<br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br> Test *p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Mytest</span>();<br> p-&gt;<span class=\"hljs-built_in\">show</span>();<br> <br> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>执行顺序：</p>\n<p>在对象构建过程中，如果有构造函数初始化列表，首先执行初始化列表中的内容，然后执行构造函数。并且，初始化列表中数据的构造顺序并不是按照在初始化列表中的先后顺序进行的，而是根据初始化列表中数据所在当前类中的定义顺序决定的。</p>\n<h2 id=\"6-类的各种成员方法及区别\"><a href=\"#6-类的各种成员方法及区别\" class=\"headerlink\" title=\"6. 类的各种成员方法及区别\"></a>6. 类的各种成员方法及区别</h2><p>C++ 中，成员函数可以分为普通成员函数、静态成员函数和const成员函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Date</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Date</span>(<span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)<br>\t\t: <span class=\"hljs-built_in\">year_</span>(year)<br>\t\t, <span class=\"hljs-built_in\">month_</span>(month)<br>\t\t, <span class=\"hljs-built_in\">day_</span>(day)<br>\t&#123;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;year：&quot;</span> &lt;&lt; year_ &lt;&lt; <span class=\"hljs-string\">&quot; month：&quot;</span> &lt;&lt; month_ &lt;&lt; <span class=\"hljs-string\">&quot; day：&quot;</span> &lt;&lt; day_ &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> year_;<br>\t<span class=\"hljs-type\">int</span> month_;<br>\t<span class=\"hljs-type\">int</span> day_;<br>&#125;;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">\t继承：a kind of，一种</span><br><span class=\"hljs-comment\">\t组合：a part of，一部分</span><br><span class=\"hljs-comment\">\t商品日期更像是商品的一部分，应该用组合的方式</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Goods</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Goods</span>(<span class=\"hljs-type\">int</span> id, string name, <span class=\"hljs-type\">int</span> price, <span class=\"hljs-type\">int</span> year, <span class=\"hljs-type\">int</span> month, <span class=\"hljs-type\">int</span> day)<br>\t\t: <span class=\"hljs-built_in\">date_</span>(year, month, day)<br>\t\t, <span class=\"hljs-built_in\">id_</span>(id)<br>\t\t, <span class=\"hljs-built_in\">name_</span>(name)<br>\t\t, <span class=\"hljs-built_in\">price_</span>(price)<br>\t&#123;<br>\t\tcount_++;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span>\t<span class=\"hljs-type\">const</span> \t</span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tdate_.<span class=\"hljs-built_in\">show</span>();<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;id：&quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot; name：&quot;</span> &lt;&lt; name_ &lt;&lt; <span class=\"hljs-string\">&quot; price：&quot;</span> &lt;&lt; price_ &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getCount</span><span class=\"hljs-params\">()</span>\t\t<span class=\"hljs-comment\">//静态成员函数</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> count_;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\tDate date_;<br>\t<span class=\"hljs-type\">int</span> id_;<br>\tstring name_;<br>\t<span class=\"hljs-type\">int</span> price_;<br>\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> count_;\t\t<span class=\"hljs-comment\">//静态成员变量的声明</span><br>&#125;;<br><br><span class=\"hljs-type\">int</span> Goods::count_ = <span class=\"hljs-number\">0</span>;\t\t<span class=\"hljs-comment\">//静态成员变量的初始化</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-静态成员变量\"><a href=\"#1-静态成员变量\" class=\"headerlink\" title=\"1. 静态成员变量\"></a>1. 静态成员变量</h3><p>静态成员变量在类内声明，在类外定义初始化<br>静态成员变量可以用类引用，也可以通过对象引用</p>\n<h3 id=\"2-静态成员函数\"><a href=\"#2-静态成员函数\" class=\"headerlink\" title=\"2.静态成员函数\"></a>2.静态成员函数</h3><p>静态成员函数不能使用普通成员变量，能使用静态成员变量<br>静态成员函数可以通过类调用，也可以通过对象调用</p>\n<h3 id=\"3-const-成员函数\"><a href=\"#3-const-成员函数\" class=\"headerlink\" title=\"3. const 成员函数\"></a>3. const 成员函数</h3><p>一般将不修改成员变量的成员函数用 const 修饰，因为 const 对象只能调用 const 成员函数。<br>const 成员函数既能够被普通对象调用，也能被 const 对象调用</p>\n<h2 id=\"7-指向类成员的指针\"><a href=\"#7-指向类成员的指针\" class=\"headerlink\" title=\"7. 指向类成员的指针\"></a>7. 指向类成员的指针</h2><p>成员指针是 C++ 引入的一种新机制，它的申明方式和使用方式都与一般的指针有所不同。成员指针分为成员函数指针和数据成员指针。</p>\n<h3 id=\"1-成员函数指针\"><a href=\"#1-成员函数指针\" class=\"headerlink\" title=\"1. 成员函数指针\"></a>1. 成员函数指针</h3><p>在事件驱动和多线程应用中被广泛用于调用回调函数。在多线程应用中，每个线程都通过指向成员函数的指针来调用该函数。在这样的应用中，如果不用成员指针，编程是非常困难的。成员函数指针的定义格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">成员函数返回类型 （类名::*指针名）（形参）= &amp;类名::成员函数名<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>(string s) &#123;<br>\t\tname = s;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>\t&#125;<br>\t<br><span class=\"hljs-keyword\">private</span>:<br>\tstring name;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">A <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;lisa&quot;</span>)</span></span>;<br>\t<span class=\"hljs-comment\">// 定义类长远函数指针并赋初始值</span><br>\t<span class=\"hljs-built_in\">void</span>(A::*memp)() = &amp;A::print;<br>\t(a.*memp)();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080920135.png\" alt=\"image.png\"></p>\n<p>使用成员函数指着注意两点：</p>\n<p>（1）使用成员函数指针时需要指明成员函数所属的类对象，因为通过指向成员函数的指针调用该函数时，需要将对象的地址用作this指针的值，以便进行函数调用；<br>（2）为成员函数指针赋值时，需要显示使用 <code>&amp;</code> 运算符，不能直接将 “类名 <code>::</code> 成员函数名”赋给成员函数指针。</p>\n<h3 id=\"2-数据成员指针\"><a href=\"#2-数据成员指针\" class=\"headerlink\" title=\"2. 数据成员指针\"></a>2. 数据成员指针</h3><p>一个类对象生成后，它的某个成员变量的地址实际上由两个因素决定：</p>\n<ul>\n<li>对象的首地址和该成员变量在对象之内的偏移量。</li>\n<li>数据成员指针是用来保存类的某个数据成员在类对象内的偏移量的。它只能用于类的非静态成员变量。</li>\n</ul>\n<p>数据成员指针的定义格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">成员类型 类名::*指针名=&amp;类名::成员名;<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-type\">int</span> age;<br>\t<span class=\"hljs-type\">int</span> score;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">(Student* objs, <span class=\"hljs-type\">int</span> Student::*pm, <span class=\"hljs-type\">int</span> count)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> result = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; count; i++)<br>\t&#123;<br>\t\tresult += objs[i].*pm;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">double</span>(result) / count;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tStudent my[<span class=\"hljs-number\">3</span>] = &#123; &#123;<span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">86</span>&#125;, &#123;<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">80</span>&#125;, &#123;<span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">58</span>&#125; &#125;;<br><br>\t<span class=\"hljs-type\">double</span> ageAver = <span class=\"hljs-built_in\">average</span>(my, &amp;Student::age, <span class=\"hljs-number\">3</span>);<br>\t<span class=\"hljs-type\">double</span> scoreAver = <span class=\"hljs-built_in\">average</span>(my, &amp;Student::score, <span class=\"hljs-number\">3</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ageAver = &quot;</span> &lt;&lt; ageAver &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;scoreAver = &quot;</span> &lt;&lt; scoreAver &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308080957284.png\" alt=\"image.png\"></p>\n<p>使用数据成员指针时，需要注意以下几点：</p>\n<p>（1）数据成员指针作为一个变量，在底层实现上，存放的是对象的数据成员相对于对象首地址的偏移量，因此通过数据成员指针访问成员变量时需要提供对象的首地址，即通过对象来访问。从这个意义上说，数据成员指针并不是一个真正的指针。<br>（2）对象的数据成员指针可以通过常规指针来模拟，例如上面的程序中，可以讲 <code>average()</code> 函数的形参pm可以申明为int型变量，表示数据成员的偏移量，那么原来的<code>obj.*pm</code> 等同于 <code>*(int*)((char*)(&amp;obj)+pm)</code>，显然，这样书写可读性差，可移植性低且容易出错。<br>（3）使用数据成员指针时，被访问的成员往往是类的公有成员，如果是类的私有成员，容易出错。考察如下程序:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayClass</span>  &#123;<br>\t<span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">ArrayClass</span>()  &#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i)<br>\t\t\tarr[i]=i;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 使用数据成员指针作为形参</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printArray</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj,<span class=\"hljs-type\">int</span> (ArrayClass::* pm)[<span class=\"hljs-number\">5</span>])</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i) &#123;<br>\t\tcout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tArrayClass arrObj;<br>\t<span class=\"hljs-built_in\">printArray</span>(arrObj,&amp;ArrayClass::arr);<span class=\"hljs-comment\">//编译出错，提示成员ArrayClass::arr不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>以上程序无法通过编译，因为成员 arr 在类 ArrayClass 中的访问权限设置为 private，无法访问。</p>\n<p>要解决这个问题，将函数 printArray() 设置为类 ArrayClass 的友元函数是不行的，因为是在调用该函数时访问了类 ArrayClass 的私有成员，而不是在函数体内用到类 ArrayClass 的私有成员。因此，可以定义一个调用 printArray() 函数的友元函数。该函数的参数中并不需要传递类 ArrayClass 的私有成员。修改后的程序如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayClass</span> &#123;<br><span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">5</span>];<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">ArrayClass</span>() &#123;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i)<br>\t\t\tarr[i]=i;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj)</span></span>;<br>&#125;;<br><br><span class=\"hljs-comment\">// 使用数据成员指针作为形参</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printArray</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj,<span class=\"hljs-type\">int</span> (ArrayClass::* pm)[<span class=\"hljs-number\">5</span>])</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;++i)<br>\t\tcout&lt;&lt;(arrObj.*pm)[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 定义友元函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(ArrayClass&amp; arrObj)</span> </span>&#123;<br>\t<span class=\"hljs-built_in\">printArray</span>(arrObj,&amp;ArrayClass::arr);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tArrayClass arrObj;<br>\t<span class=\"hljs-comment\">//printArray(arrObj,&amp;ArrayClass::arr);//编译出错，提示成员ArrayClass::arr不可访问</span><br>\t<span class=\"hljs-built_in\">print</span>(arrObj); <span class=\"hljs-comment\">//通过友元函数调用打印数组函数printArray()来访问私有成员</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"C++ 11 新特性","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n","source":"_posts/00.相关知识点/C++ 11 新特性.md","raw":"---\ntitle: C++ 11 新特性\ntags: ['C++', 'C++11', '新特性']\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n","slug":"00.相关知识点/C++ 11 新特性","published":1,"date":"2023-08-07T08:06:18.086Z","updated":"2023-08-07T08:08:36.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll0x5bxe000074pk90nucv1d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"05.C++ 运算符重载","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节分为七个部分：\n\n1. 学习复数类 Complex\n2. 模拟实现 C++ 的 string 类\n3. string 字符串对象的迭代器\n4. vector 容器的迭代器 iterator 实现\n5. 什么是容器的迭代器失效问题\n6. new 和 delete 重载实现的对象池\n7. 深入理解 new 和 delete 的原理\n\n**什么是运算符重载**\n\n运算符重载实质还是一个 函数。\n通过重载运算符，可以让类在一些场景下使用起来更加方便。\n\n**语法**\n\n~~~c++\n返回值类型 operator op (参数);​​​​​​​\n~~~\n\n示例：\n\n~~~c++\nClassType& operator= (const ClassType& src); // 重载 “=” 运算符\n~~~\n\n## 1. 学习复数类 Complex\n\n复数是形如 `a+b` 的数，复数由实部和虚部构成，在 C++ 的模板库中由 complex 类，可以直接调用，包含在complex头文件中，再使用时应该添加 `#include<complex>`。下面介绍一些基本操作\n\n### 1. 生成复数对象\n\ncomplex 类型的构造函数接受两个参数，第一个参数是复数实部的值，第二个参数是虚部的值。要想生成一个复数对象，并且对其值进行修改，参考以下代码：\n\n~~~c++\n#include <iostream>\n#include <complex>\nusing namespace std;\n\nint main()\n{\n\tcomplex<double>x1(2, 3);\n\tcomplex<double>x2;\n\tcomplex<double>x3(x1);\n\n\tcout << \"x1 = \" << x1 << endl;\t\t// x1 = (2, 3)\n\tcout << \"x2 = \" << x2 << endl;\t\t// x2 = (0, 0)\n\tcout << \"x3 = \" << x3 << endl;\t\t// x3 = (2, 3)\n\n\tx1.real(22);\t// 修改实数部\n\tx1.imag(33);\t// 修改虚数部\n\n\tcout << \"x1 = \" << x1 << endl;\t\t// x1 = (22,33)\n\n\tcomplex<double>a, b, c;\n\tcout << \"请输入三个复数：\";\n\tcin >> a >> b >> c;\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\t\t\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100912113.png)\n\n### 2. 复数的运算\n\n复数和实数一样都有加减乘除四则运算，这些运算符号在 complex 模板中已经被重载过，能够直接使用，下面代码示例展示了其功能：\n\n~~~c++\n#include <iostream>\n#include <complex>\nusing namespace std;\n\nint main()\n{\n\tcomplex<double> z(2, 3);\n\tcomplex<double> z1 = z + 5.0;\n\tcout << z1 << endl;\n\tcomplex<double> z2 = z - 5.0;\n\tcout << z2 << endl;\n\tcomplex<double> z3 = z * 2.0;\n\tcout << z3 << endl;\n\tcomplex<double>z4 = z / complex<double>(1, 1);\n\tcout << z4 << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100914081.png)\n\n### 3. 复数的比较\n\n复数的比较需要同时比较实部和虚部是否都相等，有其一不等两数就 不等，下面是示例代码：\n\n~~~c++\n#include <iostream>\n#include <complex>\nusing namespace std;\n\nint main()\n{\n\tcomplex<double> z1(2, 3);\n\tcomplex<double> z2(3, 4);\n\tcomplex<double> z3(2, 3);\n\n\tcout << boolalpha << (z1 == z3) << endl;\n\tcout << boolalpha << (z1 == z2) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100916498.png)\n\n### 4. 实现 Complex 类\n\n~~~c++\n#include <iostream>\n//#include <complex>\nusing namespace std;\n\n// 定义Complex 类\ntemplate<typename T>\nclass Complex\n{\npublic:\n\t// 无参构造函数\n\tComplex()\n\t\t: real(0)\n\t\t, imag(0)\n\t{\n\t\t// 初始化列表\n\t}\n\t// 有参构造函数\n\tComplex(T re, T im)\n\t\t: real(re)\n\t\t, imag(im)\n\t{\n\t\t// 初始化列表\n\t}\n\t// 拷贝构造\n\tComplex(const Complex<T>& com)\n\t\t: real(com.real)\n\t\t, imag(com.imag)\n\t{\n\t\t// 初始化列表\n\t}\n\t// 析构\n\t~Complex()\n\t{\n\t\t// ......\n\t}\n\n\t// 方法\n\t// 1. printComplex 方法\n\tvoid printComplex()\n\t{\n\t\tcout << \"(\" << real << \", \" << imag << \")\" << endl;\n\t}\n\t// 2. + 方法重载：复数的加法\n\tComplex& operator+(const Complex<T>& com)\n\t{\n\t\tthis->real += com.real;\n\t\tthis->imag += com.imag;\n\t\treturn *this;\n\t}\n\t// 3. - 方法重载：复数的减法\n\tComplex& operator-(const Complex<T>& com)\n\t{\n\t\tthis->real -= com.real;\n\t\tthis->imag -= com.imag;\n\t\treturn *this;\n\t}\n\t// 4. * 方法重载：复数的乘法\n\tComplex& operator*(const Complex<T>& com)\n\t{\n\t\tthis->real = (real * com.real) - (imag * com.imag);\n\t\tthis->imag = (real * com.real) + (imag * com.imag);\n\t\treturn *this;\n\t}\n\t// 5. / 方法重载：复数的除法\n\tComplex& operator/(const Complex<T>& com)\n\t{\n\t\tthis->real = (real * com.real + imag * com.imag) / (com.real * com.real + com.imag * com.imag);\n\t\tthis->real = (real * com.real - imag * com.imag) / (com.real * com.real + com.imag * com.imag);\n\t\treturn *this;\n\t}\n\nprivate:\n\tT real;\t// 实部\n\tT imag;\t// 虚部\n};\n\nint main()\n{\n\tComplex<double> c1(2.0, 1.0);\n\tc1.printComplex();\n\tComplex<double> c2(1.0, 3.0);\n\tc2.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc1 = c1 + c2;\n\tcout << \"c1 加法后：\";\n\tc1.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc2 = c2 - c1;\n\tcout << \"c2 减法后：\";\n\tc2.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc1 = c2 * c1;\n\tcout << \"c1 乘法后：\";\n\tc1.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc2 = c2 / c1;\n\tcout << \"c2 除法后：\";\n\tc2.printComplex();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100954476.png)\n\n另一种实现方式：\n\n~~~c++\n#include <iostream>\nusing namespace std;\n \nclass CComplex\n{\npublic:\n\tCComplex(int r = 0, int i = 0)\n\t\t:_mreal(r)\n\t\t,_mimage(i)\n\t{\n\t}\n\tvoid operator=(const CComplex&obj)\n\t{\n\t\tthis->_mreal = obj._mreal;\n\t\tthis->_mimage = obj._mimage;\n\t}\n\t//指导编译器怎么做CComplex类对象的加法操作\n\t/*CComplex operator+(const CComplex&com)\n\t{\n\t\treturn CComplex(this->_mreal + com._mreal,\n\t\t\tthis->_mimage + com._mimage);\n\t}*/\n\tCComplex operator++(int)\n\t{\n\t\treturn CComplex(this->_mreal++, this->_mimage++);\n\t\t/*CComplex comp = *this;\n\t\tthis->_mimage++;\n\t\tthis->_mreal++;\n\t\treturn comp;*/\n\t}\n\tCComplex& operator++()\n\t{\n\t\t_mreal += 1;\n\t\t_mimage += 1;\n\t\treturn *this;\n\t}\n\tvoid operator+=(const CComplex&rhs)\n\t{\n\t\tthis->_mreal += rhs._mreal;\n\t\tthis->_mimage += rhs._mimage;\n\t}\n\tvoid show() { cout << \"real:\" << _mreal << \"image:\" << _mimage << endl; }\nprivate:\n\tint _mreal;\n\tint _mimage;\n\tfriend CComplex operator+(const CComplex &lhs, const CComplex &rhs);\n\tfriend ostream& operator<<(ostream&out, const CComplex&src);\n\tfriend istream& operator>>(istream&in, CComplex&src);\n};\nistream& operator>>(istream&in, CComplex&src)\n{\n\tint a, b;\n\tin >> a >> b;\n\tsrc._mreal = a;\n\tsrc._mimage = b;\n\treturn in;\n}\nostream& operator<<(ostream&out, const CComplex&src)\n{\n\tout << \"real:\" << src._mreal << \"image:\" << src._mimage << endl;\n\treturn out;\n}\nCComplex operator+(const CComplex &lhs, const CComplex &rhs)\n{\n\treturn CComplex(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage);\n}\n\nint main()\n{\n\tCComplex c1(1, 2);\n\tCComplex c2(2, 3);\n\tCComplex c4;\n\t\n\tc4 = c1+c2;\n\tc4.show();\n\t\n\tc4 = c1 + 20;\n\tc4.show();\n\t\n\tc4 = 30 + c2;\n\tc4.show();\n\t\n\tCComplex c5;\n\tc5 = c4++;\n\tc5.show();\n \n\tc5 = ++c4;\n\tc5.show();\n \n\tc5 += c4;\n\tc5.show();\n\tcout << \"++++++++++++++++++++++++++++++\" << endl;\n \n\tcout << c5;\n \n\tCComplex c6;\n\tcin >> c6;\n\tcout << c6;\n\t\n\treturn 0;\n}\n~~~\n\n## 2. 模拟实现 C++ 的 string 类\n\nstring 类中的基本方法有：\n\n1. 构造函数\n2. + 运算符重载\n3. `<<` 运算符重载\n4. > 运算符重载\n5. len 方法\n6. `[]` 运算符重载\n7. 迭代器实现\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    //默认构造函数\n    string str1;\n    string str2 = \"aaa\";\n    string str3 = \"bbb\";\n\n    //+ 运算符重载\n    string str4 = str2 + str3;\n    string str5 = str2 + \"ccc\";\n    string str6 = \"ddd\" + str2;\n\n    // << 运算符重载\n    cout << \"str6:\" << str6 << endl;\n\n    // >  运算符重载\n    if (str5 > str6)\n    {\n        cout << str5 << \" > \" << str6 << endl;\n    }\n    else\n    {\n        cout << str5 << \" < \" << str6 << endl;\n    }\n\n    // 获取长度\n    int len = str6.length();\n    for (int i = 0; i < len; i++)\n    {\n        // []运算符重载\n        cout << str6[i] << \" \";\n    }\n    cout << endl;\n\n    // c_str()\n    char buff[1024] = { 0 };\n    strcpy(buff, str6.c_str());\n    cout << \"buff:\" << buff << endl;\n\n    // 迭代器实现\n    string::iterator it = str2.begin();\n    for (it = str2.begin(); it != str2.end(); ++it) {\n        cout << (*it) << \" \";\n    }\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101003436.png)\n\n### 1. 实现 string\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <ostream>\nusing namespace std;\n\n// 创建 string 类\nclass String\n{\npublic:\n    // 默认构造函数\n    String(const char* p = nullptr)\n    {\n        if (p != nullptr)\n        {\n            // 创建\n            _pstr = new char[strlen(p) + 1];\n            // 拷贝\n            strcpy(_pstr, p);\n        }\n        else\n        {\n            _pstr = new char[1];\n            *_pstr = '\\0';\n        }\n    }\n    // 拷贝构造函数\n    String(const String& str)\n    {\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n    }\n    // 析构函数\n    ~String()\n    {\n        delete[] _pstr;\n        _pstr = nullptr;\n    }\n\n    // 运算符重载\n    // 1. =\n    String& operator=(const String& str)\n    {\n        if (this == &str)\n        {\n            return *this;\n        }\n        delete[] _pstr;\n\n        // 创建\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n        return *this;\n    }\n    // 2. >\n    bool operator>(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) > 0;\n    }\n    // 3. <\n    bool operator<(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) < 0;\n    }\n    // 4. ==\n    bool operator==(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) == 0;\n    }\n    // 5. []\n    char& operator[](int index) \n    { \n        return _pstr[index]; \n    }\n    const char& operator[](int index) const \n    { \n        return _pstr[index]; \n    }\n\n    // 公共方法\n    int length()\n    {\n        return strlen(_pstr);\n    }\n    const char* c_str() const \n    { \n        return _pstr; \n    }\n\n\nprivate:\n    char* _pstr;\n\n    // 由于调用 << 不依赖于特定的对象，设计为全局函数\n    // 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。\n    friend ostream& operator<<(ostream& out, const String& str);\n/************************************************************************/\n  /*\n  重载+；\n  重载+ 有两种方式：\n  (1)定义成成员函数\n  String operator+(const String& s){\n    String tmp;\n    .....\n    return tmp;\n    如 s1 = s2+s3; => s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this\n  }\n  弊端：s1 = \"a\" + s2;无法重载+ ,因为\"a\"不是String类型。\n  （2）重载为全局函数\n  */\n/************************************************************************/\n    friend String operator+(const String& lhs, const String& rhs);\n\n};\n\nostream& operator<<(ostream& out, const String& str)\n{\n    out << str._pstr;\n    return out;\n};\n/*\n合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，\n并以此开辟空间大小，\n换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。\n*/\nString operator+(const String& lhs, const String& rhs)\n{\n    // 计算长度\n    char* _ptmp = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1];\n    // 拷贝\n    strcpy(_ptmp, lhs._pstr);\n    // 合并\n    strcat(_ptmp, rhs._pstr);\n\n    String tmp(_ptmp);\n    delete[]_ptmp;\n    \n    return tmp;\n};\n\nint main()\n{\n    //默认构造函数\n    String str1;\n    String str2 = \"aaa\";\n    String str3 = \"bbb\";\n\n    //+ 运算符重载\n    String str4 = str2 + str3;\n    String str5 = str2 + \"ccc\";\n    String str6 = \"ddd\" + str2;\n\n    // << 运算符重载\n    cout << \"str6:\" << str6 << endl;\n\n    // >  运算符重载\n    if (str5 > str6)\n    {\n        cout << str5 << \" > \" << str6 << endl;\n    }\n    else\n    {\n        cout << str5 << \" < \" << str6 << endl;\n    }\n\n    // 获取长度\n    int len = str6.length();\n    for (int i = 0; i < len; i++)\n    {\n        // []运算符重载\n        cout << str6[i] << \" \";\n    }\n    cout << endl;\n\n    // c_str()\n    char buff[1024] = { 0 };\n    strcpy(buff, str6.c_str());\n    cout << \"buff:\" << buff << endl;\n\n    //\n    //  string::iterator it = str2.begin();\n    // for (it = str2.begin(); it != str2.end(); ++it) {\n     // cout << (*it) << \" \";\n    //}\n\n    return 0;\n}\n~~~\n\n存在的问题：\n\n~~~c++\nString operator+(const String& lhs, const String& rhs)\n{\n    // 计算长度\n    char* _ptmp = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1];\n    // 拷贝\n    strcpy(_ptmp, lhs._pstr);\n    // 合并\n    strcat(_ptmp, rhs._pstr);\n\n    String tmp(_ptmp);\n    delete[]_ptmp;\n    \n    return tmp;\n};\n~~~\n\n为了将局部新开辟的内存空间 `_ptmp` 资源释放，我们后面又构造了一个临时对象 `String tmp(_ptmp)`，之后将局部变量资源释放 `delete[]_ptmp`，但是这样一来的效率非常低！\n\n## 3. string 字符串对象的迭代器\n\n容器的迭代器可以透明的访问容器内部的元素的值\n\n~~~c++\nstring::iterator it = str2.begin();\nfor (it = str2.begin(); it != str2.end(); ++it) {\n cout << (*it) << \" \";\n}\n~~~\n\n迭代器代码：\n\n~~~c++\n    // 迭代器创建\n    class iterator\n    {\n    public:\n        // 构造函数\n        iterator(char *p = nullptr) : _p(p) { }\n        // 拷贝函数\n        iterator(const iterator& iter) : _p(iter._p) { }\n        \n        // 重载运算符\n         // !=  如 it != s1.end()\n        bool operator!=(const iterator& it) {\n            return _p != it._p;//比较地址\n        }\n        //前置++  返回引用：效率更高，因为后置++ 会产生临时变量\n        iterator& operator++() {\n            ++_p;\n            return *this;\n        }\n        //后置++  返回临时量\n        iterator operator++(int) {\n            iterator tmp(*this);\n            _p++;\n            return tmp;\n        }\n        //解引用  *iter\n        char& operator*() { return *_p; }\n\n    private:\n        char* _p;\n    };\n\n    // 创建迭代器的 begin 和 end\n    iterator begin() { return iterator(_pstr); }\n    iterator end() { return iterator(_pstr + length()); }\n~~~\n\n**完整代码：**\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <ostream>\nusing namespace std;\n\n// 创建 string 类\nclass String\n{\npublic:\n    // 迭代器创建\n    class iterator\n    {\n    public:\n        // 构造函数\n        iterator(char *p = nullptr) : _p(p) { }\n        // 拷贝函数\n        iterator(const iterator& iter) : _p(iter._p) { }\n        \n        // 重载运算符\n         // !=  如 it != s1.end()\n        bool operator!=(const iterator& it) {\n            return _p != it._p;//比较地址\n        }\n        //前置++  返回引用：效率更高，因为后置++ 会产生临时变量\n        iterator& operator++() {\n            ++_p;\n            return *this;\n        }\n        //后置++  返回临时量\n        iterator operator++(int) {\n            iterator tmp(*this);\n            _p++;\n            return tmp;\n        }\n        //解引用  *iter\n        char& operator*() { return *_p; }\n\n    private:\n        char* _p;\n    };\n\n    // 创建迭代器的 begin 和 end\n    iterator begin() { return iterator(_pstr); }\n    iterator end() { return iterator(_pstr + length()); }\n\n\n    // 默认构造函数\n    String(const char* p = nullptr)\n    {\n        if (p != nullptr)\n        {\n            // 创建\n            _pstr = new char[strlen(p) + 1];\n            // 拷贝\n            strcpy(_pstr, p);\n        }\n        else\n        {\n            _pstr = new char[1];\n            *_pstr = '\\0';\n        }\n    }\n    // 拷贝构造函数\n    String(const String& str)\n    {\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n    }\n    // 析构函数\n    ~String()\n    {\n        delete[] _pstr;\n        _pstr = nullptr;\n    }\n\n    // 运算符重载\n    // 1. =\n    String& operator=(const String& str)\n    {\n        if (this == &str)\n        {\n            return *this;\n        }\n        delete[] _pstr;\n\n        // 创建\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n        return *this;\n    }\n    // 2. >\n    bool operator>(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) > 0;\n    }\n    // 3. <\n    bool operator<(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) < 0;\n    }\n    // 4. ==\n    bool operator==(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) == 0;\n    }\n    // 5. []\n    char& operator[](int index) \n    { \n        return _pstr[index]; \n    }\n    const char& operator[](int index) const \n    { \n        return _pstr[index]; \n    }\n\n    // 公共方法\n    int length()\n    {\n        return strlen(_pstr);\n    }\n    const char* c_str() const \n    { \n        return _pstr; \n    }\n\n\nprivate:\n    char* _pstr;\n\n    // 由于调用 << 不依赖于特定的对象，设计为全局函数\n    // 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。\n    friend ostream& operator<<(ostream& out, const String& str);\n/************************************************************************/\n  /*\n  重载+；\n  重载+ 有两种方式：\n  (1)定义成成员函数\n  String operator+(const String& s){\n    String tmp;\n    .....\n    return tmp;\n    如 s1 = s2+s3; => s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this\n  }\n  弊端：s1 = \"a\" + s2;无法重载+ ,因为\"a\"不是String类型。\n  （2）重载为全局函数\n  */\n/************************************************************************/\n    friend String operator+(const String& lhs, const String& rhs);\n\n};\n\nostream& operator<<(ostream& out, const String& str)\n{\n    out << str._pstr;\n    return out;\n};\n/*\n合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，\n并以此开辟空间大小，\n换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。\n*/\nString operator+(const String& lhs, const String& rhs)\n{\n    // 计算长度\n    char* _ptmp = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1];\n    // 拷贝\n    strcpy(_ptmp, lhs._pstr);\n    // 合并\n    strcat(_ptmp, rhs._pstr);\n\n    String tmp(_ptmp);\n    delete[]_ptmp;\n    \n    return tmp;\n};\n\nint main()\n{\n    //默认构造函数\n    String str1;\n    String str2 = \"aaa\";\n    String str3 = \"bbb\";\n\n    //+ 运算符重载\n    String str4 = str2 + str3;\n    String str5 = str2 + \"ccc\";\n    String str6 = \"ddd\" + str2;\n\n    // << 运算符重载\n    cout << \"str6:\" << str6 << endl;\n\n    // >  运算符重载\n    if (str5 > str6)\n    {\n        cout << str5 << \" > \" << str6 << endl;\n    }\n    else\n    {\n        cout << str5 << \" < \" << str6 << endl;\n    }\n\n    // 获取长度\n    int len = str6.length();\n    for (int i = 0; i < len; i++)\n    {\n        // []运算符重载\n        cout << str6[i] << \" \";\n    }\n    cout << endl;\n\n    // c_str()\n    char buff[1024] = { 0 };\n    strcpy(buff, str6.c_str());\n    cout << \"buff:\" << buff << endl;\n\n\n    // 迭代器\n    String::iterator it = str2.begin();\n    for (it = str2.begin(); it != str2.end(); ++it) {\n        cout << (*it) << \" \";\n    }\n\n    // auto\n    for (char ch : str2) {\n        cout << ch << \" \";\n    }\n\n    return 0;\n}\n~~~\n\n### 1. 代码优化\n\n**带右值引用参数的拷贝构造与带右值引用参数的赋值重载函数**\n\n考虑这样一个操作：\n\n**由于问题场景的特殊，子函数调用时我们无法返回一个临时对象。  \n而且我们也只能用赋值的方式接收一个函数调用的返回值。**\n\n~~~c++\nString GetString(const String&str) {\n  std::cout << \"\\n  GetString() begin\\n\";\n  String tmp(str.c_str());\n  std::cout << \"\\n  GetString() end\\n\";\n  return tmp;\n}\n \n \nint main()\n{\n  String s1 = \"123\";\n  String s2;\n \n  std::cout << \"\\n main call GetString() begin\\n\";\n  s2 = GetString(s1);\n  std::cout << \"\\n main call GetString() end\\n\";\n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101105643.png)\n\n 存在的问题：\n\n（1）在调用 `return tmp;` 时 实际是使用构造一个临时对象，临时对象调用拷贝构造函数从 tmp 中复制数据，然后调用析构函数析构 tmp 对象，这样就白耗费资源了，tmpStr 资源不要就早说，直接给函数栈帧上临时对象就好了；\n（2）s2 调用赋值运算符 ：临时量给 str2 赋值，str2 是原本已经存在的对象，它也有一个指针 mptr，原先也指向了一个空间。\n\n对于赋值来说，排除自赋值，然后把原先指向的空间释放掉，然后按照 str 的尺寸开辟空间，然后拷贝数据进行来。即按照临时对象的字符串大小开辟空间，然后把数据一个一个拷贝进来。\n\n然后出语句，把这个临时对象析构及它指向的堆内存空间释放掉。\n\n过程过于复杂，为什么不能直接把临时对象的外部资源给 str2 不就完了吗？\n\n### 2. 右值引用\n\n~~~c++\n//C++11把临时量都当做右值处理 \n\tString &&e = String(\"aaa\");//可以！ \n    const String &e = MyString(\"aaa\");//可以！\n~~~\n\n~~~c++\n  /************************************************************************/\n  /*拷贝构造函数   //String s2 = s1;*/\n  /************************************************************************/\n  String(const String& str)\n  {\n    if (str._pstr !=nullptr) {\n      _pstr = new char[strlen(str._pstr) + 1];\n      strcpy(_pstr, str._pstr);\n    }\n    std::cout << \"String 左值拷贝构造函数\\n\";\n  }\n \n  //带右值引用参数的拷贝构造\n  String(String &&str)//str引用的就是一个临时对象\n  {\n    std::cout << \"String 右值拷贝构造函数\\n\";\n      _pstr = str._pstr;\n    str._pstr = nullptr;\n  }\n \n  /************************************************************************/\n/*赋值运算符    //s2 = s1*/\n/************************************************************************/\n  String& operator=(const String& src)\n  {\n    std::cout << \"String 左值赋值运算符\\n\";\n    if (this == &src)\n      return *this;\n \n    if (src._pstr == nullptr) {\n      return *this;\n    }\n \n    if (_pstr) {\n      delete[]_pstr;\n    }\n \n \n    _pstr = new char[strlen(src._pstr) + 1];\n    strcpy(_pstr, src._pstr);\n    return *this;\n  }\n \n  //带右值引用参数的赋值重载函数\n  String& operator=(String &&str)//str引用的是临时对象\n  {\n    std::cout << \"String 右值引用参数的赋值重载函数\\n\";\n    if (this == &str)\n      return *this;\n \n    if (str._pstr == nullptr) {\n      return *this;\n    }\n \n    delete[]_pstr;\n \n    char * tmp=_pstr ;\n    _pstr = str._pstr;\n    str._pstr = tmp;\n    return *this;\n  }\n~~~\n\n通过右值引用，**没有任何内存的开辟和释放和数据的拷贝**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101116493.png)\n\n右值引用前：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117001.png)\n\n右值引用后：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117760.png)\n\n## 4. vector 容器的迭代器 iterator 实现\n\n**问题 1：删除 vector 中所有的偶数：**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tvec.push_back(i);\n\t}\n\n\t// 删除偶数\n\tauto it = vec.begin();\n\tfor (; it < vec.end(); it++)\n\t{\n\t\tif ((*it) % 2 == 0)\n\t\t{\n\t\t\tvec.erase(it);\n\t\t}\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101137035.png)\n\n运行导致程序崩溃！\n\n**问题 2：vector 容器插入元素问题**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tvec.push_back(i);\n\t}\n\n\t// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字\n\tvector<int>::iterator it = vec.begin();\n\tfor (; it < vec.end(); it++)\n\t{\n\t\tif ((*it) % 2 == 0) {\n\t\t\tvec.insert(it, *it - 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101430280.png)\n\n运行导致程序崩溃！\n\n**问题 3：push_back 触发扩容时**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tvec.push_back(1);\n\tvec.push_back(2);\n\tvector<int>::iterator it = vec.begin();\n\n\tcout << \"it = \" << *it << endl;\n\tcout << \"容量：\" << vec.capacity() << endl;\n\n\tvec.push_back(3);\n\tvec.push_back(4);\n\n\tcout << \"后push_back容量：\" << vec.capacity() << endl;\n\tcout << \"添加后，it = \" << *it << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101503945.png)\n\n\n**原因：iterator 失效**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101431915.png)\n\n当删除（获取增加）it 位置的元素时，导致 it 后面的迭代器全部失效。因此多次调用 `erase\\insert`导致崩溃\n\n## 5. 什么是容器的迭代器失效问题\n\n### 1. 原因\n\n**问题一：**\n\n当容器调用 erase 时，当前位置到容器末尾元素的所有的迭代器全部失效\n\n**问题二：**\n\n当容器调用 insert 时，当前位置到容器末尾元素的所有的迭代器全部失效\n\n当容器调用 insert 时，如果引起容器内存扩容，原来容器的所有的迭代器就全部失效\n\n**问题三：**\n\n当容器 push_back 时，如果当前容量不足，则会触发扩容，导致整个容器重新申请内存，并且将原有的数据复制到新内存中将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放。\n\n### 2. 解决\n\n进行更新操作：`erase\\insert` 后会返回指向下一个元素的迭代器\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101510112.png)\n\n- [vector::erase] https://cplusplus.com/reference/vector/vector/erase/\n\n从向量中删除单个元素（位置）或一系列元素（`[第一、最后一个]`）。\n\n这有效地减少了容器的大小，减少了被删除的元素的数量，这些元素会被销毁。\n\n由于向量使用数组作为其底层存储，擦除向量端以外位置的元素会导致容器在段擦除后将所有元素重新定位到其新位置。与其他类型的序列容器对相同操作执行的操作相比，这通常是一种低效的操作（如列表或转发列表）。\n\n同理，insert\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101512469.png)\n\n通过在指定位置的元素之前插入新元素来扩展向量，从而通过插入的元素数量有效地增加容器大小。\n\n当且仅当新向量大小超过当前向量容量时，这会导致自动重新分配分配分配的存储空间。\n\n因为向量使用数组作为其底层存储，所以在向量末端以外的位置插入元素会导致容器将位置之后的所有元素重新定位到它们的新位置。与其他类型的序列容器（如 list 或 forward_list）对相同操作执行的操作相比，这通常是一种低效的操作。\n\n这些参数确定插入的元素数量及其初始化值：\n\n也说明了进行插入操作会导致之后的迭代器失效。\n\n修改代码：\n\nerase 解决代码：**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tvec.push_back(i);\n\t}\n\n\t// 把 vec 容器中的所有偶数删除\n\tauto it = vec.begin();\n\twhile (it != vec.end())\n\t{\n\t\tif ((*it) % 2 == 0)\n\t\t{\n\t\t\t// 重新赋值\n\t\t\tit = vec.erase(it);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit++;\n\t\t}\n\t}\n\n\t// 输出查看\n\tfor (auto it : vec)\n\t{\n\t\tcout << it << \" \";\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101516128.png)\n\n**insert 解决代码：**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n \nint main()\n{\n  vector<int> vec;\n  for (int i = 0; i < 10; ++i) {\n    vec.push_back(i);\n  }\n \n  // 把vec容器中的所有偶数前面添加一个小于偶数值1的数字\n  auto it = vec.begin();\n  for (; it != vec.end(); it++) {\n    if ((*it) % 2 == 0) {\n      it = vec.insert(it, *it - 1);\n      // it原来的位置插入了新的，需要++it两次，才能到该偶数的后一个元素\n      it++;\n    }\n  }\n \n  for (auto val : vec) {\n    cout << val << \" \";\n  }\n  \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101520065.png)\n\n### 3. vector 实现中的 insert 和 erase\n\n头插法：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101522251.png)\n\n检查迭代器失效：\n\n在进行删除或增加的时候，要检测该位置到 last 位置，使其迭代器失效\n\n~~~c++\n  void pop_back() // 从容器末尾删除元素\n  {\n    if (empty())\n      return;\n \n    //检查迭代器 从该位置到最后\n    verify(Last-1,Last);\n \n    // 不仅要把_last指针--，还需要析构删除的元素\n    --Last;\n    _allocator.destroy(Last);\n  }\n~~~\n\n**迭代器检查实现：**\n\n~~~c++\nvoid verify(T* first, t* last)\n{\n\tIterator_Base* pre = &this->head;\n\tIterator_Base* it = &this->head._next;\n\n\twhile (it != nullptr)\n\t{\n\t\tif (it->_cur->_ptr > first && it->_cur->_ptr <= last)\n\t\t{\n\t\t\t// 迭代器失效，把 iterator 持有的容器指针置空\n\t\t\tit->_cur->_pVec = nullptr;\n\t\t\t// 删除当前迭代器节点，继续判断后面的迭代器是否失效\n\t\t\tpre->_next = it->_next;\n\t\t\tdelete it;\n\t\t\tit = pre->_next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpre = it;\n\t\t\tit = it->_next;\n\t\t}\n\t}\n}\n~~~\n\n## 6. new 和 delete 重载实现的对象池\n\n在编程中，我们经常会涉及到对象的操作，而经常的操作模式如下图所示:`创建对象`->`使用对象`->`销毁对象`。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101557430.png)\n\n而这个对象有可能创建的时候会需要构建很多资源，消耗比较大, 比如：在`hiredis`的SDK中每次都创建一个`redisContext`，如果需要查询，那就首先要进行网络连接。如果一直都是上图的工作方式，那将会频繁的创建连接，查询完毕后再释放连接。重新建立连接，让网络的查询效率降低。\n\n这个时候就可以构建一个`对象池`来重复利用这个对象，并且一般要做到线程安全:\n\n1. 从`对象池`中获取对象，如果没有对象，则创建一个，并返回\n2. 使用对象\n3. 使用完成对象后，将对象还回`对象池`\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101559621.png)\n\n那么符合如下条件的，应该适合使用`对象池`技术:\n\n- 有一些对象虽然创建开销比较大，但是不一定能够重复使用。要使用`对象池`一定要确保对象能够重复使用。\n- 这个对象构建的时候，有一些耗时的资源可以重复利用。比如`redisContext`的网络连接。又或者如果对象的频繁申请释放会带来一些其他的资源使用问题，比如`内存碎片`。重复利用能够提升程序的效率。\n- `对象池`的数量应该控制在能够接受的范围内，并不会无限膨胀。\n\n### 1. 对象池实现原理\n\n1. **分配过程：**\n\n**我们首先申请比如 100000 块内存空间，用这个块类型的指针指向这个申请好内存的首地址。如图：这个块可以是一个链式队列的一个节点或者一个树的节点等。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101603100.png)\n**当我们要分配给用户一块空间的时候我们就可以，先将 `_itemPool` 的地址保存到临时指针 p，然后再 `_itemPool++` 的操作，然后再将 p 返回给用户即可。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101604537.png)\n\n2. **释放过程：**\n\n**比如现在的内存分配状况如图所示：现在用户需要归还第 1 块内存。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101605266.png)\n\n我们首先要归还块的首地址指向 `_itemPool` 的下一个块，然后再将 `_itemPool` 指向归还的块的地址。即可\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101606815.png)\n\n### 2. 以队列实现一个简单对象池\n\n~~~c++\n#include <iostream>\n\nusing namespace std;\n\n/*\n运算符的重载  :成员方法、全局方法\n内存池 进程池 线程池 连接池 对象池\n*/\ntemplate<typename T>\nclass Queue\n{\npublic:\n\t// 构造函数\n\tQueue()\n\t{\n\t\t// 初始化指针\n\t\t_front = _rear = new QueueItem();\n\t}\n\t// 析构函数\n\t~Queue()\n\t{\n\t\t// 创建新对象\n\t\tQueueItem* cur = _front;\n\t\twhile (cur != nullptr)\n\t\t{\n\t\t\t_front = cur->_next;\n\t\t\tdelete cur;\n\t\t\tcur = _front;\n\t\t}\n\t}\n\t// 拷贝对象\n\tQueue(const Queue& obj) = delete;\n\n\t// 赋值重载\n\tvoid operator=(const Queue& obj) = delete;\n\n\t// 方法\n\t// 1. push 方法\n\tvoid push(const T& val)\n\t{\n\t\tQueueItem* item = new QueueItem(val);\n\t\t_rear->_next = item;\n\t\t_rear = item;\n\t}\n\t// 2. pop 方法\n\tvoid pop()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tQueueItem* first = _front->_next;\n\t\t_front->_next = first->_next;\n\t\tif (_front->_next == nullptr)\n\t\t{\n\t\t\t_rear = _front;\n\t\t}\n\t\tdelete first;\n\t}\n\t// 3. front 方法\n\tT front() const\n\t{\n\t\treturn _front->_next->_data;\n\t}\n\t// 4. empty 方法\n\tbool empty()const { return _rear == _front; }\n\n\t// 产生一个 QueueItem 的对象池\n\t// 创建一个对象池结构\n\tstruct QueueItem\n\t{\n\t\t// 构造函数\n\t\tQueueItem(T data = T()) :_data(data), _next(nullptr) {}\n\n\t\t// new 重载\n\t\tvoid* operator new(size_t size)\n\t\t{\n\t\t\tif (_itemPool == nullptr)\n\t\t\t{\n\t\t\t\t//由于我们不知道QueueItem的具体大小(模板未进行实例化)所以我们这里用char 1字节作为new的基准\n\t\t\t\t_itemPool = (QueueItem*)new char[POOL_ITEM_SIZE * sizeof(QueueItem)];\n\t\t\t\tQueueItem* p = _itemPool;\n\t\t\t\t//把开辟的POOL_ITEM_SIZE个块关联起来\n\t\t\t\tfor (; p != _itemPool + POOL_ITEM_SIZE - 1; ++p)\n\t\t\t\t{\n\t\t\t\t\tp->_next = p + 1;\n\t\t\t\t}\n\t\t\t\t//最后一块的next置为空\n\t\t\t\tp->_next = nullptr;\n\t\t\t}\n\t\t\t//将第一块可以分配的块分配给用户\n\t\t\tQueueItem* p = _itemPool;\n\t\t\t_itemPool = _itemPool->_next;\n\t\t\treturn p;\n\t\t}\n\t\t// delete 重载\n\t\tvoid operator delete(void* ptr)\n\t\t{\n\t\t\t//进行归还操作\n\t\t\tQueueItem* p = (QueueItem*)ptr;\n\t\t\tp->_next = _itemPool;\n\t\t\t_itemPool = p;\n\t\t}\n\n\t\t// 静态数据\n\t\tstatic QueueItem* _itemPool;\n\t\tstatic const int POOL_ITEM_SIZE = 1000000;\n\n\t\t// 对象池单个对象\n\t\tT _data;\n\t\tQueueItem* _next;\n\t};\n\nprivate:\n\tQueueItem* _front;//指向头节点\n\tQueueItem* _rear;//指向队尾\n};\n\n//typename 告诉编译器后面是类型\ntemplate<typename T>\ntypename Queue<T>::QueueItem* Queue<T>::QueueItem::_itemPool = nullptr;\nint main()\n{\n\tQueue<int> que;\n\tfor (int i = 0; i < 1000000; ++i)//大量的new delete;不划算\n\t{\n\t\tque.push(i);\n\t\tque.pop();\n\t}\n\n\tcout << que.empty() << endl;\n\t\n\treturn 0;\n}\n~~~\n\n## 7. 深入理解 new 和 delete 的原理\n\n**new和delete**是用户进行**动态内存申请和释放的操作符**，**operator new 和operator delete**是系统提供的**全局函数**，**new在底层调用operator new**全局函数来申请空间，**delete在底层通过operator delete**全局函数来释放空间。\n\n~~~c++\n/*\noperator new:该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。\n*/\nvoid* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)\n{\n    // try to allocate size bytes\n    void* p;\n    while ((p = malloc(size)) == 0)\n        if (_callnewh(size) == 0)\n        {\n            // report no memory\n            // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 \n            static const std::bad_alloc nomem; \n            _RAISE(nomem);\n        }\n        \n    return (p);\n}\n\n/*\noperator delete: 该函数最终是通过free来释放空间的 \n*/\nvoid operator delete(void* pUserData)\n{\n    _CrtMemBlockHeader* pHead;\n    \n    RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));\n    if (pUserData == NULL)\n        return;\n    _mlock(_HEAP_LOCK);  /* block other threads */\n    __TRY\n    \n        /* get a pointer to memory block header */\n        pHead = pHdr(pUserData);\n        \n    \t/* verify block type */\n    \t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));\n    \t\n    \t_free_dbg(pUserData, pHead->nBlockUse);\n    \t\n    __FINALLY\n        _munlock(_HEAP_LOCK);  /* release other threads */\n    __END_TRY_FINALLY\n    \n    return;\n}\n\n/*\nfree的实现\n*/\n\n#define free(p) _free_dbg(p, _NORMAL_BLOCK)\n~~~\n\n**1. 内置类型：**\n\n如果申请的是内置类型的空间 `new` 和 `malloc`，`delete` 和 `free` 基本类似，不同的地方是：`new/delete` 申请和释放的是单个元素的空间，`new[]` 和 `delete[]` 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc会返回NULL。\n\n**2. 自定义类型:**\n\n**new的原理：**\n\n1. 调用operator new函数申请空间\n2. 在申请的空间上执行构造函数，完成对象的构造\n\n**delete的原理：**\n\n在空间上执行析构函数，完成对象中资源的清理工作在空间上执行析构函数，完成对象中资源的清理工作\n\n`new T[N]` 的原理：\n\n1. 调用 `operator new[]` 函数，在 `operator new[]` 中实际调用 `operator new` 函数完成 N 个对象空间的申请\n2. 在申请的空间上执行N次构造函数\n\n`delete[ ]`的原理：\n1. 在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理\n2. 调用 `operator delete[]` 释放空间，实际在 `operator delete[]` 中调用 `operator delete` 来释放空间\n\n","source":"_posts/02.C++ 基础部分/05.C++ 运算符重载.md","raw":"---\ntitle: 05.C++ 运算符重载\ntags: [C++]\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节分为七个部分：\n\n1. 学习复数类 Complex\n2. 模拟实现 C++ 的 string 类\n3. string 字符串对象的迭代器\n4. vector 容器的迭代器 iterator 实现\n5. 什么是容器的迭代器失效问题\n6. new 和 delete 重载实现的对象池\n7. 深入理解 new 和 delete 的原理\n\n**什么是运算符重载**\n\n运算符重载实质还是一个 函数。\n通过重载运算符，可以让类在一些场景下使用起来更加方便。\n\n**语法**\n\n~~~c++\n返回值类型 operator op (参数);​​​​​​​\n~~~\n\n示例：\n\n~~~c++\nClassType& operator= (const ClassType& src); // 重载 “=” 运算符\n~~~\n\n## 1. 学习复数类 Complex\n\n复数是形如 `a+b` 的数，复数由实部和虚部构成，在 C++ 的模板库中由 complex 类，可以直接调用，包含在complex头文件中，再使用时应该添加 `#include<complex>`。下面介绍一些基本操作\n\n### 1. 生成复数对象\n\ncomplex 类型的构造函数接受两个参数，第一个参数是复数实部的值，第二个参数是虚部的值。要想生成一个复数对象，并且对其值进行修改，参考以下代码：\n\n~~~c++\n#include <iostream>\n#include <complex>\nusing namespace std;\n\nint main()\n{\n\tcomplex<double>x1(2, 3);\n\tcomplex<double>x2;\n\tcomplex<double>x3(x1);\n\n\tcout << \"x1 = \" << x1 << endl;\t\t// x1 = (2, 3)\n\tcout << \"x2 = \" << x2 << endl;\t\t// x2 = (0, 0)\n\tcout << \"x3 = \" << x3 << endl;\t\t// x3 = (2, 3)\n\n\tx1.real(22);\t// 修改实数部\n\tx1.imag(33);\t// 修改虚数部\n\n\tcout << \"x1 = \" << x1 << endl;\t\t// x1 = (22,33)\n\n\tcomplex<double>a, b, c;\n\tcout << \"请输入三个复数：\";\n\tcin >> a >> b >> c;\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\t\t\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100912113.png)\n\n### 2. 复数的运算\n\n复数和实数一样都有加减乘除四则运算，这些运算符号在 complex 模板中已经被重载过，能够直接使用，下面代码示例展示了其功能：\n\n~~~c++\n#include <iostream>\n#include <complex>\nusing namespace std;\n\nint main()\n{\n\tcomplex<double> z(2, 3);\n\tcomplex<double> z1 = z + 5.0;\n\tcout << z1 << endl;\n\tcomplex<double> z2 = z - 5.0;\n\tcout << z2 << endl;\n\tcomplex<double> z3 = z * 2.0;\n\tcout << z3 << endl;\n\tcomplex<double>z4 = z / complex<double>(1, 1);\n\tcout << z4 << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100914081.png)\n\n### 3. 复数的比较\n\n复数的比较需要同时比较实部和虚部是否都相等，有其一不等两数就 不等，下面是示例代码：\n\n~~~c++\n#include <iostream>\n#include <complex>\nusing namespace std;\n\nint main()\n{\n\tcomplex<double> z1(2, 3);\n\tcomplex<double> z2(3, 4);\n\tcomplex<double> z3(2, 3);\n\n\tcout << boolalpha << (z1 == z3) << endl;\n\tcout << boolalpha << (z1 == z2) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100916498.png)\n\n### 4. 实现 Complex 类\n\n~~~c++\n#include <iostream>\n//#include <complex>\nusing namespace std;\n\n// 定义Complex 类\ntemplate<typename T>\nclass Complex\n{\npublic:\n\t// 无参构造函数\n\tComplex()\n\t\t: real(0)\n\t\t, imag(0)\n\t{\n\t\t// 初始化列表\n\t}\n\t// 有参构造函数\n\tComplex(T re, T im)\n\t\t: real(re)\n\t\t, imag(im)\n\t{\n\t\t// 初始化列表\n\t}\n\t// 拷贝构造\n\tComplex(const Complex<T>& com)\n\t\t: real(com.real)\n\t\t, imag(com.imag)\n\t{\n\t\t// 初始化列表\n\t}\n\t// 析构\n\t~Complex()\n\t{\n\t\t// ......\n\t}\n\n\t// 方法\n\t// 1. printComplex 方法\n\tvoid printComplex()\n\t{\n\t\tcout << \"(\" << real << \", \" << imag << \")\" << endl;\n\t}\n\t// 2. + 方法重载：复数的加法\n\tComplex& operator+(const Complex<T>& com)\n\t{\n\t\tthis->real += com.real;\n\t\tthis->imag += com.imag;\n\t\treturn *this;\n\t}\n\t// 3. - 方法重载：复数的减法\n\tComplex& operator-(const Complex<T>& com)\n\t{\n\t\tthis->real -= com.real;\n\t\tthis->imag -= com.imag;\n\t\treturn *this;\n\t}\n\t// 4. * 方法重载：复数的乘法\n\tComplex& operator*(const Complex<T>& com)\n\t{\n\t\tthis->real = (real * com.real) - (imag * com.imag);\n\t\tthis->imag = (real * com.real) + (imag * com.imag);\n\t\treturn *this;\n\t}\n\t// 5. / 方法重载：复数的除法\n\tComplex& operator/(const Complex<T>& com)\n\t{\n\t\tthis->real = (real * com.real + imag * com.imag) / (com.real * com.real + com.imag * com.imag);\n\t\tthis->real = (real * com.real - imag * com.imag) / (com.real * com.real + com.imag * com.imag);\n\t\treturn *this;\n\t}\n\nprivate:\n\tT real;\t// 实部\n\tT imag;\t// 虚部\n};\n\nint main()\n{\n\tComplex<double> c1(2.0, 1.0);\n\tc1.printComplex();\n\tComplex<double> c2(1.0, 3.0);\n\tc2.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc1 = c1 + c2;\n\tcout << \"c1 加法后：\";\n\tc1.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc2 = c2 - c1;\n\tcout << \"c2 减法后：\";\n\tc2.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc1 = c2 * c1;\n\tcout << \"c1 乘法后：\";\n\tc1.printComplex();\n\tcout << \"----------------\" << endl;\n\n\tc2 = c2 / c1;\n\tcout << \"c2 除法后：\";\n\tc2.printComplex();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100954476.png)\n\n另一种实现方式：\n\n~~~c++\n#include <iostream>\nusing namespace std;\n \nclass CComplex\n{\npublic:\n\tCComplex(int r = 0, int i = 0)\n\t\t:_mreal(r)\n\t\t,_mimage(i)\n\t{\n\t}\n\tvoid operator=(const CComplex&obj)\n\t{\n\t\tthis->_mreal = obj._mreal;\n\t\tthis->_mimage = obj._mimage;\n\t}\n\t//指导编译器怎么做CComplex类对象的加法操作\n\t/*CComplex operator+(const CComplex&com)\n\t{\n\t\treturn CComplex(this->_mreal + com._mreal,\n\t\t\tthis->_mimage + com._mimage);\n\t}*/\n\tCComplex operator++(int)\n\t{\n\t\treturn CComplex(this->_mreal++, this->_mimage++);\n\t\t/*CComplex comp = *this;\n\t\tthis->_mimage++;\n\t\tthis->_mreal++;\n\t\treturn comp;*/\n\t}\n\tCComplex& operator++()\n\t{\n\t\t_mreal += 1;\n\t\t_mimage += 1;\n\t\treturn *this;\n\t}\n\tvoid operator+=(const CComplex&rhs)\n\t{\n\t\tthis->_mreal += rhs._mreal;\n\t\tthis->_mimage += rhs._mimage;\n\t}\n\tvoid show() { cout << \"real:\" << _mreal << \"image:\" << _mimage << endl; }\nprivate:\n\tint _mreal;\n\tint _mimage;\n\tfriend CComplex operator+(const CComplex &lhs, const CComplex &rhs);\n\tfriend ostream& operator<<(ostream&out, const CComplex&src);\n\tfriend istream& operator>>(istream&in, CComplex&src);\n};\nistream& operator>>(istream&in, CComplex&src)\n{\n\tint a, b;\n\tin >> a >> b;\n\tsrc._mreal = a;\n\tsrc._mimage = b;\n\treturn in;\n}\nostream& operator<<(ostream&out, const CComplex&src)\n{\n\tout << \"real:\" << src._mreal << \"image:\" << src._mimage << endl;\n\treturn out;\n}\nCComplex operator+(const CComplex &lhs, const CComplex &rhs)\n{\n\treturn CComplex(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage);\n}\n\nint main()\n{\n\tCComplex c1(1, 2);\n\tCComplex c2(2, 3);\n\tCComplex c4;\n\t\n\tc4 = c1+c2;\n\tc4.show();\n\t\n\tc4 = c1 + 20;\n\tc4.show();\n\t\n\tc4 = 30 + c2;\n\tc4.show();\n\t\n\tCComplex c5;\n\tc5 = c4++;\n\tc5.show();\n \n\tc5 = ++c4;\n\tc5.show();\n \n\tc5 += c4;\n\tc5.show();\n\tcout << \"++++++++++++++++++++++++++++++\" << endl;\n \n\tcout << c5;\n \n\tCComplex c6;\n\tcin >> c6;\n\tcout << c6;\n\t\n\treturn 0;\n}\n~~~\n\n## 2. 模拟实现 C++ 的 string 类\n\nstring 类中的基本方法有：\n\n1. 构造函数\n2. + 运算符重载\n3. `<<` 运算符重载\n4. > 运算符重载\n5. len 方法\n6. `[]` 运算符重载\n7. 迭代器实现\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    //默认构造函数\n    string str1;\n    string str2 = \"aaa\";\n    string str3 = \"bbb\";\n\n    //+ 运算符重载\n    string str4 = str2 + str3;\n    string str5 = str2 + \"ccc\";\n    string str6 = \"ddd\" + str2;\n\n    // << 运算符重载\n    cout << \"str6:\" << str6 << endl;\n\n    // >  运算符重载\n    if (str5 > str6)\n    {\n        cout << str5 << \" > \" << str6 << endl;\n    }\n    else\n    {\n        cout << str5 << \" < \" << str6 << endl;\n    }\n\n    // 获取长度\n    int len = str6.length();\n    for (int i = 0; i < len; i++)\n    {\n        // []运算符重载\n        cout << str6[i] << \" \";\n    }\n    cout << endl;\n\n    // c_str()\n    char buff[1024] = { 0 };\n    strcpy(buff, str6.c_str());\n    cout << \"buff:\" << buff << endl;\n\n    // 迭代器实现\n    string::iterator it = str2.begin();\n    for (it = str2.begin(); it != str2.end(); ++it) {\n        cout << (*it) << \" \";\n    }\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101003436.png)\n\n### 1. 实现 string\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <ostream>\nusing namespace std;\n\n// 创建 string 类\nclass String\n{\npublic:\n    // 默认构造函数\n    String(const char* p = nullptr)\n    {\n        if (p != nullptr)\n        {\n            // 创建\n            _pstr = new char[strlen(p) + 1];\n            // 拷贝\n            strcpy(_pstr, p);\n        }\n        else\n        {\n            _pstr = new char[1];\n            *_pstr = '\\0';\n        }\n    }\n    // 拷贝构造函数\n    String(const String& str)\n    {\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n    }\n    // 析构函数\n    ~String()\n    {\n        delete[] _pstr;\n        _pstr = nullptr;\n    }\n\n    // 运算符重载\n    // 1. =\n    String& operator=(const String& str)\n    {\n        if (this == &str)\n        {\n            return *this;\n        }\n        delete[] _pstr;\n\n        // 创建\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n        return *this;\n    }\n    // 2. >\n    bool operator>(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) > 0;\n    }\n    // 3. <\n    bool operator<(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) < 0;\n    }\n    // 4. ==\n    bool operator==(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) == 0;\n    }\n    // 5. []\n    char& operator[](int index) \n    { \n        return _pstr[index]; \n    }\n    const char& operator[](int index) const \n    { \n        return _pstr[index]; \n    }\n\n    // 公共方法\n    int length()\n    {\n        return strlen(_pstr);\n    }\n    const char* c_str() const \n    { \n        return _pstr; \n    }\n\n\nprivate:\n    char* _pstr;\n\n    // 由于调用 << 不依赖于特定的对象，设计为全局函数\n    // 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。\n    friend ostream& operator<<(ostream& out, const String& str);\n/************************************************************************/\n  /*\n  重载+；\n  重载+ 有两种方式：\n  (1)定义成成员函数\n  String operator+(const String& s){\n    String tmp;\n    .....\n    return tmp;\n    如 s1 = s2+s3; => s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this\n  }\n  弊端：s1 = \"a\" + s2;无法重载+ ,因为\"a\"不是String类型。\n  （2）重载为全局函数\n  */\n/************************************************************************/\n    friend String operator+(const String& lhs, const String& rhs);\n\n};\n\nostream& operator<<(ostream& out, const String& str)\n{\n    out << str._pstr;\n    return out;\n};\n/*\n合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，\n并以此开辟空间大小，\n换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。\n*/\nString operator+(const String& lhs, const String& rhs)\n{\n    // 计算长度\n    char* _ptmp = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1];\n    // 拷贝\n    strcpy(_ptmp, lhs._pstr);\n    // 合并\n    strcat(_ptmp, rhs._pstr);\n\n    String tmp(_ptmp);\n    delete[]_ptmp;\n    \n    return tmp;\n};\n\nint main()\n{\n    //默认构造函数\n    String str1;\n    String str2 = \"aaa\";\n    String str3 = \"bbb\";\n\n    //+ 运算符重载\n    String str4 = str2 + str3;\n    String str5 = str2 + \"ccc\";\n    String str6 = \"ddd\" + str2;\n\n    // << 运算符重载\n    cout << \"str6:\" << str6 << endl;\n\n    // >  运算符重载\n    if (str5 > str6)\n    {\n        cout << str5 << \" > \" << str6 << endl;\n    }\n    else\n    {\n        cout << str5 << \" < \" << str6 << endl;\n    }\n\n    // 获取长度\n    int len = str6.length();\n    for (int i = 0; i < len; i++)\n    {\n        // []运算符重载\n        cout << str6[i] << \" \";\n    }\n    cout << endl;\n\n    // c_str()\n    char buff[1024] = { 0 };\n    strcpy(buff, str6.c_str());\n    cout << \"buff:\" << buff << endl;\n\n    //\n    //  string::iterator it = str2.begin();\n    // for (it = str2.begin(); it != str2.end(); ++it) {\n     // cout << (*it) << \" \";\n    //}\n\n    return 0;\n}\n~~~\n\n存在的问题：\n\n~~~c++\nString operator+(const String& lhs, const String& rhs)\n{\n    // 计算长度\n    char* _ptmp = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1];\n    // 拷贝\n    strcpy(_ptmp, lhs._pstr);\n    // 合并\n    strcat(_ptmp, rhs._pstr);\n\n    String tmp(_ptmp);\n    delete[]_ptmp;\n    \n    return tmp;\n};\n~~~\n\n为了将局部新开辟的内存空间 `_ptmp` 资源释放，我们后面又构造了一个临时对象 `String tmp(_ptmp)`，之后将局部变量资源释放 `delete[]_ptmp`，但是这样一来的效率非常低！\n\n## 3. string 字符串对象的迭代器\n\n容器的迭代器可以透明的访问容器内部的元素的值\n\n~~~c++\nstring::iterator it = str2.begin();\nfor (it = str2.begin(); it != str2.end(); ++it) {\n cout << (*it) << \" \";\n}\n~~~\n\n迭代器代码：\n\n~~~c++\n    // 迭代器创建\n    class iterator\n    {\n    public:\n        // 构造函数\n        iterator(char *p = nullptr) : _p(p) { }\n        // 拷贝函数\n        iterator(const iterator& iter) : _p(iter._p) { }\n        \n        // 重载运算符\n         // !=  如 it != s1.end()\n        bool operator!=(const iterator& it) {\n            return _p != it._p;//比较地址\n        }\n        //前置++  返回引用：效率更高，因为后置++ 会产生临时变量\n        iterator& operator++() {\n            ++_p;\n            return *this;\n        }\n        //后置++  返回临时量\n        iterator operator++(int) {\n            iterator tmp(*this);\n            _p++;\n            return tmp;\n        }\n        //解引用  *iter\n        char& operator*() { return *_p; }\n\n    private:\n        char* _p;\n    };\n\n    // 创建迭代器的 begin 和 end\n    iterator begin() { return iterator(_pstr); }\n    iterator end() { return iterator(_pstr + length()); }\n~~~\n\n**完整代码：**\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <ostream>\nusing namespace std;\n\n// 创建 string 类\nclass String\n{\npublic:\n    // 迭代器创建\n    class iterator\n    {\n    public:\n        // 构造函数\n        iterator(char *p = nullptr) : _p(p) { }\n        // 拷贝函数\n        iterator(const iterator& iter) : _p(iter._p) { }\n        \n        // 重载运算符\n         // !=  如 it != s1.end()\n        bool operator!=(const iterator& it) {\n            return _p != it._p;//比较地址\n        }\n        //前置++  返回引用：效率更高，因为后置++ 会产生临时变量\n        iterator& operator++() {\n            ++_p;\n            return *this;\n        }\n        //后置++  返回临时量\n        iterator operator++(int) {\n            iterator tmp(*this);\n            _p++;\n            return tmp;\n        }\n        //解引用  *iter\n        char& operator*() { return *_p; }\n\n    private:\n        char* _p;\n    };\n\n    // 创建迭代器的 begin 和 end\n    iterator begin() { return iterator(_pstr); }\n    iterator end() { return iterator(_pstr + length()); }\n\n\n    // 默认构造函数\n    String(const char* p = nullptr)\n    {\n        if (p != nullptr)\n        {\n            // 创建\n            _pstr = new char[strlen(p) + 1];\n            // 拷贝\n            strcpy(_pstr, p);\n        }\n        else\n        {\n            _pstr = new char[1];\n            *_pstr = '\\0';\n        }\n    }\n    // 拷贝构造函数\n    String(const String& str)\n    {\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n    }\n    // 析构函数\n    ~String()\n    {\n        delete[] _pstr;\n        _pstr = nullptr;\n    }\n\n    // 运算符重载\n    // 1. =\n    String& operator=(const String& str)\n    {\n        if (this == &str)\n        {\n            return *this;\n        }\n        delete[] _pstr;\n\n        // 创建\n        _pstr = new char[strlen(str._pstr) + 1];\n        strcpy(_pstr, str._pstr);\n        return *this;\n    }\n    // 2. >\n    bool operator>(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) > 0;\n    }\n    // 3. <\n    bool operator<(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) < 0;\n    }\n    // 4. ==\n    bool operator==(const String& str) const\n    {\n        return strcmp(_pstr, str._pstr) == 0;\n    }\n    // 5. []\n    char& operator[](int index) \n    { \n        return _pstr[index]; \n    }\n    const char& operator[](int index) const \n    { \n        return _pstr[index]; \n    }\n\n    // 公共方法\n    int length()\n    {\n        return strlen(_pstr);\n    }\n    const char* c_str() const \n    { \n        return _pstr; \n    }\n\n\nprivate:\n    char* _pstr;\n\n    // 由于调用 << 不依赖于特定的对象，设计为全局函数\n    // 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。\n    friend ostream& operator<<(ostream& out, const String& str);\n/************************************************************************/\n  /*\n  重载+；\n  重载+ 有两种方式：\n  (1)定义成成员函数\n  String operator+(const String& s){\n    String tmp;\n    .....\n    return tmp;\n    如 s1 = s2+s3; => s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this\n  }\n  弊端：s1 = \"a\" + s2;无法重载+ ,因为\"a\"不是String类型。\n  （2）重载为全局函数\n  */\n/************************************************************************/\n    friend String operator+(const String& lhs, const String& rhs);\n\n};\n\nostream& operator<<(ostream& out, const String& str)\n{\n    out << str._pstr;\n    return out;\n};\n/*\n合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，\n并以此开辟空间大小，\n换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。\n*/\nString operator+(const String& lhs, const String& rhs)\n{\n    // 计算长度\n    char* _ptmp = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1];\n    // 拷贝\n    strcpy(_ptmp, lhs._pstr);\n    // 合并\n    strcat(_ptmp, rhs._pstr);\n\n    String tmp(_ptmp);\n    delete[]_ptmp;\n    \n    return tmp;\n};\n\nint main()\n{\n    //默认构造函数\n    String str1;\n    String str2 = \"aaa\";\n    String str3 = \"bbb\";\n\n    //+ 运算符重载\n    String str4 = str2 + str3;\n    String str5 = str2 + \"ccc\";\n    String str6 = \"ddd\" + str2;\n\n    // << 运算符重载\n    cout << \"str6:\" << str6 << endl;\n\n    // >  运算符重载\n    if (str5 > str6)\n    {\n        cout << str5 << \" > \" << str6 << endl;\n    }\n    else\n    {\n        cout << str5 << \" < \" << str6 << endl;\n    }\n\n    // 获取长度\n    int len = str6.length();\n    for (int i = 0; i < len; i++)\n    {\n        // []运算符重载\n        cout << str6[i] << \" \";\n    }\n    cout << endl;\n\n    // c_str()\n    char buff[1024] = { 0 };\n    strcpy(buff, str6.c_str());\n    cout << \"buff:\" << buff << endl;\n\n\n    // 迭代器\n    String::iterator it = str2.begin();\n    for (it = str2.begin(); it != str2.end(); ++it) {\n        cout << (*it) << \" \";\n    }\n\n    // auto\n    for (char ch : str2) {\n        cout << ch << \" \";\n    }\n\n    return 0;\n}\n~~~\n\n### 1. 代码优化\n\n**带右值引用参数的拷贝构造与带右值引用参数的赋值重载函数**\n\n考虑这样一个操作：\n\n**由于问题场景的特殊，子函数调用时我们无法返回一个临时对象。  \n而且我们也只能用赋值的方式接收一个函数调用的返回值。**\n\n~~~c++\nString GetString(const String&str) {\n  std::cout << \"\\n  GetString() begin\\n\";\n  String tmp(str.c_str());\n  std::cout << \"\\n  GetString() end\\n\";\n  return tmp;\n}\n \n \nint main()\n{\n  String s1 = \"123\";\n  String s2;\n \n  std::cout << \"\\n main call GetString() begin\\n\";\n  s2 = GetString(s1);\n  std::cout << \"\\n main call GetString() end\\n\";\n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101105643.png)\n\n 存在的问题：\n\n（1）在调用 `return tmp;` 时 实际是使用构造一个临时对象，临时对象调用拷贝构造函数从 tmp 中复制数据，然后调用析构函数析构 tmp 对象，这样就白耗费资源了，tmpStr 资源不要就早说，直接给函数栈帧上临时对象就好了；\n（2）s2 调用赋值运算符 ：临时量给 str2 赋值，str2 是原本已经存在的对象，它也有一个指针 mptr，原先也指向了一个空间。\n\n对于赋值来说，排除自赋值，然后把原先指向的空间释放掉，然后按照 str 的尺寸开辟空间，然后拷贝数据进行来。即按照临时对象的字符串大小开辟空间，然后把数据一个一个拷贝进来。\n\n然后出语句，把这个临时对象析构及它指向的堆内存空间释放掉。\n\n过程过于复杂，为什么不能直接把临时对象的外部资源给 str2 不就完了吗？\n\n### 2. 右值引用\n\n~~~c++\n//C++11把临时量都当做右值处理 \n\tString &&e = String(\"aaa\");//可以！ \n    const String &e = MyString(\"aaa\");//可以！\n~~~\n\n~~~c++\n  /************************************************************************/\n  /*拷贝构造函数   //String s2 = s1;*/\n  /************************************************************************/\n  String(const String& str)\n  {\n    if (str._pstr !=nullptr) {\n      _pstr = new char[strlen(str._pstr) + 1];\n      strcpy(_pstr, str._pstr);\n    }\n    std::cout << \"String 左值拷贝构造函数\\n\";\n  }\n \n  //带右值引用参数的拷贝构造\n  String(String &&str)//str引用的就是一个临时对象\n  {\n    std::cout << \"String 右值拷贝构造函数\\n\";\n      _pstr = str._pstr;\n    str._pstr = nullptr;\n  }\n \n  /************************************************************************/\n/*赋值运算符    //s2 = s1*/\n/************************************************************************/\n  String& operator=(const String& src)\n  {\n    std::cout << \"String 左值赋值运算符\\n\";\n    if (this == &src)\n      return *this;\n \n    if (src._pstr == nullptr) {\n      return *this;\n    }\n \n    if (_pstr) {\n      delete[]_pstr;\n    }\n \n \n    _pstr = new char[strlen(src._pstr) + 1];\n    strcpy(_pstr, src._pstr);\n    return *this;\n  }\n \n  //带右值引用参数的赋值重载函数\n  String& operator=(String &&str)//str引用的是临时对象\n  {\n    std::cout << \"String 右值引用参数的赋值重载函数\\n\";\n    if (this == &str)\n      return *this;\n \n    if (str._pstr == nullptr) {\n      return *this;\n    }\n \n    delete[]_pstr;\n \n    char * tmp=_pstr ;\n    _pstr = str._pstr;\n    str._pstr = tmp;\n    return *this;\n  }\n~~~\n\n通过右值引用，**没有任何内存的开辟和释放和数据的拷贝**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101116493.png)\n\n右值引用前：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117001.png)\n\n右值引用后：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117760.png)\n\n## 4. vector 容器的迭代器 iterator 实现\n\n**问题 1：删除 vector 中所有的偶数：**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tvec.push_back(i);\n\t}\n\n\t// 删除偶数\n\tauto it = vec.begin();\n\tfor (; it < vec.end(); it++)\n\t{\n\t\tif ((*it) % 2 == 0)\n\t\t{\n\t\t\tvec.erase(it);\n\t\t}\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101137035.png)\n\n运行导致程序崩溃！\n\n**问题 2：vector 容器插入元素问题**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tvec.push_back(i);\n\t}\n\n\t// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字\n\tvector<int>::iterator it = vec.begin();\n\tfor (; it < vec.end(); it++)\n\t{\n\t\tif ((*it) % 2 == 0) {\n\t\t\tvec.insert(it, *it - 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101430280.png)\n\n运行导致程序崩溃！\n\n**问题 3：push_back 触发扩容时**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tvec.push_back(1);\n\tvec.push_back(2);\n\tvector<int>::iterator it = vec.begin();\n\n\tcout << \"it = \" << *it << endl;\n\tcout << \"容量：\" << vec.capacity() << endl;\n\n\tvec.push_back(3);\n\tvec.push_back(4);\n\n\tcout << \"后push_back容量：\" << vec.capacity() << endl;\n\tcout << \"添加后，it = \" << *it << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101503945.png)\n\n\n**原因：iterator 失效**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101431915.png)\n\n当删除（获取增加）it 位置的元素时，导致 it 后面的迭代器全部失效。因此多次调用 `erase\\insert`导致崩溃\n\n## 5. 什么是容器的迭代器失效问题\n\n### 1. 原因\n\n**问题一：**\n\n当容器调用 erase 时，当前位置到容器末尾元素的所有的迭代器全部失效\n\n**问题二：**\n\n当容器调用 insert 时，当前位置到容器末尾元素的所有的迭代器全部失效\n\n当容器调用 insert 时，如果引起容器内存扩容，原来容器的所有的迭代器就全部失效\n\n**问题三：**\n\n当容器 push_back 时，如果当前容量不足，则会触发扩容，导致整个容器重新申请内存，并且将原有的数据复制到新内存中将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放。\n\n### 2. 解决\n\n进行更新操作：`erase\\insert` 后会返回指向下一个元素的迭代器\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101510112.png)\n\n- [vector::erase] https://cplusplus.com/reference/vector/vector/erase/\n\n从向量中删除单个元素（位置）或一系列元素（`[第一、最后一个]`）。\n\n这有效地减少了容器的大小，减少了被删除的元素的数量，这些元素会被销毁。\n\n由于向量使用数组作为其底层存储，擦除向量端以外位置的元素会导致容器在段擦除后将所有元素重新定位到其新位置。与其他类型的序列容器对相同操作执行的操作相比，这通常是一种低效的操作（如列表或转发列表）。\n\n同理，insert\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101512469.png)\n\n通过在指定位置的元素之前插入新元素来扩展向量，从而通过插入的元素数量有效地增加容器大小。\n\n当且仅当新向量大小超过当前向量容量时，这会导致自动重新分配分配分配的存储空间。\n\n因为向量使用数组作为其底层存储，所以在向量末端以外的位置插入元素会导致容器将位置之后的所有元素重新定位到它们的新位置。与其他类型的序列容器（如 list 或 forward_list）对相同操作执行的操作相比，这通常是一种低效的操作。\n\n这些参数确定插入的元素数量及其初始化值：\n\n也说明了进行插入操作会导致之后的迭代器失效。\n\n修改代码：\n\nerase 解决代码：**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tvec.push_back(i);\n\t}\n\n\t// 把 vec 容器中的所有偶数删除\n\tauto it = vec.begin();\n\twhile (it != vec.end())\n\t{\n\t\tif ((*it) % 2 == 0)\n\t\t{\n\t\t\t// 重新赋值\n\t\t\tit = vec.erase(it);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit++;\n\t\t}\n\t}\n\n\t// 输出查看\n\tfor (auto it : vec)\n\t{\n\t\tcout << it << \" \";\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101516128.png)\n\n**insert 解决代码：**\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n \nint main()\n{\n  vector<int> vec;\n  for (int i = 0; i < 10; ++i) {\n    vec.push_back(i);\n  }\n \n  // 把vec容器中的所有偶数前面添加一个小于偶数值1的数字\n  auto it = vec.begin();\n  for (; it != vec.end(); it++) {\n    if ((*it) % 2 == 0) {\n      it = vec.insert(it, *it - 1);\n      // it原来的位置插入了新的，需要++it两次，才能到该偶数的后一个元素\n      it++;\n    }\n  }\n \n  for (auto val : vec) {\n    cout << val << \" \";\n  }\n  \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101520065.png)\n\n### 3. vector 实现中的 insert 和 erase\n\n头插法：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101522251.png)\n\n检查迭代器失效：\n\n在进行删除或增加的时候，要检测该位置到 last 位置，使其迭代器失效\n\n~~~c++\n  void pop_back() // 从容器末尾删除元素\n  {\n    if (empty())\n      return;\n \n    //检查迭代器 从该位置到最后\n    verify(Last-1,Last);\n \n    // 不仅要把_last指针--，还需要析构删除的元素\n    --Last;\n    _allocator.destroy(Last);\n  }\n~~~\n\n**迭代器检查实现：**\n\n~~~c++\nvoid verify(T* first, t* last)\n{\n\tIterator_Base* pre = &this->head;\n\tIterator_Base* it = &this->head._next;\n\n\twhile (it != nullptr)\n\t{\n\t\tif (it->_cur->_ptr > first && it->_cur->_ptr <= last)\n\t\t{\n\t\t\t// 迭代器失效，把 iterator 持有的容器指针置空\n\t\t\tit->_cur->_pVec = nullptr;\n\t\t\t// 删除当前迭代器节点，继续判断后面的迭代器是否失效\n\t\t\tpre->_next = it->_next;\n\t\t\tdelete it;\n\t\t\tit = pre->_next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpre = it;\n\t\t\tit = it->_next;\n\t\t}\n\t}\n}\n~~~\n\n## 6. new 和 delete 重载实现的对象池\n\n在编程中，我们经常会涉及到对象的操作，而经常的操作模式如下图所示:`创建对象`->`使用对象`->`销毁对象`。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101557430.png)\n\n而这个对象有可能创建的时候会需要构建很多资源，消耗比较大, 比如：在`hiredis`的SDK中每次都创建一个`redisContext`，如果需要查询，那就首先要进行网络连接。如果一直都是上图的工作方式，那将会频繁的创建连接，查询完毕后再释放连接。重新建立连接，让网络的查询效率降低。\n\n这个时候就可以构建一个`对象池`来重复利用这个对象，并且一般要做到线程安全:\n\n1. 从`对象池`中获取对象，如果没有对象，则创建一个，并返回\n2. 使用对象\n3. 使用完成对象后，将对象还回`对象池`\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101559621.png)\n\n那么符合如下条件的，应该适合使用`对象池`技术:\n\n- 有一些对象虽然创建开销比较大，但是不一定能够重复使用。要使用`对象池`一定要确保对象能够重复使用。\n- 这个对象构建的时候，有一些耗时的资源可以重复利用。比如`redisContext`的网络连接。又或者如果对象的频繁申请释放会带来一些其他的资源使用问题，比如`内存碎片`。重复利用能够提升程序的效率。\n- `对象池`的数量应该控制在能够接受的范围内，并不会无限膨胀。\n\n### 1. 对象池实现原理\n\n1. **分配过程：**\n\n**我们首先申请比如 100000 块内存空间，用这个块类型的指针指向这个申请好内存的首地址。如图：这个块可以是一个链式队列的一个节点或者一个树的节点等。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101603100.png)\n**当我们要分配给用户一块空间的时候我们就可以，先将 `_itemPool` 的地址保存到临时指针 p，然后再 `_itemPool++` 的操作，然后再将 p 返回给用户即可。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101604537.png)\n\n2. **释放过程：**\n\n**比如现在的内存分配状况如图所示：现在用户需要归还第 1 块内存。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101605266.png)\n\n我们首先要归还块的首地址指向 `_itemPool` 的下一个块，然后再将 `_itemPool` 指向归还的块的地址。即可\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101606815.png)\n\n### 2. 以队列实现一个简单对象池\n\n~~~c++\n#include <iostream>\n\nusing namespace std;\n\n/*\n运算符的重载  :成员方法、全局方法\n内存池 进程池 线程池 连接池 对象池\n*/\ntemplate<typename T>\nclass Queue\n{\npublic:\n\t// 构造函数\n\tQueue()\n\t{\n\t\t// 初始化指针\n\t\t_front = _rear = new QueueItem();\n\t}\n\t// 析构函数\n\t~Queue()\n\t{\n\t\t// 创建新对象\n\t\tQueueItem* cur = _front;\n\t\twhile (cur != nullptr)\n\t\t{\n\t\t\t_front = cur->_next;\n\t\t\tdelete cur;\n\t\t\tcur = _front;\n\t\t}\n\t}\n\t// 拷贝对象\n\tQueue(const Queue& obj) = delete;\n\n\t// 赋值重载\n\tvoid operator=(const Queue& obj) = delete;\n\n\t// 方法\n\t// 1. push 方法\n\tvoid push(const T& val)\n\t{\n\t\tQueueItem* item = new QueueItem(val);\n\t\t_rear->_next = item;\n\t\t_rear = item;\n\t}\n\t// 2. pop 方法\n\tvoid pop()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tQueueItem* first = _front->_next;\n\t\t_front->_next = first->_next;\n\t\tif (_front->_next == nullptr)\n\t\t{\n\t\t\t_rear = _front;\n\t\t}\n\t\tdelete first;\n\t}\n\t// 3. front 方法\n\tT front() const\n\t{\n\t\treturn _front->_next->_data;\n\t}\n\t// 4. empty 方法\n\tbool empty()const { return _rear == _front; }\n\n\t// 产生一个 QueueItem 的对象池\n\t// 创建一个对象池结构\n\tstruct QueueItem\n\t{\n\t\t// 构造函数\n\t\tQueueItem(T data = T()) :_data(data), _next(nullptr) {}\n\n\t\t// new 重载\n\t\tvoid* operator new(size_t size)\n\t\t{\n\t\t\tif (_itemPool == nullptr)\n\t\t\t{\n\t\t\t\t//由于我们不知道QueueItem的具体大小(模板未进行实例化)所以我们这里用char 1字节作为new的基准\n\t\t\t\t_itemPool = (QueueItem*)new char[POOL_ITEM_SIZE * sizeof(QueueItem)];\n\t\t\t\tQueueItem* p = _itemPool;\n\t\t\t\t//把开辟的POOL_ITEM_SIZE个块关联起来\n\t\t\t\tfor (; p != _itemPool + POOL_ITEM_SIZE - 1; ++p)\n\t\t\t\t{\n\t\t\t\t\tp->_next = p + 1;\n\t\t\t\t}\n\t\t\t\t//最后一块的next置为空\n\t\t\t\tp->_next = nullptr;\n\t\t\t}\n\t\t\t//将第一块可以分配的块分配给用户\n\t\t\tQueueItem* p = _itemPool;\n\t\t\t_itemPool = _itemPool->_next;\n\t\t\treturn p;\n\t\t}\n\t\t// delete 重载\n\t\tvoid operator delete(void* ptr)\n\t\t{\n\t\t\t//进行归还操作\n\t\t\tQueueItem* p = (QueueItem*)ptr;\n\t\t\tp->_next = _itemPool;\n\t\t\t_itemPool = p;\n\t\t}\n\n\t\t// 静态数据\n\t\tstatic QueueItem* _itemPool;\n\t\tstatic const int POOL_ITEM_SIZE = 1000000;\n\n\t\t// 对象池单个对象\n\t\tT _data;\n\t\tQueueItem* _next;\n\t};\n\nprivate:\n\tQueueItem* _front;//指向头节点\n\tQueueItem* _rear;//指向队尾\n};\n\n//typename 告诉编译器后面是类型\ntemplate<typename T>\ntypename Queue<T>::QueueItem* Queue<T>::QueueItem::_itemPool = nullptr;\nint main()\n{\n\tQueue<int> que;\n\tfor (int i = 0; i < 1000000; ++i)//大量的new delete;不划算\n\t{\n\t\tque.push(i);\n\t\tque.pop();\n\t}\n\n\tcout << que.empty() << endl;\n\t\n\treturn 0;\n}\n~~~\n\n## 7. 深入理解 new 和 delete 的原理\n\n**new和delete**是用户进行**动态内存申请和释放的操作符**，**operator new 和operator delete**是系统提供的**全局函数**，**new在底层调用operator new**全局函数来申请空间，**delete在底层通过operator delete**全局函数来释放空间。\n\n~~~c++\n/*\noperator new:该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。\n*/\nvoid* __CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc)\n{\n    // try to allocate size bytes\n    void* p;\n    while ((p = malloc(size)) == 0)\n        if (_callnewh(size) == 0)\n        {\n            // report no memory\n            // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 \n            static const std::bad_alloc nomem; \n            _RAISE(nomem);\n        }\n        \n    return (p);\n}\n\n/*\noperator delete: 该函数最终是通过free来释放空间的 \n*/\nvoid operator delete(void* pUserData)\n{\n    _CrtMemBlockHeader* pHead;\n    \n    RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));\n    if (pUserData == NULL)\n        return;\n    _mlock(_HEAP_LOCK);  /* block other threads */\n    __TRY\n    \n        /* get a pointer to memory block header */\n        pHead = pHdr(pUserData);\n        \n    \t/* verify block type */\n    \t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));\n    \t\n    \t_free_dbg(pUserData, pHead->nBlockUse);\n    \t\n    __FINALLY\n        _munlock(_HEAP_LOCK);  /* release other threads */\n    __END_TRY_FINALLY\n    \n    return;\n}\n\n/*\nfree的实现\n*/\n\n#define free(p) _free_dbg(p, _NORMAL_BLOCK)\n~~~\n\n**1. 内置类型：**\n\n如果申请的是内置类型的空间 `new` 和 `malloc`，`delete` 和 `free` 基本类似，不同的地方是：`new/delete` 申请和释放的是单个元素的空间，`new[]` 和 `delete[]` 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc会返回NULL。\n\n**2. 自定义类型:**\n\n**new的原理：**\n\n1. 调用operator new函数申请空间\n2. 在申请的空间上执行构造函数，完成对象的构造\n\n**delete的原理：**\n\n在空间上执行析构函数，完成对象中资源的清理工作在空间上执行析构函数，完成对象中资源的清理工作\n\n`new T[N]` 的原理：\n\n1. 调用 `operator new[]` 函数，在 `operator new[]` 中实际调用 `operator new` 函数完成 N 个对象空间的申请\n2. 在申请的空间上执行N次构造函数\n\n`delete[ ]`的原理：\n1. 在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理\n2. 调用 `operator delete[]` 释放空间，实际在 `operator delete[]` 中调用 `operator delete` 来释放空间\n\n","slug":"02.C++ 基础部分/05.C++ 运算符重载","published":1,"date":"2023-08-09T00:38:38.325Z","updated":"2023-08-10T08:58:14.056Z","_id":"cll3spnt7000124pk8nok985o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节分为七个部分：</p>\n<ol>\n<li>学习复数类 Complex</li>\n<li>模拟实现 C++ 的 string 类</li>\n<li>string 字符串对象的迭代器</li>\n<li>vector 容器的迭代器 iterator 实现</li>\n<li>什么是容器的迭代器失效问题</li>\n<li>new 和 delete 重载实现的对象池</li>\n<li>深入理解 new 和 delete 的原理</li>\n</ol>\n<p><strong>什么是运算符重载</strong></p>\n<p>运算符重载实质还是一个 函数。<br>通过重载运算符，可以让类在一些场景下使用起来更加方便。</p>\n<p><strong>语法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">返回值类型 <span class=\"hljs-function\"><span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">op</span> <span class=\"hljs-params\">(参数)</span></span>;​​​​​​​<br></code></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">ClassType&amp; <span class=\"hljs-keyword\">operator</span>= (<span class=\"hljs-type\">const</span> ClassType&amp; src); <span class=\"hljs-comment\">// 重载 “=” 运算符</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-学习复数类-Complex\"><a href=\"#1-学习复数类-Complex\" class=\"headerlink\" title=\"1. 学习复数类 Complex\"></a>1. 学习复数类 Complex</h2><p>复数是形如 <code>a+b</code> 的数，复数由实部和虚部构成，在 C++ 的模板库中由 complex 类，可以直接调用，包含在complex头文件中，再使用时应该添加 <code>#include&lt;complex&gt;</code>。下面介绍一些基本操作</p>\n<h3 id=\"1-生成复数对象\"><a href=\"#1-生成复数对象\" class=\"headerlink\" title=\"1. 生成复数对象\"></a>1. 生成复数对象</h3><p>complex 类型的构造函数接受两个参数，第一个参数是复数实部的值，第二个参数是虚部的值。要想生成一个复数对象，并且对其值进行修改，参考以下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;<span class=\"hljs-built_in\">x1</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;x2;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;<span class=\"hljs-built_in\">x3</span>(x1);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x1 = (2, 3)</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x2 = &quot;</span> &lt;&lt; x2 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x2 = (0, 0)</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x3 = &quot;</span> &lt;&lt; x3 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x3 = (2, 3)</span><br><br>\tx1.<span class=\"hljs-built_in\">real</span>(<span class=\"hljs-number\">22</span>);\t<span class=\"hljs-comment\">// 修改实数部</span><br>\tx1.<span class=\"hljs-built_in\">imag</span>(<span class=\"hljs-number\">33</span>);\t<span class=\"hljs-comment\">// 修改虚数部</span><br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x1 = (22,33)</span><br><br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;a, b, c;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;请输入三个复数：&quot;</span>;<br>\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>\t\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100912113.png\" alt=\"image.png\"></p>\n<h3 id=\"2-复数的运算\"><a href=\"#2-复数的运算\" class=\"headerlink\" title=\"2. 复数的运算\"></a>2. 复数的运算</h3><p>复数和实数一样都有加减乘除四则运算，这些运算符号在 complex 模板中已经被重载过，能够直接使用，下面代码示例展示了其功能：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt; z1 = z + <span class=\"hljs-number\">5.0</span>;<br>\tcout &lt;&lt; z1 &lt;&lt; endl;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt; z2 = z - <span class=\"hljs-number\">5.0</span>;<br>\tcout &lt;&lt; z2 &lt;&lt; endl;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt; z3 = z * <span class=\"hljs-number\">2.0</span>;<br>\tcout &lt;&lt; z3 &lt;&lt; endl;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;z4 = z / <span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>\tcout &lt;&lt; z4 &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100914081.png\" alt=\"image.png\"></p>\n<h3 id=\"3-复数的比较\"><a href=\"#3-复数的比较\" class=\"headerlink\" title=\"3. 复数的比较\"></a>3. 复数的比较</h3><p>复数的比较需要同时比较实部和虚部是否都相等，有其一不等两数就 不等，下面是示例代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)</span></span>;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z3</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br><br>\tcout &lt;&lt; boolalpha &lt;&lt; (z1 == z3) &lt;&lt; endl;<br>\tcout &lt;&lt; boolalpha &lt;&lt; (z1 == z2) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100916498.png\" alt=\"image.png\"></p>\n<h3 id=\"4-实现-Complex-类\"><a href=\"#4-实现-Complex-类\" class=\"headerlink\" title=\"4. 实现 Complex 类\"></a>4. 实现 Complex 类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">//#include &lt;complex&gt;</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义Complex 类</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Complex</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 无参构造函数</span><br>\t<span class=\"hljs-built_in\">Complex</span>()<br>\t\t: <span class=\"hljs-built_in\">real</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">imag</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 有参构造函数</span><br>\t<span class=\"hljs-built_in\">Complex</span>(T re, T im)<br>\t\t: <span class=\"hljs-built_in\">real</span>(re)<br>\t\t, <span class=\"hljs-built_in\">imag</span>(im)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝构造</span><br>\t<span class=\"hljs-built_in\">Complex</span>(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t\t: <span class=\"hljs-built_in\">real</span>(com.real)<br>\t\t, <span class=\"hljs-built_in\">imag</span>(com.imag)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构</span><br>\t~<span class=\"hljs-built_in\">Complex</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// ......</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 方法</span><br>\t<span class=\"hljs-comment\">// 1. printComplex 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printComplex</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. + 方法重载：复数的加法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real += com.real;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;imag += com.imag;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. - 方法重载：复数的减法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>-(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real -= com.real;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;imag -= com.imag;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. * 方法重载：复数的乘法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real = (real * com.real) - (imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;imag = (real * com.real) + (imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 5. / 方法重载：复数的除法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>/(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real = (real * com.real + imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real = (real * com.real - imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tT real;\t<span class=\"hljs-comment\">// 实部</span><br>\tT imag;\t<span class=\"hljs-comment\">// 虚部</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">Complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">c1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0</span>, <span class=\"hljs-number\">1.0</span>)</span></span>;<br>\tc1.<span class=\"hljs-built_in\">printComplex</span>();<br>\t<span class=\"hljs-function\">Complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">c2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">3.0</span>)</span></span>;<br>\tc2.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc1 = c1 + c2;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c1 加法后：&quot;</span>;<br>\tc1.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc2 = c2 - c1;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c2 减法后：&quot;</span>;<br>\tc2.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc1 = c2 * c1;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c1 乘法后：&quot;</span>;<br>\tc1.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc2 = c2 / c1;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c2 除法后：&quot;</span>;<br>\tc2.<span class=\"hljs-built_in\">printComplex</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100954476.png\" alt=\"image.png\"></p>\n<p>另一种实现方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CComplex</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">CComplex</span>(<span class=\"hljs-type\">int</span> r = <span class=\"hljs-number\">0</span>, <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>)<br>\t\t:_mreal(r)<br>\t\t,_mimage(i)<br>\t&#123;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> CComplex&amp;obj)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mreal = obj._mreal;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mimage = obj._mimage;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//指导编译器怎么做CComplex类对象的加法操作</span><br>\t<span class=\"hljs-comment\">/*CComplex operator+(const CComplex&amp;com)</span><br><span class=\"hljs-comment\">\t&#123;</span><br><span class=\"hljs-comment\">\t\treturn CComplex(this-&gt;_mreal + com._mreal,</span><br><span class=\"hljs-comment\">\t\t\tthis-&gt;_mimage + com._mimage);</span><br><span class=\"hljs-comment\">\t&#125;*/</span><br>\tCComplex <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">CComplex</span>(<span class=\"hljs-keyword\">this</span>-&gt;_mreal++, <span class=\"hljs-keyword\">this</span>-&gt;_mimage++);<br>\t\t<span class=\"hljs-comment\">/*CComplex comp = *this;</span><br><span class=\"hljs-comment\">\t\tthis-&gt;_mimage++;</span><br><span class=\"hljs-comment\">\t\tthis-&gt;_mreal++;</span><br><span class=\"hljs-comment\">\t\treturn comp;*/</span><br>\t&#125;<br>\tCComplex&amp; <span class=\"hljs-keyword\">operator</span>++()<br>\t&#123;<br>\t\t_mreal += <span class=\"hljs-number\">1</span>;<br>\t\t_mimage += <span class=\"hljs-number\">1</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span>+=(<span class=\"hljs-type\">const</span> CComplex&amp;rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mreal += rhs._mreal;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mimage += rhs._mimage;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;real:&quot;</span> &lt;&lt; _mreal &lt;&lt; <span class=\"hljs-string\">&quot;image:&quot;</span> &lt;&lt; _mimage &lt;&lt; endl; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _mreal;<br>\t<span class=\"hljs-type\">int</span> _mimage;<br>\t<span class=\"hljs-keyword\">friend</span> CComplex <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> CComplex &amp;lhs, <span class=\"hljs-type\">const</span> CComplex &amp;rhs);<br>\t<span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp;out, <span class=\"hljs-type\">const</span> CComplex&amp;src);<br>\t<span class=\"hljs-keyword\">friend</span> istream&amp; <span class=\"hljs-keyword\">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src);<br>&#125;;<br>istream&amp; <span class=\"hljs-keyword\">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src)<br>&#123;<br>\t<span class=\"hljs-type\">int</span> a, b;<br>\tin &gt;&gt; a &gt;&gt; b;<br>\tsrc._mreal = a;<br>\tsrc._mimage = b;<br>\t<span class=\"hljs-keyword\">return</span> in;<br>&#125;<br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp;out, <span class=\"hljs-type\">const</span> CComplex&amp;src)<br>&#123;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;real:&quot;</span> &lt;&lt; src._mreal &lt;&lt; <span class=\"hljs-string\">&quot;image:&quot;</span> &lt;&lt; src._mimage &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> out;<br>&#125;<br>CComplex <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> CComplex &amp;lhs, <span class=\"hljs-type\">const</span> CComplex &amp;rhs)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">CComplex</span>(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">CComplex <span class=\"hljs-title\">c1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)</span></span>;<br>\t<span class=\"hljs-function\">CComplex <span class=\"hljs-title\">c2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>\tCComplex c4;<br>\t<br>\tc4 = c1+c2;<br>\tc4.<span class=\"hljs-built_in\">show</span>();<br>\t<br>\tc4 = c1 + <span class=\"hljs-number\">20</span>;<br>\tc4.<span class=\"hljs-built_in\">show</span>();<br>\t<br>\tc4 = <span class=\"hljs-number\">30</span> + c2;<br>\tc4.<span class=\"hljs-built_in\">show</span>();<br>\t<br>\tCComplex c5;<br>\tc5 = c4++;<br>\tc5.<span class=\"hljs-built_in\">show</span>();<br> <br>\tc5 = ++c4;<br>\tc5.<span class=\"hljs-built_in\">show</span>();<br> <br>\tc5 += c4;<br>\tc5.<span class=\"hljs-built_in\">show</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;<br> <br>\tcout &lt;&lt; c5;<br> <br>\tCComplex c6;<br>\tcin &gt;&gt; c6;<br>\tcout &lt;&lt; c6;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-模拟实现-C-的-string-类\"><a href=\"#2-模拟实现-C-的-string-类\" class=\"headerlink\" title=\"2. 模拟实现 C++ 的 string 类\"></a>2. 模拟实现 C++ 的 string 类</h2><p>string 类中的基本方法有：</p>\n<ol>\n<li>构造函数</li>\n<li><ul>\n<li>运算符重载</li>\n</ul>\n</li>\n<li><code>&lt;&lt;</code> 运算符重载</li>\n<li><blockquote>\n<p>运算符重载</p>\n</blockquote>\n</li>\n<li>len 方法</li>\n<li><code>[]</code> 运算符重载</li>\n<li>迭代器实现</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//默认构造函数</span><br>    string str1;<br>    string str2 = <span class=\"hljs-string\">&quot;aaa&quot;</span>;<br>    string str3 = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br>    <span class=\"hljs-comment\">//+ 运算符重载</span><br>    string str4 = str2 + str3;<br>    string str5 = str2 + <span class=\"hljs-string\">&quot;ccc&quot;</span>;<br>    string str6 = <span class=\"hljs-string\">&quot;ddd&quot;</span> + str2;<br><br>    <span class=\"hljs-comment\">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// &gt;  运算符重载</span><br>    <span class=\"hljs-keyword\">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获取长度</span><br>    <span class=\"hljs-type\">int</span> len = str6.<span class=\"hljs-built_in\">length</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// c_str()</span><br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">1024</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>    <span class=\"hljs-built_in\">strcpy</span>(buff, str6.<span class=\"hljs-built_in\">c_str</span>());<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// 迭代器实现</span><br>    string::iterator it = str2.<span class=\"hljs-built_in\">begin</span>();<br>    <span class=\"hljs-keyword\">for</span> (it = str2.<span class=\"hljs-built_in\">begin</span>(); it != str2.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101003436.png\" alt=\"image.png\"></p>\n<h3 id=\"1-实现-string\"><a href=\"#1-实现-string\" class=\"headerlink\" title=\"1. 实现 string\"></a>1. 实现 string</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 创建 string 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p = <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">// 创建</span><br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(p) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-comment\">// 拷贝</span><br>            <span class=\"hljs-built_in\">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">1</span>];<br>            *_pstr = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class=\"hljs-comment\">// 析构函数</span><br>    ~<span class=\"hljs-built_in\">String</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br>        _pstr = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 运算符重载</span><br>    <span class=\"hljs-comment\">// 1. =</span><br>    String&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>        &#123;<br>            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br><br>        <span class=\"hljs-comment\">// 创建</span><br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 2. &gt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&gt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &gt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 3. &lt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &lt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 4. ==</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) == <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 5. []</span><br>    <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <span class=\"hljs-type\">const</span> <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class=\"hljs-comment\">// 公共方法</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strlen</span>(_pstr);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">c_str</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">    </span>&#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr; <br>    &#125;<br><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* _pstr;<br><br>    <span class=\"hljs-comment\">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class=\"hljs-comment\">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str);<br><span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">  重载+；</span><br><span class=\"hljs-comment\">  重载+ 有两种方式：</span><br><span class=\"hljs-comment\">  (1)定义成成员函数</span><br><span class=\"hljs-comment\">  String operator+(const String&amp; s)&#123;</span><br><span class=\"hljs-comment\">    String tmp;</span><br><span class=\"hljs-comment\">    .....</span><br><span class=\"hljs-comment\">    return tmp;</span><br><span class=\"hljs-comment\">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class=\"hljs-comment\">  （2）重载为全局函数</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-comment\">/************************************************************************/</span><br>    <span class=\"hljs-keyword\">friend</span> String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class=\"hljs-keyword\">return</span> out;<br>&#125;;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class=\"hljs-comment\">并以此开辟空间大小，</span><br><span class=\"hljs-comment\">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class=\"hljs-comment\">*/</span><br>String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs)<br>&#123;<br>    <span class=\"hljs-comment\">// 计算长度</span><br>    <span class=\"hljs-type\">char</span>* _ptmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(lhs._pstr) + <span class=\"hljs-built_in\">strlen</span>(rhs._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-comment\">// 拷贝</span><br>    <span class=\"hljs-built_in\">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class=\"hljs-comment\">// 合并</span><br>    <span class=\"hljs-built_in\">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(_ptmp)</span></span>;<br>    <span class=\"hljs-keyword\">delete</span>[]_ptmp;<br>    <br>    <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class=\"hljs-string\">&quot;aaa&quot;</span>;<br>    String str3 = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br>    <span class=\"hljs-comment\">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class=\"hljs-string\">&quot;ccc&quot;</span>;<br>    String str6 = <span class=\"hljs-string\">&quot;ddd&quot;</span> + str2;<br><br>    <span class=\"hljs-comment\">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// &gt;  运算符重载</span><br>    <span class=\"hljs-keyword\">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获取长度</span><br>    <span class=\"hljs-type\">int</span> len = str6.<span class=\"hljs-built_in\">length</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// c_str()</span><br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">1024</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>    <span class=\"hljs-built_in\">strcpy</span>(buff, str6.<span class=\"hljs-built_in\">c_str</span>());<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">//</span><br>    <span class=\"hljs-comment\">//  string::iterator it = str2.begin();</span><br>    <span class=\"hljs-comment\">// for (it = str2.begin(); it != str2.end(); ++it) &#123;</span><br>     <span class=\"hljs-comment\">// cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;</span><br>    <span class=\"hljs-comment\">//&#125;</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>存在的问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs)<br>&#123;<br>    <span class=\"hljs-comment\">// 计算长度</span><br>    <span class=\"hljs-type\">char</span>* _ptmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(lhs._pstr) + <span class=\"hljs-built_in\">strlen</span>(rhs._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-comment\">// 拷贝</span><br>    <span class=\"hljs-built_in\">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class=\"hljs-comment\">// 合并</span><br>    <span class=\"hljs-built_in\">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(_ptmp)</span></span>;<br>    <span class=\"hljs-keyword\">delete</span>[]_ptmp;<br>    <br>    <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>为了将局部新开辟的内存空间 <code>_ptmp</code> 资源释放，我们后面又构造了一个临时对象 <code>String tmp(_ptmp)</code>，之后将局部变量资源释放 <code>delete[]_ptmp</code>，但是这样一来的效率非常低！</p>\n<h2 id=\"3-string-字符串对象的迭代器\"><a href=\"#3-string-字符串对象的迭代器\" class=\"headerlink\" title=\"3. string 字符串对象的迭代器\"></a>3. string 字符串对象的迭代器</h2><p>容器的迭代器可以透明的访问容器内部的元素的值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">string::iterator it = str2.<span class=\"hljs-built_in\">begin</span>();<br><span class=\"hljs-keyword\">for</span> (it = str2.<span class=\"hljs-built_in\">begin</span>(); it != str2.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br> cout &lt;&lt; (*it) &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>迭代器代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 迭代器创建</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数</span><br>    <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">char</span> *p = <span class=\"hljs-literal\">nullptr</span>) : _p(p) &#123; &#125;<br>    <span class=\"hljs-comment\">// 拷贝函数</span><br>    <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>    <br>    <span class=\"hljs-comment\">// 重载运算符</span><br>     <span class=\"hljs-comment\">// !=  如 it != s1.end()</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; it) &#123;<br>        <span class=\"hljs-keyword\">return</span> _p != it._p;<span class=\"hljs-comment\">//比较地址</span><br>    &#125;<br>    <span class=\"hljs-comment\">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>    iterator&amp; <span class=\"hljs-keyword\">operator</span>++() &#123;<br>        ++_p;<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//后置++  返回临时量</span><br>    iterator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>        <span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>        _p++;<br>        <span class=\"hljs-keyword\">return</span> tmp;<br>    &#125;<br>    <span class=\"hljs-comment\">//解引用  *iter</span><br>    <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>*() &#123; <span class=\"hljs-keyword\">return</span> *_p; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* _p;<br>&#125;;<br><br><span class=\"hljs-comment\">// 创建迭代器的 begin 和 end</span><br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr); &#125;<br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr + <span class=\"hljs-built_in\">length</span>()); &#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 创建 string 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 迭代器创建</span><br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>    &#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-comment\">// 构造函数</span><br>        <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">char</span> *p = <span class=\"hljs-literal\">nullptr</span>) : _p(p) &#123; &#125;<br>        <span class=\"hljs-comment\">// 拷贝函数</span><br>        <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>        <br>        <span class=\"hljs-comment\">// 重载运算符</span><br>         <span class=\"hljs-comment\">// !=  如 it != s1.end()</span><br>        <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; it) &#123;<br>            <span class=\"hljs-keyword\">return</span> _p != it._p;<span class=\"hljs-comment\">//比较地址</span><br>        &#125;<br>        <span class=\"hljs-comment\">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>        iterator&amp; <span class=\"hljs-keyword\">operator</span>++() &#123;<br>            ++_p;<br>            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">//后置++  返回临时量</span><br>        iterator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>            <span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>            _p++;<br>            <span class=\"hljs-keyword\">return</span> tmp;<br>        &#125;<br>        <span class=\"hljs-comment\">//解引用  *iter</span><br>        <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>*() &#123; <span class=\"hljs-keyword\">return</span> *_p; &#125;<br><br>    <span class=\"hljs-keyword\">private</span>:<br>        <span class=\"hljs-type\">char</span>* _p;<br>    &#125;;<br><br>    <span class=\"hljs-comment\">// 创建迭代器的 begin 和 end</span><br>    <span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr); &#125;<br>    <span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr + <span class=\"hljs-built_in\">length</span>()); &#125;<br><br><br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p = <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">// 创建</span><br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(p) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-comment\">// 拷贝</span><br>            <span class=\"hljs-built_in\">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">1</span>];<br>            *_pstr = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class=\"hljs-comment\">// 析构函数</span><br>    ~<span class=\"hljs-built_in\">String</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br>        _pstr = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 运算符重载</span><br>    <span class=\"hljs-comment\">// 1. =</span><br>    String&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>        &#123;<br>            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br><br>        <span class=\"hljs-comment\">// 创建</span><br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 2. &gt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&gt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &gt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 3. &lt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &lt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 4. ==</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) == <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 5. []</span><br>    <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <span class=\"hljs-type\">const</span> <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class=\"hljs-comment\">// 公共方法</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strlen</span>(_pstr);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">c_str</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">    </span>&#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr; <br>    &#125;<br><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* _pstr;<br><br>    <span class=\"hljs-comment\">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class=\"hljs-comment\">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str);<br><span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">  重载+；</span><br><span class=\"hljs-comment\">  重载+ 有两种方式：</span><br><span class=\"hljs-comment\">  (1)定义成成员函数</span><br><span class=\"hljs-comment\">  String operator+(const String&amp; s)&#123;</span><br><span class=\"hljs-comment\">    String tmp;</span><br><span class=\"hljs-comment\">    .....</span><br><span class=\"hljs-comment\">    return tmp;</span><br><span class=\"hljs-comment\">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class=\"hljs-comment\">  （2）重载为全局函数</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-comment\">/************************************************************************/</span><br>    <span class=\"hljs-keyword\">friend</span> String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class=\"hljs-keyword\">return</span> out;<br>&#125;;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class=\"hljs-comment\">并以此开辟空间大小，</span><br><span class=\"hljs-comment\">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class=\"hljs-comment\">*/</span><br>String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs)<br>&#123;<br>    <span class=\"hljs-comment\">// 计算长度</span><br>    <span class=\"hljs-type\">char</span>* _ptmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(lhs._pstr) + <span class=\"hljs-built_in\">strlen</span>(rhs._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-comment\">// 拷贝</span><br>    <span class=\"hljs-built_in\">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class=\"hljs-comment\">// 合并</span><br>    <span class=\"hljs-built_in\">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(_ptmp)</span></span>;<br>    <span class=\"hljs-keyword\">delete</span>[]_ptmp;<br>    <br>    <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class=\"hljs-string\">&quot;aaa&quot;</span>;<br>    String str3 = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br>    <span class=\"hljs-comment\">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class=\"hljs-string\">&quot;ccc&quot;</span>;<br>    String str6 = <span class=\"hljs-string\">&quot;ddd&quot;</span> + str2;<br><br>    <span class=\"hljs-comment\">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// &gt;  运算符重载</span><br>    <span class=\"hljs-keyword\">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获取长度</span><br>    <span class=\"hljs-type\">int</span> len = str6.<span class=\"hljs-built_in\">length</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// c_str()</span><br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">1024</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>    <span class=\"hljs-built_in\">strcpy</span>(buff, str6.<span class=\"hljs-built_in\">c_str</span>());<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br><br>    <span class=\"hljs-comment\">// 迭代器</span><br>    String::iterator it = str2.<span class=\"hljs-built_in\">begin</span>();<br>    <span class=\"hljs-keyword\">for</span> (it = str2.<span class=\"hljs-built_in\">begin</span>(); it != str2.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// auto</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : str2) &#123;<br>        cout &lt;&lt; ch &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-代码优化\"><a href=\"#1-代码优化\" class=\"headerlink\" title=\"1. 代码优化\"></a>1. 代码优化</h3><p><strong>带右值引用参数的拷贝构造与带右值引用参数的赋值重载函数</strong></p>\n<p>考虑这样一个操作：</p>\n<p><strong>由于问题场景的特殊，子函数调用时我们无法返回一个临时对象。<br>而且我们也只能用赋值的方式接收一个函数调用的返回值。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">String <span class=\"hljs-title\">GetString</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> String&amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n  GetString() begin\\n&quot;</span>;<br>  <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(str.c_str())</span></span>;<br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n  GetString() end\\n&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;<br> <br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  String s1 = <span class=\"hljs-string\">&quot;123&quot;</span>;<br>  String s2;<br> <br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n main call GetString() begin\\n&quot;</span>;<br>  s2 = <span class=\"hljs-built_in\">GetString</span>(s1);<br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n main call GetString() end\\n&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101105643.png\" alt=\"image.png\"></p>\n<p> 存在的问题：</p>\n<p>（1）在调用 <code>return tmp;</code> 时 实际是使用构造一个临时对象，临时对象调用拷贝构造函数从 tmp 中复制数据，然后调用析构函数析构 tmp 对象，这样就白耗费资源了，tmpStr 资源不要就早说，直接给函数栈帧上临时对象就好了；<br>（2）s2 调用赋值运算符 ：临时量给 str2 赋值，str2 是原本已经存在的对象，它也有一个指针 mptr，原先也指向了一个空间。</p>\n<p>对于赋值来说，排除自赋值，然后把原先指向的空间释放掉，然后按照 str 的尺寸开辟空间，然后拷贝数据进行来。即按照临时对象的字符串大小开辟空间，然后把数据一个一个拷贝进来。</p>\n<p>然后出语句，把这个临时对象析构及它指向的堆内存空间释放掉。</p>\n<p>过程过于复杂，为什么不能直接把临时对象的外部资源给 str2 不就完了吗？</p>\n<h3 id=\"2-右值引用\"><a href=\"#2-右值引用\" class=\"headerlink\" title=\"2. 右值引用\"></a>2. 右值引用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//C++11把临时量都当做右值处理 </span><br>\tString &amp;&amp;e = <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>);<span class=\"hljs-comment\">//可以！ </span><br>    <span class=\"hljs-type\">const</span> String &amp;e = <span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>);<span class=\"hljs-comment\">//可以！</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">  <span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-comment\">/*拷贝构造函数   //String s2 = s1;*/</span><br>  <span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (str._pstr !=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>      _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>      <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 左值拷贝构造函数\\n&quot;</span>;<br>  &#125;<br> <br>  <span class=\"hljs-comment\">//带右值引用参数的拷贝构造</span><br>  <span class=\"hljs-built_in\">String</span>(String &amp;&amp;str)<span class=\"hljs-comment\">//str引用的就是一个临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 右值拷贝构造函数\\n&quot;</span>;<br>      _pstr = str._pstr;<br>    str._pstr = <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br> <br>  <span class=\"hljs-comment\">/************************************************************************/</span><br><span class=\"hljs-comment\">/*赋值运算符    //s2 = s1*/</span><br><span class=\"hljs-comment\">/************************************************************************/</span><br>  String&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; src)<br>  &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 左值赋值运算符\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;src)<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (src._pstr == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (_pstr) &#123;<br>      <span class=\"hljs-keyword\">delete</span>[]_pstr;<br>    &#125;<br> <br> <br>    _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(src._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-built_in\">strcpy</span>(_pstr, src._pstr);<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>  &#125;<br> <br>  <span class=\"hljs-comment\">//带右值引用参数的赋值重载函数</span><br>  String&amp; <span class=\"hljs-keyword\">operator</span>=(String &amp;&amp;str)<span class=\"hljs-comment\">//str引用的是临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 右值引用参数的赋值重载函数\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (str._pstr == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">delete</span>[]_pstr;<br> <br>    <span class=\"hljs-type\">char</span> * tmp=_pstr ;<br>    _pstr = str._pstr;<br>    str._pstr = tmp;<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过右值引用，<strong>没有任何内存的开辟和释放和数据的拷贝</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101116493.png\" alt=\"image.png\"></p>\n<p>右值引用前：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117001.png\" alt=\"image.png\"></p>\n<p>右值引用后：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117760.png\" alt=\"image.png\"></p>\n<h2 id=\"4-vector-容器的迭代器-iterator-实现\"><a href=\"#4-vector-容器的迭代器-iterator-实现\" class=\"headerlink\" title=\"4. vector 容器的迭代器 iterator 实现\"></a>4. vector 容器的迭代器 iterator 实现</h2><p><strong>问题 1：删除 vector 中所有的偶数：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 删除偶数</span><br>\t<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it &lt; vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tvec.<span class=\"hljs-built_in\">erase</span>(it);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101137035.png\" alt=\"image.png\"></p>\n<p>运行导致程序崩溃！</p>\n<p><strong>问题 2：vector 容器插入元素问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it &lt; vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tvec.<span class=\"hljs-built_in\">insert</span>(it, *it - <span class=\"hljs-number\">1</span>);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101430280.png\" alt=\"image.png\"></p>\n<p>运行导致程序崩溃！</p>\n<p><strong>问题 3：push_back 触发扩容时</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">1</span>);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">2</span>);<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;容量：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">3</span>);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">4</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;后push_back容量：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;添加后，it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101503945.png\" alt=\"image.png\"></p>\n<p><strong>原因：iterator 失效</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101431915.png\" alt=\"image.png\"></p>\n<p>当删除（获取增加）it 位置的元素时，导致 it 后面的迭代器全部失效。因此多次调用 <code>erase\\insert</code>导致崩溃</p>\n<h2 id=\"5-什么是容器的迭代器失效问题\"><a href=\"#5-什么是容器的迭代器失效问题\" class=\"headerlink\" title=\"5. 什么是容器的迭代器失效问题\"></a>5. 什么是容器的迭代器失效问题</h2><h3 id=\"1-原因\"><a href=\"#1-原因\" class=\"headerlink\" title=\"1. 原因\"></a>1. 原因</h3><p><strong>问题一：</strong></p>\n<p>当容器调用 erase 时，当前位置到容器末尾元素的所有的迭代器全部失效</p>\n<p><strong>问题二：</strong></p>\n<p>当容器调用 insert 时，当前位置到容器末尾元素的所有的迭代器全部失效</p>\n<p>当容器调用 insert 时，如果引起容器内存扩容，原来容器的所有的迭代器就全部失效</p>\n<p><strong>问题三：</strong></p>\n<p>当容器 push_back 时，如果当前容量不足，则会触发扩容，导致整个容器重新申请内存，并且将原有的数据复制到新内存中将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放。</p>\n<h3 id=\"2-解决\"><a href=\"#2-解决\" class=\"headerlink\" title=\"2. 解决\"></a>2. 解决</h3><p>进行更新操作：<code>erase\\insert</code> 后会返回指向下一个元素的迭代器</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101510112.png\" alt=\"image.png\"></p>\n<ul>\n<li>[vector::erase] <a href=\"https://cplusplus.com/reference/vector/vector/erase/\">https://cplusplus.com/reference/vector/vector/erase/</a></li>\n</ul>\n<p>从向量中删除单个元素（位置）或一系列元素（<code>[第一、最后一个]</code>）。</p>\n<p>这有效地减少了容器的大小，减少了被删除的元素的数量，这些元素会被销毁。</p>\n<p>由于向量使用数组作为其底层存储，擦除向量端以外位置的元素会导致容器在段擦除后将所有元素重新定位到其新位置。与其他类型的序列容器对相同操作执行的操作相比，这通常是一种低效的操作（如列表或转发列表）。</p>\n<p>同理，insert</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101512469.png\" alt=\"image.png\"></p>\n<p>通过在指定位置的元素之前插入新元素来扩展向量，从而通过插入的元素数量有效地增加容器大小。</p>\n<p>当且仅当新向量大小超过当前向量容量时，这会导致自动重新分配分配分配的存储空间。</p>\n<p>因为向量使用数组作为其底层存储，所以在向量末端以外的位置插入元素会导致容器将位置之后的所有元素重新定位到它们的新位置。与其他类型的序列容器（如 list 或 forward_list）对相同操作执行的操作相比，这通常是一种低效的操作。</p>\n<p>这些参数确定插入的元素数量及其初始化值：</p>\n<p>也说明了进行插入操作会导致之后的迭代器失效。</p>\n<p>修改代码：</p>\n<p>erase 解决代码：**</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 把 vec 容器中的所有偶数删除</span><br>\t<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">while</span> (it != vec.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\t\tit = vec.<span class=\"hljs-built_in\">erase</span>(it);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 输出查看</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : vec)<br>\t&#123;<br>\t\tcout &lt;&lt; it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101516128.png\" alt=\"image.png\"></p>\n<p><strong>insert 解决代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  vector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; ++i) &#123;<br>    vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>  &#125;<br> <br>  <span class=\"hljs-comment\">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>  <span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>  <span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); it++) &#123;<br>    <span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>      it = vec.<span class=\"hljs-built_in\">insert</span>(it, *it - <span class=\"hljs-number\">1</span>);<br>      <span class=\"hljs-comment\">// it原来的位置插入了新的，需要++it两次，才能到该偶数的后一个元素</span><br>      it++;<br>    &#125;<br>  &#125;<br> <br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> val : vec) &#123;<br>    cout &lt;&lt; val &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101520065.png\" alt=\"image.png\"></p>\n<h3 id=\"3-vector-实现中的-insert-和-erase\"><a href=\"#3-vector-实现中的-insert-和-erase\" class=\"headerlink\" title=\"3. vector 实现中的 insert 和 erase\"></a>3. vector 实现中的 insert 和 erase</h3><p>头插法：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101522251.png\" alt=\"image.png\"></p>\n<p>检查迭代器失效：</p>\n<p>在进行删除或增加的时候，要检测该位置到 last 位置，使其迭代器失效</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 从容器末尾删除元素</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>    <span class=\"hljs-keyword\">return</span>;<br> <br>  <span class=\"hljs-comment\">//检查迭代器 从该位置到最后</span><br>  <span class=\"hljs-built_in\">verify</span>(Last<span class=\"hljs-number\">-1</span>,Last);<br> <br>  <span class=\"hljs-comment\">// 不仅要把_last指针--，还需要析构删除的元素</span><br>  --Last;<br>  _allocator.<span class=\"hljs-built_in\">destroy</span>(Last);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>迭代器检查实现：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">verify</span><span class=\"hljs-params\">(T* first, t* last)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tIterator_Base* pre = &amp;<span class=\"hljs-keyword\">this</span>-&gt;head;<br>\tIterator_Base* it = &amp;<span class=\"hljs-keyword\">this</span>-&gt;head._next;<br><br>\t<span class=\"hljs-keyword\">while</span> (it != <span class=\"hljs-literal\">nullptr</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 迭代器失效，把 iterator 持有的容器指针置空</span><br>\t\t\tit-&gt;_cur-&gt;_pVec = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t\t<span class=\"hljs-comment\">// 删除当前迭代器节点，继续判断后面的迭代器是否失效</span><br>\t\t\tpre-&gt;_next = it-&gt;_next;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> it;<br>\t\t\tit = pre-&gt;_next;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tpre = it;<br>\t\t\tit = it-&gt;_next;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-new-和-delete-重载实现的对象池\"><a href=\"#6-new-和-delete-重载实现的对象池\" class=\"headerlink\" title=\"6. new 和 delete 重载实现的对象池\"></a>6. new 和 delete 重载实现的对象池</h2><p>在编程中，我们经常会涉及到对象的操作，而经常的操作模式如下图所示:<code>创建对象</code>-&gt;<code>使用对象</code>-&gt;<code>销毁对象</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101557430.png\" alt=\"image.png\"></p>\n<p>而这个对象有可能创建的时候会需要构建很多资源，消耗比较大, 比如：在<code>hiredis</code>的SDK中每次都创建一个<code>redisContext</code>，如果需要查询，那就首先要进行网络连接。如果一直都是上图的工作方式，那将会频繁的创建连接，查询完毕后再释放连接。重新建立连接，让网络的查询效率降低。</p>\n<p>这个时候就可以构建一个<code>对象池</code>来重复利用这个对象，并且一般要做到线程安全:</p>\n<ol>\n<li>从<code>对象池</code>中获取对象，如果没有对象，则创建一个，并返回</li>\n<li>使用对象</li>\n<li>使用完成对象后，将对象还回<code>对象池</code></li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101559621.png\" alt=\"image.png\"></p>\n<p>那么符合如下条件的，应该适合使用<code>对象池</code>技术:</p>\n<ul>\n<li>有一些对象虽然创建开销比较大，但是不一定能够重复使用。要使用<code>对象池</code>一定要确保对象能够重复使用。</li>\n<li>这个对象构建的时候，有一些耗时的资源可以重复利用。比如<code>redisContext</code>的网络连接。又或者如果对象的频繁申请释放会带来一些其他的资源使用问题，比如<code>内存碎片</code>。重复利用能够提升程序的效率。</li>\n<li><code>对象池</code>的数量应该控制在能够接受的范围内，并不会无限膨胀。</li>\n</ul>\n<h3 id=\"1-对象池实现原理\"><a href=\"#1-对象池实现原理\" class=\"headerlink\" title=\"1. 对象池实现原理\"></a>1. 对象池实现原理</h3><ol>\n<li><strong>分配过程：</strong></li>\n</ol>\n<p><strong>我们首先申请比如 100000 块内存空间，用这个块类型的指针指向这个申请好内存的首地址。如图：这个块可以是一个链式队列的一个节点或者一个树的节点等。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101603100.png\" alt=\"image.png\"><br><strong>当我们要分配给用户一块空间的时候我们就可以，先将 <code>_itemPool</code> 的地址保存到临时指针 p，然后再 <code>_itemPool++</code> 的操作，然后再将 p 返回给用户即可。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101604537.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>释放过程：</strong></li>\n</ol>\n<p><strong>比如现在的内存分配状况如图所示：现在用户需要归还第 1 块内存。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101605266.png\" alt=\"image.png\"></p>\n<p>我们首先要归还块的首地址指向 <code>_itemPool</code> 的下一个块，然后再将 <code>_itemPool</code> 指向归还的块的地址。即可</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101606815.png\" alt=\"image.png\"></p>\n<h3 id=\"2-以队列实现一个简单对象池\"><a href=\"#2-以队列实现一个简单对象池\" class=\"headerlink\" title=\"2. 以队列实现一个简单对象池\"></a>2. 以队列实现一个简单对象池</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">运算符的重载  :成员方法、全局方法</span><br><span class=\"hljs-comment\">内存池 进程池 线程池 连接池 对象池</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">Queue</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化指针</span><br>\t\t_front = _rear = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">QueueItem</span>();<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">Queue</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 创建新对象</span><br>\t\tQueueItem* cur = _front;<br>\t\t<span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">nullptr</span>)<br>\t\t&#123;<br>\t\t\t_front = cur-&gt;_next;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> cur;<br>\t\t\tcur = _front;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝对象</span><br>\t<span class=\"hljs-built_in\">Queue</span>(<span class=\"hljs-type\">const</span> Queue&amp; obj) = <span class=\"hljs-keyword\">delete</span>;<br><br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Queue&amp; obj) = <span class=\"hljs-keyword\">delete</span>;<br><br>\t<span class=\"hljs-comment\">// 方法</span><br>\t<span class=\"hljs-comment\">// 1. push 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tQueueItem* item = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">QueueItem</span>(val);<br>\t\t_rear-&gt;_next = item;<br>\t\t_rear = item;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. pop 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\tQueueItem* first = _front-&gt;_next;<br>\t\t_front-&gt;_next = first-&gt;_next;<br>\t\t<span class=\"hljs-keyword\">if</span> (_front-&gt;_next == <span class=\"hljs-literal\">nullptr</span>)<br>\t\t&#123;<br>\t\t\t_rear = _front;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> first;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. front 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">front</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> _front-&gt;_next-&gt;_data;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span><span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> _rear == _front; &#125;<br><br>\t<span class=\"hljs-comment\">// 产生一个 QueueItem 的对象池</span><br>\t<span class=\"hljs-comment\">// 创建一个对象池结构</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">QueueItem</span><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 构造函数</span><br>\t\t<span class=\"hljs-built_in\">QueueItem</span>(T data = <span class=\"hljs-built_in\">T</span>()) :_data(data), _next(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;<br><br>\t\t<span class=\"hljs-comment\">// new 重载</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (_itemPool == <span class=\"hljs-literal\">nullptr</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-comment\">//由于我们不知道QueueItem的具体大小(模板未进行实例化)所以我们这里用char 1字节作为new的基准</span><br>\t\t\t\t_itemPool = (QueueItem*)<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[POOL_ITEM_SIZE * <span class=\"hljs-built_in\">sizeof</span>(QueueItem)];<br>\t\t\t\tQueueItem* p = _itemPool;<br>\t\t\t\t<span class=\"hljs-comment\">//把开辟的POOL_ITEM_SIZE个块关联起来</span><br>\t\t\t\t<span class=\"hljs-keyword\">for</span> (; p != _itemPool + POOL_ITEM_SIZE - <span class=\"hljs-number\">1</span>; ++p)<br>\t\t\t\t&#123;<br>\t\t\t\t\tp-&gt;_next = p + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-comment\">//最后一块的next置为空</span><br>\t\t\t\tp-&gt;_next = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">//将第一块可以分配的块分配给用户</span><br>\t\t\tQueueItem* p = _itemPool;<br>\t\t\t_itemPool = _itemPool-&gt;_next;<br>\t\t\t<span class=\"hljs-keyword\">return</span> p;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// delete 重载</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ptr)</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-comment\">//进行归还操作</span><br>\t\t\tQueueItem* p = (QueueItem*)ptr;<br>\t\t\tp-&gt;_next = _itemPool;<br>\t\t\t_itemPool = p;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 静态数据</span><br>\t\t<span class=\"hljs-type\">static</span> QueueItem* _itemPool;<br>\t\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> POOL_ITEM_SIZE = <span class=\"hljs-number\">1000000</span>;<br><br>\t\t<span class=\"hljs-comment\">// 对象池单个对象</span><br>\t\tT _data;<br>\t\tQueueItem* _next;<br>\t&#125;;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tQueueItem* _front;<span class=\"hljs-comment\">//指向头节点</span><br>\tQueueItem* _rear;<span class=\"hljs-comment\">//指向队尾</span><br>&#125;;<br><br><span class=\"hljs-comment\">//typename 告诉编译器后面是类型</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">typename</span> Queue&lt;T&gt;::QueueItem* Queue&lt;T&gt;::QueueItem::_itemPool = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tQueue&lt;<span class=\"hljs-type\">int</span>&gt; que;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000000</span>; ++i)<span class=\"hljs-comment\">//大量的new delete;不划算</span><br>\t&#123;<br>\t\tque.<span class=\"hljs-built_in\">push</span>(i);<br>\t\tque.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\tcout &lt;&lt; que.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-深入理解-new-和-delete-的原理\"><a href=\"#7-深入理解-new-和-delete-的原理\" class=\"headerlink\" title=\"7. 深入理解 new 和 delete 的原理\"></a>7. 深入理解 new 和 delete 的原理</h2><p><strong>new和delete</strong>是用户进行<strong>动态内存申请和释放的操作符</strong>，<strong>operator new 和operator delete</strong>是系统提供的<strong>全局函数</strong>，<strong>new在底层调用operator new</strong>全局函数来申请空间，<strong>delete在底层通过operator delete</strong>全局函数来释放空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">operator new:该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* __CRTDECL <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span> _<span class=\"hljs-title\">THROW1</span><span class=\"hljs-params\">(_STD bad_alloc)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// try to allocate size bytes</span><br>    <span class=\"hljs-type\">void</span>* p;<br>    <span class=\"hljs-keyword\">while</span> ((p = <span class=\"hljs-built_in\">malloc</span>(size)) == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">if</span> (_callnewh(size) == <span class=\"hljs-number\">0</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">// report no memory</span><br>            <span class=\"hljs-comment\">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常 </span><br>            <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> std::bad_alloc nomem; <br>            _RAISE(nomem);<br>        &#125;<br>        <br>    <span class=\"hljs-keyword\">return</span> (p);<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">operator delete: 该函数最终是通过free来释放空间的 </span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* pUserData)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    _CrtMemBlockHeader* pHead;<br>    <br>    <span class=\"hljs-built_in\">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class=\"hljs-number\">0</span>));<br>    <span class=\"hljs-keyword\">if</span> (pUserData == <span class=\"hljs-literal\">NULL</span>)<br>        <span class=\"hljs-keyword\">return</span>;<br>    _mlock(_HEAP_LOCK);  <span class=\"hljs-comment\">/* block other threads */</span><br>    __TRY<br>    <br>        <span class=\"hljs-comment\">/* get a pointer to memory block header */</span><br>        pHead = <span class=\"hljs-built_in\">pHdr</span>(pUserData);<br>        <br>    \t<span class=\"hljs-comment\">/* verify block type */</span><br>    \t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));<br>    \t<br>    \t_free_dbg(pUserData, pHead-&gt;nBlockUse);<br>    \t<br>    __FINALLY<br>        _munlock(_HEAP_LOCK);  <span class=\"hljs-comment\">/* release other threads */</span><br>    __END_TRY_FINALLY<br>    <br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">free的实现</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> free(p) _free_dbg(p, _NORMAL_BLOCK)</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>1. 内置类型：</strong></p>\n<p>如果申请的是内置类型的空间 <code>new</code> 和 <code>malloc</code>，<code>delete</code> 和 <code>free</code> 基本类似，不同的地方是：<code>new/delete</code> 申请和释放的是单个元素的空间，<code>new[]</code> 和 <code>delete[]</code> 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc会返回NULL。</p>\n<p><strong>2. 自定义类型:</strong></p>\n<p><strong>new的原理：</strong></p>\n<ol>\n<li>调用operator new函数申请空间</li>\n<li>在申请的空间上执行构造函数，完成对象的构造</li>\n</ol>\n<p><strong>delete的原理：</strong></p>\n<p>在空间上执行析构函数，完成对象中资源的清理工作在空间上执行析构函数，完成对象中资源的清理工作</p>\n<p><code>new T[N]</code> 的原理：</p>\n<ol>\n<li>调用 <code>operator new[]</code> 函数，在 <code>operator new[]</code> 中实际调用 <code>operator new</code> 函数完成 N 个对象空间的申请</li>\n<li>在申请的空间上执行N次构造函数</li>\n</ol>\n<p><code>delete[ ]</code>的原理：</p>\n<ol>\n<li>在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理</li>\n<li>调用 <code>operator delete[]</code> 释放空间，实际在 <code>operator delete[]</code> 中调用 <code>operator delete</code> 来释放空间</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本节分为七个部分：</p>\n<ol>\n<li>学习复数类 Complex</li>\n<li>模拟实现 C++ 的 string 类</li>\n<li>string 字符串对象的迭代器</li>\n<li>vector 容器的迭代器 iterator 实现</li>\n<li>什么是容器的迭代器失效问题</li>\n<li>new 和 delete 重载实现的对象池</li>\n<li>深入理解 new 和 delete 的原理</li>\n</ol>\n<p><strong>什么是运算符重载</strong></p>\n<p>运算符重载实质还是一个 函数。<br>通过重载运算符，可以让类在一些场景下使用起来更加方便。</p>\n<p><strong>语法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">返回值类型 <span class=\"hljs-function\"><span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">op</span> <span class=\"hljs-params\">(参数)</span></span>;​​​​​​​<br></code></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">ClassType&amp; <span class=\"hljs-keyword\">operator</span>= (<span class=\"hljs-type\">const</span> ClassType&amp; src); <span class=\"hljs-comment\">// 重载 “=” 运算符</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-学习复数类-Complex\"><a href=\"#1-学习复数类-Complex\" class=\"headerlink\" title=\"1. 学习复数类 Complex\"></a>1. 学习复数类 Complex</h2><p>复数是形如 <code>a+b</code> 的数，复数由实部和虚部构成，在 C++ 的模板库中由 complex 类，可以直接调用，包含在complex头文件中，再使用时应该添加 <code>#include&lt;complex&gt;</code>。下面介绍一些基本操作</p>\n<h3 id=\"1-生成复数对象\"><a href=\"#1-生成复数对象\" class=\"headerlink\" title=\"1. 生成复数对象\"></a>1. 生成复数对象</h3><p>complex 类型的构造函数接受两个参数，第一个参数是复数实部的值，第二个参数是虚部的值。要想生成一个复数对象，并且对其值进行修改，参考以下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;<span class=\"hljs-built_in\">x1</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;x2;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;<span class=\"hljs-built_in\">x3</span>(x1);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x1 = (2, 3)</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x2 = &quot;</span> &lt;&lt; x2 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x2 = (0, 0)</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x3 = &quot;</span> &lt;&lt; x3 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x3 = (2, 3)</span><br><br>\tx1.<span class=\"hljs-built_in\">real</span>(<span class=\"hljs-number\">22</span>);\t<span class=\"hljs-comment\">// 修改实数部</span><br>\tx1.<span class=\"hljs-built_in\">imag</span>(<span class=\"hljs-number\">33</span>);\t<span class=\"hljs-comment\">// 修改虚数部</span><br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;x1 = &quot;</span> &lt;&lt; x1 &lt;&lt; endl;\t\t<span class=\"hljs-comment\">// x1 = (22,33)</span><br><br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;a, b, c;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;请输入三个复数：&quot;</span>;<br>\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>\t\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100912113.png\" alt=\"image.png\"></p>\n<h3 id=\"2-复数的运算\"><a href=\"#2-复数的运算\" class=\"headerlink\" title=\"2. 复数的运算\"></a>2. 复数的运算</h3><p>复数和实数一样都有加减乘除四则运算，这些运算符号在 complex 模板中已经被重载过，能够直接使用，下面代码示例展示了其功能：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt; z1 = z + <span class=\"hljs-number\">5.0</span>;<br>\tcout &lt;&lt; z1 &lt;&lt; endl;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt; z2 = z - <span class=\"hljs-number\">5.0</span>;<br>\tcout &lt;&lt; z2 &lt;&lt; endl;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt; z3 = z * <span class=\"hljs-number\">2.0</span>;<br>\tcout &lt;&lt; z3 &lt;&lt; endl;<br>\tcomplex&lt;<span class=\"hljs-type\">double</span>&gt;z4 = z / <span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>);<br>\tcout &lt;&lt; z4 &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100914081.png\" alt=\"image.png\"></p>\n<h3 id=\"3-复数的比较\"><a href=\"#3-复数的比较\" class=\"headerlink\" title=\"3. 复数的比较\"></a>3. 复数的比较</h3><p>复数的比较需要同时比较实部和虚部是否都相等，有其一不等两数就 不等，下面是示例代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)</span></span>;<br>\t<span class=\"hljs-function\">complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">z3</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br><br>\tcout &lt;&lt; boolalpha &lt;&lt; (z1 == z3) &lt;&lt; endl;<br>\tcout &lt;&lt; boolalpha &lt;&lt; (z1 == z2) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100916498.png\" alt=\"image.png\"></p>\n<h3 id=\"4-实现-Complex-类\"><a href=\"#4-实现-Complex-类\" class=\"headerlink\" title=\"4. 实现 Complex 类\"></a>4. 实现 Complex 类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">//#include &lt;complex&gt;</span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义Complex 类</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Complex</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 无参构造函数</span><br>\t<span class=\"hljs-built_in\">Complex</span>()<br>\t\t: <span class=\"hljs-built_in\">real</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">imag</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 有参构造函数</span><br>\t<span class=\"hljs-built_in\">Complex</span>(T re, T im)<br>\t\t: <span class=\"hljs-built_in\">real</span>(re)<br>\t\t, <span class=\"hljs-built_in\">imag</span>(im)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝构造</span><br>\t<span class=\"hljs-built_in\">Complex</span>(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t\t: <span class=\"hljs-built_in\">real</span>(com.real)<br>\t\t, <span class=\"hljs-built_in\">imag</span>(com.imag)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构</span><br>\t~<span class=\"hljs-built_in\">Complex</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// ......</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 方法</span><br>\t<span class=\"hljs-comment\">// 1. printComplex 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printComplex</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. + 方法重载：复数的加法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real += com.real;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;imag += com.imag;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. - 方法重载：复数的减法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>-(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real -= com.real;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;imag -= com.imag;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. * 方法重载：复数的乘法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real = (real * com.real) - (imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;imag = (real * com.real) + (imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 5. / 方法重载：复数的除法</span><br>\tComplex&amp; <span class=\"hljs-keyword\">operator</span>/(<span class=\"hljs-type\">const</span> Complex&lt;T&gt;&amp; com)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real = (real * com.real + imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;real = (real * com.real - imag * com.imag) / (com.real * com.real + com.imag * com.imag);<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tT real;\t<span class=\"hljs-comment\">// 实部</span><br>\tT imag;\t<span class=\"hljs-comment\">// 虚部</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">Complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">c1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0</span>, <span class=\"hljs-number\">1.0</span>)</span></span>;<br>\tc1.<span class=\"hljs-built_in\">printComplex</span>();<br>\t<span class=\"hljs-function\">Complex&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">c2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">3.0</span>)</span></span>;<br>\tc2.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc1 = c1 + c2;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c1 加法后：&quot;</span>;<br>\tc1.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc2 = c2 - c1;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c2 减法后：&quot;</span>;<br>\tc2.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc1 = c2 * c1;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c1 乘法后：&quot;</span>;<br>\tc1.<span class=\"hljs-built_in\">printComplex</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tc2 = c2 / c1;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;c2 除法后：&quot;</span>;<br>\tc2.<span class=\"hljs-built_in\">printComplex</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308100954476.png\" alt=\"image.png\"></p>\n<p>另一种实现方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CComplex</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">CComplex</span>(<span class=\"hljs-type\">int</span> r = <span class=\"hljs-number\">0</span>, <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>)<br>\t\t:_mreal(r)<br>\t\t,_mimage(i)<br>\t&#123;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> CComplex&amp;obj)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mreal = obj._mreal;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mimage = obj._mimage;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//指导编译器怎么做CComplex类对象的加法操作</span><br>\t<span class=\"hljs-comment\">/*CComplex operator+(const CComplex&amp;com)</span><br><span class=\"hljs-comment\">\t&#123;</span><br><span class=\"hljs-comment\">\t\treturn CComplex(this-&gt;_mreal + com._mreal,</span><br><span class=\"hljs-comment\">\t\t\tthis-&gt;_mimage + com._mimage);</span><br><span class=\"hljs-comment\">\t&#125;*/</span><br>\tCComplex <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">CComplex</span>(<span class=\"hljs-keyword\">this</span>-&gt;_mreal++, <span class=\"hljs-keyword\">this</span>-&gt;_mimage++);<br>\t\t<span class=\"hljs-comment\">/*CComplex comp = *this;</span><br><span class=\"hljs-comment\">\t\tthis-&gt;_mimage++;</span><br><span class=\"hljs-comment\">\t\tthis-&gt;_mreal++;</span><br><span class=\"hljs-comment\">\t\treturn comp;*/</span><br>\t&#125;<br>\tCComplex&amp; <span class=\"hljs-keyword\">operator</span>++()<br>\t&#123;<br>\t\t_mreal += <span class=\"hljs-number\">1</span>;<br>\t\t_mimage += <span class=\"hljs-number\">1</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span>+=(<span class=\"hljs-type\">const</span> CComplex&amp;rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mreal += rhs._mreal;<br>\t\t<span class=\"hljs-keyword\">this</span>-&gt;_mimage += rhs._mimage;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;real:&quot;</span> &lt;&lt; _mreal &lt;&lt; <span class=\"hljs-string\">&quot;image:&quot;</span> &lt;&lt; _mimage &lt;&lt; endl; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _mreal;<br>\t<span class=\"hljs-type\">int</span> _mimage;<br>\t<span class=\"hljs-keyword\">friend</span> CComplex <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> CComplex &amp;lhs, <span class=\"hljs-type\">const</span> CComplex &amp;rhs);<br>\t<span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp;out, <span class=\"hljs-type\">const</span> CComplex&amp;src);<br>\t<span class=\"hljs-keyword\">friend</span> istream&amp; <span class=\"hljs-keyword\">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src);<br>&#125;;<br>istream&amp; <span class=\"hljs-keyword\">operator</span>&gt;&gt;(istream&amp;in, CComplex&amp;src)<br>&#123;<br>\t<span class=\"hljs-type\">int</span> a, b;<br>\tin &gt;&gt; a &gt;&gt; b;<br>\tsrc._mreal = a;<br>\tsrc._mimage = b;<br>\t<span class=\"hljs-keyword\">return</span> in;<br>&#125;<br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp;out, <span class=\"hljs-type\">const</span> CComplex&amp;src)<br>&#123;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;real:&quot;</span> &lt;&lt; src._mreal &lt;&lt; <span class=\"hljs-string\">&quot;image:&quot;</span> &lt;&lt; src._mimage &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> out;<br>&#125;<br>CComplex <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> CComplex &amp;lhs, <span class=\"hljs-type\">const</span> CComplex &amp;rhs)<br>&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">CComplex</span>(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">CComplex <span class=\"hljs-title\">c1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)</span></span>;<br>\t<span class=\"hljs-function\">CComplex <span class=\"hljs-title\">c2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)</span></span>;<br>\tCComplex c4;<br>\t<br>\tc4 = c1+c2;<br>\tc4.<span class=\"hljs-built_in\">show</span>();<br>\t<br>\tc4 = c1 + <span class=\"hljs-number\">20</span>;<br>\tc4.<span class=\"hljs-built_in\">show</span>();<br>\t<br>\tc4 = <span class=\"hljs-number\">30</span> + c2;<br>\tc4.<span class=\"hljs-built_in\">show</span>();<br>\t<br>\tCComplex c5;<br>\tc5 = c4++;<br>\tc5.<span class=\"hljs-built_in\">show</span>();<br> <br>\tc5 = ++c4;<br>\tc5.<span class=\"hljs-built_in\">show</span>();<br> <br>\tc5 += c4;<br>\tc5.<span class=\"hljs-built_in\">show</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;<br> <br>\tcout &lt;&lt; c5;<br> <br>\tCComplex c6;<br>\tcin &gt;&gt; c6;<br>\tcout &lt;&lt; c6;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-模拟实现-C-的-string-类\"><a href=\"#2-模拟实现-C-的-string-类\" class=\"headerlink\" title=\"2. 模拟实现 C++ 的 string 类\"></a>2. 模拟实现 C++ 的 string 类</h2><p>string 类中的基本方法有：</p>\n<ol>\n<li>构造函数</li>\n<li><ul>\n<li>运算符重载</li>\n</ul>\n</li>\n<li><code>&lt;&lt;</code> 运算符重载</li>\n<li><blockquote>\n<p>运算符重载</p>\n</blockquote>\n</li>\n<li>len 方法</li>\n<li><code>[]</code> 运算符重载</li>\n<li>迭代器实现</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//默认构造函数</span><br>    string str1;<br>    string str2 = <span class=\"hljs-string\">&quot;aaa&quot;</span>;<br>    string str3 = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br>    <span class=\"hljs-comment\">//+ 运算符重载</span><br>    string str4 = str2 + str3;<br>    string str5 = str2 + <span class=\"hljs-string\">&quot;ccc&quot;</span>;<br>    string str6 = <span class=\"hljs-string\">&quot;ddd&quot;</span> + str2;<br><br>    <span class=\"hljs-comment\">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// &gt;  运算符重载</span><br>    <span class=\"hljs-keyword\">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获取长度</span><br>    <span class=\"hljs-type\">int</span> len = str6.<span class=\"hljs-built_in\">length</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// c_str()</span><br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">1024</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>    <span class=\"hljs-built_in\">strcpy</span>(buff, str6.<span class=\"hljs-built_in\">c_str</span>());<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// 迭代器实现</span><br>    string::iterator it = str2.<span class=\"hljs-built_in\">begin</span>();<br>    <span class=\"hljs-keyword\">for</span> (it = str2.<span class=\"hljs-built_in\">begin</span>(); it != str2.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101003436.png\" alt=\"image.png\"></p>\n<h3 id=\"1-实现-string\"><a href=\"#1-实现-string\" class=\"headerlink\" title=\"1. 实现 string\"></a>1. 实现 string</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 创建 string 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p = <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">// 创建</span><br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(p) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-comment\">// 拷贝</span><br>            <span class=\"hljs-built_in\">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">1</span>];<br>            *_pstr = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class=\"hljs-comment\">// 析构函数</span><br>    ~<span class=\"hljs-built_in\">String</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br>        _pstr = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 运算符重载</span><br>    <span class=\"hljs-comment\">// 1. =</span><br>    String&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>        &#123;<br>            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br><br>        <span class=\"hljs-comment\">// 创建</span><br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 2. &gt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&gt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &gt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 3. &lt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &lt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 4. ==</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) == <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 5. []</span><br>    <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <span class=\"hljs-type\">const</span> <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class=\"hljs-comment\">// 公共方法</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strlen</span>(_pstr);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">c_str</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">    </span>&#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr; <br>    &#125;<br><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* _pstr;<br><br>    <span class=\"hljs-comment\">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class=\"hljs-comment\">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str);<br><span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">  重载+；</span><br><span class=\"hljs-comment\">  重载+ 有两种方式：</span><br><span class=\"hljs-comment\">  (1)定义成成员函数</span><br><span class=\"hljs-comment\">  String operator+(const String&amp; s)&#123;</span><br><span class=\"hljs-comment\">    String tmp;</span><br><span class=\"hljs-comment\">    .....</span><br><span class=\"hljs-comment\">    return tmp;</span><br><span class=\"hljs-comment\">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class=\"hljs-comment\">  （2）重载为全局函数</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-comment\">/************************************************************************/</span><br>    <span class=\"hljs-keyword\">friend</span> String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class=\"hljs-keyword\">return</span> out;<br>&#125;;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class=\"hljs-comment\">并以此开辟空间大小，</span><br><span class=\"hljs-comment\">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class=\"hljs-comment\">*/</span><br>String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs)<br>&#123;<br>    <span class=\"hljs-comment\">// 计算长度</span><br>    <span class=\"hljs-type\">char</span>* _ptmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(lhs._pstr) + <span class=\"hljs-built_in\">strlen</span>(rhs._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-comment\">// 拷贝</span><br>    <span class=\"hljs-built_in\">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class=\"hljs-comment\">// 合并</span><br>    <span class=\"hljs-built_in\">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(_ptmp)</span></span>;<br>    <span class=\"hljs-keyword\">delete</span>[]_ptmp;<br>    <br>    <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class=\"hljs-string\">&quot;aaa&quot;</span>;<br>    String str3 = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br>    <span class=\"hljs-comment\">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class=\"hljs-string\">&quot;ccc&quot;</span>;<br>    String str6 = <span class=\"hljs-string\">&quot;ddd&quot;</span> + str2;<br><br>    <span class=\"hljs-comment\">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// &gt;  运算符重载</span><br>    <span class=\"hljs-keyword\">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获取长度</span><br>    <span class=\"hljs-type\">int</span> len = str6.<span class=\"hljs-built_in\">length</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// c_str()</span><br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">1024</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>    <span class=\"hljs-built_in\">strcpy</span>(buff, str6.<span class=\"hljs-built_in\">c_str</span>());<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">//</span><br>    <span class=\"hljs-comment\">//  string::iterator it = str2.begin();</span><br>    <span class=\"hljs-comment\">// for (it = str2.begin(); it != str2.end(); ++it) &#123;</span><br>     <span class=\"hljs-comment\">// cout &lt;&lt; (*it) &lt;&lt; &quot; &quot;;</span><br>    <span class=\"hljs-comment\">//&#125;</span><br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>存在的问题：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs)<br>&#123;<br>    <span class=\"hljs-comment\">// 计算长度</span><br>    <span class=\"hljs-type\">char</span>* _ptmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(lhs._pstr) + <span class=\"hljs-built_in\">strlen</span>(rhs._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-comment\">// 拷贝</span><br>    <span class=\"hljs-built_in\">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class=\"hljs-comment\">// 合并</span><br>    <span class=\"hljs-built_in\">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(_ptmp)</span></span>;<br>    <span class=\"hljs-keyword\">delete</span>[]_ptmp;<br>    <br>    <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>为了将局部新开辟的内存空间 <code>_ptmp</code> 资源释放，我们后面又构造了一个临时对象 <code>String tmp(_ptmp)</code>，之后将局部变量资源释放 <code>delete[]_ptmp</code>，但是这样一来的效率非常低！</p>\n<h2 id=\"3-string-字符串对象的迭代器\"><a href=\"#3-string-字符串对象的迭代器\" class=\"headerlink\" title=\"3. string 字符串对象的迭代器\"></a>3. string 字符串对象的迭代器</h2><p>容器的迭代器可以透明的访问容器内部的元素的值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">string::iterator it = str2.<span class=\"hljs-built_in\">begin</span>();<br><span class=\"hljs-keyword\">for</span> (it = str2.<span class=\"hljs-built_in\">begin</span>(); it != str2.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br> cout &lt;&lt; (*it) &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>迭代器代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 迭代器创建</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数</span><br>    <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">char</span> *p = <span class=\"hljs-literal\">nullptr</span>) : _p(p) &#123; &#125;<br>    <span class=\"hljs-comment\">// 拷贝函数</span><br>    <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>    <br>    <span class=\"hljs-comment\">// 重载运算符</span><br>     <span class=\"hljs-comment\">// !=  如 it != s1.end()</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; it) &#123;<br>        <span class=\"hljs-keyword\">return</span> _p != it._p;<span class=\"hljs-comment\">//比较地址</span><br>    &#125;<br>    <span class=\"hljs-comment\">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>    iterator&amp; <span class=\"hljs-keyword\">operator</span>++() &#123;<br>        ++_p;<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">//后置++  返回临时量</span><br>    iterator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>        <span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>        _p++;<br>        <span class=\"hljs-keyword\">return</span> tmp;<br>    &#125;<br>    <span class=\"hljs-comment\">//解引用  *iter</span><br>    <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>*() &#123; <span class=\"hljs-keyword\">return</span> *_p; &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* _p;<br>&#125;;<br><br><span class=\"hljs-comment\">// 创建迭代器的 begin 和 end</span><br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr); &#125;<br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr + <span class=\"hljs-built_in\">length</span>()); &#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 创建 string 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">String</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 迭代器创建</span><br>    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>    &#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-comment\">// 构造函数</span><br>        <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">char</span> *p = <span class=\"hljs-literal\">nullptr</span>) : _p(p) &#123; &#125;<br>        <span class=\"hljs-comment\">// 拷贝函数</span><br>        <span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter) : _p(iter._p) &#123; &#125;<br>        <br>        <span class=\"hljs-comment\">// 重载运算符</span><br>         <span class=\"hljs-comment\">// !=  如 it != s1.end()</span><br>        <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; it) &#123;<br>            <span class=\"hljs-keyword\">return</span> _p != it._p;<span class=\"hljs-comment\">//比较地址</span><br>        &#125;<br>        <span class=\"hljs-comment\">//前置++  返回引用：效率更高，因为后置++ 会产生临时变量</span><br>        iterator&amp; <span class=\"hljs-keyword\">operator</span>++() &#123;<br>            ++_p;<br>            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">//后置++  返回临时量</span><br>        iterator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>            <span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>            _p++;<br>            <span class=\"hljs-keyword\">return</span> tmp;<br>        &#125;<br>        <span class=\"hljs-comment\">//解引用  *iter</span><br>        <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>*() &#123; <span class=\"hljs-keyword\">return</span> *_p; &#125;<br><br>    <span class=\"hljs-keyword\">private</span>:<br>        <span class=\"hljs-type\">char</span>* _p;<br>    &#125;;<br><br>    <span class=\"hljs-comment\">// 创建迭代器的 begin 和 end</span><br>    <span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr); &#125;<br>    <span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(_pstr + <span class=\"hljs-built_in\">length</span>()); &#125;<br><br><br>    <span class=\"hljs-comment\">// 默认构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p = <span class=\"hljs-literal\">nullptr</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (p != <span class=\"hljs-literal\">nullptr</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">// 创建</span><br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(p) + <span class=\"hljs-number\">1</span>];<br>            <span class=\"hljs-comment\">// 拷贝</span><br>            <span class=\"hljs-built_in\">strcpy</span>(_pstr, p);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>        &#123;<br>            _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">1</span>];<br>            *_pstr = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">// 拷贝构造函数</span><br>    <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    <span class=\"hljs-comment\">// 析构函数</span><br>    ~<span class=\"hljs-built_in\">String</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br>        _pstr = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 运算符重载</span><br>    <span class=\"hljs-comment\">// 1. =</span><br>    String&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; str)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>        &#123;<br>            <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">delete</span>[] _pstr;<br><br>        <span class=\"hljs-comment\">// 创建</span><br>        _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>        <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>        <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 2. &gt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&gt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &gt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 3. &lt;</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) &lt; <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 4. ==</span><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> String&amp; str) <span class=\"hljs-type\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strcmp</span>(_pstr, str._pstr) == <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-comment\">// 5. []</span><br>    <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <span class=\"hljs-type\">const</span> <br>    &#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr[index]; <br>    &#125;<br><br>    <span class=\"hljs-comment\">// 公共方法</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">length</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">strlen</span>(_pstr);<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">c_str</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">    </span>&#123; <br>        <span class=\"hljs-keyword\">return</span> _pstr; <br>    &#125;<br><br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">char</span>* _pstr;<br><br>    <span class=\"hljs-comment\">// 由于调用 &lt;&lt; 不依赖于特定的对象，设计为全局函数</span><br>    <span class=\"hljs-comment\">// 为了方位到类型的私有数据（private），重载方法定义为该类型的友元函数。</span><br>    <span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str);<br><span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">  重载+；</span><br><span class=\"hljs-comment\">  重载+ 有两种方式：</span><br><span class=\"hljs-comment\">  (1)定义成成员函数</span><br><span class=\"hljs-comment\">  String operator+(const String&amp; s)&#123;</span><br><span class=\"hljs-comment\">    String tmp;</span><br><span class=\"hljs-comment\">    .....</span><br><span class=\"hljs-comment\">    return tmp;</span><br><span class=\"hljs-comment\">    如 s1 = s2+s3; =&gt; s2.operator+(s3);在运算符重载中，将计算的值返回，而不是修改*this</span><br><span class=\"hljs-comment\">  &#125;</span><br><span class=\"hljs-comment\">  弊端：s1 = &quot;a&quot; + s2;无法重载+ ,因为&quot;a&quot;不是String类型。</span><br><span class=\"hljs-comment\">  （2）重载为全局函数</span><br><span class=\"hljs-comment\">  */</span><br><span class=\"hljs-comment\">/************************************************************************/</span><br>    <span class=\"hljs-keyword\">friend</span> String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs);<br><br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> String&amp; str)<br>&#123;<br>    out &lt;&lt; str._pstr;<br>    <span class=\"hljs-keyword\">return</span> out;<br>&#125;;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">合并后的字符串是否有足够的空间容纳，我们会发现，前面的相关构造函数都是通过strlen()方法计算实参的大小，</span><br><span class=\"hljs-comment\">并以此开辟空间大小，</span><br><span class=\"hljs-comment\">换句话说：有多大开辟多大，一点不剩。所以，将后一个字符串连接到前一个字符串的时候，就会出现空间不够的问题。</span><br><span class=\"hljs-comment\">*/</span><br>String <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> String&amp; lhs, <span class=\"hljs-type\">const</span> String&amp; rhs)<br>&#123;<br>    <span class=\"hljs-comment\">// 计算长度</span><br>    <span class=\"hljs-type\">char</span>* _ptmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(lhs._pstr) + <span class=\"hljs-built_in\">strlen</span>(rhs._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-comment\">// 拷贝</span><br>    <span class=\"hljs-built_in\">strcpy</span>(_ptmp, lhs._pstr);<br>    <span class=\"hljs-comment\">// 合并</span><br>    <span class=\"hljs-built_in\">strcat</span>(_ptmp, rhs._pstr);<br><br>    <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(_ptmp)</span></span>;<br>    <span class=\"hljs-keyword\">delete</span>[]_ptmp;<br>    <br>    <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//默认构造函数</span><br>    String str1;<br>    String str2 = <span class=\"hljs-string\">&quot;aaa&quot;</span>;<br>    String str3 = <span class=\"hljs-string\">&quot;bbb&quot;</span>;<br><br>    <span class=\"hljs-comment\">//+ 运算符重载</span><br>    String str4 = str2 + str3;<br>    String str5 = str2 + <span class=\"hljs-string\">&quot;ccc&quot;</span>;<br>    String str6 = <span class=\"hljs-string\">&quot;ddd&quot;</span> + str2;<br><br>    <span class=\"hljs-comment\">// &lt;&lt; 运算符重载</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;str6:&quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// &gt;  运算符重载</span><br>    <span class=\"hljs-keyword\">if</span> (str5 &gt; str6)<br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &gt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span><br>    &#123;<br>        cout &lt;&lt; str5 &lt;&lt; <span class=\"hljs-string\">&quot; &lt; &quot;</span> &lt;&lt; str6 &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 获取长度</span><br>    <span class=\"hljs-type\">int</span> len = str6.<span class=\"hljs-built_in\">length</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class=\"hljs-comment\">// []运算符重载</span><br>        cout &lt;&lt; str6[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-comment\">// c_str()</span><br>    <span class=\"hljs-type\">char</span> buff[<span class=\"hljs-number\">1024</span>] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>    <span class=\"hljs-built_in\">strcpy</span>(buff, str6.<span class=\"hljs-built_in\">c_str</span>());<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;buff:&quot;</span> &lt;&lt; buff &lt;&lt; endl;<br><br><br>    <span class=\"hljs-comment\">// 迭代器</span><br>    String::iterator it = str2.<span class=\"hljs-built_in\">begin</span>();<br>    <span class=\"hljs-keyword\">for</span> (it = str2.<span class=\"hljs-built_in\">begin</span>(); it != str2.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>        cout &lt;&lt; (*it) &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// auto</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> ch : str2) &#123;<br>        cout &lt;&lt; ch &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-代码优化\"><a href=\"#1-代码优化\" class=\"headerlink\" title=\"1. 代码优化\"></a>1. 代码优化</h3><p><strong>带右值引用参数的拷贝构造与带右值引用参数的赋值重载函数</strong></p>\n<p>考虑这样一个操作：</p>\n<p><strong>由于问题场景的特殊，子函数调用时我们无法返回一个临时对象。<br>而且我们也只能用赋值的方式接收一个函数调用的返回值。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">String <span class=\"hljs-title\">GetString</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> String&amp;str)</span> </span>&#123;<br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n  GetString() begin\\n&quot;</span>;<br>  <span class=\"hljs-function\">String <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(str.c_str())</span></span>;<br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n  GetString() end\\n&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> tmp;<br>&#125;<br> <br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  String s1 = <span class=\"hljs-string\">&quot;123&quot;</span>;<br>  String s2;<br> <br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n main call GetString() begin\\n&quot;</span>;<br>  s2 = <span class=\"hljs-built_in\">GetString</span>(s1);<br>  std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n main call GetString() end\\n&quot;</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101105643.png\" alt=\"image.png\"></p>\n<p> 存在的问题：</p>\n<p>（1）在调用 <code>return tmp;</code> 时 实际是使用构造一个临时对象，临时对象调用拷贝构造函数从 tmp 中复制数据，然后调用析构函数析构 tmp 对象，这样就白耗费资源了，tmpStr 资源不要就早说，直接给函数栈帧上临时对象就好了；<br>（2）s2 调用赋值运算符 ：临时量给 str2 赋值，str2 是原本已经存在的对象，它也有一个指针 mptr，原先也指向了一个空间。</p>\n<p>对于赋值来说，排除自赋值，然后把原先指向的空间释放掉，然后按照 str 的尺寸开辟空间，然后拷贝数据进行来。即按照临时对象的字符串大小开辟空间，然后把数据一个一个拷贝进来。</p>\n<p>然后出语句，把这个临时对象析构及它指向的堆内存空间释放掉。</p>\n<p>过程过于复杂，为什么不能直接把临时对象的外部资源给 str2 不就完了吗？</p>\n<h3 id=\"2-右值引用\"><a href=\"#2-右值引用\" class=\"headerlink\" title=\"2. 右值引用\"></a>2. 右值引用</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//C++11把临时量都当做右值处理 </span><br>\tString &amp;&amp;e = <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>);<span class=\"hljs-comment\">//可以！ </span><br>    <span class=\"hljs-type\">const</span> String &amp;e = <span class=\"hljs-built_in\">MyString</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>);<span class=\"hljs-comment\">//可以！</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">  <span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-comment\">/*拷贝构造函数   //String s2 = s1;*/</span><br>  <span class=\"hljs-comment\">/************************************************************************/</span><br>  <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-type\">const</span> String&amp; str)<br>  &#123;<br>    <span class=\"hljs-keyword\">if</span> (str._pstr !=<span class=\"hljs-literal\">nullptr</span>) &#123;<br>      _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(str._pstr) + <span class=\"hljs-number\">1</span>];<br>      <span class=\"hljs-built_in\">strcpy</span>(_pstr, str._pstr);<br>    &#125;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 左值拷贝构造函数\\n&quot;</span>;<br>  &#125;<br> <br>  <span class=\"hljs-comment\">//带右值引用参数的拷贝构造</span><br>  <span class=\"hljs-built_in\">String</span>(String &amp;&amp;str)<span class=\"hljs-comment\">//str引用的就是一个临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 右值拷贝构造函数\\n&quot;</span>;<br>      _pstr = str._pstr;<br>    str._pstr = <span class=\"hljs-literal\">nullptr</span>;<br>  &#125;<br> <br>  <span class=\"hljs-comment\">/************************************************************************/</span><br><span class=\"hljs-comment\">/*赋值运算符    //s2 = s1*/</span><br><span class=\"hljs-comment\">/************************************************************************/</span><br>  String&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> String&amp; src)<br>  &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 左值赋值运算符\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;src)<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (src._pstr == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (_pstr) &#123;<br>      <span class=\"hljs-keyword\">delete</span>[]_pstr;<br>    &#125;<br> <br> <br>    _pstr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-built_in\">strlen</span>(src._pstr) + <span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-built_in\">strcpy</span>(_pstr, src._pstr);<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>  &#125;<br> <br>  <span class=\"hljs-comment\">//带右值引用参数的赋值重载函数</span><br>  String&amp; <span class=\"hljs-keyword\">operator</span>=(String &amp;&amp;str)<span class=\"hljs-comment\">//str引用的是临时对象</span><br>  &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;String 右值引用参数的赋值重载函数\\n&quot;</span>;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;str)<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (str._pstr == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">delete</span>[]_pstr;<br> <br>    <span class=\"hljs-type\">char</span> * tmp=_pstr ;<br>    _pstr = str._pstr;<br>    str._pstr = tmp;<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过右值引用，<strong>没有任何内存的开辟和释放和数据的拷贝</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101116493.png\" alt=\"image.png\"></p>\n<p>右值引用前：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117001.png\" alt=\"image.png\"></p>\n<p>右值引用后：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101117760.png\" alt=\"image.png\"></p>\n<h2 id=\"4-vector-容器的迭代器-iterator-实现\"><a href=\"#4-vector-容器的迭代器-iterator-实现\" class=\"headerlink\" title=\"4. vector 容器的迭代器 iterator 实现\"></a>4. vector 容器的迭代器 iterator 实现</h2><p><strong>问题 1：删除 vector 中所有的偶数：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 删除偶数</span><br>\t<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it &lt; vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tvec.<span class=\"hljs-built_in\">erase</span>(it);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101137035.png\" alt=\"image.png\"></p>\n<p>运行导致程序崩溃！</p>\n<p><strong>问题 2：vector 容器插入元素问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it &lt; vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tvec.<span class=\"hljs-built_in\">insert</span>(it, *it - <span class=\"hljs-number\">1</span>);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101430280.png\" alt=\"image.png\"></p>\n<p>运行导致程序崩溃！</p>\n<p><strong>问题 3：push_back 触发扩容时</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">1</span>);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">2</span>);<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;容量：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">3</span>);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">4</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;后push_back容量：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">capacity</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;添加后，it = &quot;</span> &lt;&lt; *it &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101503945.png\" alt=\"image.png\"></p>\n<p><strong>原因：iterator 失效</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101431915.png\" alt=\"image.png\"></p>\n<p>当删除（获取增加）it 位置的元素时，导致 it 后面的迭代器全部失效。因此多次调用 <code>erase\\insert</code>导致崩溃</p>\n<h2 id=\"5-什么是容器的迭代器失效问题\"><a href=\"#5-什么是容器的迭代器失效问题\" class=\"headerlink\" title=\"5. 什么是容器的迭代器失效问题\"></a>5. 什么是容器的迭代器失效问题</h2><h3 id=\"1-原因\"><a href=\"#1-原因\" class=\"headerlink\" title=\"1. 原因\"></a>1. 原因</h3><p><strong>问题一：</strong></p>\n<p>当容器调用 erase 时，当前位置到容器末尾元素的所有的迭代器全部失效</p>\n<p><strong>问题二：</strong></p>\n<p>当容器调用 insert 时，当前位置到容器末尾元素的所有的迭代器全部失效</p>\n<p>当容器调用 insert 时，如果引起容器内存扩容，原来容器的所有的迭代器就全部失效</p>\n<p><strong>问题三：</strong></p>\n<p>当容器 push_back 时，如果当前容量不足，则会触发扩容，导致整个容器重新申请内存，并且将原有的数据复制到新内存中将原有内存释放，这自然是会导致迭代器失效的，因为迭代器所指的内存都已经被释放。</p>\n<h3 id=\"2-解决\"><a href=\"#2-解决\" class=\"headerlink\" title=\"2. 解决\"></a>2. 解决</h3><p>进行更新操作：<code>erase\\insert</code> 后会返回指向下一个元素的迭代器</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101510112.png\" alt=\"image.png\"></p>\n<ul>\n<li>[vector::erase] <a href=\"https://cplusplus.com/reference/vector/vector/erase/\">https://cplusplus.com/reference/vector/vector/erase/</a></li>\n</ul>\n<p>从向量中删除单个元素（位置）或一系列元素（<code>[第一、最后一个]</code>）。</p>\n<p>这有效地减少了容器的大小，减少了被删除的元素的数量，这些元素会被销毁。</p>\n<p>由于向量使用数组作为其底层存储，擦除向量端以外位置的元素会导致容器在段擦除后将所有元素重新定位到其新位置。与其他类型的序列容器对相同操作执行的操作相比，这通常是一种低效的操作（如列表或转发列表）。</p>\n<p>同理，insert</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101512469.png\" alt=\"image.png\"></p>\n<p>通过在指定位置的元素之前插入新元素来扩展向量，从而通过插入的元素数量有效地增加容器大小。</p>\n<p>当且仅当新向量大小超过当前向量容量时，这会导致自动重新分配分配分配的存储空间。</p>\n<p>因为向量使用数组作为其底层存储，所以在向量末端以外的位置插入元素会导致容器将位置之后的所有元素重新定位到它们的新位置。与其他类型的序列容器（如 list 或 forward_list）对相同操作执行的操作相比，这通常是一种低效的操作。</p>\n<p>这些参数确定插入的元素数量及其初始化值：</p>\n<p>也说明了进行插入操作会导致之后的迭代器失效。</p>\n<p>修改代码：</p>\n<p>erase 解决代码：**</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 把 vec 容器中的所有偶数删除</span><br>\t<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">while</span> (it != vec.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\t\tit = vec.<span class=\"hljs-built_in\">erase</span>(it);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 输出查看</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : vec)<br>\t&#123;<br>\t\tcout &lt;&lt; it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101516128.png\" alt=\"image.png\"></p>\n<p><strong>insert 解决代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  vector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; ++i) &#123;<br>    vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>  &#125;<br> <br>  <span class=\"hljs-comment\">// 把vec容器中的所有偶数前面添加一个小于偶数值1的数字</span><br>  <span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>  <span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); it++) &#123;<br>    <span class=\"hljs-keyword\">if</span> ((*it) % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>      it = vec.<span class=\"hljs-built_in\">insert</span>(it, *it - <span class=\"hljs-number\">1</span>);<br>      <span class=\"hljs-comment\">// it原来的位置插入了新的，需要++it两次，才能到该偶数的后一个元素</span><br>      it++;<br>    &#125;<br>  &#125;<br> <br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> val : vec) &#123;<br>    cout &lt;&lt; val &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101520065.png\" alt=\"image.png\"></p>\n<h3 id=\"3-vector-实现中的-insert-和-erase\"><a href=\"#3-vector-实现中的-insert-和-erase\" class=\"headerlink\" title=\"3. vector 实现中的 insert 和 erase\"></a>3. vector 实现中的 insert 和 erase</h3><p>头插法：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101522251.png\" alt=\"image.png\"></p>\n<p>检查迭代器失效：</p>\n<p>在进行删除或增加的时候，要检测该位置到 last 位置，使其迭代器失效</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 从容器末尾删除元素</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>    <span class=\"hljs-keyword\">return</span>;<br> <br>  <span class=\"hljs-comment\">//检查迭代器 从该位置到最后</span><br>  <span class=\"hljs-built_in\">verify</span>(Last<span class=\"hljs-number\">-1</span>,Last);<br> <br>  <span class=\"hljs-comment\">// 不仅要把_last指针--，还需要析构删除的元素</span><br>  --Last;<br>  _allocator.<span class=\"hljs-built_in\">destroy</span>(Last);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>迭代器检查实现：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">verify</span><span class=\"hljs-params\">(T* first, t* last)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tIterator_Base* pre = &amp;<span class=\"hljs-keyword\">this</span>-&gt;head;<br>\tIterator_Base* it = &amp;<span class=\"hljs-keyword\">this</span>-&gt;head._next;<br><br>\t<span class=\"hljs-keyword\">while</span> (it != <span class=\"hljs-literal\">nullptr</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 迭代器失效，把 iterator 持有的容器指针置空</span><br>\t\t\tit-&gt;_cur-&gt;_pVec = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t\t<span class=\"hljs-comment\">// 删除当前迭代器节点，继续判断后面的迭代器是否失效</span><br>\t\t\tpre-&gt;_next = it-&gt;_next;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> it;<br>\t\t\tit = pre-&gt;_next;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tpre = it;<br>\t\t\tit = it-&gt;_next;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-new-和-delete-重载实现的对象池\"><a href=\"#6-new-和-delete-重载实现的对象池\" class=\"headerlink\" title=\"6. new 和 delete 重载实现的对象池\"></a>6. new 和 delete 重载实现的对象池</h2><p>在编程中，我们经常会涉及到对象的操作，而经常的操作模式如下图所示:<code>创建对象</code>-&gt;<code>使用对象</code>-&gt;<code>销毁对象</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101557430.png\" alt=\"image.png\"></p>\n<p>而这个对象有可能创建的时候会需要构建很多资源，消耗比较大, 比如：在<code>hiredis</code>的SDK中每次都创建一个<code>redisContext</code>，如果需要查询，那就首先要进行网络连接。如果一直都是上图的工作方式，那将会频繁的创建连接，查询完毕后再释放连接。重新建立连接，让网络的查询效率降低。</p>\n<p>这个时候就可以构建一个<code>对象池</code>来重复利用这个对象，并且一般要做到线程安全:</p>\n<ol>\n<li>从<code>对象池</code>中获取对象，如果没有对象，则创建一个，并返回</li>\n<li>使用对象</li>\n<li>使用完成对象后，将对象还回<code>对象池</code></li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101559621.png\" alt=\"image.png\"></p>\n<p>那么符合如下条件的，应该适合使用<code>对象池</code>技术:</p>\n<ul>\n<li>有一些对象虽然创建开销比较大，但是不一定能够重复使用。要使用<code>对象池</code>一定要确保对象能够重复使用。</li>\n<li>这个对象构建的时候，有一些耗时的资源可以重复利用。比如<code>redisContext</code>的网络连接。又或者如果对象的频繁申请释放会带来一些其他的资源使用问题，比如<code>内存碎片</code>。重复利用能够提升程序的效率。</li>\n<li><code>对象池</code>的数量应该控制在能够接受的范围内，并不会无限膨胀。</li>\n</ul>\n<h3 id=\"1-对象池实现原理\"><a href=\"#1-对象池实现原理\" class=\"headerlink\" title=\"1. 对象池实现原理\"></a>1. 对象池实现原理</h3><ol>\n<li><strong>分配过程：</strong></li>\n</ol>\n<p><strong>我们首先申请比如 100000 块内存空间，用这个块类型的指针指向这个申请好内存的首地址。如图：这个块可以是一个链式队列的一个节点或者一个树的节点等。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101603100.png\" alt=\"image.png\"><br><strong>当我们要分配给用户一块空间的时候我们就可以，先将 <code>_itemPool</code> 的地址保存到临时指针 p，然后再 <code>_itemPool++</code> 的操作，然后再将 p 返回给用户即可。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101604537.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>释放过程：</strong></li>\n</ol>\n<p><strong>比如现在的内存分配状况如图所示：现在用户需要归还第 1 块内存。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101605266.png\" alt=\"image.png\"></p>\n<p>我们首先要归还块的首地址指向 <code>_itemPool</code> 的下一个块，然后再将 <code>_itemPool</code> 指向归还的块的地址。即可</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308101606815.png\" alt=\"image.png\"></p>\n<h3 id=\"2-以队列实现一个简单对象池\"><a href=\"#2-以队列实现一个简单对象池\" class=\"headerlink\" title=\"2. 以队列实现一个简单对象池\"></a>2. 以队列实现一个简单对象池</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">运算符的重载  :成员方法、全局方法</span><br><span class=\"hljs-comment\">内存池 进程池 线程池 连接池 对象池</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Queue</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">Queue</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化指针</span><br>\t\t_front = _rear = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">QueueItem</span>();<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">Queue</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 创建新对象</span><br>\t\tQueueItem* cur = _front;<br>\t\t<span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">nullptr</span>)<br>\t\t&#123;<br>\t\t\t_front = cur-&gt;_next;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> cur;<br>\t\t\tcur = _front;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝对象</span><br>\t<span class=\"hljs-built_in\">Queue</span>(<span class=\"hljs-type\">const</span> Queue&amp; obj) = <span class=\"hljs-keyword\">delete</span>;<br><br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Queue&amp; obj) = <span class=\"hljs-keyword\">delete</span>;<br><br>\t<span class=\"hljs-comment\">// 方法</span><br>\t<span class=\"hljs-comment\">// 1. push 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tQueueItem* item = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">QueueItem</span>(val);<br>\t\t_rear-&gt;_next = item;<br>\t\t_rear = item;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. pop 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\tQueueItem* first = _front-&gt;_next;<br>\t\t_front-&gt;_next = first-&gt;_next;<br>\t\t<span class=\"hljs-keyword\">if</span> (_front-&gt;_next == <span class=\"hljs-literal\">nullptr</span>)<br>\t\t&#123;<br>\t\t\t_rear = _front;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> first;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. front 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">front</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> _front-&gt;_next-&gt;_data;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span><span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> _rear == _front; &#125;<br><br>\t<span class=\"hljs-comment\">// 产生一个 QueueItem 的对象池</span><br>\t<span class=\"hljs-comment\">// 创建一个对象池结构</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">QueueItem</span><br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 构造函数</span><br>\t\t<span class=\"hljs-built_in\">QueueItem</span>(T data = <span class=\"hljs-built_in\">T</span>()) :_data(data), _next(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;<br><br>\t\t<span class=\"hljs-comment\">// new 重载</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (_itemPool == <span class=\"hljs-literal\">nullptr</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-comment\">//由于我们不知道QueueItem的具体大小(模板未进行实例化)所以我们这里用char 1字节作为new的基准</span><br>\t\t\t\t_itemPool = (QueueItem*)<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[POOL_ITEM_SIZE * <span class=\"hljs-built_in\">sizeof</span>(QueueItem)];<br>\t\t\t\tQueueItem* p = _itemPool;<br>\t\t\t\t<span class=\"hljs-comment\">//把开辟的POOL_ITEM_SIZE个块关联起来</span><br>\t\t\t\t<span class=\"hljs-keyword\">for</span> (; p != _itemPool + POOL_ITEM_SIZE - <span class=\"hljs-number\">1</span>; ++p)<br>\t\t\t\t&#123;<br>\t\t\t\t\tp-&gt;_next = p + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-comment\">//最后一块的next置为空</span><br>\t\t\t\tp-&gt;_next = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">//将第一块可以分配的块分配给用户</span><br>\t\t\tQueueItem* p = _itemPool;<br>\t\t\t_itemPool = _itemPool-&gt;_next;<br>\t\t\t<span class=\"hljs-keyword\">return</span> p;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// delete 重载</span><br>\t\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ptr)</span></span><br><span class=\"hljs-function\">\t\t</span>&#123;<br>\t\t\t<span class=\"hljs-comment\">//进行归还操作</span><br>\t\t\tQueueItem* p = (QueueItem*)ptr;<br>\t\t\tp-&gt;_next = _itemPool;<br>\t\t\t_itemPool = p;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 静态数据</span><br>\t\t<span class=\"hljs-type\">static</span> QueueItem* _itemPool;<br>\t\t<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> POOL_ITEM_SIZE = <span class=\"hljs-number\">1000000</span>;<br><br>\t\t<span class=\"hljs-comment\">// 对象池单个对象</span><br>\t\tT _data;<br>\t\tQueueItem* _next;<br>\t&#125;;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tQueueItem* _front;<span class=\"hljs-comment\">//指向头节点</span><br>\tQueueItem* _rear;<span class=\"hljs-comment\">//指向队尾</span><br>&#125;;<br><br><span class=\"hljs-comment\">//typename 告诉编译器后面是类型</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">typename</span> Queue&lt;T&gt;::QueueItem* Queue&lt;T&gt;::QueueItem::_itemPool = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tQueue&lt;<span class=\"hljs-type\">int</span>&gt; que;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000000</span>; ++i)<span class=\"hljs-comment\">//大量的new delete;不划算</span><br>\t&#123;<br>\t\tque.<span class=\"hljs-built_in\">push</span>(i);<br>\t\tque.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\tcout &lt;&lt; que.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\t<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-深入理解-new-和-delete-的原理\"><a href=\"#7-深入理解-new-和-delete-的原理\" class=\"headerlink\" title=\"7. 深入理解 new 和 delete 的原理\"></a>7. 深入理解 new 和 delete 的原理</h2><p><strong>new和delete</strong>是用户进行<strong>动态内存申请和释放的操作符</strong>，<strong>operator new 和operator delete</strong>是系统提供的<strong>全局函数</strong>，<strong>new在底层调用operator new</strong>全局函数来申请空间，<strong>delete在底层通过operator delete</strong>全局函数来释放空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">operator new:该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* __CRTDECL <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span> _<span class=\"hljs-title\">THROW1</span><span class=\"hljs-params\">(_STD bad_alloc)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">// try to allocate size bytes</span><br>    <span class=\"hljs-type\">void</span>* p;<br>    <span class=\"hljs-keyword\">while</span> ((p = <span class=\"hljs-built_in\">malloc</span>(size)) == <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">if</span> (_callnewh(size) == <span class=\"hljs-number\">0</span>)<br>        &#123;<br>            <span class=\"hljs-comment\">// report no memory</span><br>            <span class=\"hljs-comment\">// 如果申请内存失败了，这里会抛出bad_alloc 类型异常 </span><br>            <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> std::bad_alloc nomem; <br>            _RAISE(nomem);<br>        &#125;<br>        <br>    <span class=\"hljs-keyword\">return</span> (p);<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">operator delete: 该函数最终是通过free来释放空间的 </span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* pUserData)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    _CrtMemBlockHeader* pHead;<br>    <br>    <span class=\"hljs-built_in\">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class=\"hljs-number\">0</span>));<br>    <span class=\"hljs-keyword\">if</span> (pUserData == <span class=\"hljs-literal\">NULL</span>)<br>        <span class=\"hljs-keyword\">return</span>;<br>    _mlock(_HEAP_LOCK);  <span class=\"hljs-comment\">/* block other threads */</span><br>    __TRY<br>    <br>        <span class=\"hljs-comment\">/* get a pointer to memory block header */</span><br>        pHead = <span class=\"hljs-built_in\">pHdr</span>(pUserData);<br>        <br>    \t<span class=\"hljs-comment\">/* verify block type */</span><br>    \t_ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));<br>    \t<br>    \t_free_dbg(pUserData, pHead-&gt;nBlockUse);<br>    \t<br>    __FINALLY<br>        _munlock(_HEAP_LOCK);  <span class=\"hljs-comment\">/* release other threads */</span><br>    __END_TRY_FINALLY<br>    <br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">free的实现</span><br><span class=\"hljs-comment\">*/</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> free(p) _free_dbg(p, _NORMAL_BLOCK)</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>1. 内置类型：</strong></p>\n<p>如果申请的是内置类型的空间 <code>new</code> 和 <code>malloc</code>，<code>delete</code> 和 <code>free</code> 基本类似，不同的地方是：<code>new/delete</code> 申请和释放的是单个元素的空间，<code>new[]</code> 和 <code>delete[]</code> 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc会返回NULL。</p>\n<p><strong>2. 自定义类型:</strong></p>\n<p><strong>new的原理：</strong></p>\n<ol>\n<li>调用operator new函数申请空间</li>\n<li>在申请的空间上执行构造函数，完成对象的构造</li>\n</ol>\n<p><strong>delete的原理：</strong></p>\n<p>在空间上执行析构函数，完成对象中资源的清理工作在空间上执行析构函数，完成对象中资源的清理工作</p>\n<p><code>new T[N]</code> 的原理：</p>\n<ol>\n<li>调用 <code>operator new[]</code> 函数，在 <code>operator new[]</code> 中实际调用 <code>operator new</code> 函数完成 N 个对象空间的申请</li>\n<li>在申请的空间上执行N次构造函数</li>\n</ol>\n<p><code>delete[ ]</code>的原理：</p>\n<ol>\n<li>在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理</li>\n<li>调用 <code>operator delete[]</code> 释放空间，实际在 <code>operator delete[]</code> 中调用 <code>operator delete</code> 来释放空间</li>\n</ol>\n"},{"title":"04.C++ 函数模板","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节分为四个部分：\n\n1. 理解函数模板\n2. 理解类模板\n3. 实现 C++ STL 向量容器 vector\n4. 理解容器控件配置器 allocator\n\n## 1. 理解函数模板\n\n### 1. 定义\n\n函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。\n\n### 2. 用法\n\n面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：\n\n~~~c++\nvoid Swap(int& x, int& y) \n{\n\tint temp = x;\n\tx = y;\n\ty = temp;\n}\n~~~\n\n为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：\n\n~~~c++\nvoid Swap (double & xr double & y)\n{\n    double tmp = x;\n    x = y;\n    y = tmp;\n}\n~~~\n\n如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。\n\n能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。\n\n程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。\n\n**模板函数、模板的特例化和非模板函数的重载关系**：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。\n\n**模板代码是不能声明在.h，实现在.cpp**，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 `#include`\n\n### 3. 原理\n\nC++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。\n\n在 C++ 中，模板分为函数模板和类模板两种。\n\n- 函数模板是用于生成函数；\n- 类模板则是用于生成类的。\n\n函数模板的写法如下：\n\n~~~c++\ntemplate <class 类型参数1, class类型参数2, ...>\n返回值类型  模板名(形参表)\n{\n    函数体\n}\n~~~\n\n**其中的 class 关键字也可以用 typename 关键字替换**，例如：\n\n~~~c++\ntemplate <typename 类型参数1, typename 类型参数2, ...>\n~~~\n\n函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：\n\n~~~c++\ntemplate <typename T>\nT Swap(T& x, T& y)\n{\n\tT tmp = x; \n\tx = y; \n\ty = tmp;\n}\n~~~\n\nT 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。\n\n**示例：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nT Swap(T& x, T& y)\n{\n\tT tmp = x;\n\tx = y;\n\ty = tmp;\n}\n\nint main()\n{\n\tint n = 1, m = 2;\n\t// 编译器自动生成 void Swap (int &, int &)函数\n\tSwap(n, m);\n\n\tdouble f = 1.2, g = 3.4;\n\t// 编译器自动生成 void Swap (double &, double &)函数\n\tSwap(f, g);\n\n\treturn 0;\n}\n~~~\n\n编译器在编译到 `Swap(n, m);` 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：\n\n~~~c++\nvoid Swap (int & x, int & y)\n{\n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n~~~\n\n该函数可以匹配 `Swap(n, m);` 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 `Swap(n, m);` 编译成对自动生成的 Swap 函数的调用。\n\n同理，编译器在编译到 `Swap(f, g);` 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：\n\n~~~c++\nvoid Swap(double & x, double & y)\n{\n    double tmp = x;\n    x = y;\n    y = tmp;\n}\n~~~\n\n然后再将 `Swap(f, g);` 编译成对该 Swap 函数的调用。\n\n编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。\n\n编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：\n\n~~~c++\n模板名<实际类型参数1, 实际类型参数2, ...>\n~~~\n\n## 2. 理解类模板\n\n### 1. 定义\n\n为了多快好省地定义出一批**相似的类**,可以定义「类模板」，然后**由类模板生成不同的类**。\n\n类模板的定义形式如下：\n\n~~~c++\ntemplate <class 类型参数1，class 类型参数2，...> //类型参数表\nclass 类模板名\n{\n   成员函数和成员变量\n};\n~~~\n\n用类模板定义对象的写法：\n\n~~~c++\n类模板名<真实类型参数表> 对象名(构造函数实参表);\n~~~\n\n- 类模板用于实现类所需数据的类型参数化\n- 类模板在表示如数组、表、图等数据结构显得特别重要\n- 这些数据结构的表示和算法不受所包含的元素类型的影响\n\n### 2. 类模板实现顺序栈\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\ntemplate <class T>\nclass SeqStack\n{\npublic:\n\t// 公共方法\n\t\t// 构造函数初始化\n\t\t// 构造和析构函数名不加<T> 其他出现模板的地方都加上类型参数列表\n\tSeqStack(int size = 10)\n\t\t: PStack(new T[size])\n\t\t, Top(0)\n\t\t, Size(size) {\n\t\t// 初始化生成的指令更少，效率更高。\n\t\t// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符\n\t};\n\n\t// 拷贝构造\n\t// 初始化列表的方式初始化 size 和 top\n\tSeqStack(const SeqStack<T>& stack)\n\t\t: Top(stack.Top)\n\t\t, Size(stack.Size) {\n\t\t// 重新设置栈\n\t\tPStack = new T[stack.Size];\n\t\tint i = 0;\n\t\tfor (i = 0; i < Top; i++)\n\t\t{\n\t\t\tPStack[i] = stack.PStack[i];\n\t\t}\n\t}\n\n\t// 析构函数 释放内存\n\t~SeqStack()\n\t{\n\t\tif (PStack)\n\t\t{\n\t\t\tdelete[] PStack;\n\t\t\tPStack = nullptr;\n\t\t}\n\t}\n\n\t// 复制重载\n\tSeqStack<T>& operator=(const SeqStack<T>& stack)\n\t{\n\t\t// 判断是否相等\n\t\tif (this == &stack)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 清空\n\t\tdelete[] PStack;\n\n\t\t// 重新赋值\n\t\tTop = stack.Top;\n\t\tSize = stack.Size;\n\t\tPStack = new T[stack.Size];\n\t\tint i = 0;\n\t\tfor (i = 0; i < Top; i++)\n\t\t{\n\t\t\tPStack[i] = stack.PStack[i];\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\t// 共有方法\n\t// 1. push 方法\n\tvoid push(const T& val)\n\t{\n\t\tif (full())\n\t\t{\n\t\t\tresize();\n\t\t}\n\t\tPStack[Top] = val;\n\t\tTop++;\n\t}\n\n\t// 2. pop 方法\n\tvoid pop()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTop--;\n\t}\n\n\t// 3. top 方法\n\tT top() const\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\tthrow \"Stack is empty!\";\n\t\t}\n\t\treturn PStack[Top - 1];\n\t}\n\n\t// 4. full 方法\n\tbool full() const {\n\t\treturn Top == Size;\n\t}\n\n\t// 5. empty 方法\n\tbool empty() const {\n\t\treturn Top == 0;\n\t}\n\n\t// 私有方法和数据\nprivate:\n\t// 扩容方法\n\tvoid resize()\n\t{\n\t\tT* p = new T[Size * 2];\n\t\t// 将值赋值过去\n\t\tint i = 0;\n\t\tfor (i = 0; i < Top; i++)\n\t\t{\n\t\t\tp[i] = PStack[i];\n\t\t}\n\t\t// 扩大\n\t\tSize *= 2;\n\t\t// 清空\n\t\tdelete PStack;\n\t\t// 重新赋值\n\t\tPStack = p;\n\t}\n\n\tT* PStack;\n\tint Top;\n\tint Size;\n};\n\nint main()\n{\n\tSeqStack<int> stack;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tstack.push(i);\n\t}\n\n\twhile (!stack.empty())\n\t{\n\t\tcout << stack.top() << \" \";\n\t\tstack.pop();\n\t}\n\treturn 0;\n}\n~~~\n\n## 3. 实现 C++ STL 向量容器 vector\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png)\n\nvector 的本质是一个数组，在vector 中需要有三个指针：\n\n- `First`：指向数组的起始位置\n- `Last`：指向已经存放的最后一个元素的下一个位置\n- `End`：指向数组长度的末尾元素的下一个位置。\n\nvector 方法：\n\n- 数组的容量：`End-First`\n- 数组中存放的元素个数：`Last-First`\n- 数组是否为空：`First == Last`\n- 数组是否已满：`Last == End`\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\ntemplate <class T>\nclass vector\n{\npublic:\n\t// 构造函数\n\tvector(int size = 10)\n\t\t: First(new T[size])\n\t\t, Last(First)\n\t\t, End(First + size)\n\t{\n\t\t// 使用初始化列表方式\n\t}\n\t// 拷贝构造函数\n\tvector(const vector<T>& rhs)\n\t{\n\t\t// 获取容器长度\n\t\tint size = rhs.End - rhs.First;\n\t\t// 创建新容器\n\t\tFirst = new T[size];\n\t\t// 获取数据长度\n\t\tint len = rhs.Last - rhs.First;\n\t\t// 遍历赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tFirst[i] = rhs.First[i];\n\t\t}\n\t\t// 重置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\t}\n\t// 析构函数\n\t~vector()\n\t{\n\t\tdelete[] First;\n\t\tFirst = End = Last = nullptr;\n\t}\n\t// 赋值重载\n\tvector<T>& operator=(const vector<T>& rhs)\n\t{\n\t\t// 判断\n\t\tif (this == &rhs)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\n\t\t// 清除\n\t\tdelete[] First;\n\n\t\t// 重新计算并赋值\n\t\t// 获取容器长度\n\t\tint size = rhs.End - rhs.First;\n\t\t// 创建新容器\n\t\tFirst = new T[size];\n\t\t// 获取数据长度\n\t\tint len = rhs.Last - rhs.First;\n\t\t// 遍历赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tFirst[i] = rhs.First[i];\n\t\t}\n\t\t// 重置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\n\t\treturn *this;\n\t}\n\n\t// 共有方法\n\t// push_back 方法：容器添加内容\n\tvoid push_back(const T& val)\n\t{\n\t\tif (full())\n\t\t{\n\t\t\textend();\n\t\t}\n\t\t// 先给之以后，下次 push 则会递增内存\n\t\t*Last++ = val;\n\t}\n\t// pop_back 方法：容器删除内容\n\tvoid pop_back()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t--Last;\n\t}\n\t// back 方法：输出删除内容\n\tT back() const\n\t{\n\t\treturn *(Last - 1);\n\t}\n\t// full 方法：容器是否已满\n\tbool full() const\n\t{\n\t\treturn Last == End;\n\t}\n\t// empty 方法：容器是否为空\n\tbool empty() const\n\t{\n\t\treturn Last == First;\n\t}\n\t// size 方法：获取内容厂区\n\tint size() const\n\t{\n\t\treturn Last - First;\n\t}\n\n// 私有方法\nprivate:\n\t// vector 容器扩容\n\tvoid extend()\n\t{\n\t\tint size = End - First;\n\t\tT* ptmp = new T[size * 2];\n\n\t\t// 遍历并转移\n\t\tint i = 0;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\tptmp[i] = First[i];\n\t\t}\n\t\t// 删除原先的\n\t\tdelete[] First;\n\n\t\t// 重新覆盖\n\t\tFirst = ptmp;\n\t\tLast = First + size;\n\t\tEnd = First + 2 * size;\n\t}\n\n// 私有数据\nprivate:\n\tT* First;\n\tT* Last;\n\tT* End;\n};\n\nclass Test\n{\npublic:\n\tTest() \n\t{ \n\t\tcout << \"Test()\" << endl; \n\t}\n\tTest& operator=(const Test& t) \n\t{ \n\t\tcout << \"operator=\" << endl; \n\t\treturn *this; \n\t}\n\t~Test() \n\t{ \n\t\tcout << \"~Test()\" << endl; \n\t}\n\tTest(const Test&) \n\t{ \n\t\tcout << \"Test(const Test&)\" << endl; \n\t}\n};\n\nint main()\n{\n\tTest t1;\n\tTest t2;\n\n\tcout << \"vector<Test> vec\" << endl;\n\n\tvector<Test> vec;\n\tcout << \"vector<Test> vec; push_back\" << endl;\n\n\tvec.push_back(t1);\n\tvec.push_back(t2);\n\n\tcout << \"vector<Test> vec; pop_back\" << std::endl;\n\tvec.pop_back();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png)\n\n问题：在我们实现的 `vector` 构造函数中，使用 `new T[size]`  ：它做了两件事情：\n\n（1）开辟内存空间\n（2）调用 T 类型的默认构造函数构造对象\n\n其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。\n\n同时：在实现 `pop_back(）` 时，存在内存泄漏\n\n~~~c++\n  void pop_back() // 从容器末尾删除元素\n  {\n    if (empty())\n      return;\n    --Last;\n  }\n~~~\n\n 仅仅将 Last 指针 --，并没有释放 Test 申请的资源。**需要调用对象的析构函数**\n\n## 4. 理解容器控件配置器 allocator\n\n**通过 Win msvc 编译器的实现：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png)\n\n~~~c++\n// CLASS TEMPLATE vector\ntemplate<class _Ty, class _Alloc = allocator<_Ty>>\n\tclass vector\n\t\t: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>\n\t{\t// varying size array of values\nprivate:\n\tusing _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>;\n\tusing _Alty = typename _Mybase::_Alty;\n\tusing _Alty_traits = typename _Mybase::_Alty_traits;\n......\n~~~\n\n系统的实现，除了数据类型外，还有一个`allocator`,它将开辟空间和构造对象分离开。  \n\n而这，也就是空间配置器做的工作；\n\n### 1. 容器的空间配置器\n\n空间配置器主要有四个功能：\n\n1. 内存开辟 allocate（底层调用`malloc`）；\n2. 内存释放 deallocate（底层调用`free`）；\n3. 对象构造 construct（调用`构造函数`）；\n4. 对象析构 destroy（调用`析构函数`）；\n\n~~~c++\n// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样\ntemplate <typename T>\nstruct Allocator\n{\n\t// 负责内存的开辟\n\tT* allocate(size_t size)\n\t{\n\t\treturn (T*)malloc(sizeof(T) * size);\n\t}\n\t// 负责内存的释放\n\tvoid deallocate(void* p)\n\t{\n\t\tfree(p);\n\t}\n\t// 负责对象构造\n\tvoid construct(T* p, const T& val)\n\t{\n\t\tnew (p) T(val);\n\t}\n\t// 负责对象析构\n\tvoid destory(T* p)\n\t{\n\t\t// ~T() 代表了 T 类型的析构函数\n \t\tp->~T();\n\t}\n};\n~~~\n\n**重新实现 vector：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// 定义容器的空间配置器，和C++标准库的allocator实现一样\ntemplate<typename T>\nclass Allocator\n{\npublic:\n\t// 负责内存开辟\n\tT* allocate(size_t size) \n\t{\n\t\treturn (T*)malloc(sizeof(T) * size);\n\t}\n\t// 负责内存释放\n\tvoid deallocate(void* p) \n\t{\n\t\tfree(p);\n\t}\n\t// 负责对象构造\n\tvoid construct(T* p, const T& val) \n\t{\n\t\tnew (p)T(val); // 定位new\n\t}\n\t// 负责对象析构\n\tvoid destroy(T* p) \n\t{\n\t\tp->~T(); // ~T()代表了T类型的析构函数\n\t}\n};\n\n// 通过 allocator 适配器重写 vector\ntemplate<typename T, typename Alloc = Allocator<T>>\nclass vector\n{\n\t// 公共构造、拷贝、重载、析构、方法函数\npublic:\n\t// 构造函数\n\t// 需要把内存开辟和对象构造分开处理\n\tvector(int size = 10)\n\t\t: First(_allocator.allocate(size))\n\t\t, Last(First)\n\t\t, End(First + size)\n\t{\n\t\t// 通过初始化列表的方式，初始化数据\n\t}\n\n\t// 拷贝函数\n\tvector(const vector<T>& rhs)\n\t{\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\t}\n\t// 析构函数\n\t~vector()\n\t{\n\t\tcout << \"~vector\" << endl;\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != Last; p++)\n\t\t{\n\t\t\t// cout << \"p =\" << p << endl;\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\t\t// 重置 指针\n\t\tFirst = Last = End = nullptr;\n\t}\n\n\n\t// 赋值重载\n\tvector<T>& operator=(const vector<T>& rhs)\n\t{\n\t\t// 1. 判断\n\t\tif (this == &rhs)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 2. 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 3. 重新计算\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\n\t\treturn *this;\n\t}\n\n\t// 公共方法\n\t// 1. push_back 方法\n\tvoid push_back(const T& val)\n\t{\n\t\t// 判断\n\t\tif (full())\n\t\t{\n\t\t\texpand();\n\t\t}\n\t\t// 通过适配器添加内容\n\t\t_allocator.construct(Last, val);\n\t\tLast++;\n\t}\n\t// 2. pop_back 方法\n\tvoid pop_back()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t// 不仅要把 Last 指针--，还需要析构删除的元素\n\t\t--Last;\n\t\t_allocator.destroy(Last);\n\t}\n\t// 3. back 方法\n\tT back() const \n\t{\n\t\treturn *(Last - 1);\n\t}\n\t// 4. full 方法\n\tbool full() const { return Last == End; }\n\t// 5. empty 方法\n\tbool empty() const { return First == Last; }\n\t// 6. size 方法\n\tint size() const { return Last - First; }\n\n// 私有属性和方法\nprivate:\n\t// 指向数组起始的位置\n\tT* First;\n\t// 指向数组中有效元素的后继位置\n\tT* Last;\n\t// 指向数组空间的后继位置\n\tT* End;\n\t// 定义容器的空间配置器对象\n\tAlloc _allocator;\n\n\t// 扩容方法\n\tvoid expand()\n\t{\n\t\t// 获取大小\n\t\tint size = End - First;\n\t\t// 配置 2 倍适配器空间\n\t\tT* ptmp = _allocator.allocate(size * 2);\n\t\t// 赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\t_allocator.construct(ptmp + i, First[i]);\n\t\t}\n\n\t\t// 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 重新赋值\n\t\tFirst = ptmp;\n\t\tLast = First + size;\n\t\tEnd = First + size * 2;\n\t}\n};\n\n\nclass Test\n{\npublic:\n\tTest()\n\t{\n\t\tcout << \"Test()\" << endl;\n\t}\n\tTest& operator=(const Test& t)\n\t{\n\t\tcout << \"operator=\" << endl;\n\t\treturn *this;\n\t}\n\t~Test() \n\t{ \n\t\tcout << \"~Test()\" << endl; \n\t}\n\tTest(const Test&)\n\t{ \n\t\tcout << \"Test(const Test&)\" << endl; \n\t}\n};\n\nint main()\n{\n\tTest t1, t2;\n\tcout << \"1.\" << endl;\n\tcout << \"vector<Test> vec\" << endl;\n\n\tvector<Test> vec;\n\tcout << \"vector<Test> vec; push_back\" << endl;\n\n\tvec.push_back(t1);\n\tvec.push_back(t2);\n\n\tcout << \"vector<Test> vec; pop_back\" << endl;\n\tvec.pop_back();\n\tcout << \"end\" << endl;\n\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png)\n\n现在的效果就和 msvc 实现的 vector 相同了\n\n### 2. 运算符重载与迭代器实现\n\n~~~c++\n// 迭代器一般是现成容器的嵌套类型\ntemplate<class T>\nclass iterator\n{\npublic:\n\t// 构造函数\n\titerator(T* p = nullptr)\n\t\t: _ptr(p)\n\t{\n\t\t// 初始化列表方式\n\t}\n\t// 拷贝构造函数\n\titerator(const iterator& iter)\n\t\t: _ptr(iter._ptr)\n\t{\n\t\t// ...\n\t}\n\n\t// 重载函数合集\n\t// 1. 前置 ++\n\titerator& operator++()\n\t{\n\t\t_ptr++;\n\t\treturn *this;\n\t}\n\t// 2. 后置 ++\n\titerator operator++(int) {\n\t\titerator tmp(*this);\n\t\t_ptr++;\n\t\treturn tmp;\n\t}\n\t// 3. 解引用\n\tT& operator*()\n\t{\n\t\treturn *_ptr;\n\t}\n\t// 4. !=\n\tbool operator!=(const iterator& iter) const\n\t{\n\t\treturn _ptr != iter._ptr;\n\t}\n\nprivate:\n\tT* _ptr;\n};\n\n\n//迭代器方法\niterator begin() { return iterator(First); }\niterator end() { return iterator(Last); }\n\n//运算符重载[]\nT& operator[](int index) {\n\tif (index < 0 || index >= size()) {\n\t\tthrow \"OutofRangeException\";\n\t}\n\n\treturn First[index];\n}\n~~~\n\n### 3. 最终 vector 实现\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n\n// 定义容器的空间配置器，和C++标准库的allocator实现一样\ntemplate<typename T>\nclass Allocator\n{\npublic:\n\t// 负责内存开辟\n\tT* allocate(size_t size) \n\t{\n\t\treturn (T*)malloc(sizeof(T) * size);\n\t}\n\t// 负责内存释放\n\tvoid deallocate(void* p) \n\t{\n\t\tfree(p);\n\t}\n\t// 负责对象构造\n\tvoid construct(T* p, const T& val) \n\t{\n\t\tnew (p)T(val); // 定位new\n\t}\n\t// 负责对象析构\n\tvoid destroy(T* p) \n\t{\n\t\tp->~T(); // ~T()代表了T类型的析构函数\n\t}\n};\n\n// 通过 allocator 适配器重写 vector\ntemplate<typename T, typename Alloc = Allocator<T>>\nclass vector\n{\n\t// 公共构造、拷贝、重载、析构、方法函数\npublic:\n\t// 构造函数\n\t// 需要把内存开辟和对象构造分开处理\n\tvector(int size = 10)\n\t\t: First(_allocator.allocate(size))\n\t\t, Last(First)\n\t\t, End(First + size)\n\t{\n\t\t// 通过初始化列表的方式，初始化数据\n\t}\n\n\t// 拷贝函数\n\tvector(const vector<T>& rhs)\n\t{\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\t}\n\t// 析构函数\n\t~vector()\n\t{\n\t\tcout << \"~vector\" << endl;\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != Last; p++)\n\t\t{\n\t\t\t// cout << \"p =\" << p << endl;\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\t\t// 重置 指针\n\t\tFirst = Last = End = nullptr;\n\t}\n\n\n\t// 赋值重载\n\tvector<T>& operator=(const vector<T>& rhs)\n\t{\n\t\t// 1. 判断\n\t\tif (this == &rhs)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 2. 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 3. 重新计算\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\n\t\treturn *this;\n\t}\n\t//运算符重载[]\n\tT& operator[](int index) \n\t{\n\t\t// 判断索引位置\n\t\tif (index < 0 || index >= size()) {\n\t\t\tthrow \"OutofRangeException\";\n\t\t}\n\t\t// 返回索引值\n\t\treturn First[index];\n\t}\n\n\t// 公共方法\n\t// 1. push_back 方法\n\tvoid push_back(const T& val)\n\t{\n\t\t// 判断\n\t\tif (full())\n\t\t{\n\t\t\texpand();\n\t\t}\n\t\t// 通过适配器添加内容\n\t\t_allocator.construct(Last, val);\n\t\tLast++;\n\t}\n\t// 2. pop_back 方法\n\tvoid pop_back()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t// 不仅要把 Last 指针--，还需要析构删除的元素\n\t\t--Last;\n\t\t_allocator.destroy(Last);\n\t}\n\t// 3. back 方法\n\tT back() const \n\t{\n\t\treturn *(Last - 1);\n\t}\n\t// 4. full 方法\n\tbool full() const { return Last == End; }\n\t// 5. empty 方法\n\tbool empty() const { return First == Last; }\n\t// 6. size 方法\n\tint size() const { return Last - First; }\n\n\t// 迭代器一般是现成容器的嵌套类型\n\tclass iterator\n\t{\n\tpublic:\n\t\t// 构造函数\n\t\titerator(T* p = nullptr)\n\t\t\t: _ptr(p)\n\t\t{\n\t\t\t// 初始化列表方式\n\t\t}\n\t\t// 拷贝构造函数\n\t\titerator(const iterator& iter)\n\t\t\t: _ptr(iter._ptr)\n\t\t{\n\t\t\t// ...\n\t\t}\n\n\t\t// 重载函数合集\n\t\t// 1. 前置 ++\n\t\titerator& operator++()\n\t\t{\n\t\t\t_ptr++;\n\t\t\treturn *this;\n\t\t}\n\t\t// 2. 后置 ++\n\t\titerator operator++(int) {\n\t\t\titerator tmp(*this);\n\t\t\t_ptr++;\n\t\t\treturn tmp;\n\t\t}\n\t\t// 3. 解引用\n\t\tT& operator*()\n\t\t{\n\t\t\treturn *_ptr;\n\t\t}\n\t\t// 4. !=\n\t\tbool operator!=(const iterator& iter) const\n\t\t{\n\t\t\treturn _ptr != iter._ptr;\n\t\t}\n\n\tprivate:\n\t\tT* _ptr;\n\t};\n\t//迭代器方法\n\titerator begin() { return iterator(First); }\n\titerator end() { return iterator(Last); }\n\n\n// 私有属性和方法\nprivate:\n\t// 指向数组起始的位置\n\tT* First;\n\t// 指向数组中有效元素的后继位置\n\tT* Last;\n\t// 指向数组空间的后继位置\n\tT* End;\n\t// 定义容器的空间配置器对象\n\tAlloc _allocator;\n\n\t// 扩容方法\n\tvoid expand()\n\t{\n\t\t// 获取大小\n\t\tint size = End - First;\n\t\t// 配置 2 倍适配器空间\n\t\tT* ptmp = _allocator.allocate(size * 2);\n\t\t// 赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\t_allocator.construct(ptmp + i, First[i]);\n\t\t}\n\n\t\t// 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 重新赋值\n\t\tFirst = ptmp;\n\t\tLast = First + size;\n\t\tEnd = First + size * 2;\n\t}\n};\n\nclass Test\n{\npublic:\n\tTest()\n\t{\n\t\tcout << \"Test()\" << endl;\n\t}\n\tTest& operator=(const Test& t)\n\t{\n\t\tcout << \"operator=\" << endl;\n\t\treturn *this;\n\t}\n\t~Test() \n\t{ \n\t\tcout << \"~Test()\" << endl; \n\t}\n\tTest(const Test&)\n\t{ \n\t\tcout << \"Test(const Test&)\" << endl; \n\t}\n};\n\nint main()\n{\n\tTest t1, t2;\n\tcout << \"vector<Test> vec\" << endl;\n\n\tvector<Test> vec;\n\tcout << \"vector<Test> vec; push_back\" << endl;\n\n\tvec.push_back(t1);\n\tvec.push_back(t2);\n\n\tcout << \"vector<Test> vec; pop_back\" << endl;\n\tvec.pop_back();\n\tcout << \"end\" << endl;\n\n\tcout << \"-------------------------------\" << endl;\n\tvector<Test>::iterator it = vec.begin();\n\tfor (; it != vec.end(); ++it) {\n\t\tcout << \"it = \" << &(*it) << endl;\n\t\tstd::cout << \"iterator\" << \" \" << endl;;\n\t}\n\n\treturn 0;\n}\n~~~\n\n","source":"_posts/02.C++ 基础部分/04.C++ 函数模板.md","raw":"---\ntitle: 04.C++ 函数模板\ntags: [C++]\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节分为四个部分：\n\n1. 理解函数模板\n2. 理解类模板\n3. 实现 C++ STL 向量容器 vector\n4. 理解容器控件配置器 allocator\n\n## 1. 理解函数模板\n\n### 1. 定义\n\n函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。\n\n### 2. 用法\n\n面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：\n\n~~~c++\nvoid Swap(int& x, int& y) \n{\n\tint temp = x;\n\tx = y;\n\ty = temp;\n}\n~~~\n\n为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：\n\n~~~c++\nvoid Swap (double & xr double & y)\n{\n    double tmp = x;\n    x = y;\n    y = tmp;\n}\n~~~\n\n如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。\n\n能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。\n\n程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。\n\n**模板函数、模板的特例化和非模板函数的重载关系**：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。\n\n**模板代码是不能声明在.h，实现在.cpp**，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 `#include`\n\n### 3. 原理\n\nC++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。\n\n在 C++ 中，模板分为函数模板和类模板两种。\n\n- 函数模板是用于生成函数；\n- 类模板则是用于生成类的。\n\n函数模板的写法如下：\n\n~~~c++\ntemplate <class 类型参数1, class类型参数2, ...>\n返回值类型  模板名(形参表)\n{\n    函数体\n}\n~~~\n\n**其中的 class 关键字也可以用 typename 关键字替换**，例如：\n\n~~~c++\ntemplate <typename 类型参数1, typename 类型参数2, ...>\n~~~\n\n函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：\n\n~~~c++\ntemplate <typename T>\nT Swap(T& x, T& y)\n{\n\tT tmp = x; \n\tx = y; \n\ty = tmp;\n}\n~~~\n\nT 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。\n\n**示例：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\ntemplate <typename T>\nT Swap(T& x, T& y)\n{\n\tT tmp = x;\n\tx = y;\n\ty = tmp;\n}\n\nint main()\n{\n\tint n = 1, m = 2;\n\t// 编译器自动生成 void Swap (int &, int &)函数\n\tSwap(n, m);\n\n\tdouble f = 1.2, g = 3.4;\n\t// 编译器自动生成 void Swap (double &, double &)函数\n\tSwap(f, g);\n\n\treturn 0;\n}\n~~~\n\n编译器在编译到 `Swap(n, m);` 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：\n\n~~~c++\nvoid Swap (int & x, int & y)\n{\n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n~~~\n\n该函数可以匹配 `Swap(n, m);` 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 `Swap(n, m);` 编译成对自动生成的 Swap 函数的调用。\n\n同理，编译器在编译到 `Swap(f, g);` 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：\n\n~~~c++\nvoid Swap(double & x, double & y)\n{\n    double tmp = x;\n    x = y;\n    y = tmp;\n}\n~~~\n\n然后再将 `Swap(f, g);` 编译成对该 Swap 函数的调用。\n\n编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。\n\n编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：\n\n~~~c++\n模板名<实际类型参数1, 实际类型参数2, ...>\n~~~\n\n## 2. 理解类模板\n\n### 1. 定义\n\n为了多快好省地定义出一批**相似的类**,可以定义「类模板」，然后**由类模板生成不同的类**。\n\n类模板的定义形式如下：\n\n~~~c++\ntemplate <class 类型参数1，class 类型参数2，...> //类型参数表\nclass 类模板名\n{\n   成员函数和成员变量\n};\n~~~\n\n用类模板定义对象的写法：\n\n~~~c++\n类模板名<真实类型参数表> 对象名(构造函数实参表);\n~~~\n\n- 类模板用于实现类所需数据的类型参数化\n- 类模板在表示如数组、表、图等数据结构显得特别重要\n- 这些数据结构的表示和算法不受所包含的元素类型的影响\n\n### 2. 类模板实现顺序栈\n\n~~~c++\n#define  _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\ntemplate <class T>\nclass SeqStack\n{\npublic:\n\t// 公共方法\n\t\t// 构造函数初始化\n\t\t// 构造和析构函数名不加<T> 其他出现模板的地方都加上类型参数列表\n\tSeqStack(int size = 10)\n\t\t: PStack(new T[size])\n\t\t, Top(0)\n\t\t, Size(size) {\n\t\t// 初始化生成的指令更少，效率更高。\n\t\t// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符\n\t};\n\n\t// 拷贝构造\n\t// 初始化列表的方式初始化 size 和 top\n\tSeqStack(const SeqStack<T>& stack)\n\t\t: Top(stack.Top)\n\t\t, Size(stack.Size) {\n\t\t// 重新设置栈\n\t\tPStack = new T[stack.Size];\n\t\tint i = 0;\n\t\tfor (i = 0; i < Top; i++)\n\t\t{\n\t\t\tPStack[i] = stack.PStack[i];\n\t\t}\n\t}\n\n\t// 析构函数 释放内存\n\t~SeqStack()\n\t{\n\t\tif (PStack)\n\t\t{\n\t\t\tdelete[] PStack;\n\t\t\tPStack = nullptr;\n\t\t}\n\t}\n\n\t// 复制重载\n\tSeqStack<T>& operator=(const SeqStack<T>& stack)\n\t{\n\t\t// 判断是否相等\n\t\tif (this == &stack)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 清空\n\t\tdelete[] PStack;\n\n\t\t// 重新赋值\n\t\tTop = stack.Top;\n\t\tSize = stack.Size;\n\t\tPStack = new T[stack.Size];\n\t\tint i = 0;\n\t\tfor (i = 0; i < Top; i++)\n\t\t{\n\t\t\tPStack[i] = stack.PStack[i];\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\t// 共有方法\n\t// 1. push 方法\n\tvoid push(const T& val)\n\t{\n\t\tif (full())\n\t\t{\n\t\t\tresize();\n\t\t}\n\t\tPStack[Top] = val;\n\t\tTop++;\n\t}\n\n\t// 2. pop 方法\n\tvoid pop()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tTop--;\n\t}\n\n\t// 3. top 方法\n\tT top() const\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\tthrow \"Stack is empty!\";\n\t\t}\n\t\treturn PStack[Top - 1];\n\t}\n\n\t// 4. full 方法\n\tbool full() const {\n\t\treturn Top == Size;\n\t}\n\n\t// 5. empty 方法\n\tbool empty() const {\n\t\treturn Top == 0;\n\t}\n\n\t// 私有方法和数据\nprivate:\n\t// 扩容方法\n\tvoid resize()\n\t{\n\t\tT* p = new T[Size * 2];\n\t\t// 将值赋值过去\n\t\tint i = 0;\n\t\tfor (i = 0; i < Top; i++)\n\t\t{\n\t\t\tp[i] = PStack[i];\n\t\t}\n\t\t// 扩大\n\t\tSize *= 2;\n\t\t// 清空\n\t\tdelete PStack;\n\t\t// 重新赋值\n\t\tPStack = p;\n\t}\n\n\tT* PStack;\n\tint Top;\n\tint Size;\n};\n\nint main()\n{\n\tSeqStack<int> stack;\n\tfor (int i = 0; i < 8; ++i) {\n\t\tstack.push(i);\n\t}\n\n\twhile (!stack.empty())\n\t{\n\t\tcout << stack.top() << \" \";\n\t\tstack.pop();\n\t}\n\treturn 0;\n}\n~~~\n\n## 3. 实现 C++ STL 向量容器 vector\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png)\n\nvector 的本质是一个数组，在vector 中需要有三个指针：\n\n- `First`：指向数组的起始位置\n- `Last`：指向已经存放的最后一个元素的下一个位置\n- `End`：指向数组长度的末尾元素的下一个位置。\n\nvector 方法：\n\n- 数组的容量：`End-First`\n- 数组中存放的元素个数：`Last-First`\n- 数组是否为空：`First == Last`\n- 数组是否已满：`Last == End`\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\ntemplate <class T>\nclass vector\n{\npublic:\n\t// 构造函数\n\tvector(int size = 10)\n\t\t: First(new T[size])\n\t\t, Last(First)\n\t\t, End(First + size)\n\t{\n\t\t// 使用初始化列表方式\n\t}\n\t// 拷贝构造函数\n\tvector(const vector<T>& rhs)\n\t{\n\t\t// 获取容器长度\n\t\tint size = rhs.End - rhs.First;\n\t\t// 创建新容器\n\t\tFirst = new T[size];\n\t\t// 获取数据长度\n\t\tint len = rhs.Last - rhs.First;\n\t\t// 遍历赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tFirst[i] = rhs.First[i];\n\t\t}\n\t\t// 重置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\t}\n\t// 析构函数\n\t~vector()\n\t{\n\t\tdelete[] First;\n\t\tFirst = End = Last = nullptr;\n\t}\n\t// 赋值重载\n\tvector<T>& operator=(const vector<T>& rhs)\n\t{\n\t\t// 判断\n\t\tif (this == &rhs)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\n\t\t// 清除\n\t\tdelete[] First;\n\n\t\t// 重新计算并赋值\n\t\t// 获取容器长度\n\t\tint size = rhs.End - rhs.First;\n\t\t// 创建新容器\n\t\tFirst = new T[size];\n\t\t// 获取数据长度\n\t\tint len = rhs.Last - rhs.First;\n\t\t// 遍历赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\tFirst[i] = rhs.First[i];\n\t\t}\n\t\t// 重置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\n\t\treturn *this;\n\t}\n\n\t// 共有方法\n\t// push_back 方法：容器添加内容\n\tvoid push_back(const T& val)\n\t{\n\t\tif (full())\n\t\t{\n\t\t\textend();\n\t\t}\n\t\t// 先给之以后，下次 push 则会递增内存\n\t\t*Last++ = val;\n\t}\n\t// pop_back 方法：容器删除内容\n\tvoid pop_back()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t--Last;\n\t}\n\t// back 方法：输出删除内容\n\tT back() const\n\t{\n\t\treturn *(Last - 1);\n\t}\n\t// full 方法：容器是否已满\n\tbool full() const\n\t{\n\t\treturn Last == End;\n\t}\n\t// empty 方法：容器是否为空\n\tbool empty() const\n\t{\n\t\treturn Last == First;\n\t}\n\t// size 方法：获取内容厂区\n\tint size() const\n\t{\n\t\treturn Last - First;\n\t}\n\n// 私有方法\nprivate:\n\t// vector 容器扩容\n\tvoid extend()\n\t{\n\t\tint size = End - First;\n\t\tT* ptmp = new T[size * 2];\n\n\t\t// 遍历并转移\n\t\tint i = 0;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\tptmp[i] = First[i];\n\t\t}\n\t\t// 删除原先的\n\t\tdelete[] First;\n\n\t\t// 重新覆盖\n\t\tFirst = ptmp;\n\t\tLast = First + size;\n\t\tEnd = First + 2 * size;\n\t}\n\n// 私有数据\nprivate:\n\tT* First;\n\tT* Last;\n\tT* End;\n};\n\nclass Test\n{\npublic:\n\tTest() \n\t{ \n\t\tcout << \"Test()\" << endl; \n\t}\n\tTest& operator=(const Test& t) \n\t{ \n\t\tcout << \"operator=\" << endl; \n\t\treturn *this; \n\t}\n\t~Test() \n\t{ \n\t\tcout << \"~Test()\" << endl; \n\t}\n\tTest(const Test&) \n\t{ \n\t\tcout << \"Test(const Test&)\" << endl; \n\t}\n};\n\nint main()\n{\n\tTest t1;\n\tTest t2;\n\n\tcout << \"vector<Test> vec\" << endl;\n\n\tvector<Test> vec;\n\tcout << \"vector<Test> vec; push_back\" << endl;\n\n\tvec.push_back(t1);\n\tvec.push_back(t2);\n\n\tcout << \"vector<Test> vec; pop_back\" << std::endl;\n\tvec.pop_back();\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png)\n\n问题：在我们实现的 `vector` 构造函数中，使用 `new T[size]`  ：它做了两件事情：\n\n（1）开辟内存空间\n（2）调用 T 类型的默认构造函数构造对象\n\n其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。\n\n同时：在实现 `pop_back(）` 时，存在内存泄漏\n\n~~~c++\n  void pop_back() // 从容器末尾删除元素\n  {\n    if (empty())\n      return;\n    --Last;\n  }\n~~~\n\n 仅仅将 Last 指针 --，并没有释放 Test 申请的资源。**需要调用对象的析构函数**\n\n## 4. 理解容器控件配置器 allocator\n\n**通过 Win msvc 编译器的实现：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png)\n\n~~~c++\n// CLASS TEMPLATE vector\ntemplate<class _Ty, class _Alloc = allocator<_Ty>>\n\tclass vector\n\t\t: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>\n\t{\t// varying size array of values\nprivate:\n\tusing _Mybase = _Vector_alloc<_Vec_base_types<_Ty, _Alloc>>;\n\tusing _Alty = typename _Mybase::_Alty;\n\tusing _Alty_traits = typename _Mybase::_Alty_traits;\n......\n~~~\n\n系统的实现，除了数据类型外，还有一个`allocator`,它将开辟空间和构造对象分离开。  \n\n而这，也就是空间配置器做的工作；\n\n### 1. 容器的空间配置器\n\n空间配置器主要有四个功能：\n\n1. 内存开辟 allocate（底层调用`malloc`）；\n2. 内存释放 deallocate（底层调用`free`）；\n3. 对象构造 construct（调用`构造函数`）；\n4. 对象析构 destroy（调用`析构函数`）；\n\n~~~c++\n// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样\ntemplate <typename T>\nstruct Allocator\n{\n\t// 负责内存的开辟\n\tT* allocate(size_t size)\n\t{\n\t\treturn (T*)malloc(sizeof(T) * size);\n\t}\n\t// 负责内存的释放\n\tvoid deallocate(void* p)\n\t{\n\t\tfree(p);\n\t}\n\t// 负责对象构造\n\tvoid construct(T* p, const T& val)\n\t{\n\t\tnew (p) T(val);\n\t}\n\t// 负责对象析构\n\tvoid destory(T* p)\n\t{\n\t\t// ~T() 代表了 T 类型的析构函数\n \t\tp->~T();\n\t}\n};\n~~~\n\n**重新实现 vector：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// 定义容器的空间配置器，和C++标准库的allocator实现一样\ntemplate<typename T>\nclass Allocator\n{\npublic:\n\t// 负责内存开辟\n\tT* allocate(size_t size) \n\t{\n\t\treturn (T*)malloc(sizeof(T) * size);\n\t}\n\t// 负责内存释放\n\tvoid deallocate(void* p) \n\t{\n\t\tfree(p);\n\t}\n\t// 负责对象构造\n\tvoid construct(T* p, const T& val) \n\t{\n\t\tnew (p)T(val); // 定位new\n\t}\n\t// 负责对象析构\n\tvoid destroy(T* p) \n\t{\n\t\tp->~T(); // ~T()代表了T类型的析构函数\n\t}\n};\n\n// 通过 allocator 适配器重写 vector\ntemplate<typename T, typename Alloc = Allocator<T>>\nclass vector\n{\n\t// 公共构造、拷贝、重载、析构、方法函数\npublic:\n\t// 构造函数\n\t// 需要把内存开辟和对象构造分开处理\n\tvector(int size = 10)\n\t\t: First(_allocator.allocate(size))\n\t\t, Last(First)\n\t\t, End(First + size)\n\t{\n\t\t// 通过初始化列表的方式，初始化数据\n\t}\n\n\t// 拷贝函数\n\tvector(const vector<T>& rhs)\n\t{\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\t}\n\t// 析构函数\n\t~vector()\n\t{\n\t\tcout << \"~vector\" << endl;\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != Last; p++)\n\t\t{\n\t\t\t// cout << \"p =\" << p << endl;\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\t\t// 重置 指针\n\t\tFirst = Last = End = nullptr;\n\t}\n\n\n\t// 赋值重载\n\tvector<T>& operator=(const vector<T>& rhs)\n\t{\n\t\t// 1. 判断\n\t\tif (this == &rhs)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 2. 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 3. 重新计算\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\n\t\treturn *this;\n\t}\n\n\t// 公共方法\n\t// 1. push_back 方法\n\tvoid push_back(const T& val)\n\t{\n\t\t// 判断\n\t\tif (full())\n\t\t{\n\t\t\texpand();\n\t\t}\n\t\t// 通过适配器添加内容\n\t\t_allocator.construct(Last, val);\n\t\tLast++;\n\t}\n\t// 2. pop_back 方法\n\tvoid pop_back()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t// 不仅要把 Last 指针--，还需要析构删除的元素\n\t\t--Last;\n\t\t_allocator.destroy(Last);\n\t}\n\t// 3. back 方法\n\tT back() const \n\t{\n\t\treturn *(Last - 1);\n\t}\n\t// 4. full 方法\n\tbool full() const { return Last == End; }\n\t// 5. empty 方法\n\tbool empty() const { return First == Last; }\n\t// 6. size 方法\n\tint size() const { return Last - First; }\n\n// 私有属性和方法\nprivate:\n\t// 指向数组起始的位置\n\tT* First;\n\t// 指向数组中有效元素的后继位置\n\tT* Last;\n\t// 指向数组空间的后继位置\n\tT* End;\n\t// 定义容器的空间配置器对象\n\tAlloc _allocator;\n\n\t// 扩容方法\n\tvoid expand()\n\t{\n\t\t// 获取大小\n\t\tint size = End - First;\n\t\t// 配置 2 倍适配器空间\n\t\tT* ptmp = _allocator.allocate(size * 2);\n\t\t// 赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\t_allocator.construct(ptmp + i, First[i]);\n\t\t}\n\n\t\t// 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 重新赋值\n\t\tFirst = ptmp;\n\t\tLast = First + size;\n\t\tEnd = First + size * 2;\n\t}\n};\n\n\nclass Test\n{\npublic:\n\tTest()\n\t{\n\t\tcout << \"Test()\" << endl;\n\t}\n\tTest& operator=(const Test& t)\n\t{\n\t\tcout << \"operator=\" << endl;\n\t\treturn *this;\n\t}\n\t~Test() \n\t{ \n\t\tcout << \"~Test()\" << endl; \n\t}\n\tTest(const Test&)\n\t{ \n\t\tcout << \"Test(const Test&)\" << endl; \n\t}\n};\n\nint main()\n{\n\tTest t1, t2;\n\tcout << \"1.\" << endl;\n\tcout << \"vector<Test> vec\" << endl;\n\n\tvector<Test> vec;\n\tcout << \"vector<Test> vec; push_back\" << endl;\n\n\tvec.push_back(t1);\n\tvec.push_back(t2);\n\n\tcout << \"vector<Test> vec; pop_back\" << endl;\n\tvec.pop_back();\n\tcout << \"end\" << endl;\n\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png)\n\n现在的效果就和 msvc 实现的 vector 相同了\n\n### 2. 运算符重载与迭代器实现\n\n~~~c++\n// 迭代器一般是现成容器的嵌套类型\ntemplate<class T>\nclass iterator\n{\npublic:\n\t// 构造函数\n\titerator(T* p = nullptr)\n\t\t: _ptr(p)\n\t{\n\t\t// 初始化列表方式\n\t}\n\t// 拷贝构造函数\n\titerator(const iterator& iter)\n\t\t: _ptr(iter._ptr)\n\t{\n\t\t// ...\n\t}\n\n\t// 重载函数合集\n\t// 1. 前置 ++\n\titerator& operator++()\n\t{\n\t\t_ptr++;\n\t\treturn *this;\n\t}\n\t// 2. 后置 ++\n\titerator operator++(int) {\n\t\titerator tmp(*this);\n\t\t_ptr++;\n\t\treturn tmp;\n\t}\n\t// 3. 解引用\n\tT& operator*()\n\t{\n\t\treturn *_ptr;\n\t}\n\t// 4. !=\n\tbool operator!=(const iterator& iter) const\n\t{\n\t\treturn _ptr != iter._ptr;\n\t}\n\nprivate:\n\tT* _ptr;\n};\n\n\n//迭代器方法\niterator begin() { return iterator(First); }\niterator end() { return iterator(Last); }\n\n//运算符重载[]\nT& operator[](int index) {\n\tif (index < 0 || index >= size()) {\n\t\tthrow \"OutofRangeException\";\n\t}\n\n\treturn First[index];\n}\n~~~\n\n### 3. 最终 vector 实现\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n\n// 定义容器的空间配置器，和C++标准库的allocator实现一样\ntemplate<typename T>\nclass Allocator\n{\npublic:\n\t// 负责内存开辟\n\tT* allocate(size_t size) \n\t{\n\t\treturn (T*)malloc(sizeof(T) * size);\n\t}\n\t// 负责内存释放\n\tvoid deallocate(void* p) \n\t{\n\t\tfree(p);\n\t}\n\t// 负责对象构造\n\tvoid construct(T* p, const T& val) \n\t{\n\t\tnew (p)T(val); // 定位new\n\t}\n\t// 负责对象析构\n\tvoid destroy(T* p) \n\t{\n\t\tp->~T(); // ~T()代表了T类型的析构函数\n\t}\n};\n\n// 通过 allocator 适配器重写 vector\ntemplate<typename T, typename Alloc = Allocator<T>>\nclass vector\n{\n\t// 公共构造、拷贝、重载、析构、方法函数\npublic:\n\t// 构造函数\n\t// 需要把内存开辟和对象构造分开处理\n\tvector(int size = 10)\n\t\t: First(_allocator.allocate(size))\n\t\t, Last(First)\n\t\t, End(First + size)\n\t{\n\t\t// 通过初始化列表的方式，初始化数据\n\t}\n\n\t// 拷贝函数\n\tvector(const vector<T>& rhs)\n\t{\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\t}\n\t// 析构函数\n\t~vector()\n\t{\n\t\tcout << \"~vector\" << endl;\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != Last; p++)\n\t\t{\n\t\t\t// cout << \"p =\" << p << endl;\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\t\t// 重置 指针\n\t\tFirst = Last = End = nullptr;\n\t}\n\n\n\t// 赋值重载\n\tvector<T>& operator=(const vector<T>& rhs)\n\t{\n\t\t// 1. 判断\n\t\tif (this == &rhs)\n\t\t{\n\t\t\treturn *this;\n\t\t}\n\t\t// 2. 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 3. 重新计算\n\t\t// 定义 大小\n\t\tint size = rhs.End - rhs.First;\n\t\t// 空间适配器开辟空间\n\t\tFirst = _allocator.allocate(size);\n\t\t// 获取长度\n\t\tint len = rhs.Last - rhs.First;\n\n\t\t// 拷贝数据\n\t\tint i = 0;\n\t\tfor (i = 0; i < len; i++)\n\t\t{\n\t\t\t// 空间适配器的构造方法赋值\n\t\t\t_allocator.construct(First + i, rhs.First[i]);\n\t\t}\n\t\t// 重新配置 Last 和 End\n\t\tLast = First + len;\n\t\tEnd = First + size;\n\n\t\treturn *this;\n\t}\n\t//运算符重载[]\n\tT& operator[](int index) \n\t{\n\t\t// 判断索引位置\n\t\tif (index < 0 || index >= size()) {\n\t\t\tthrow \"OutofRangeException\";\n\t\t}\n\t\t// 返回索引值\n\t\treturn First[index];\n\t}\n\n\t// 公共方法\n\t// 1. push_back 方法\n\tvoid push_back(const T& val)\n\t{\n\t\t// 判断\n\t\tif (full())\n\t\t{\n\t\t\texpand();\n\t\t}\n\t\t// 通过适配器添加内容\n\t\t_allocator.construct(Last, val);\n\t\tLast++;\n\t}\n\t// 2. pop_back 方法\n\tvoid pop_back()\n\t{\n\t\tif (empty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t// 不仅要把 Last 指针--，还需要析构删除的元素\n\t\t--Last;\n\t\t_allocator.destroy(Last);\n\t}\n\t// 3. back 方法\n\tT back() const \n\t{\n\t\treturn *(Last - 1);\n\t}\n\t// 4. full 方法\n\tbool full() const { return Last == End; }\n\t// 5. empty 方法\n\tbool empty() const { return First == Last; }\n\t// 6. size 方法\n\tint size() const { return Last - First; }\n\n\t// 迭代器一般是现成容器的嵌套类型\n\tclass iterator\n\t{\n\tpublic:\n\t\t// 构造函数\n\t\titerator(T* p = nullptr)\n\t\t\t: _ptr(p)\n\t\t{\n\t\t\t// 初始化列表方式\n\t\t}\n\t\t// 拷贝构造函数\n\t\titerator(const iterator& iter)\n\t\t\t: _ptr(iter._ptr)\n\t\t{\n\t\t\t// ...\n\t\t}\n\n\t\t// 重载函数合集\n\t\t// 1. 前置 ++\n\t\titerator& operator++()\n\t\t{\n\t\t\t_ptr++;\n\t\t\treturn *this;\n\t\t}\n\t\t// 2. 后置 ++\n\t\titerator operator++(int) {\n\t\t\titerator tmp(*this);\n\t\t\t_ptr++;\n\t\t\treturn tmp;\n\t\t}\n\t\t// 3. 解引用\n\t\tT& operator*()\n\t\t{\n\t\t\treturn *_ptr;\n\t\t}\n\t\t// 4. !=\n\t\tbool operator!=(const iterator& iter) const\n\t\t{\n\t\t\treturn _ptr != iter._ptr;\n\t\t}\n\n\tprivate:\n\t\tT* _ptr;\n\t};\n\t//迭代器方法\n\titerator begin() { return iterator(First); }\n\titerator end() { return iterator(Last); }\n\n\n// 私有属性和方法\nprivate:\n\t// 指向数组起始的位置\n\tT* First;\n\t// 指向数组中有效元素的后继位置\n\tT* Last;\n\t// 指向数组空间的后继位置\n\tT* End;\n\t// 定义容器的空间配置器对象\n\tAlloc _allocator;\n\n\t// 扩容方法\n\tvoid expand()\n\t{\n\t\t// 获取大小\n\t\tint size = End - First;\n\t\t// 配置 2 倍适配器空间\n\t\tT* ptmp = _allocator.allocate(size * 2);\n\t\t// 赋值\n\t\tint i = 0;\n\t\tfor (i = 0; i < size; i++)\n\t\t{\n\t\t\t_allocator.construct(ptmp + i, First[i]);\n\t\t}\n\n\t\t// 清空\n\t\t// 析构容器有效的元素，然后释放 First 指针指向的堆内存\n\t\tT* p = First;\n\t\tfor (p = First; p != End; p++)\n\t\t{\n\t\t\t//  把 First 指针指向的数组的有效元素进行析构操作\n\t\t\t_allocator.destroy(p);\n\t\t}\n\t\t// 释放堆上的数组内存\n\t\t_allocator.deallocate(First);\n\n\t\t// 重新赋值\n\t\tFirst = ptmp;\n\t\tLast = First + size;\n\t\tEnd = First + size * 2;\n\t}\n};\n\nclass Test\n{\npublic:\n\tTest()\n\t{\n\t\tcout << \"Test()\" << endl;\n\t}\n\tTest& operator=(const Test& t)\n\t{\n\t\tcout << \"operator=\" << endl;\n\t\treturn *this;\n\t}\n\t~Test() \n\t{ \n\t\tcout << \"~Test()\" << endl; \n\t}\n\tTest(const Test&)\n\t{ \n\t\tcout << \"Test(const Test&)\" << endl; \n\t}\n};\n\nint main()\n{\n\tTest t1, t2;\n\tcout << \"vector<Test> vec\" << endl;\n\n\tvector<Test> vec;\n\tcout << \"vector<Test> vec; push_back\" << endl;\n\n\tvec.push_back(t1);\n\tvec.push_back(t2);\n\n\tcout << \"vector<Test> vec; pop_back\" << endl;\n\tvec.pop_back();\n\tcout << \"end\" << endl;\n\n\tcout << \"-------------------------------\" << endl;\n\tvector<Test>::iterator it = vec.begin();\n\tfor (; it != vec.end(); ++it) {\n\t\tcout << \"it = \" << &(*it) << endl;\n\t\tstd::cout << \"iterator\" << \" \" << endl;;\n\t}\n\n\treturn 0;\n}\n~~~\n\n","slug":"02.C++ 基础部分/04.C++ 函数模板","published":1,"date":"2023-08-08T02:04:06.631Z","updated":"2023-08-09T09:14:07.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll3spnt8000224pk2oyickm4","content":"<p>本节分为四个部分：</p>\n<ol>\n<li>理解函数模板</li>\n<li>理解类模板</li>\n<li>实现 C++ STL 向量容器 vector</li>\n<li>理解容器控件配置器 allocator</li>\n</ol>\n<h2 id=\"1-理解函数模板\"><a href=\"#1-理解函数模板\" class=\"headerlink\" title=\"1. 理解函数模板\"></a>1. 理解函数模板</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</p>\n<h3 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><p>面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; x, <span class=\"hljs-type\">int</span>&amp; y)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> temp = x;<br>\tx = y;<br>\ty = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> &amp; xr <span class=\"hljs-type\">double</span> &amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。</p>\n<p>能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。</p>\n<p>程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。</p>\n<p><strong>模板函数、模板的特例化和非模板函数的重载关系</strong>：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。</p>\n<p><strong>模板代码是不能声明在.h，实现在.cpp</strong>，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 <code>#include</code></p>\n<h3 id=\"3-原理\"><a href=\"#3-原理\" class=\"headerlink\" title=\"3. 原理\"></a>3. 原理</h3><p>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p>\n<p>在 C++ 中，模板分为函数模板和类模板两种。</p>\n<ul>\n<li>函数模板是用于生成函数；</li>\n<li>类模板则是用于生成类的。</li>\n</ul>\n<p>函数模板的写法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> 类型参数<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">class</span>类型参数<span class=\"hljs-number\">2</span>, ...&gt;<br>返回值类型  模板名(形参表)<br>&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>其中的 class 关键字也可以用 typename 关键字替换</strong>，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> 类型参数<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">typename</span> 类型参数<span class=\"hljs-number\">2</span>, ...&gt;<br></code></pre></td></tr></table></figure>\n\n<p>函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\">T <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(T&amp; x, T&amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT tmp = x; <br>\tx = y; <br>\ty = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>T 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\">T <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(T&amp; x, T&amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT tmp = x;<br>\tx = y;<br>\ty = tmp;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">1</span>, m = <span class=\"hljs-number\">2</span>;<br>\t<span class=\"hljs-comment\">// 编译器自动生成 void Swap (int &amp;, int &amp;)函数</span><br>\t<span class=\"hljs-built_in\">Swap</span>(n, m);<br><br>\t<span class=\"hljs-type\">double</span> f = <span class=\"hljs-number\">1.2</span>, g = <span class=\"hljs-number\">3.4</span>;<br>\t<span class=\"hljs-comment\">// 编译器自动生成 void Swap (double &amp;, double &amp;)函数</span><br>\t<span class=\"hljs-built_in\">Swap</span>(f, g);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译器在编译到 <code>Swap(n, m);</code> 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> &amp; x, <span class=\"hljs-type\">int</span> &amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该函数可以匹配 <code>Swap(n, m);</code> 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 <code>Swap(n, m);</code> 编译成对自动生成的 Swap 函数的调用。</p>\n<p>同理，编译器在编译到 <code>Swap(f, g);</code> 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> &amp; x, <span class=\"hljs-type\">double</span> &amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后再将 <code>Swap(f, g);</code> 编译成对该 Swap 函数的调用。</p>\n<p>编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。</p>\n<p>编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">模板名&lt;实际类型参数<span class=\"hljs-number\">1</span>, 实际类型参数<span class=\"hljs-number\">2</span>, ...&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-理解类模板\"><a href=\"#2-理解类模板\" class=\"headerlink\" title=\"2. 理解类模板\"></a>2. 理解类模板</h2><h3 id=\"1-定义-1\"><a href=\"#1-定义-1\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>为了多快好省地定义出一批<strong>相似的类</strong>,可以定义「类模板」，然后<strong>由类模板生成不同的类</strong>。</p>\n<p>类模板的定义形式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> 类型参数<span class=\"hljs-number\">1</span>，<span class=\"hljs-keyword\">class</span> 类型参数<span class=\"hljs-number\">2</span>，...&gt; <span class=\"hljs-comment\">//类型参数表</span><br><span class=\"hljs-keyword\">class</span> 类模板名<br>&#123;<br>   成员函数和成员变量<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>用类模板定义对象的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实参表);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>类模板用于实现类所需数据的类型参数化</li>\n<li>类模板在表示如数组、表、图等数据结构显得特别重要</li>\n<li>这些数据结构的表示和算法不受所包含的元素类型的影响</li>\n</ul>\n<h3 id=\"2-类模板实现顺序栈\"><a href=\"#2-类模板实现顺序栈\" class=\"headerlink\" title=\"2. 类模板实现顺序栈\"></a>2. 类模板实现顺序栈</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqStack</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 公共方法</span><br>\t\t<span class=\"hljs-comment\">// 构造函数初始化</span><br>\t\t<span class=\"hljs-comment\">// 构造和析构函数名不加&lt;T&gt; 其他出现模板的地方都加上类型参数列表</span><br>\t<span class=\"hljs-built_in\">SeqStack</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">PStack</span>(<span class=\"hljs-keyword\">new</span> T[size])<br>\t\t, <span class=\"hljs-built_in\">Top</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">Size</span>(size) &#123;<br>\t\t<span class=\"hljs-comment\">// 初始化生成的指令更少，效率更高。</span><br>\t\t<span class=\"hljs-comment\">// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符</span><br>\t&#125;;<br><br>\t<span class=\"hljs-comment\">// 拷贝构造</span><br>\t<span class=\"hljs-comment\">// 初始化列表的方式初始化 size 和 top</span><br>\t<span class=\"hljs-built_in\">SeqStack</span>(<span class=\"hljs-type\">const</span> SeqStack&lt;T&gt;&amp; stack)<br>\t\t: <span class=\"hljs-built_in\">Top</span>(stack.Top)<br>\t\t, <span class=\"hljs-built_in\">Size</span>(stack.Size) &#123;<br>\t\t<span class=\"hljs-comment\">// 重新设置栈</span><br>\t\tPStack = <span class=\"hljs-keyword\">new</span> T[stack.Size];<br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Top; i++)<br>\t\t&#123;<br>\t\t\tPStack[i] = stack.PStack[i];<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 析构函数 释放内存</span><br>\t~<span class=\"hljs-built_in\">SeqStack</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (PStack)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">delete</span>[] PStack;<br>\t\t\tPStack = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 复制重载</span><br>\tSeqStack&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> SeqStack&lt;T&gt;&amp; stack)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 判断是否相等</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;stack)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-keyword\">delete</span>[] PStack;<br><br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tTop = stack.Top;<br>\t\tSize = stack.Size;<br>\t\tPStack = <span class=\"hljs-keyword\">new</span> T[stack.Size];<br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Top; i++)<br>\t\t&#123;<br>\t\t\tPStack[i] = stack.PStack[i];<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 共有方法</span><br>\t<span class=\"hljs-comment\">// 1. push 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">resize</span>();<br>\t\t&#125;<br>\t\tPStack[Top] = val;<br>\t\tTop++;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. pop 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\tTop--;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 3. top 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;Stack is empty!&quot;</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> PStack[Top - <span class=\"hljs-number\">1</span>];<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4. full 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Top == Size;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 5. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Top == <span class=\"hljs-number\">0</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 私有方法和数据</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 扩容方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">resize</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tT* p = <span class=\"hljs-keyword\">new</span> T[Size * <span class=\"hljs-number\">2</span>];<br>\t\t<span class=\"hljs-comment\">// 将值赋值过去</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Top; i++)<br>\t\t&#123;<br>\t\t\tp[i] = PStack[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 扩大</span><br>\t\tSize *= <span class=\"hljs-number\">2</span>;<br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-keyword\">delete</span> PStack;<br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tPStack = p;<br>\t&#125;<br><br>\tT* PStack;<br>\t<span class=\"hljs-type\">int</span> Top;<br>\t<span class=\"hljs-type\">int</span> Size;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSeqStack&lt;<span class=\"hljs-type\">int</span>&gt; stack;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; ++i) &#123;<br>\t\tstack.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; stack.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tstack.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-实现-C-STL-向量容器-vector\"><a href=\"#3-实现-C-STL-向量容器-vector\" class=\"headerlink\" title=\"3. 实现 C++ STL 向量容器 vector\"></a>3. 实现 C++ STL 向量容器 vector</h2><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png\" alt=\"image.png\"></p>\n<p>vector 的本质是一个数组，在vector 中需要有三个指针：</p>\n<ul>\n<li><code>First</code>：指向数组的起始位置</li>\n<li><code>Last</code>：指向已经存放的最后一个元素的下一个位置</li>\n<li><code>End</code>：指向数组长度的末尾元素的下一个位置。</li>\n</ul>\n<p>vector 方法：</p>\n<ul>\n<li>数组的容量：<code>End-First</code></li>\n<li>数组中存放的元素个数：<code>Last-First</code></li>\n<li>数组是否为空：<code>First == Last</code></li>\n<li>数组是否已满：<code>Last == End</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">vector</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">First</span>(<span class=\"hljs-keyword\">new</span> T[size])<br>\t\t, <span class=\"hljs-built_in\">Last</span>(First)<br>\t\t, <span class=\"hljs-built_in\">End</span>(First + size)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 使用初始化列表方式</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 获取容器长度</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 创建新容器</span><br>\t\tFirst = <span class=\"hljs-keyword\">new</span> T[size];<br>\t\t<span class=\"hljs-comment\">// 获取数据长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 遍历赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\tFirst[i] = rhs.First[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">vector</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span>[] First;<br>\t\tFirst = End = Last = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\tvector&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;rhs)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清除</span><br>\t\t<span class=\"hljs-keyword\">delete</span>[] First;<br><br>\t\t<span class=\"hljs-comment\">// 重新计算并赋值</span><br>\t\t<span class=\"hljs-comment\">// 获取容器长度</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 创建新容器</span><br>\t\tFirst = <span class=\"hljs-keyword\">new</span> T[size];<br>\t\t<span class=\"hljs-comment\">// 获取数据长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 遍历赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\tFirst[i] = rhs.First[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 共有方法</span><br>\t<span class=\"hljs-comment\">// push_back 方法：容器添加内容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">extend</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 先给之以后，下次 push 则会递增内存</span><br>\t\t*Last++ = val;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// pop_back 方法：容器删除内容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t--Last;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// back 方法：输出删除内容</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *(Last - <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// full 方法：容器是否已满</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Last == End;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// empty 方法：容器是否为空</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Last == First;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// size 方法：获取内容厂区</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Last - First;<br>\t&#125;<br><br><span class=\"hljs-comment\">// 私有方法</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// vector 容器扩容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extend</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> size = End - First;<br>\t\tT* ptmp = <span class=\"hljs-keyword\">new</span> T[size * <span class=\"hljs-number\">2</span>];<br><br>\t\t<span class=\"hljs-comment\">// 遍历并转移</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t\t&#123;<br>\t\t\tptmp[i] = First[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 删除原先的</span><br>\t\t<span class=\"hljs-keyword\">delete</span>[] First;<br><br>\t\t<span class=\"hljs-comment\">// 重新覆盖</span><br>\t\tFirst = ptmp;<br>\t\tLast = First + size;<br>\t\tEnd = First + <span class=\"hljs-number\">2</span> * size;<br>\t&#125;<br><br><span class=\"hljs-comment\">// 私有数据</span><br><span class=\"hljs-keyword\">private</span>:<br>\tT* First;<br>\tT* Last;<br>\tT* End;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\tTest&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Test&amp; t) <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl; <br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>; <br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp;) <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest t1;<br>\tTest t2;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>\tvector&lt;Test&gt; vec;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t1);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t2);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; std::endl;<br>\tvec.<span class=\"hljs-built_in\">pop_back</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png\" alt=\"image.png\"></p>\n<p>问题：在我们实现的 <code>vector</code> 构造函数中，使用 <code>new T[size]</code>  ：它做了两件事情：</p>\n<p>（1）开辟内存空间<br>（2）调用 T 类型的默认构造函数构造对象</p>\n<p>其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。</p>\n<p>同时：在实现 <code>pop_back(）</code> 时，存在内存泄漏</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 从容器末尾删除元素</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>    <span class=\"hljs-keyword\">return</span>;<br>  --Last;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 仅仅将 Last 指针 –，并没有释放 Test 申请的资源。<strong>需要调用对象的析构函数</strong></p>\n<h2 id=\"4-理解容器控件配置器-allocator\"><a href=\"#4-理解容器控件配置器-allocator\" class=\"headerlink\" title=\"4. 理解容器控件配置器 allocator\"></a>4. 理解容器控件配置器 allocator</h2><p><strong>通过 Win msvc 编译器的实现：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png\" alt=\"image.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// CLASS TEMPLATE vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Ty</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Alloc</span> = allocator&lt;_Ty&gt;&gt;<br>\t<span class=\"hljs-keyword\">class</span> vector<br>\t\t: <span class=\"hljs-keyword\">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>\t&#123;\t<span class=\"hljs-comment\">// varying size array of values</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">using</span> _Mybase = _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;;<br>\t<span class=\"hljs-keyword\">using</span> _Alty = <span class=\"hljs-keyword\">typename</span> _Mybase::_Alty;<br>\t<span class=\"hljs-keyword\">using</span> _Alty_traits = <span class=\"hljs-keyword\">typename</span> _Mybase::_Alty_traits;<br>......<br></code></pre></td></tr></table></figure>\n\n<p>系统的实现，除了数据类型外，还有一个<code>allocator</code>,它将开辟空间和构造对象分离开。  </p>\n<p>而这，也就是空间配置器做的工作；</p>\n<h3 id=\"1-容器的空间配置器\"><a href=\"#1-容器的空间配置器\" class=\"headerlink\" title=\"1. 容器的空间配置器\"></a>1. 容器的空间配置器</h3><p>空间配置器主要有四个功能：</p>\n<ol>\n<li>内存开辟 allocate（底层调用<code>malloc</code>）；</li>\n<li>内存释放 deallocate（底层调用<code>free</code>）；</li>\n<li>对象构造 construct（调用<code>构造函数</code>）；</li>\n<li>对象析构 destroy（调用<code>析构函数</code>）；</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Allocator</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 负责内存的开辟</span><br>\t<span class=\"hljs-function\">T* <span class=\"hljs-title\">allocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (T*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(T) * size);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责内存的释放</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象构造</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(T* p, <span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">new</span> (p) <span class=\"hljs-built_in\">T</span>(val);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象析构</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destory</span><span class=\"hljs-params\">(T* p)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// ~T() 代表了 T 类型的析构函数</span><br> \t\tp-&gt;~<span class=\"hljs-built_in\">T</span>();<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>重新实现 vector：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Allocator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 负责内存开辟</span><br>\t<span class=\"hljs-function\">T* <span class=\"hljs-title\">allocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (T*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(T) * size);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责内存释放</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象构造</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(T* p, <span class=\"hljs-type\">const</span> T&amp; val)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">new</span> (p)<span class=\"hljs-built_in\">T</span>(val); <span class=\"hljs-comment\">// 定位new</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象析构</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">(T* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tp-&gt;~<span class=\"hljs-built_in\">T</span>(); <span class=\"hljs-comment\">// ~T()代表了T类型的析构函数</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 通过 allocator 适配器重写 vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">class</span> vector<br>&#123;<br>\t<span class=\"hljs-comment\">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-comment\">// 需要把内存开辟和对象构造分开处理</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">First</span>(_allocator.<span class=\"hljs-built_in\">allocate</span>(size))<br>\t\t, <span class=\"hljs-built_in\">Last</span>(First)<br>\t\t, <span class=\"hljs-built_in\">End</span>(First + size)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 通过初始化列表的方式，初始化数据</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 拷贝函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">vector</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~vector&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != Last; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br>\t\t<span class=\"hljs-comment\">// 重置 指针</span><br>\t\tFirst = Last = End = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br><br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\tvector&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 1. 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;rhs)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 2. 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 3. 重新计算</span><br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 公共方法</span><br>\t<span class=\"hljs-comment\">// 1. push_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">expand</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 通过适配器添加内容</span><br>\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(Last, val);<br>\t\tLast++;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. pop_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>\t\t--Last;<br>\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(Last);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. back 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *(Last - <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. full 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last == End; &#125;<br>\t<span class=\"hljs-comment\">// 5. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> First == Last; &#125;<br>\t<span class=\"hljs-comment\">// 6. size 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last - First; &#125;<br><br><span class=\"hljs-comment\">// 私有属性和方法</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 指向数组起始的位置</span><br>\tT* First;<br>\t<span class=\"hljs-comment\">// 指向数组中有效元素的后继位置</span><br>\tT* Last;<br>\t<span class=\"hljs-comment\">// 指向数组空间的后继位置</span><br>\tT* End;<br>\t<span class=\"hljs-comment\">// 定义容器的空间配置器对象</span><br>\tAlloc _allocator;<br><br>\t<span class=\"hljs-comment\">// 扩容方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">expand</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 获取大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = End - First;<br>\t\t<span class=\"hljs-comment\">// 配置 2 倍适配器空间</span><br>\t\tT* ptmp = _allocator.<span class=\"hljs-built_in\">allocate</span>(size * <span class=\"hljs-number\">2</span>);<br>\t\t<span class=\"hljs-comment\">// 赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t\t&#123;<br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(ptmp + i, First[i]);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tFirst = ptmp;<br>\t\tLast = First + size;<br>\t\tEnd = First + size * <span class=\"hljs-number\">2</span>;<br>\t&#125;<br>&#125;;<br><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\tTest&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Test&amp; t)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp;)<br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest t1, t2;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;1.&quot;</span> &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>\tvector&lt;Test&gt; vec;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t1);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t2);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>\tvec.<span class=\"hljs-built_in\">pop_back</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;end&quot;</span> &lt;&lt; endl;<br><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png\" alt=\"image.png\"></p>\n<p>现在的效果就和 msvc 实现的 vector 相同了</p>\n<h3 id=\"2-运算符重载与迭代器实现\"><a href=\"#2-运算符重载与迭代器实现\" class=\"headerlink\" title=\"2. 运算符重载与迭代器实现\"></a>2. 运算符重载与迭代器实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 迭代器一般是现成容器的嵌套类型</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">iterator</span>(T* p = <span class=\"hljs-literal\">nullptr</span>)<br>\t\t: _ptr(p)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表方式</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t<span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter)<br>\t\t: _ptr(iter._ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// ...</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 重载函数合集</span><br>\t<span class=\"hljs-comment\">// 1. 前置 ++</span><br>\titerator&amp; <span class=\"hljs-keyword\">operator</span>++()<br>\t&#123;<br>\t\t_ptr++;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. 后置 ++</span><br>\titerator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>\t\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>\t\t_ptr++;<br>\t\t<span class=\"hljs-keyword\">return</span> tmp;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. 解引用</span><br>\tT&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. !=</span><br>\t<span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; iter) <span class=\"hljs-type\">const</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> _ptr != iter._ptr;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tT* _ptr;<br>&#125;;<br><br><br><span class=\"hljs-comment\">//迭代器方法</span><br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(First); &#125;<br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(Last); &#125;<br><br><span class=\"hljs-comment\">//运算符重载[]</span><br>T&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-number\">0</span> || index &gt;= <span class=\"hljs-built_in\">size</span>()) &#123;<br>\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;OutofRangeException&quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> First[index];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-最终-vector-实现\"><a href=\"#3-最终-vector-实现\" class=\"headerlink\" title=\"3. 最终 vector 实现\"></a>3. 最终 vector 实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><br><span class=\"hljs-comment\">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Allocator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 负责内存开辟</span><br>\t<span class=\"hljs-function\">T* <span class=\"hljs-title\">allocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (T*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(T) * size);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责内存释放</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象构造</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(T* p, <span class=\"hljs-type\">const</span> T&amp; val)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">new</span> (p)<span class=\"hljs-built_in\">T</span>(val); <span class=\"hljs-comment\">// 定位new</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象析构</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">(T* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tp-&gt;~<span class=\"hljs-built_in\">T</span>(); <span class=\"hljs-comment\">// ~T()代表了T类型的析构函数</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 通过 allocator 适配器重写 vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">class</span> vector<br>&#123;<br>\t<span class=\"hljs-comment\">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-comment\">// 需要把内存开辟和对象构造分开处理</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">First</span>(_allocator.<span class=\"hljs-built_in\">allocate</span>(size))<br>\t\t, <span class=\"hljs-built_in\">Last</span>(First)<br>\t\t, <span class=\"hljs-built_in\">End</span>(First + size)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 通过初始化列表的方式，初始化数据</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 拷贝函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">vector</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~vector&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != Last; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br>\t\t<span class=\"hljs-comment\">// 重置 指针</span><br>\t\tFirst = Last = End = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br><br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\tvector&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 1. 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;rhs)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 2. 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 3. 重新计算</span><br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//运算符重载[]</span><br>\tT&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 判断索引位置</span><br>\t\t<span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-number\">0</span> || index &gt;= <span class=\"hljs-built_in\">size</span>()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;OutofRangeException&quot;</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 返回索引值</span><br>\t\t<span class=\"hljs-keyword\">return</span> First[index];<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 公共方法</span><br>\t<span class=\"hljs-comment\">// 1. push_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">expand</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 通过适配器添加内容</span><br>\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(Last, val);<br>\t\tLast++;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. pop_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>\t\t--Last;<br>\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(Last);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. back 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *(Last - <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. full 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last == End; &#125;<br>\t<span class=\"hljs-comment\">// 5. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> First == Last; &#125;<br>\t<span class=\"hljs-comment\">// 6. size 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last - First; &#125;<br><br>\t<span class=\"hljs-comment\">// 迭代器一般是现成容器的嵌套类型</span><br>\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>\t&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-comment\">// 构造函数</span><br>\t\t<span class=\"hljs-built_in\">iterator</span>(T* p = <span class=\"hljs-literal\">nullptr</span>)<br>\t\t\t: _ptr(p)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 初始化列表方式</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t\t<span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter)<br>\t\t\t: _ptr(iter._ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// ...</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 重载函数合集</span><br>\t\t<span class=\"hljs-comment\">// 1. 前置 ++</span><br>\t\titerator&amp; <span class=\"hljs-keyword\">operator</span>++()<br>\t\t&#123;<br>\t\t\t_ptr++;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 2. 后置 ++</span><br>\t\titerator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>\t\t\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>\t\t\t_ptr++;<br>\t\t\t<span class=\"hljs-keyword\">return</span> tmp;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 3. 解引用</span><br>\t\tT&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 4. !=</span><br>\t\t<span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; iter) <span class=\"hljs-type\">const</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> _ptr != iter._ptr;<br>\t\t&#125;<br><br>\t<span class=\"hljs-keyword\">private</span>:<br>\t\tT* _ptr;<br>\t&#125;;<br>\t<span class=\"hljs-comment\">//迭代器方法</span><br>\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(First); &#125;<br>\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(Last); &#125;<br><br><br><span class=\"hljs-comment\">// 私有属性和方法</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 指向数组起始的位置</span><br>\tT* First;<br>\t<span class=\"hljs-comment\">// 指向数组中有效元素的后继位置</span><br>\tT* Last;<br>\t<span class=\"hljs-comment\">// 指向数组空间的后继位置</span><br>\tT* End;<br>\t<span class=\"hljs-comment\">// 定义容器的空间配置器对象</span><br>\tAlloc _allocator;<br><br>\t<span class=\"hljs-comment\">// 扩容方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">expand</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 获取大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = End - First;<br>\t\t<span class=\"hljs-comment\">// 配置 2 倍适配器空间</span><br>\t\tT* ptmp = _allocator.<span class=\"hljs-built_in\">allocate</span>(size * <span class=\"hljs-number\">2</span>);<br>\t\t<span class=\"hljs-comment\">// 赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t\t&#123;<br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(ptmp + i, First[i]);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tFirst = ptmp;<br>\t\tLast = First + size;<br>\t\tEnd = First + size * <span class=\"hljs-number\">2</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\tTest&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Test&amp; t)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp;)<br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest t1, t2;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>\tvector&lt;Test&gt; vec;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t1);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t2);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>\tvec.<span class=\"hljs-built_in\">pop_back</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;end&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;-------------------------------&quot;</span> &lt;&lt; endl;<br>\tvector&lt;Test&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;it = &quot;</span> &lt;&lt; &amp;(*it) &lt;&lt; endl;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;iterator&quot;</span> &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; endl;;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>本节分为四个部分：</p>\n<ol>\n<li>理解函数模板</li>\n<li>理解类模板</li>\n<li>实现 C++ STL 向量容器 vector</li>\n<li>理解容器控件配置器 allocator</li>\n</ol>\n<h2 id=\"1-理解函数模板\"><a href=\"#1-理解函数模板\" class=\"headerlink\" title=\"1. 理解函数模板\"></a>1. 理解函数模板</h2><h3 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>函数模板不是一个实在的函数，编译器不能为其生成可执行代码。定义函数模板后只是一个对函数功能框架的描述，当它具体执行时，将根据传递的实际参数决定其功能。</p>\n<h3 id=\"2-用法\"><a href=\"#2-用法\" class=\"headerlink\" title=\"2. 用法\"></a>2. 用法</h3><p>面向对象的继承和多态机制有效提高了程序的可重用性和可扩充性。在程序的可重用性方面，程序员还希望得到更多支持。举一个最简单的例子，为了交换两个整型变量的值，需要写下面的 Swap 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; x, <span class=\"hljs-type\">int</span>&amp; y)</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> temp = x;<br>\tx = y;<br>\ty = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>为了交换两个 double 型变量的值，还需要编写下面的 Swap 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> &amp; xr <span class=\"hljs-type\">double</span> &amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果还要交换两个 char 型变量的值，交换两个 CStudent 类对象的值……都需要再编写 Swap 函数。而这些 Swap 函数除了处理的数据类型不同外，形式上都是一样的。</p>\n<p>能否只写一遍 Swap 函数，就能用来交换各种类型的变量的值呢？继承和多态显然无法解决这个问题。因此，“模板”的概念就应运而生了。</p>\n<p>程序设计语言中的模板就是用来批量生成功能和形式都几乎相同的代码的。有了模板，编译器就能在需要的时候，根据模板自动生成程序的代码。从同一个模板自动生成的代码，形式几乎是一样的。</p>\n<p><strong>模板函数、模板的特例化和非模板函数的重载关系</strong>：候选的函数中，优先在精确匹配中选择，优先选择普通函数，特例性更强的模版函数次之，然后是模版函数的特化版本，最后才是泛化版本。</p>\n<p><strong>模板代码是不能声明在.h，实现在.cpp</strong>，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能够正常的实例化，产生能够被编译器编译的代码。模板代码都是放在头文件中，然后在源文件中直接进行 <code>#include</code></p>\n<h3 id=\"3-原理\"><a href=\"#3-原理\" class=\"headerlink\" title=\"3. 原理\"></a>3. 原理</h3><p>C++ 语言支持模板。有了模板，可以只写一个 Swap 模板，编译器会根据 Swap 模板自动生成多个 Sawp 函数，用以交换不同类型变量的值。</p>\n<p>在 C++ 中，模板分为函数模板和类模板两种。</p>\n<ul>\n<li>函数模板是用于生成函数；</li>\n<li>类模板则是用于生成类的。</li>\n</ul>\n<p>函数模板的写法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> 类型参数<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">class</span>类型参数<span class=\"hljs-number\">2</span>, ...&gt;<br>返回值类型  模板名(形参表)<br>&#123;<br>    函数体<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>其中的 class 关键字也可以用 typename 关键字替换</strong>，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> 类型参数<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">typename</span> 类型参数<span class=\"hljs-number\">2</span>, ...&gt;<br></code></pre></td></tr></table></figure>\n\n<p>函数模板看上去就像一个函数。前面提到的 Swap 模板的写法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\">T <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(T&amp; x, T&amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT tmp = x; <br>\tx = y; <br>\ty = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>T 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-function\">T <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(T&amp; x, T&amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tT tmp = x;<br>\tx = y;<br>\ty = tmp;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">1</span>, m = <span class=\"hljs-number\">2</span>;<br>\t<span class=\"hljs-comment\">// 编译器自动生成 void Swap (int &amp;, int &amp;)函数</span><br>\t<span class=\"hljs-built_in\">Swap</span>(n, m);<br><br>\t<span class=\"hljs-type\">double</span> f = <span class=\"hljs-number\">1.2</span>, g = <span class=\"hljs-number\">3.4</span>;<br>\t<span class=\"hljs-comment\">// 编译器自动生成 void Swap (double &amp;, double &amp;)函数</span><br>\t<span class=\"hljs-built_in\">Swap</span>(f, g);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译器在编译到 <code>Swap(n, m);</code> 时找不到函数 Swap 的定义，但是发现实参 n、m 都是 int 类型的，用 int 类型替换 Swap 模板中的 T 能得到下面的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span> <span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> &amp; x, <span class=\"hljs-type\">int</span> &amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该函数可以匹配 <code>Swap(n, m);</code> 这条语句。于是编译器就自动用 int 替换 Swap 模板中的 T，生成上面的 Swap 函数，将该 Swap 函数的源代码加入程序中一起编译，并且将 <code>Swap(n, m);</code> 编译成对自动生成的 Swap 函数的调用。</p>\n<p>同理，编译器在编译到 <code>Swap(f, g);</code> 时会用 double 替换 Swap 模板中的 T，自动生成以下 Swap 函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> &amp; x, <span class=\"hljs-type\">double</span> &amp; y)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">double</span> tmp = x;<br>    x = y;<br>    y = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后再将 <code>Swap(f, g);</code> 编译成对该 Swap 函数的调用。</p>\n<p>编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。在某些编译器中，模板只有在被实例化时，编译器才会检查其语法正确性。如果程序中写了一个模板却没有用到，那么编译器不会报告这个模板中的语法错误。</p>\n<p>编译器对模板进行实例化时，并非只能通过模板调用语句的实参来实例化模板中的类型参数，模板调用语句可以明确指明要把类型参数实例化为哪种类型。可以用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">模板名&lt;实际类型参数<span class=\"hljs-number\">1</span>, 实际类型参数<span class=\"hljs-number\">2</span>, ...&gt;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-理解类模板\"><a href=\"#2-理解类模板\" class=\"headerlink\" title=\"2. 理解类模板\"></a>2. 理解类模板</h2><h3 id=\"1-定义-1\"><a href=\"#1-定义-1\" class=\"headerlink\" title=\"1. 定义\"></a>1. 定义</h3><p>为了多快好省地定义出一批<strong>相似的类</strong>,可以定义「类模板」，然后<strong>由类模板生成不同的类</strong>。</p>\n<p>类模板的定义形式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> 类型参数<span class=\"hljs-number\">1</span>，<span class=\"hljs-keyword\">class</span> 类型参数<span class=\"hljs-number\">2</span>，...&gt; <span class=\"hljs-comment\">//类型参数表</span><br><span class=\"hljs-keyword\">class</span> 类模板名<br>&#123;<br>   成员函数和成员变量<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>用类模板定义对象的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">类模板名&lt;真实类型参数表&gt; 对象名(构造函数实参表);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>类模板用于实现类所需数据的类型参数化</li>\n<li>类模板在表示如数组、表、图等数据结构显得特别重要</li>\n<li>这些数据结构的表示和算法不受所包含的元素类型的影响</li>\n</ul>\n<h3 id=\"2-类模板实现顺序栈\"><a href=\"#2-类模板实现顺序栈\" class=\"headerlink\" title=\"2. 类模板实现顺序栈\"></a>2. 类模板实现顺序栈</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  _CRT_SECURE_NO_WARNINGS</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SeqStack</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 公共方法</span><br>\t\t<span class=\"hljs-comment\">// 构造函数初始化</span><br>\t\t<span class=\"hljs-comment\">// 构造和析构函数名不加&lt;T&gt; 其他出现模板的地方都加上类型参数列表</span><br>\t<span class=\"hljs-built_in\">SeqStack</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">PStack</span>(<span class=\"hljs-keyword\">new</span> T[size])<br>\t\t, <span class=\"hljs-built_in\">Top</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">Size</span>(size) &#123;<br>\t\t<span class=\"hljs-comment\">// 初始化生成的指令更少，效率更高。</span><br>\t\t<span class=\"hljs-comment\">// 仅调用默认构造函数（如果存在类成员）。赋值需要调用默认构造函数和赋值运算符</span><br>\t&#125;;<br><br>\t<span class=\"hljs-comment\">// 拷贝构造</span><br>\t<span class=\"hljs-comment\">// 初始化列表的方式初始化 size 和 top</span><br>\t<span class=\"hljs-built_in\">SeqStack</span>(<span class=\"hljs-type\">const</span> SeqStack&lt;T&gt;&amp; stack)<br>\t\t: <span class=\"hljs-built_in\">Top</span>(stack.Top)<br>\t\t, <span class=\"hljs-built_in\">Size</span>(stack.Size) &#123;<br>\t\t<span class=\"hljs-comment\">// 重新设置栈</span><br>\t\tPStack = <span class=\"hljs-keyword\">new</span> T[stack.Size];<br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Top; i++)<br>\t\t&#123;<br>\t\t\tPStack[i] = stack.PStack[i];<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 析构函数 释放内存</span><br>\t~<span class=\"hljs-built_in\">SeqStack</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (PStack)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">delete</span>[] PStack;<br>\t\t\tPStack = <span class=\"hljs-literal\">nullptr</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 复制重载</span><br>\tSeqStack&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> SeqStack&lt;T&gt;&amp; stack)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 判断是否相等</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;stack)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-keyword\">delete</span>[] PStack;<br><br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tTop = stack.Top;<br>\t\tSize = stack.Size;<br>\t\tPStack = <span class=\"hljs-keyword\">new</span> T[stack.Size];<br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Top; i++)<br>\t\t&#123;<br>\t\t\tPStack[i] = stack.PStack[i];<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 共有方法</span><br>\t<span class=\"hljs-comment\">// 1. push 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">resize</span>();<br>\t\t&#125;<br>\t\tPStack[Top] = val;<br>\t\tTop++;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. pop 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\tTop--;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 3. top 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;Stack is empty!&quot;</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> PStack[Top - <span class=\"hljs-number\">1</span>];<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 4. full 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Top == Size;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 5. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Top == <span class=\"hljs-number\">0</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 私有方法和数据</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 扩容方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">resize</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tT* p = <span class=\"hljs-keyword\">new</span> T[Size * <span class=\"hljs-number\">2</span>];<br>\t\t<span class=\"hljs-comment\">// 将值赋值过去</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; Top; i++)<br>\t\t&#123;<br>\t\t\tp[i] = PStack[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 扩大</span><br>\t\tSize *= <span class=\"hljs-number\">2</span>;<br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-keyword\">delete</span> PStack;<br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tPStack = p;<br>\t&#125;<br><br>\tT* PStack;<br>\t<span class=\"hljs-type\">int</span> Top;<br>\t<span class=\"hljs-type\">int</span> Size;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSeqStack&lt;<span class=\"hljs-type\">int</span>&gt; stack;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; ++i) &#123;<br>\t\tstack.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; stack.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tstack.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3-实现-C-STL-向量容器-vector\"><a href=\"#3-实现-C-STL-向量容器-vector\" class=\"headerlink\" title=\"3. 实现 C++ STL 向量容器 vector\"></a>3. 实现 C++ STL 向量容器 vector</h2><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308081541125.png\" alt=\"image.png\"></p>\n<p>vector 的本质是一个数组，在vector 中需要有三个指针：</p>\n<ul>\n<li><code>First</code>：指向数组的起始位置</li>\n<li><code>Last</code>：指向已经存放的最后一个元素的下一个位置</li>\n<li><code>End</code>：指向数组长度的末尾元素的下一个位置。</li>\n</ul>\n<p>vector 方法：</p>\n<ul>\n<li>数组的容量：<code>End-First</code></li>\n<li>数组中存放的元素个数：<code>Last-First</code></li>\n<li>数组是否为空：<code>First == Last</code></li>\n<li>数组是否已满：<code>Last == End</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">vector</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">First</span>(<span class=\"hljs-keyword\">new</span> T[size])<br>\t\t, <span class=\"hljs-built_in\">Last</span>(First)<br>\t\t, <span class=\"hljs-built_in\">End</span>(First + size)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 使用初始化列表方式</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 获取容器长度</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 创建新容器</span><br>\t\tFirst = <span class=\"hljs-keyword\">new</span> T[size];<br>\t\t<span class=\"hljs-comment\">// 获取数据长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 遍历赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\tFirst[i] = rhs.First[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">vector</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span>[] First;<br>\t\tFirst = End = Last = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\tvector&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;rhs)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清除</span><br>\t\t<span class=\"hljs-keyword\">delete</span>[] First;<br><br>\t\t<span class=\"hljs-comment\">// 重新计算并赋值</span><br>\t\t<span class=\"hljs-comment\">// 获取容器长度</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 创建新容器</span><br>\t\tFirst = <span class=\"hljs-keyword\">new</span> T[size];<br>\t\t<span class=\"hljs-comment\">// 获取数据长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 遍历赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\tFirst[i] = rhs.First[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 共有方法</span><br>\t<span class=\"hljs-comment\">// push_back 方法：容器添加内容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">extend</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 先给之以后，下次 push 则会递增内存</span><br>\t\t*Last++ = val;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// pop_back 方法：容器删除内容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t--Last;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// back 方法：输出删除内容</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *(Last - <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// full 方法：容器是否已满</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Last == End;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// empty 方法：容器是否为空</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Last == First;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// size 方法：获取内容厂区</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> Last - First;<br>\t&#125;<br><br><span class=\"hljs-comment\">// 私有方法</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// vector 容器扩容</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extend</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> size = End - First;<br>\t\tT* ptmp = <span class=\"hljs-keyword\">new</span> T[size * <span class=\"hljs-number\">2</span>];<br><br>\t\t<span class=\"hljs-comment\">// 遍历并转移</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t\t&#123;<br>\t\t\tptmp[i] = First[i];<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 删除原先的</span><br>\t\t<span class=\"hljs-keyword\">delete</span>[] First;<br><br>\t\t<span class=\"hljs-comment\">// 重新覆盖</span><br>\t\tFirst = ptmp;<br>\t\tLast = First + size;<br>\t\tEnd = First + <span class=\"hljs-number\">2</span> * size;<br>\t&#125;<br><br><span class=\"hljs-comment\">// 私有数据</span><br><span class=\"hljs-keyword\">private</span>:<br>\tT* First;<br>\tT* Last;<br>\tT* End;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\tTest&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Test&amp; t) <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl; <br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>; <br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp;) <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest t1;<br>\tTest t2;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>\tvector&lt;Test&gt; vec;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t1);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t2);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; std::endl;<br>\tvec.<span class=\"hljs-built_in\">pop_back</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082143193.png\" alt=\"image.png\"></p>\n<p>问题：在我们实现的 <code>vector</code> 构造函数中，使用 <code>new T[size]</code>  ：它做了两件事情：</p>\n<p>（1）开辟内存空间<br>（2）调用 T 类型的默认构造函数构造对象</p>\n<p>其中第二步是一种浪费，因为我还没在vector 添加元素，提前构造一遍对象 然后在析构时候是否纯属多余。</p>\n<p>同时：在实现 <code>pop_back(）</code> 时，存在内存泄漏</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 从容器末尾删除元素</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>    <span class=\"hljs-keyword\">return</span>;<br>  --Last;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p> 仅仅将 Last 指针 –，并没有释放 Test 申请的资源。<strong>需要调用对象的析构函数</strong></p>\n<h2 id=\"4-理解容器控件配置器-allocator\"><a href=\"#4-理解容器控件配置器-allocator\" class=\"headerlink\" title=\"4. 理解容器控件配置器 allocator\"></a>4. 理解容器控件配置器 allocator</h2><p><strong>通过 Win msvc 编译器的实现：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308082147401.png\" alt=\"image.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// CLASS TEMPLATE vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Ty</span>, <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Alloc</span> = allocator&lt;_Ty&gt;&gt;<br>\t<span class=\"hljs-keyword\">class</span> vector<br>\t\t: <span class=\"hljs-keyword\">public</span> _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;<br>\t&#123;\t<span class=\"hljs-comment\">// varying size array of values</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-keyword\">using</span> _Mybase = _Vector_alloc&lt;_Vec_base_types&lt;_Ty, _Alloc&gt;&gt;;<br>\t<span class=\"hljs-keyword\">using</span> _Alty = <span class=\"hljs-keyword\">typename</span> _Mybase::_Alty;<br>\t<span class=\"hljs-keyword\">using</span> _Alty_traits = <span class=\"hljs-keyword\">typename</span> _Mybase::_Alty_traits;<br>......<br></code></pre></td></tr></table></figure>\n\n<p>系统的实现，除了数据类型外，还有一个<code>allocator</code>,它将开辟空间和构造对象分离开。  </p>\n<p>而这，也就是空间配置器做的工作；</p>\n<h3 id=\"1-容器的空间配置器\"><a href=\"#1-容器的空间配置器\" class=\"headerlink\" title=\"1. 容器的空间配置器\"></a>1. 容器的空间配置器</h3><p>空间配置器主要有四个功能：</p>\n<ol>\n<li>内存开辟 allocate（底层调用<code>malloc</code>）；</li>\n<li>内存释放 deallocate（底层调用<code>free</code>）；</li>\n<li>对象构造 construct（调用<code>构造函数</code>）；</li>\n<li>对象析构 destroy（调用<code>析构函数</code>）；</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 定义容器的空间适配器和 C++ 标准库的 allocator 实现一样</span><br><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Allocator</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 负责内存的开辟</span><br>\t<span class=\"hljs-function\">T* <span class=\"hljs-title\">allocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (T*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(T) * size);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责内存的释放</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象构造</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(T* p, <span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">new</span> (p) <span class=\"hljs-built_in\">T</span>(val);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象析构</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destory</span><span class=\"hljs-params\">(T* p)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// ~T() 代表了 T 类型的析构函数</span><br> \t\tp-&gt;~<span class=\"hljs-built_in\">T</span>();<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>重新实现 vector：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Allocator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 负责内存开辟</span><br>\t<span class=\"hljs-function\">T* <span class=\"hljs-title\">allocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (T*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(T) * size);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责内存释放</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象构造</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(T* p, <span class=\"hljs-type\">const</span> T&amp; val)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">new</span> (p)<span class=\"hljs-built_in\">T</span>(val); <span class=\"hljs-comment\">// 定位new</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象析构</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">(T* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tp-&gt;~<span class=\"hljs-built_in\">T</span>(); <span class=\"hljs-comment\">// ~T()代表了T类型的析构函数</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 通过 allocator 适配器重写 vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">class</span> vector<br>&#123;<br>\t<span class=\"hljs-comment\">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-comment\">// 需要把内存开辟和对象构造分开处理</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">First</span>(_allocator.<span class=\"hljs-built_in\">allocate</span>(size))<br>\t\t, <span class=\"hljs-built_in\">Last</span>(First)<br>\t\t, <span class=\"hljs-built_in\">End</span>(First + size)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 通过初始化列表的方式，初始化数据</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 拷贝函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">vector</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~vector&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != Last; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br>\t\t<span class=\"hljs-comment\">// 重置 指针</span><br>\t\tFirst = Last = End = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br><br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\tvector&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 1. 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;rhs)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 2. 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 3. 重新计算</span><br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 公共方法</span><br>\t<span class=\"hljs-comment\">// 1. push_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">expand</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 通过适配器添加内容</span><br>\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(Last, val);<br>\t\tLast++;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. pop_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>\t\t--Last;<br>\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(Last);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. back 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *(Last - <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. full 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last == End; &#125;<br>\t<span class=\"hljs-comment\">// 5. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> First == Last; &#125;<br>\t<span class=\"hljs-comment\">// 6. size 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last - First; &#125;<br><br><span class=\"hljs-comment\">// 私有属性和方法</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 指向数组起始的位置</span><br>\tT* First;<br>\t<span class=\"hljs-comment\">// 指向数组中有效元素的后继位置</span><br>\tT* Last;<br>\t<span class=\"hljs-comment\">// 指向数组空间的后继位置</span><br>\tT* End;<br>\t<span class=\"hljs-comment\">// 定义容器的空间配置器对象</span><br>\tAlloc _allocator;<br><br>\t<span class=\"hljs-comment\">// 扩容方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">expand</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 获取大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = End - First;<br>\t\t<span class=\"hljs-comment\">// 配置 2 倍适配器空间</span><br>\t\tT* ptmp = _allocator.<span class=\"hljs-built_in\">allocate</span>(size * <span class=\"hljs-number\">2</span>);<br>\t\t<span class=\"hljs-comment\">// 赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t\t&#123;<br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(ptmp + i, First[i]);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tFirst = ptmp;<br>\t\tLast = First + size;<br>\t\tEnd = First + size * <span class=\"hljs-number\">2</span>;<br>\t&#125;<br>&#125;;<br><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\tTest&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Test&amp; t)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp;)<br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest t1, t2;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;1.&quot;</span> &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>\tvector&lt;Test&gt; vec;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t1);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t2);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>\tvec.<span class=\"hljs-built_in\">pop_back</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;end&quot;</span> &lt;&lt; endl;<br><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308091632516.png\" alt=\"image.png\"></p>\n<p>现在的效果就和 msvc 实现的 vector 相同了</p>\n<h3 id=\"2-运算符重载与迭代器实现\"><a href=\"#2-运算符重载与迭代器实现\" class=\"headerlink\" title=\"2. 运算符重载与迭代器实现\"></a>2. 运算符重载与迭代器实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 迭代器一般是现成容器的嵌套类型</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-built_in\">iterator</span>(T* p = <span class=\"hljs-literal\">nullptr</span>)<br>\t\t: _ptr(p)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 初始化列表方式</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t<span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter)<br>\t\t: _ptr(iter._ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// ...</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 重载函数合集</span><br>\t<span class=\"hljs-comment\">// 1. 前置 ++</span><br>\titerator&amp; <span class=\"hljs-keyword\">operator</span>++()<br>\t&#123;<br>\t\t_ptr++;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. 后置 ++</span><br>\titerator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>\t\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>\t\t_ptr++;<br>\t\t<span class=\"hljs-keyword\">return</span> tmp;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. 解引用</span><br>\tT&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. !=</span><br>\t<span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; iter) <span class=\"hljs-type\">const</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> _ptr != iter._ptr;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tT* _ptr;<br>&#125;;<br><br><br><span class=\"hljs-comment\">//迭代器方法</span><br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(First); &#125;<br><span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(Last); &#125;<br><br><span class=\"hljs-comment\">//运算符重载[]</span><br>T&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) &#123;<br>\t<span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-number\">0</span> || index &gt;= <span class=\"hljs-built_in\">size</span>()) &#123;<br>\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;OutofRangeException&quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> First[index];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-最终-vector-实现\"><a href=\"#3-最终-vector-实现\" class=\"headerlink\" title=\"3. 最终 vector 实现\"></a>3. 最终 vector 实现</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><br><span class=\"hljs-comment\">// 定义容器的空间配置器，和C++标准库的allocator实现一样</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Allocator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 负责内存开辟</span><br>\t<span class=\"hljs-function\">T* <span class=\"hljs-title\">allocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (T*)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(T) * size);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责内存释放</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deallocate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(p);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象构造</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">construct</span><span class=\"hljs-params\">(T* p, <span class=\"hljs-type\">const</span> T&amp; val)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">new</span> (p)<span class=\"hljs-built_in\">T</span>(val); <span class=\"hljs-comment\">// 定位new</span><br>\t&#125;<br>\t<span class=\"hljs-comment\">// 负责对象析构</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">(T* p)</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tp-&gt;~<span class=\"hljs-built_in\">T</span>(); <span class=\"hljs-comment\">// ~T()代表了T类型的析构函数</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 通过 allocator 适配器重写 vector</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">typename</span> Alloc = Allocator&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">class</span> vector<br>&#123;<br>\t<span class=\"hljs-comment\">// 公共构造、拷贝、重载、析构、方法函数</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 构造函数</span><br>\t<span class=\"hljs-comment\">// 需要把内存开辟和对象构造分开处理</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">int</span> size = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">First</span>(_allocator.<span class=\"hljs-built_in\">allocate</span>(size))<br>\t\t, <span class=\"hljs-built_in\">Last</span>(First)<br>\t\t, <span class=\"hljs-built_in\">End</span>(First + size)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 通过初始化列表的方式，初始化数据</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 拷贝函数</span><br>\t<span class=\"hljs-built_in\">vector</span>(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 析构函数</span><br>\t~<span class=\"hljs-built_in\">vector</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~vector&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != Last; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// cout &lt;&lt; &quot;p =&quot; &lt;&lt; p &lt;&lt; endl;</span><br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br>\t\t<span class=\"hljs-comment\">// 重置 指针</span><br>\t\tFirst = Last = End = <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br><br><br>\t<span class=\"hljs-comment\">// 赋值重载</span><br>\tvector&lt;T&gt;&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> vector&lt;T&gt;&amp; rhs)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 1. 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span> == &amp;rhs)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 2. 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 3. 重新计算</span><br>\t\t<span class=\"hljs-comment\">// 定义 大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = rhs.End - rhs.First;<br>\t\t<span class=\"hljs-comment\">// 空间适配器开辟空间</span><br>\t\tFirst = _allocator.<span class=\"hljs-built_in\">allocate</span>(size);<br>\t\t<span class=\"hljs-comment\">// 获取长度</span><br>\t\t<span class=\"hljs-type\">int</span> len = rhs.Last - rhs.First;<br><br>\t\t<span class=\"hljs-comment\">// 拷贝数据</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; len; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 空间适配器的构造方法赋值</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(First + i, rhs.First[i]);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 重新配置 Last 和 End</span><br>\t\tLast = First + len;<br>\t\tEnd = First + size;<br><br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//运算符重载[]</span><br>\tT&amp; <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">int</span> index) <br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 判断索引位置</span><br>\t\t<span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-number\">0</span> || index &gt;= <span class=\"hljs-built_in\">size</span>()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">&quot;OutofRangeException&quot;</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 返回索引值</span><br>\t\t<span class=\"hljs-keyword\">return</span> First[index];<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 公共方法</span><br>\t<span class=\"hljs-comment\">// 1. push_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> T&amp; val)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 判断</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">full</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">expand</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 通过适配器添加内容</span><br>\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(Last, val);<br>\t\tLast++;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 2. pop_back 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop_back</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 不仅要把 Last 指针--，还需要析构删除的元素</span><br>\t\t--Last;<br>\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(Last);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 3. back 方法</span><br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">back</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *(Last - <span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 4. full 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">full</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last == End; &#125;<br>\t<span class=\"hljs-comment\">// 5. empty 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> First == Last; &#125;<br>\t<span class=\"hljs-comment\">// 6. size 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>&#123; <span class=\"hljs-keyword\">return</span> Last - First; &#125;<br><br>\t<span class=\"hljs-comment\">// 迭代器一般是现成容器的嵌套类型</span><br>\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span><br>\t&#123;<br>\t<span class=\"hljs-keyword\">public</span>:<br>\t\t<span class=\"hljs-comment\">// 构造函数</span><br>\t\t<span class=\"hljs-built_in\">iterator</span>(T* p = <span class=\"hljs-literal\">nullptr</span>)<br>\t\t\t: _ptr(p)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 初始化列表方式</span><br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 拷贝构造函数</span><br>\t\t<span class=\"hljs-built_in\">iterator</span>(<span class=\"hljs-type\">const</span> iterator&amp; iter)<br>\t\t\t: _ptr(iter._ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// ...</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 重载函数合集</span><br>\t\t<span class=\"hljs-comment\">// 1. 前置 ++</span><br>\t\titerator&amp; <span class=\"hljs-keyword\">operator</span>++()<br>\t\t&#123;<br>\t\t\t_ptr++;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 2. 后置 ++</span><br>\t\titerator <span class=\"hljs-keyword\">operator</span>++(<span class=\"hljs-type\">int</span>) &#123;<br>\t\t\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">tmp</span><span class=\"hljs-params\">(*<span class=\"hljs-keyword\">this</span>)</span></span>;<br>\t\t\t_ptr++;<br>\t\t\t<span class=\"hljs-keyword\">return</span> tmp;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 3. 解引用</span><br>\t\tT&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 4. !=</span><br>\t\t<span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> iterator&amp; iter) <span class=\"hljs-type\">const</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span> _ptr != iter._ptr;<br>\t\t&#125;<br><br>\t<span class=\"hljs-keyword\">private</span>:<br>\t\tT* _ptr;<br>\t&#125;;<br>\t<span class=\"hljs-comment\">//迭代器方法</span><br>\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(First); &#125;<br>\t<span class=\"hljs-function\">iterator <span class=\"hljs-title\">end</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iterator</span>(Last); &#125;<br><br><br><span class=\"hljs-comment\">// 私有属性和方法</span><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 指向数组起始的位置</span><br>\tT* First;<br>\t<span class=\"hljs-comment\">// 指向数组中有效元素的后继位置</span><br>\tT* Last;<br>\t<span class=\"hljs-comment\">// 指向数组空间的后继位置</span><br>\tT* End;<br>\t<span class=\"hljs-comment\">// 定义容器的空间配置器对象</span><br>\tAlloc _allocator;<br><br>\t<span class=\"hljs-comment\">// 扩容方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">expand</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 获取大小</span><br>\t\t<span class=\"hljs-type\">int</span> size = End - First;<br>\t\t<span class=\"hljs-comment\">// 配置 2 倍适配器空间</span><br>\t\tT* ptmp = _allocator.<span class=\"hljs-built_in\">allocate</span>(size * <span class=\"hljs-number\">2</span>);<br>\t\t<span class=\"hljs-comment\">// 赋值</span><br>\t\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t\t&#123;<br>\t\t\t_allocator.<span class=\"hljs-built_in\">construct</span>(ptmp + i, First[i]);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 清空</span><br>\t\t<span class=\"hljs-comment\">// 析构容器有效的元素，然后释放 First 指针指向的堆内存</span><br>\t\tT* p = First;<br>\t\t<span class=\"hljs-keyword\">for</span> (p = First; p != End; p++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">//  把 First 指针指向的数组的有效元素进行析构操作</span><br>\t\t\t_allocator.<span class=\"hljs-built_in\">destroy</span>(p);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 释放堆上的数组内存</span><br>\t\t_allocator.<span class=\"hljs-built_in\">deallocate</span>(First);<br><br>\t\t<span class=\"hljs-comment\">// 重新赋值</span><br>\t\tFirst = ptmp;<br>\t\tLast = First + size;<br>\t\tEnd = First + size * <span class=\"hljs-number\">2</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Test</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\tTest&amp; <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-type\">const</span> Test&amp; t)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator=&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">Test</span>() <br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~Test()&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>\t<span class=\"hljs-built_in\">Test</span>(<span class=\"hljs-type\">const</span> Test&amp;)<br>\t&#123; <br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTest t1, t2;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec&quot;</span> &lt;&lt; endl;<br><br>\tvector&lt;Test&gt; vec;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; push_back&quot;</span> &lt;&lt; endl;<br><br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t1);<br>\tvec.<span class=\"hljs-built_in\">push_back</span>(t2);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;vector&lt;Test&gt; vec; pop_back&quot;</span> &lt;&lt; endl;<br>\tvec.<span class=\"hljs-built_in\">pop_back</span>();<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;end&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;-------------------------------&quot;</span> &lt;&lt; endl;<br>\tvector&lt;Test&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;it = &quot;</span> &lt;&lt; &amp;(*it) &lt;&lt; endl;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;iterator&quot;</span> &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; endl;;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"07.C++ STL","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节分为十部分：\n\n1. vector 容器\n2. deque 容器\n3. list 容器\n4. vector、deque、list 对比分析\n5. 详解容器适配器\n6. 无序关联容器\n7. 有序关联容器\n8. 迭代器 iterator\n9. 函数对象\n10. 泛型算法和绑定器\n\n**STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。**\n\n## 1. vector 容器\n\n**vector**：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 \n\n容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。\n\n### 1. 使用方法合集\n\n**语法结构：**\n\n~~~c++\nvector<type> TypeName;\n~~~\n\n**使用方式：** 使用前包含头文件\n\n~~~c++\n#include <vector>\n~~~\n\n1. **增加：**\n\n- **`push_back()`**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。\n- **`insert(迭代器，迭代器位置)`**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。\n\n2. **删除：**\n\n- **`pop_back()`**：在容器末尾删除一个元素，时间复杂度O(1)。\n- **`erase()`**：删除it迭代器指向的元素，时间复杂度O(n)。\n\n3. **查询：**\n\n- **`operator[]`**：数据下标的随机访问`vec[5]`，时间复杂度O(1)。\n- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。\n- **`find()\\for_each`**：泛型算法。\n- **`foreach`**：C++11提供的语法糖，通过迭代器iterator来实现的。\n\n4. **常用方法：**\n\n- **`size()`**：返回容器底层有效元素的个数。\n- **`empty()`**：判断容器是否为空。\n- **`reserve()`**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。\n- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。\n- **`swap()`**：两个容器进行元素交换。\n\n### 2. 容器使用\n\n1. **对 vector 容器中元素遍历。**\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\t// 定义 vector \n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\t// 1. 运算符重载遍历\n\tint size = vec.size();\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << vec[i] << \" \";\n\t}\n\tcout << endl;\n\n\t// 2. 迭代器遍历\n\tauto it = vec.begin();\n\tfor (; it != vec.end(); it++)\n\t{\n\t\tcout << *it << \" \";\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png)\n\n2. **把 vec 容器中所有偶数全部删除**\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\t// 定义 vector \n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tauto it1 = vec.begin();\n\twhile (it1 != vec.end())\n\t{\n\t\tif (*it1 % 2 == 0) \n\t\t{\n\t\t\tit1 = vec.erase(it1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit1++;\n\t\t}\n\t}\n\n\t// 2. 迭代器遍历\n\tauto it2 = vec.begin();\n\tfor (; it2 != vec.end(); it2++)\n\t{\n\t\tcout << *it2 << \" \";\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png)\n\n3. **在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45**\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\t// 定义 vector \n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\t//vec的operator[]运算符重载函数进行vector遍历\n\tint size = vec.size();\n\tfor (int i = 0; i < size; ++i)\n\t{\n\t\tcout << vec[i] << \" \";\n\t}\n\tcout << endl;\n\n\t// 删除\n\tauto it1 = vec.begin();\n\twhile (it1 != vec.end())\n\t{\n\t\tif (*it1 % 2 == 0) \n\t\t{\n\t\t\tit1 = vec.erase(it1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit1++;\n\t\t}\n\t}\n\n\t// 迭代器遍历\n\tauto it2 = vec.begin();\n\tfor (; it2 != vec.end(); it2++)\n\t{\n\t\tcout << *it2 << \" \";\n\t}\n\tcout << endl;\n\n\t// 添加\n\tfor (it2 = vec.begin(); it2 != vec.end(); it2++)\n\t{\n\t\tif (*it2 % 2 != 0)\n\t\t{\n\t\t\tit2 = vec.insert(it2, *it2-1);\n\t\t\t++it2;\n\t\t}\n\t}\n\n\tit2 = vec.begin();\n\tfor (; it2 != vec.end(); it2++)\n\t{\n\t\tcout << *it2 << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png)\n\n4. **reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。**\n\n默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;// 默认定义的 vector 底层为 0\n\tvec.reserve(20);// 给 vector 容器预留空间\n\n\tcout << \"Before，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"Before，vec.size()：\" << vec.size() << endl;\n\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tcout << \"After，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"After，vec.size()：\" << vec.size() << endl;\n\n}\n~~~\n\n输出结果: `empty()` 是 1 为空，0 为非空。刚开始为空，`reserve(20)` 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png)\n\n5. **resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。**\n\n`resize()` 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;//默认定义的vector底层为0\n\tvec.resize(20);\n\n\tcout << \"Before，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"Before，vec.size()：\" << vec.size() << endl;\n\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tcout << \"After，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"After，vec.size()：\" << vec.size() << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png)\n\n## 2. deque 容器\n\n**deque：双端队列容器，底层为动态开辟的二维数组。** **\n\n一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 `oldsize/2` 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。\n\n### 1. 容器结构\n\n其底层为：**动态开辟的二维数组**。\n\n其有两个宏：`MAP_SIZE`，为2；`QUE_SIZE`，为 `4096/sizeof(T)`，T 为实际的类型。底层有 2 个维度，还有一个 mapper 指针，指向第一维的一维数组，默认大小为` MAP_SIZE 2`；第二维为动态开辟的 `QUE_SIZE` 的大小，例如：使用整型时会有1024个元素。\n\n双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；\n\n简易的画了一个方向，first 与 last 处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150854875.png)\n\n### 2. 扩容方式\n\n当我们元素的不断增加，相应的指示位置向后移动。\n\n- 如图 2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150858867.png)\n\n- 如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150902713.png)\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150903312.png)\n\n- 如图5，6；刚才的第二维移动到第一维中间部分(`oldsize/2`)，方便任何一边的元素改动。若需再次扩容，同理。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150906687.png)\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150909908.png)\n\n### 3. 使用方法合集\n\n**使用前提：**\n\n~~~c++\n#include <deque>\n~~~\n\n**语法：**\n\n~~~c++\ndeque<type> TypeName;\n~~~\n\n1. **增加：**\n\n- **`push_back()`**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。\n- **`push_front()`**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 `insert()`，为O(n)。\n- **`insert()`**：迭代器指向的位置添加元素，时间复杂度O(n)。\n\n2. **删除：**\n\n- **`pop_back()`**：从末尾删除元素，时间复杂度O(1)。\n- **`pop_front()`**：从首部删除，时间复杂度O(1)。\n- **`erase()`**：迭代器指向的位置进行元素删除，时间复杂度O(n)。\n\n3. **查询：**\n\n- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。\n\n4. **常用方法：**\n\n- **`size()`**：返回容器底层有效元素的个数。\n- **`empty()`**：判断容器是否为空。\n- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。\n- **`swap()`**：两个容器进行元素交换。\n\n### 4. 使用\n\n和 vector 实例类似，直接参考 vector 容器实例即可。\n\n## 3. list 容器\n\n**list：链表容器，底层数据结构为双向循环链表。**\n\n### 1. 使用方法合集\n\n**使用前提：**\n\n~~~c++\n#include <list>\n~~~\n\n**语法：**\n\n~~~c++\nlist<type> TypeName;\n~~~\n\n1. **增加：**\n\n- **`push_back()`**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。\n- **`push_front()`**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 `insert()`，为O(n)。\n- **`insert()`**：迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行 `insert()` 时，要先进行 `query()` 操作，效率就慢了。\n\n2. **删除：**\n\n- **`pop_back()`**：从末尾删除元素，时间复杂度O(1)。\n- **`pop_front()`**：从首部删除，时间复杂度O(1)。\n- **`erase()`**：迭代器指向的位置进行元素删除，时间复杂度O(n)。\n\n3. **查询：**\n\n- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。\n\n4. **常用方法：**\n\n- **`size()`**：返回容器底层有效元素的个数。\n- **`empty()`**：判断容器是否为空。\n- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。\n- **`swap()`**：两个容器进行元素交换。\n\n### 2. 使用\n\n使用实例与vector类似。\n\n## 4. vector、deque、list 对比分析\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150924833.png)\n\n1. **deque 底层内存是否是连续的？**\n\n不是，deque 底层是动态开辟的二维数组，第二维都是独立开辟的空间，每一个第二维是连续的，但是所有的二维不是连续的。\n\n2. **vector 与 deque 容器之间的区别：**\n\n- **vector 特点：** 底层是一个动态开辟数组，内存是连续的，2 倍的方式进行扩容。当默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。\n- **deque 特点：** 底层为动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容时候(第一维的数组进行 2 倍扩容，原来的第二维的数组放入新扩容的数组中间)，支持前后插入删除为 O(1) 的操作。\n\n**区别：**\n\n- **底层数据结构不同**：vector 底层为动态开辟的数组，内存是连续的；deque 底层是动态开辟的二维数组空间，内存不连续。\n- **前中后删除的时间复杂度不同**：它们中间与末尾插入删除一样为 O(1)，但最前面进行元素添加时候 deque 为 O(1)，vector 为 O(n)。\n- **内存使用效率不同**：vector 低，需要的内存空间必须是连续的；deque 第二维内存空间不一定连续，可以分块进行数据存储，对内存使用效率会更高。\n- **在中间进行 insert 或者 erase，vector 与 deque 的效率不同**：它们时间复杂度都为 O(n)，但 vecto r内存完全连续，其他元素容易移动；但 deque 内存不连续，元素移动更加麻烦一些，效率不如 vector。\n\n3. **vector 与 list 容器之间的区别：**\n\n- **vector 特点**： 底层是一个动态开辟的数组，内存是连续的，2 倍的方式进行扩容。当我们默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。\n- **list 特点**： 底层是一个双向循环链表。\n\n**区别：**\n\n**数组与链表区别**：数组增加删除为 O(n)，查询 O(n)，随机访问为 O(1)；链表增加删除一个结点本身为 O(1)，但搜索的时间为 O(n)。如果增加删除使用多，优先使用 list；随机访问使用多，优先使用 vector。\n\n## 5. 详解容器适配器\n\n容器适配器：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。\n\n**使用容器适配器实现栈**\n\n~~~c++\n#include <iostream>\n#include <deque>\nusing namespace std;\n\ntemplate<class T, typename Container=deque<T>>\nclass Stack\n{\npublic:\n\tvoid push(const T& val)\n\t{\n\t\tcon.push_back(val);\n\t}\n\tvoid pop()\n\t{\n\t\tcon.pop_back();\n\t}\n\tT top()const\n\t{\n\t\treturn con.back();\n\t}\n\nprivate:\n\tContainer con;\n};\n\nint main()\n{\n\tStack<int> s;\n\t\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\ts.push(i);\n\t}\n\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tcout << s.top() << \" \";\n\t\ts.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n实现成功，相当于栈将 deque 代理了一下，也成为代理模式。push 将底层容器的 `push_back` 代理了，pop 将底层 `pop_back` 代理了，栈的 top 将容器底层的 back 代理了。\n\n### 1. Stack 栈容器\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151017597.png)\n\n`stack<T>` 容器适配器中的数据是以 LIFO（Last In First Out） 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。\n\n上图：展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。\n\n**使用前提：**\n\n~~~c++\n#include <stack>\n~~~\n\n**常用方法：**\n\n- **`push()`**：入栈  \n- **`pop()`**：  出栈 \n- **`top()`**：查看栈顶元素  \n- **`empty()`**：判断栈空  \n- **`size()`**：返回元素个数\n\n**使用：**\n\n~~~c++\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n\tstack<int> s;\n\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\ts.push(rand() % 100 + 1);\n\t}\n\n\tcout << \"栈中元素个数:\" << s.size() << endl;\n\n\twhile (!s.empty())\n\t{\n\t\tcout << s.top() << \" \";\n\t\ts.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151023238.png)\n\n### 2. 队列\n\n只能访问 `queue<T>` 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。  \n  \n许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO（First In First Out） 准则处理的序列来说，使用 queue 容器适配器都是好的选择。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151024083.png)\n\n**使用前提：**\n\n~~~c++\n#include <queue>\n~~~\n\n**常用方法：**\n\n- **`push()`**：入栈  \n- **`pop()`**：  出栈 \n- **`front()`**：查看对头元素\n- **`back()`**：查看队尾元素\n- **`empty()`**：判断空  \n- **`size()`**：返回元素个数\n\n**使用：**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tqueue<int> q;\n\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tq.push(rand() % 100 + 1);\n\t}\n\n\tcout << \"队列中元素个数:\" << q.size() << endl;\n\n\twhile (!q.empty())\n\t{\n\t\tcout << q.front() << \" \";\n\t\tq.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151027513.png)\n\n### 3. 优先级队列\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151036304.png)\n\n**优先级队列：底层数据结构为大根堆。** \n\n使用库中的优先级队列，需要加上头文件`<queue>`；**优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。**\n\n**常用方法：**\n\n- **`push()`**：入栈  \n- **`pop()`**：  出栈 \n- **`top()`**：查看栈顶元素  \n- **`empty()`**：判断栈空  \n- **`size()`**：返回元素个数\n\n**使用：**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tpriority_queue<int> q;\n\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tq.push(rand() % 100 + 1);\n\t}\n\n\tcout << \"优先队列中元素个数:\" << q.size() << endl;\n\n\twhile (!q.empty())\n\t{\n\t\tcout << q.top() << \" \";\n\t\tq.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n数据从大到小依次出队，数据越大优先级越高。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151039915.png)\n\n**问题一：stack 与 queue 第二个模板类型参数依赖 deque，为什么不依赖 vector？**\n\n1. vector 的初始化内存使用效率太低了，没有 deque 好。\n2. 对于 queue 来说，需要支持尾部插入，头部删除，时间复杂度需要为 O(1)，deque 恰好符合条件，若用 vector 其底层效率太低。\n3. vector 需要大片的连续内存，而 deque 只需要分段的内存，当存储大量数据时，显然 deuqe 对于内存的利用率更高更好一些。\n\n**问题二：优先级队列为什么底层依赖 vector？**\n\n优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为 i，左孩子为 `2i+1`，右孩子为 `2i+2`；大根堆为堆顶，其元素最大，结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的，因此底层依赖 vector；而 deque 的第二维不是连续的，不能使用。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151042363.png)\n\n## 6. 无序关联容器\n\n**关联容器分为：无序关联容器与有序关联容器，简单对比下：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151043482.png)\n\n**无序关联容器：底层为哈希表，里面元素无顺序，增删查为O(1)。**\n\n### 1. 单重集合与多重集合\n\n- **set 集合**：存储的是关键字。`[key]`\n- **unordered_set**：单重集合；不允许 key 重复。\n- **unordered_multiset**：多重集合；允许 key 重复。\n\n**包含文件：**\n\n~~~c++\n#include <unordered_set>\n~~~\n\n**常用方法：**\n\n增加：`insert(val)`;\n遍历：`iterator` 自己搜索，调用 `find()`；\n删除：`erase(key);` 或 `erase(it);`\n\n**`size()`**：返回容器中元素个数。\n**`count(val)`**：返回元素值为val的个数，val不会重复。\n**`find(val)`**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。\n\n**使用1：**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main()\n{\n\t// 不允许存储key值重复的元素\n\tunordered_set<int> set1;\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\t// 与vector/deque/list插入不同\n\t\tset1.insert(rand() % 20 + 1);\n\t}\n\n\tcout << \"set1.size() = \" << set1.size() << endl;\n\t// 返回key为15的元素的个数\n\tcout << \"set1.count(15) = \" << set1.count(15) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151117267.png)\n\n**使用2：**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main()\n{\n\t// 不允许存储key值重复的元素\n\tunordered_set<int> set1;\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\t// 与vector/deque/list插入不同\n\t\tset1.insert(rand() % 20 + 1);\n\t}\n\n\t// 迭代器遍历容器\n\tauto it1 = set1.begin();\n\tfor (; it1 != set1.end(); ++it1)\n\t{\n\t\tcout << *it1 << \" \";\n\t}\n\tcout << endl;\n\n\t// 按key值删除元素\n\tset1.erase(20);\n\tfor (it1 = set1.begin(); it1 != set1.end();)\n\t{\n\t\tif (*it1 == 30)\n\t\t{\n\t\t\t// 迭代器删除元素\n\t\t\tit1 = set1.erase(it1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++it1;\n\t\t}\n\t}\n\n\tit1 = set1.find(20);\n\tif (it1 != set1.end())\n\t{\n\t\tset1.erase(it1);\n\t}\n\n\tfor (int v : set1)\n\t{\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151119097.png)\n\n**使用3：unordered_multiset**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main()\n{\n\t// 允许存储key值重复的元素\n\tunordered_multiset<int> set1;\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\t// 与vector/deque/list插入不同\t\n\t\tset1.insert(rand() % 20 + 1);\n\t}\n\n\tcout << \"set1.size() = \" << set1.size() << endl;\n\t// 返回key为15的元素的个数\n\tcout << \"set1.count(15) = \" << set1.count(15) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151121798.png)\n\n### 2. 单重映射表与多重映射表\n\n- **map 集合**：存储的是键值对。`[key，value]`\n- **unordered_map**：单重映射表；不可重复。\n- **unordered_multimap**：多重映射表；可重复。\n\n**包含文件：**\n\n~~~c++\n#include <unordered_map>\n~~~\n\n**常用方法：**\n\n增加：`insert(val)`;\n遍历：`iterator` 自己搜索，调用 `find()`；\n删除：`erase(key);` 或 `erase(it);`\n\n**`size()`**：返回容器中元素个数。\n**`count(val)`**：返回元素值为val的个数，val不会重复。\n**`find(val)`**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。\n\n**使用1：unordered_map**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_map<int, string> map1;\n\n\tmap1.insert(make_pair(1000, \"张三\"));\n\tmap1.insert(make_pair(1010, \"李四\"));\n\tmap1.insert(make_pair(1020, \"王五\"));\n\n\tmap1.insert(make_pair(1000, \"王五\"));\n\n\tcout << \"size: \" << map1.size() << endl;//键值对个数\n\n\treturn 0;\n}\n~~~\n\n**使用2：unordered_multimap**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_multimap<int,string> map1;\n\tmap1.insert(make_pair(1000,\"张三\"));//打包成键值对\n\tmap1.insert(make_pair(1010,\"李四\"));\n\tmap1.insert(make_pair(1020,\"王五\"));\n\n\tmap1.insert(make_pair(1000,\"王五\"));\n\n\tcout << \"size: \" << map1.size() << endl;// 键值对个数\n\n\treturn 0;\n}\n~~~\n\n**使用3：查询**\n\n~~~c++\n//map operator[](key) =>value \ncout << map1[1000] << endl;\n~~~\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_map<int, string> map1;\n\n\tmap1.insert(make_pair(1000, \"张三\"));\n\tmap1.insert(make_pair(1010, \"李四\"));\n\tmap1.insert(make_pair(1020, \"王五\"));\n\n\tmap1.insert(make_pair(1000, \"王五\"));\n\n\tmap1.erase(1020);//删除\n\tmap1[2000] = \"刘帅\";//相当于插入\n\tmap1[1000] = \"张三2\";//相当于修改操作\n\n\tcout << map1.size() << endl;//键值对个数\n\t// map operator[](key) =>value 查询\n\tcout << map1[1000] << endl;\n\n\treturn 0;\n}\n~~~\n\n**使用4：iterator 查找**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_map<int, string> map1;\n\n\tmap1.insert(make_pair(1000, \"张三\"));\n\tmap1.insert(make_pair(1010, \"李四\"));\n\tmap1.insert(make_pair(1020, \"王五\"));\n\tmap1.insert(make_pair(1030, \"赵六\"));\n\n\tauto it1 = map1.find(1030);\n\tif (it1 != map1.end())\n\t{\n\t\tcout << \"key:\" << it1->first << \" value:\" << it1->second << endl;\n\t}\n\n\treturn 0;\n}\n~~~\n\n### 3. 海量数据\n\n**案例1：处理海量数据数据查重，经常会使用map。**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nconst int ARR_LEN = 1000;\n\nint main()\n{\n\tint arr[ARR_LEN] = { 0 };\n\n\tint i = 0;\n\tfor (i = 0; i < ARR_LEN; i++)\n\t{\n\t\tarr[i] = rand() % 20 + 1;\n\t}\n\n\t// 上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数\n\n\tunordered_map<int, int> map1;\n\tfor (int k : arr)\n\t{\n\t\tauto it = map1.find(k);\n\t\tif (it == map1.end())//数字没出现过\n\t\t{\n\t\t\tmap1.insert(make_pair(k, 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit->second++;\n\t\t}\n\t}\n\n\tauto it = map1.begin();\n\tfor (; it != map1.end(); ++it)\n\t{\n\t\tif (it->second > 1)\n\t\t{\n\t\t\tcout << \"key:\" << it->first << \" value:\" << it->second << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n~~~\n\n**案例2：海量数据去重。**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nconst int ARR_LEN = 1000;\n\nint main()\n{\n\tint arr[ARR_LEN] = { 0 };\n\tfor (int i = 0; i < ARR_LEN; i++)\n\t{\n\t\tarr[i] = rand() % 20 + 1;\n\t}\n\n\t// 上面的整数中，将数字进行去重打印\n\tunordered_set<int> set;\n\tfor (int v : arr)\n\t{\n\t\tset.insert(v);\n\t}\n\n\tfor (int v : set)\n\t{\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n## 7. 有序关联容器\n\n**有序关联容器：底层为红黑树，里面元素有序，增删查 $O(log^{2n})$。**\n\n**包含文件：**\n\n~~~c++\n#include <map>\n#include <set>\n~~~\n\n- set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。\n- multiset：多重集合，可以存储重复的元素，从小到大元素有序排列。\n- map：单重映射表，重复的只出现一次，从小到大元素有序排列。\n- multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。\n\n**实例1：set 实例**\n\n~~~c++\nset<int> set1;\nfor (int i=0; i<20; i++)\n{\n\tset1.insert(rand()%20 + 1);\n}\n\nfor (int v : set1)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n**实例2：set 存放自定义类型**\n\n~~~c++\n#include <iostream>\n#include <ostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nclass Student\n{\npublic:\n\tStudent(int id, string name)\n\t\t: _id(id)\n\t\t, _name(name)\n\t{\n\t\t// 舒适化列表\n\t}\n\n\tbool operator<(const Student& stu) const\n\t{\n\t\treturn _id < stu._id;\n\t}\n\nprivate:\n\tint _id;\n\tstring _name;\n\t// 友元\n\tfriend ostream& operator<<(ostream& out, const Student& str);\n};\n\nostream& operator<<(ostream& out, const Student& stu)\n{\n\tout << \"id: \" << stu._id << endl;\n\tout << \"name: \" << stu._name;\n\n\treturn out;\n}\n\nint main()\n{\n\tset<Student> set1;\n\tset1.insert(Student(1000, \"张文\"));\n\tset1.insert(Student(1020, \"李广\"));\n\n\tfor (auto it = set1.begin(); it != set1.end(); ++it)\n\t{\n\t\tcout << *it << endl;\n\t\tcout << \"---------------------\" << endl;\n\t}\n\n\treturn 0;\n}\n~~~\n\n**实例3：map 实例**\n\n~~~c++\nclass Student\n{\npublic:\n\tStudent(int id = 0, string name = \"\")\n\t\t:_id(id), _name(name){}\nprivate:\n\tint _id;\n\tstring _name;\n\tfriend ostream& operator<<(ostream &out, const Student &stu);\n};\n\nostream& operator<<(ostream &out, const Student &stu)\n{\n\tout << \"id:\" << stu._id << \" name:\" << stu._name << endl;\n\treturn out;\n}\n\nint main()\n{\n\tmap<int, Student> stuMap;\n\tstuMap.insert(make_pair(1010,Student(1010,\"张文\")));\n\tstuMap.insert(make_pair(1020,Student(1020,\"李广\")));\n\tstuMap.insert(make_pair(1030,Student(1030,\"高阳\")));\n\n\t//stuMap.erase(it) stuMap.erase(1020)\n\t//cout << stuMap[1020] << endl;\n\tauto it = stuMap.begin();\n\tfor (; it!=stuMap.end(); ++it)\n\t{\n\t\tcout << \"key:\" << it->first << \"value:\" << it->second << endl;\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n## 8. 迭代器 iterator\n\n1. 正向迭代器 `iterator`：输出元素时从第一个到对后一个，既可以读也可修改。\n2. 常量的正向迭代器 `const_iterator`：输出元素时从第一个到对后一个，只可以读。\n3. 反向迭代器 `reverse_iterator`：输出元素时从最后一个到第一个，既可以读也可修改。\n4. 常量的反向迭代器 `const_reverse_iterator`：输出元素时从最后一个到第一个，既可以读也可修改。\n\n**顺序容器、关联容器，都支持正向迭代器与反向迭代器。**\n\n### 1. iterator\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tvector<int>::iterator it = vec.begin();\n\tfor (; it != vec.end(); it++)\n\t{\n\t\tcout << *it << \" \";\n\t\tif (*it % 2 == 0)\n\t\t{\n\t\t\t*it = 0;\n\t\t}\n\t}\n\tcout << endl;\n\n\tfor (int v : vec)\n\t{\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161445442.png)\n\n### 2. const_iterator\n\n**底层原理：**\n\n~~~c++\n// const_iterator <= iterator\nclass const_iterator\n{\npublic:\n\tconst T& operator*()\n\t{\n\t\treturn *_ptr;\n\t}\n}\nclass iterator : public const_iterator\n{\n\tT& operator*()\n\t{\n\t\treturn *_ptr;\n\t}\n}\n// class const_iterator{}基类\n// class iterator : public const_iterator派生类\n~~~\n\n**语法：**\n\n~~~c++\n// vector<int>::iterator it1 = vec.begin();//可以接受派生类对象\nvector<int>::const_iterator it1 = vec.begin();\n~~~\n\n将上面普通的正向迭代器换为常量的正向迭代器，编译器报错。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161447974.png)\n\n### 3. reverse_iterator\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tvector<int>::reverse_iterator it = vec.rbegin();\n\tfor (; it != vec.rend(); it++)\n\t{\n\t\tcout << *it << \" \";\n\t\tif (*it % 2 == 0)\n\t\t{\n\t\t\t*it = 0;\n\t\t}\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161450170.png)\n\n### 4. const_reverse_iterator\n\n~~~c++\n//vector<int>::reverse_iterator rit = vec.rbegin();\nvector<int>::const_reverse_iterator rit = vec.rbegin();\n~~~\n\n## 9. 函数对象\n\n**函数对象**：拥有 `()operator` 重载函数的对象即函数对象，函数对象类似 C 语言里面的函数指针，但在 C++ 里为函数对象。\n\n### 1. 函数对象解释\n\n下图为，C 语言进行函数调用与 C++ 中两个函数调用。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161453547.png)\n\n看起来它们好像一模一样，但是 C 语言中的 `sum()`，是函数名为一个地址；但 C++ 中的 `sum()` 为一个对象，sum 调用自己的 `( )` 重载函数将 10 与 20 传给 sum 调用的 `()` 运算符重载函数了，它接受两个实参，再执行 a+b。\n\n**这里就把 `()` 运算符重载函数的对象，称作函数对象，或者称作仿函数。**\n\n**好处：**\n\n~~~c++\ntemplate<typename T>\nbool compare(T a, T b)\n{\n\treturn a > b;\n}\n\nint main()\n{\n\tcout << compare(10, 20) << endl;\n\tcout << compare('b','y') << endl;\n\n\treturn 0;\n}\n~~~\n\n实现了一个比较大于的函数模板，这里编译器会根据实参推导出 T 的类型，再从原模板实例化处理整型与 char 类型的 `compare()` 函数。  \n\n但是它不够灵活，有时想比较小于，每次改动符号有些麻烦，C 语言中的函数指针刚好可以很好解决这个问题。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// 使用C的函数指针解决\ntemplate<typename T>\nbool myGreater(T a, T b)\n{\n\treturn a > b;\n}\n\ntemplate<typename T>\nbool myLess(T a, T b)\n{\n\treturn a < b;\n}\n\n// compare是C++的库函数模板\ntemplate<typename T, class Compare>\nbool compare(T a, T b, Compare comp)\n{\n\treturn comp(a, b);\n}\n\nint main()\n{\n\t\n\tcout << \"大于：\"\n\t\t<< compare(10, 20, myGreater<int>) << endl;\n\tcout << \"小于：\"\n\t\t<< compare(10, 20, myLess<int>) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161516099.png)\n\n此时，就可以很好的解决这个问题了，当传入不同的函数指针来解决，想比较大就传入 myGreater，想比较小就传入 myLess，通过函数指针间接调用函数。\n\n这里，使用函数指针虽然解决了问题，但函数指针无法进行内联，有函数的调用开销，效率很低；即使将其能够写为内联函数，编译的时候还是不知道调用时 myGreater，myLess。这里是通过函数指针间接调用的，编译器在编译过程中看到函数指针时候，不知道其调用的哪个函数，只有运行时候才知道。\n\n因此，C++ 有一个专门的函数对象来解决这个问题。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// C++ 对象实现\ntemplate<class T>\nclass myGreater {\npublic:\n\tbool operator()(T a, T b)\n\t{\n\t\treturn a > b;\n\t}\n};\n\ntemplate<class T>\nclass myLess {\npublic:\n\tbool operator()(T a, T b)\n\t{\n\t\treturn a < b;\n\t}\n};\n\n// compare 是 C++ 的库函数模板\ntemplate<typename T, class Compare>\nbool compare(T a, T b, Compare comp)\n{\n\t// 编译过程知道调用对象的函数 operator()(a, b);\n\treturn comp(a, b);\n}\n\nint main()\n{\n\t\n\tcout << \"大于：\"\n\t\t<< compare(10, 20, myGreater<int>()) << endl;\n\tcout << \"小于：\"\n\t\t<< compare(10, 20, myLess<int>()) << endl;\n\n\treturn 0;\n}\n~~~\n\n1. 通过函数对象调用 `()` 运算符重载，可以省略函数的调用开销，比通过函数指针调用函数(不能内联调用)效率高。  \n2. 因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。\n\n### 2. 使用示例\n\n1. **优先级队列**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\t// 底层vector\n\tpriority_queue<int> que;\n\t// 大根堆\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tque.push(rand() % 100 + 1);\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tcout << que.top() << \" \";\n\t\tque.pop();\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161525837.png)\n\n**如何使用小根堆：**\n\n库中的实现：\n\n~~~c++\ntemplate<class _Ty,\n\tclass _Container = vector<_Ty>,\n\tclass _Pr = less<typename _Container::value_type> >\n~~~\n\n将 less 改为 greater 即可变为小根堆即可。\n\n~~~c++\nusing MinHeap = priority_queue<int, vector<int>, greater<int>>;\n~~~\n\n**完整代码：**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nusing MinHeap = priority_queue<int, vector<int>, greater<int>>;\n\nint main()\n{\n\t// 底层vector\n\tMinHeap que;\n\t// 大根堆\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tque.push(rand() % 100 + 1);\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tcout << que.top() << \" \";\n\t\tque.pop();\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161528812.png)\n\n2. **set 集合**\n\nset 底层为红黑树，默认底层从小到大进行输出。底层为：\n\n~~~c++\ntemplate<class _Kty,\n\tclass _Pr = less<_Kty>,\n\tclass _Alloc = allocator<_Kty> >\n~~~\n\n~~~c++\nset<int, greater<int>> set;\nfor (int i=0; i<10; ++i)\n{\n\tset.insert(rand() % 100);\n}\n\nfor (int v : set)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n## 10. 泛型算法和绑定器\n\n### 1. 泛型算法\n\n使用 STL 库中提供的泛型算法需要引入：\n\n~~~c++\n#include <algorithm>\n~~~\n\n泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果。\n\n**特点：**\n\n1. 泛型算法的参数接受的都是迭代器。\n2. 泛型算法的参数还可以接受函数对象。\n\n~~~c++\nint arr[] = {12, 4, 78, 9, 21, 43, 56, 52, 42, 31};\nvector<int> vec(arr, arr+sizeof(arr)/sizeof(arr[0]));\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n\nsort(vec.begin(), vec.end());//begin——end之间元素默认小到大排序\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161543085.png)\n\n**在上面有序的容器进行二分查找**\n\n~~~c++\nint arr[] = {12, 4, 78, 9, 21, 43, 56, 52, 42, 31};\nvector<int> vec(arr, arr+sizeof(arr)/sizeof(arr[0]));\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n\nsort(vec.begin(), vec.end());//begin——end之间元素默认小到大排序\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n\nif (binary_search(vec.begin(), vec.end(), 21));\n{\n\tcout << \"21存在\" <<endl;\n}\n~~~\n\n**改变 sort 排序方式**\n\n~~~c++\n// 传入函数对象greater，改变容器元素比较方式\nsort(vec.begin(), vec.end(), greater<int>());\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n**for_each 将容器中所有偶数打印出来。**\n\n~~~c++\n// for_each可以遍历容器的所有元素，可以自行添加合适的函数对象\n// 对容器的元素进行过滤。\nfor_each(vec.begin(), vec.end(), \n\t[](int val)->void   // 拉姆达表达式\n{\n\tif (val %2 == 0)\n\t{\n\t\tcout << val << \" \";\n\t}\n});\n~~~\n\n### 2. 绑定器\n\n**包含头文件：**\n\n~~~c++\n#include <functional>\n~~~\n\n绑定器：绑定器 + 二元函数对象 = 一元函数对象。\n\n- **bind1st**：把二元函数对象 `operator()(a,b)` 第一个形参绑定起来，绑定为固定的值，只需要传入一个实参。\n- **bind2nd**：把二元函数对象 `operator()(a,b)` 第二个形参绑定起来，绑定为固定的值，只需要传入一个实参。\n\n~~~c++\n//78 56 52 43 42 31 21 12 9 4\n//find_if\n//将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象\n//因此我们需要绑定器\n//greater a > b   less a < b\nauto it2 = find_if(vec.begin(), vec.end(), \n\tbind1st(greater<int>(), 48));\n//bind2nd(less<int>(),48);\n//[](int val)->bool{return val < 48;}); 拉姆达表达式\nvec.insert(it2, 48);\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n","source":"_posts/02.C++ 基础部分/07.C++ STL.md","raw":"---\ntitle: 07.C++ STL\ntags: ['C++']\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节分为十部分：\n\n1. vector 容器\n2. deque 容器\n3. list 容器\n4. vector、deque、list 对比分析\n5. 详解容器适配器\n6. 无序关联容器\n7. 有序关联容器\n8. 迭代器 iterator\n9. 函数对象\n10. 泛型算法和绑定器\n\n**STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。**\n\n## 1. vector 容器\n\n**vector**：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 \n\n容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。\n\n### 1. 使用方法合集\n\n**语法结构：**\n\n~~~c++\nvector<type> TypeName;\n~~~\n\n**使用方式：** 使用前包含头文件\n\n~~~c++\n#include <vector>\n~~~\n\n1. **增加：**\n\n- **`push_back()`**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。\n- **`insert(迭代器，迭代器位置)`**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。\n\n2. **删除：**\n\n- **`pop_back()`**：在容器末尾删除一个元素，时间复杂度O(1)。\n- **`erase()`**：删除it迭代器指向的元素，时间复杂度O(n)。\n\n3. **查询：**\n\n- **`operator[]`**：数据下标的随机访问`vec[5]`，时间复杂度O(1)。\n- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。\n- **`find()\\for_each`**：泛型算法。\n- **`foreach`**：C++11提供的语法糖，通过迭代器iterator来实现的。\n\n4. **常用方法：**\n\n- **`size()`**：返回容器底层有效元素的个数。\n- **`empty()`**：判断容器是否为空。\n- **`reserve()`**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。\n- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。\n- **`swap()`**：两个容器进行元素交换。\n\n### 2. 容器使用\n\n1. **对 vector 容器中元素遍历。**\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\t// 定义 vector \n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\t// 1. 运算符重载遍历\n\tint size = vec.size();\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << vec[i] << \" \";\n\t}\n\tcout << endl;\n\n\t// 2. 迭代器遍历\n\tauto it = vec.begin();\n\tfor (; it != vec.end(); it++)\n\t{\n\t\tcout << *it << \" \";\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png)\n\n2. **把 vec 容器中所有偶数全部删除**\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\t// 定义 vector \n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tauto it1 = vec.begin();\n\twhile (it1 != vec.end())\n\t{\n\t\tif (*it1 % 2 == 0) \n\t\t{\n\t\t\tit1 = vec.erase(it1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit1++;\n\t\t}\n\t}\n\n\t// 2. 迭代器遍历\n\tauto it2 = vec.begin();\n\tfor (; it2 != vec.end(); it2++)\n\t{\n\t\tcout << *it2 << \" \";\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png)\n\n3. **在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45**\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\t// 定义 vector \n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\t//vec的operator[]运算符重载函数进行vector遍历\n\tint size = vec.size();\n\tfor (int i = 0; i < size; ++i)\n\t{\n\t\tcout << vec[i] << \" \";\n\t}\n\tcout << endl;\n\n\t// 删除\n\tauto it1 = vec.begin();\n\twhile (it1 != vec.end())\n\t{\n\t\tif (*it1 % 2 == 0) \n\t\t{\n\t\t\tit1 = vec.erase(it1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit1++;\n\t\t}\n\t}\n\n\t// 迭代器遍历\n\tauto it2 = vec.begin();\n\tfor (; it2 != vec.end(); it2++)\n\t{\n\t\tcout << *it2 << \" \";\n\t}\n\tcout << endl;\n\n\t// 添加\n\tfor (it2 = vec.begin(); it2 != vec.end(); it2++)\n\t{\n\t\tif (*it2 % 2 != 0)\n\t\t{\n\t\t\tit2 = vec.insert(it2, *it2-1);\n\t\t\t++it2;\n\t\t}\n\t}\n\n\tit2 = vec.begin();\n\tfor (; it2 != vec.end(); it2++)\n\t{\n\t\tcout << *it2 << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png)\n\n4. **reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。**\n\n默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;// 默认定义的 vector 底层为 0\n\tvec.reserve(20);// 给 vector 容器预留空间\n\n\tcout << \"Before，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"Before，vec.size()：\" << vec.size() << endl;\n\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tcout << \"After，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"After，vec.size()：\" << vec.size() << endl;\n\n}\n~~~\n\n输出结果: `empty()` 是 1 为空，0 为非空。刚开始为空，`reserve(20)` 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png)\n\n5. **resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。**\n\n`resize()` 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。\n\n~~~c++\n#include <iostream>\n// 使用 vector 库\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;//默认定义的vector底层为0\n\tvec.resize(20);\n\n\tcout << \"Before，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"Before，vec.size()：\" << vec.size() << endl;\n\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tcout << \"After，vec.empty()：\" << vec.empty() << endl;\n\tcout << \"After，vec.size()：\" << vec.size() << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png)\n\n## 2. deque 容器\n\n**deque：双端队列容器，底层为动态开辟的二维数组。** **\n\n一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 `oldsize/2` 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。\n\n### 1. 容器结构\n\n其底层为：**动态开辟的二维数组**。\n\n其有两个宏：`MAP_SIZE`，为2；`QUE_SIZE`，为 `4096/sizeof(T)`，T 为实际的类型。底层有 2 个维度，还有一个 mapper 指针，指向第一维的一维数组，默认大小为` MAP_SIZE 2`；第二维为动态开辟的 `QUE_SIZE` 的大小，例如：使用整型时会有1024个元素。\n\n双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；\n\n简易的画了一个方向，first 与 last 处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150854875.png)\n\n### 2. 扩容方式\n\n当我们元素的不断增加，相应的指示位置向后移动。\n\n- 如图 2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150858867.png)\n\n- 如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150902713.png)\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150903312.png)\n\n- 如图5，6；刚才的第二维移动到第一维中间部分(`oldsize/2`)，方便任何一边的元素改动。若需再次扩容，同理。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150906687.png)\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150909908.png)\n\n### 3. 使用方法合集\n\n**使用前提：**\n\n~~~c++\n#include <deque>\n~~~\n\n**语法：**\n\n~~~c++\ndeque<type> TypeName;\n~~~\n\n1. **增加：**\n\n- **`push_back()`**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。\n- **`push_front()`**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 `insert()`，为O(n)。\n- **`insert()`**：迭代器指向的位置添加元素，时间复杂度O(n)。\n\n2. **删除：**\n\n- **`pop_back()`**：从末尾删除元素，时间复杂度O(1)。\n- **`pop_front()`**：从首部删除，时间复杂度O(1)。\n- **`erase()`**：迭代器指向的位置进行元素删除，时间复杂度O(n)。\n\n3. **查询：**\n\n- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。\n\n4. **常用方法：**\n\n- **`size()`**：返回容器底层有效元素的个数。\n- **`empty()`**：判断容器是否为空。\n- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。\n- **`swap()`**：两个容器进行元素交换。\n\n### 4. 使用\n\n和 vector 实例类似，直接参考 vector 容器实例即可。\n\n## 3. list 容器\n\n**list：链表容器，底层数据结构为双向循环链表。**\n\n### 1. 使用方法合集\n\n**使用前提：**\n\n~~~c++\n#include <list>\n~~~\n\n**语法：**\n\n~~~c++\nlist<type> TypeName;\n~~~\n\n1. **增加：**\n\n- **`push_back()`**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。\n- **`push_front()`**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 `insert()`，为O(n)。\n- **`insert()`**：迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行 `insert()` 时，要先进行 `query()` 操作，效率就慢了。\n\n2. **删除：**\n\n- **`pop_back()`**：从末尾删除元素，时间复杂度O(1)。\n- **`pop_front()`**：从首部删除，时间复杂度O(1)。\n- **`erase()`**：迭代器指向的位置进行元素删除，时间复杂度O(n)。\n\n3. **查询：**\n\n- **`iterator`**：迭代器进行遍历，一定要考虑迭代器失效问题。\n\n4. **常用方法：**\n\n- **`size()`**：返回容器底层有效元素的个数。\n- **`empty()`**：判断容器是否为空。\n- **`resize()`**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。\n- **`swap()`**：两个容器进行元素交换。\n\n### 2. 使用\n\n使用实例与vector类似。\n\n## 4. vector、deque、list 对比分析\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150924833.png)\n\n1. **deque 底层内存是否是连续的？**\n\n不是，deque 底层是动态开辟的二维数组，第二维都是独立开辟的空间，每一个第二维是连续的，但是所有的二维不是连续的。\n\n2. **vector 与 deque 容器之间的区别：**\n\n- **vector 特点：** 底层是一个动态开辟数组，内存是连续的，2 倍的方式进行扩容。当默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。\n- **deque 特点：** 底层为动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容时候(第一维的数组进行 2 倍扩容，原来的第二维的数组放入新扩容的数组中间)，支持前后插入删除为 O(1) 的操作。\n\n**区别：**\n\n- **底层数据结构不同**：vector 底层为动态开辟的数组，内存是连续的；deque 底层是动态开辟的二维数组空间，内存不连续。\n- **前中后删除的时间复杂度不同**：它们中间与末尾插入删除一样为 O(1)，但最前面进行元素添加时候 deque 为 O(1)，vector 为 O(n)。\n- **内存使用效率不同**：vector 低，需要的内存空间必须是连续的；deque 第二维内存空间不一定连续，可以分块进行数据存储，对内存使用效率会更高。\n- **在中间进行 insert 或者 erase，vector 与 deque 的效率不同**：它们时间复杂度都为 O(n)，但 vecto r内存完全连续，其他元素容易移动；但 deque 内存不连续，元素移动更加麻烦一些，效率不如 vector。\n\n3. **vector 与 list 容器之间的区别：**\n\n- **vector 特点**： 底层是一个动态开辟的数组，内存是连续的，2 倍的方式进行扩容。当我们默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。\n- **list 特点**： 底层是一个双向循环链表。\n\n**区别：**\n\n**数组与链表区别**：数组增加删除为 O(n)，查询 O(n)，随机访问为 O(1)；链表增加删除一个结点本身为 O(1)，但搜索的时间为 O(n)。如果增加删除使用多，优先使用 list；随机访问使用多，优先使用 vector。\n\n## 5. 详解容器适配器\n\n容器适配器：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。\n\n**使用容器适配器实现栈**\n\n~~~c++\n#include <iostream>\n#include <deque>\nusing namespace std;\n\ntemplate<class T, typename Container=deque<T>>\nclass Stack\n{\npublic:\n\tvoid push(const T& val)\n\t{\n\t\tcon.push_back(val);\n\t}\n\tvoid pop()\n\t{\n\t\tcon.pop_back();\n\t}\n\tT top()const\n\t{\n\t\treturn con.back();\n\t}\n\nprivate:\n\tContainer con;\n};\n\nint main()\n{\n\tStack<int> s;\n\t\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\ts.push(i);\n\t}\n\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tcout << s.top() << \" \";\n\t\ts.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n实现成功，相当于栈将 deque 代理了一下，也成为代理模式。push 将底层容器的 `push_back` 代理了，pop 将底层 `pop_back` 代理了，栈的 top 将容器底层的 back 代理了。\n\n### 1. Stack 栈容器\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151017597.png)\n\n`stack<T>` 容器适配器中的数据是以 LIFO（Last In First Out） 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。\n\n上图：展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。\n\n**使用前提：**\n\n~~~c++\n#include <stack>\n~~~\n\n**常用方法：**\n\n- **`push()`**：入栈  \n- **`pop()`**：  出栈 \n- **`top()`**：查看栈顶元素  \n- **`empty()`**：判断栈空  \n- **`size()`**：返回元素个数\n\n**使用：**\n\n~~~c++\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n\tstack<int> s;\n\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\ts.push(rand() % 100 + 1);\n\t}\n\n\tcout << \"栈中元素个数:\" << s.size() << endl;\n\n\twhile (!s.empty())\n\t{\n\t\tcout << s.top() << \" \";\n\t\ts.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151023238.png)\n\n### 2. 队列\n\n只能访问 `queue<T>` 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。  \n  \n许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO（First In First Out） 准则处理的序列来说，使用 queue 容器适配器都是好的选择。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151024083.png)\n\n**使用前提：**\n\n~~~c++\n#include <queue>\n~~~\n\n**常用方法：**\n\n- **`push()`**：入栈  \n- **`pop()`**：  出栈 \n- **`front()`**：查看对头元素\n- **`back()`**：查看队尾元素\n- **`empty()`**：判断空  \n- **`size()`**：返回元素个数\n\n**使用：**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tqueue<int> q;\n\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tq.push(rand() % 100 + 1);\n\t}\n\n\tcout << \"队列中元素个数:\" << q.size() << endl;\n\n\twhile (!q.empty())\n\t{\n\t\tcout << q.front() << \" \";\n\t\tq.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151027513.png)\n\n### 3. 优先级队列\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151036304.png)\n\n**优先级队列：底层数据结构为大根堆。** \n\n使用库中的优先级队列，需要加上头文件`<queue>`；**优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。**\n\n**常用方法：**\n\n- **`push()`**：入栈  \n- **`pop()`**：  出栈 \n- **`top()`**：查看栈顶元素  \n- **`empty()`**：判断栈空  \n- **`size()`**：返回元素个数\n\n**使用：**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\tpriority_queue<int> q;\n\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tq.push(rand() % 100 + 1);\n\t}\n\n\tcout << \"优先队列中元素个数:\" << q.size() << endl;\n\n\twhile (!q.empty())\n\t{\n\t\tcout << q.top() << \" \";\n\t\tq.pop();\n\t}\n\n\treturn 0;\n}\n~~~\n\n数据从大到小依次出队，数据越大优先级越高。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151039915.png)\n\n**问题一：stack 与 queue 第二个模板类型参数依赖 deque，为什么不依赖 vector？**\n\n1. vector 的初始化内存使用效率太低了，没有 deque 好。\n2. 对于 queue 来说，需要支持尾部插入，头部删除，时间复杂度需要为 O(1)，deque 恰好符合条件，若用 vector 其底层效率太低。\n3. vector 需要大片的连续内存，而 deque 只需要分段的内存，当存储大量数据时，显然 deuqe 对于内存的利用率更高更好一些。\n\n**问题二：优先级队列为什么底层依赖 vector？**\n\n优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为 i，左孩子为 `2i+1`，右孩子为 `2i+2`；大根堆为堆顶，其元素最大，结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的，因此底层依赖 vector；而 deque 的第二维不是连续的，不能使用。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151042363.png)\n\n## 6. 无序关联容器\n\n**关联容器分为：无序关联容器与有序关联容器，简单对比下：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151043482.png)\n\n**无序关联容器：底层为哈希表，里面元素无顺序，增删查为O(1)。**\n\n### 1. 单重集合与多重集合\n\n- **set 集合**：存储的是关键字。`[key]`\n- **unordered_set**：单重集合；不允许 key 重复。\n- **unordered_multiset**：多重集合；允许 key 重复。\n\n**包含文件：**\n\n~~~c++\n#include <unordered_set>\n~~~\n\n**常用方法：**\n\n增加：`insert(val)`;\n遍历：`iterator` 自己搜索，调用 `find()`；\n删除：`erase(key);` 或 `erase(it);`\n\n**`size()`**：返回容器中元素个数。\n**`count(val)`**：返回元素值为val的个数，val不会重复。\n**`find(val)`**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。\n\n**使用1：**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main()\n{\n\t// 不允许存储key值重复的元素\n\tunordered_set<int> set1;\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\t// 与vector/deque/list插入不同\n\t\tset1.insert(rand() % 20 + 1);\n\t}\n\n\tcout << \"set1.size() = \" << set1.size() << endl;\n\t// 返回key为15的元素的个数\n\tcout << \"set1.count(15) = \" << set1.count(15) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151117267.png)\n\n**使用2：**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main()\n{\n\t// 不允许存储key值重复的元素\n\tunordered_set<int> set1;\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\t// 与vector/deque/list插入不同\n\t\tset1.insert(rand() % 20 + 1);\n\t}\n\n\t// 迭代器遍历容器\n\tauto it1 = set1.begin();\n\tfor (; it1 != set1.end(); ++it1)\n\t{\n\t\tcout << *it1 << \" \";\n\t}\n\tcout << endl;\n\n\t// 按key值删除元素\n\tset1.erase(20);\n\tfor (it1 = set1.begin(); it1 != set1.end();)\n\t{\n\t\tif (*it1 == 30)\n\t\t{\n\t\t\t// 迭代器删除元素\n\t\t\tit1 = set1.erase(it1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++it1;\n\t\t}\n\t}\n\n\tit1 = set1.find(20);\n\tif (it1 != set1.end())\n\t{\n\t\tset1.erase(it1);\n\t}\n\n\tfor (int v : set1)\n\t{\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151119097.png)\n\n**使用3：unordered_multiset**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nint main()\n{\n\t// 允许存储key值重复的元素\n\tunordered_multiset<int> set1;\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\t// 与vector/deque/list插入不同\t\n\t\tset1.insert(rand() % 20 + 1);\n\t}\n\n\tcout << \"set1.size() = \" << set1.size() << endl;\n\t// 返回key为15的元素的个数\n\tcout << \"set1.count(15) = \" << set1.count(15) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151121798.png)\n\n### 2. 单重映射表与多重映射表\n\n- **map 集合**：存储的是键值对。`[key，value]`\n- **unordered_map**：单重映射表；不可重复。\n- **unordered_multimap**：多重映射表；可重复。\n\n**包含文件：**\n\n~~~c++\n#include <unordered_map>\n~~~\n\n**常用方法：**\n\n增加：`insert(val)`;\n遍历：`iterator` 自己搜索，调用 `find()`；\n删除：`erase(key);` 或 `erase(it);`\n\n**`size()`**：返回容器中元素个数。\n**`count(val)`**：返回元素值为val的个数，val不会重复。\n**`find(val)`**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。\n\n**使用1：unordered_map**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_map<int, string> map1;\n\n\tmap1.insert(make_pair(1000, \"张三\"));\n\tmap1.insert(make_pair(1010, \"李四\"));\n\tmap1.insert(make_pair(1020, \"王五\"));\n\n\tmap1.insert(make_pair(1000, \"王五\"));\n\n\tcout << \"size: \" << map1.size() << endl;//键值对个数\n\n\treturn 0;\n}\n~~~\n\n**使用2：unordered_multimap**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_multimap<int,string> map1;\n\tmap1.insert(make_pair(1000,\"张三\"));//打包成键值对\n\tmap1.insert(make_pair(1010,\"李四\"));\n\tmap1.insert(make_pair(1020,\"王五\"));\n\n\tmap1.insert(make_pair(1000,\"王五\"));\n\n\tcout << \"size: \" << map1.size() << endl;// 键值对个数\n\n\treturn 0;\n}\n~~~\n\n**使用3：查询**\n\n~~~c++\n//map operator[](key) =>value \ncout << map1[1000] << endl;\n~~~\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_map<int, string> map1;\n\n\tmap1.insert(make_pair(1000, \"张三\"));\n\tmap1.insert(make_pair(1010, \"李四\"));\n\tmap1.insert(make_pair(1020, \"王五\"));\n\n\tmap1.insert(make_pair(1000, \"王五\"));\n\n\tmap1.erase(1020);//删除\n\tmap1[2000] = \"刘帅\";//相当于插入\n\tmap1[1000] = \"张三2\";//相当于修改操作\n\n\tcout << map1.size() << endl;//键值对个数\n\t// map operator[](key) =>value 查询\n\tcout << map1[1000] << endl;\n\n\treturn 0;\n}\n~~~\n\n**使用4：iterator 查找**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main()\n{\n\tunordered_map<int, string> map1;\n\n\tmap1.insert(make_pair(1000, \"张三\"));\n\tmap1.insert(make_pair(1010, \"李四\"));\n\tmap1.insert(make_pair(1020, \"王五\"));\n\tmap1.insert(make_pair(1030, \"赵六\"));\n\n\tauto it1 = map1.find(1030);\n\tif (it1 != map1.end())\n\t{\n\t\tcout << \"key:\" << it1->first << \" value:\" << it1->second << endl;\n\t}\n\n\treturn 0;\n}\n~~~\n\n### 3. 海量数据\n\n**案例1：处理海量数据数据查重，经常会使用map。**\n\n~~~c++\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nconst int ARR_LEN = 1000;\n\nint main()\n{\n\tint arr[ARR_LEN] = { 0 };\n\n\tint i = 0;\n\tfor (i = 0; i < ARR_LEN; i++)\n\t{\n\t\tarr[i] = rand() % 20 + 1;\n\t}\n\n\t// 上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数\n\n\tunordered_map<int, int> map1;\n\tfor (int k : arr)\n\t{\n\t\tauto it = map1.find(k);\n\t\tif (it == map1.end())//数字没出现过\n\t\t{\n\t\t\tmap1.insert(make_pair(k, 1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tit->second++;\n\t\t}\n\t}\n\n\tauto it = map1.begin();\n\tfor (; it != map1.end(); ++it)\n\t{\n\t\tif (it->second > 1)\n\t\t{\n\t\t\tcout << \"key:\" << it->first << \" value:\" << it->second << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n~~~\n\n**案例2：海量数据去重。**\n\n~~~c++\n#include <iostream>\n#include <unordered_set>\nusing namespace std;\n\nconst int ARR_LEN = 1000;\n\nint main()\n{\n\tint arr[ARR_LEN] = { 0 };\n\tfor (int i = 0; i < ARR_LEN; i++)\n\t{\n\t\tarr[i] = rand() % 20 + 1;\n\t}\n\n\t// 上面的整数中，将数字进行去重打印\n\tunordered_set<int> set;\n\tfor (int v : arr)\n\t{\n\t\tset.insert(v);\n\t}\n\n\tfor (int v : set)\n\t{\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n## 7. 有序关联容器\n\n**有序关联容器：底层为红黑树，里面元素有序，增删查 $O(log^{2n})$。**\n\n**包含文件：**\n\n~~~c++\n#include <map>\n#include <set>\n~~~\n\n- set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。\n- multiset：多重集合，可以存储重复的元素，从小到大元素有序排列。\n- map：单重映射表，重复的只出现一次，从小到大元素有序排列。\n- multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。\n\n**实例1：set 实例**\n\n~~~c++\nset<int> set1;\nfor (int i=0; i<20; i++)\n{\n\tset1.insert(rand()%20 + 1);\n}\n\nfor (int v : set1)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n**实例2：set 存放自定义类型**\n\n~~~c++\n#include <iostream>\n#include <ostream>\n#include <string>\n#include <set>\nusing namespace std;\n\nclass Student\n{\npublic:\n\tStudent(int id, string name)\n\t\t: _id(id)\n\t\t, _name(name)\n\t{\n\t\t// 舒适化列表\n\t}\n\n\tbool operator<(const Student& stu) const\n\t{\n\t\treturn _id < stu._id;\n\t}\n\nprivate:\n\tint _id;\n\tstring _name;\n\t// 友元\n\tfriend ostream& operator<<(ostream& out, const Student& str);\n};\n\nostream& operator<<(ostream& out, const Student& stu)\n{\n\tout << \"id: \" << stu._id << endl;\n\tout << \"name: \" << stu._name;\n\n\treturn out;\n}\n\nint main()\n{\n\tset<Student> set1;\n\tset1.insert(Student(1000, \"张文\"));\n\tset1.insert(Student(1020, \"李广\"));\n\n\tfor (auto it = set1.begin(); it != set1.end(); ++it)\n\t{\n\t\tcout << *it << endl;\n\t\tcout << \"---------------------\" << endl;\n\t}\n\n\treturn 0;\n}\n~~~\n\n**实例3：map 实例**\n\n~~~c++\nclass Student\n{\npublic:\n\tStudent(int id = 0, string name = \"\")\n\t\t:_id(id), _name(name){}\nprivate:\n\tint _id;\n\tstring _name;\n\tfriend ostream& operator<<(ostream &out, const Student &stu);\n};\n\nostream& operator<<(ostream &out, const Student &stu)\n{\n\tout << \"id:\" << stu._id << \" name:\" << stu._name << endl;\n\treturn out;\n}\n\nint main()\n{\n\tmap<int, Student> stuMap;\n\tstuMap.insert(make_pair(1010,Student(1010,\"张文\")));\n\tstuMap.insert(make_pair(1020,Student(1020,\"李广\")));\n\tstuMap.insert(make_pair(1030,Student(1030,\"高阳\")));\n\n\t//stuMap.erase(it) stuMap.erase(1020)\n\t//cout << stuMap[1020] << endl;\n\tauto it = stuMap.begin();\n\tfor (; it!=stuMap.end(); ++it)\n\t{\n\t\tcout << \"key:\" << it->first << \"value:\" << it->second << endl;\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n## 8. 迭代器 iterator\n\n1. 正向迭代器 `iterator`：输出元素时从第一个到对后一个，既可以读也可修改。\n2. 常量的正向迭代器 `const_iterator`：输出元素时从第一个到对后一个，只可以读。\n3. 反向迭代器 `reverse_iterator`：输出元素时从最后一个到第一个，既可以读也可修改。\n4. 常量的反向迭代器 `const_reverse_iterator`：输出元素时从最后一个到第一个，既可以读也可修改。\n\n**顺序容器、关联容器，都支持正向迭代器与反向迭代器。**\n\n### 1. iterator\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tvector<int>::iterator it = vec.begin();\n\tfor (; it != vec.end(); it++)\n\t{\n\t\tcout << *it << \" \";\n\t\tif (*it % 2 == 0)\n\t\t{\n\t\t\t*it = 0;\n\t\t}\n\t}\n\tcout << endl;\n\n\tfor (int v : vec)\n\t{\n\t\tcout << v << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161445442.png)\n\n### 2. const_iterator\n\n**底层原理：**\n\n~~~c++\n// const_iterator <= iterator\nclass const_iterator\n{\npublic:\n\tconst T& operator*()\n\t{\n\t\treturn *_ptr;\n\t}\n}\nclass iterator : public const_iterator\n{\n\tT& operator*()\n\t{\n\t\treturn *_ptr;\n\t}\n}\n// class const_iterator{}基类\n// class iterator : public const_iterator派生类\n~~~\n\n**语法：**\n\n~~~c++\n// vector<int>::iterator it1 = vec.begin();//可以接受派生类对象\nvector<int>::const_iterator it1 = vec.begin();\n~~~\n\n将上面普通的正向迭代器换为常量的正向迭代器，编译器报错。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161447974.png)\n\n### 3. reverse_iterator\n\n~~~c++\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> vec;\n\tint i = 0;\n\tfor (i = 0; i < 20; i++)\n\t{\n\t\tvec.push_back(rand() % 100 + 1);\n\t}\n\n\tvector<int>::reverse_iterator it = vec.rbegin();\n\tfor (; it != vec.rend(); it++)\n\t{\n\t\tcout << *it << \" \";\n\t\tif (*it % 2 == 0)\n\t\t{\n\t\t\t*it = 0;\n\t\t}\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161450170.png)\n\n### 4. const_reverse_iterator\n\n~~~c++\n//vector<int>::reverse_iterator rit = vec.rbegin();\nvector<int>::const_reverse_iterator rit = vec.rbegin();\n~~~\n\n## 9. 函数对象\n\n**函数对象**：拥有 `()operator` 重载函数的对象即函数对象，函数对象类似 C 语言里面的函数指针，但在 C++ 里为函数对象。\n\n### 1. 函数对象解释\n\n下图为，C 语言进行函数调用与 C++ 中两个函数调用。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161453547.png)\n\n看起来它们好像一模一样，但是 C 语言中的 `sum()`，是函数名为一个地址；但 C++ 中的 `sum()` 为一个对象，sum 调用自己的 `( )` 重载函数将 10 与 20 传给 sum 调用的 `()` 运算符重载函数了，它接受两个实参，再执行 a+b。\n\n**这里就把 `()` 运算符重载函数的对象，称作函数对象，或者称作仿函数。**\n\n**好处：**\n\n~~~c++\ntemplate<typename T>\nbool compare(T a, T b)\n{\n\treturn a > b;\n}\n\nint main()\n{\n\tcout << compare(10, 20) << endl;\n\tcout << compare('b','y') << endl;\n\n\treturn 0;\n}\n~~~\n\n实现了一个比较大于的函数模板，这里编译器会根据实参推导出 T 的类型，再从原模板实例化处理整型与 char 类型的 `compare()` 函数。  \n\n但是它不够灵活，有时想比较小于，每次改动符号有些麻烦，C 语言中的函数指针刚好可以很好解决这个问题。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// 使用C的函数指针解决\ntemplate<typename T>\nbool myGreater(T a, T b)\n{\n\treturn a > b;\n}\n\ntemplate<typename T>\nbool myLess(T a, T b)\n{\n\treturn a < b;\n}\n\n// compare是C++的库函数模板\ntemplate<typename T, class Compare>\nbool compare(T a, T b, Compare comp)\n{\n\treturn comp(a, b);\n}\n\nint main()\n{\n\t\n\tcout << \"大于：\"\n\t\t<< compare(10, 20, myGreater<int>) << endl;\n\tcout << \"小于：\"\n\t\t<< compare(10, 20, myLess<int>) << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161516099.png)\n\n此时，就可以很好的解决这个问题了，当传入不同的函数指针来解决，想比较大就传入 myGreater，想比较小就传入 myLess，通过函数指针间接调用函数。\n\n这里，使用函数指针虽然解决了问题，但函数指针无法进行内联，有函数的调用开销，效率很低；即使将其能够写为内联函数，编译的时候还是不知道调用时 myGreater，myLess。这里是通过函数指针间接调用的，编译器在编译过程中看到函数指针时候，不知道其调用的哪个函数，只有运行时候才知道。\n\n因此，C++ 有一个专门的函数对象来解决这个问题。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// C++ 对象实现\ntemplate<class T>\nclass myGreater {\npublic:\n\tbool operator()(T a, T b)\n\t{\n\t\treturn a > b;\n\t}\n};\n\ntemplate<class T>\nclass myLess {\npublic:\n\tbool operator()(T a, T b)\n\t{\n\t\treturn a < b;\n\t}\n};\n\n// compare 是 C++ 的库函数模板\ntemplate<typename T, class Compare>\nbool compare(T a, T b, Compare comp)\n{\n\t// 编译过程知道调用对象的函数 operator()(a, b);\n\treturn comp(a, b);\n}\n\nint main()\n{\n\t\n\tcout << \"大于：\"\n\t\t<< compare(10, 20, myGreater<int>()) << endl;\n\tcout << \"小于：\"\n\t\t<< compare(10, 20, myLess<int>()) << endl;\n\n\treturn 0;\n}\n~~~\n\n1. 通过函数对象调用 `()` 运算符重载，可以省略函数的调用开销，比通过函数指针调用函数(不能内联调用)效率高。  \n2. 因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。\n\n### 2. 使用示例\n\n1. **优先级队列**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n\t// 底层vector\n\tpriority_queue<int> que;\n\t// 大根堆\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tque.push(rand() % 100 + 1);\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tcout << que.top() << \" \";\n\t\tque.pop();\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161525837.png)\n\n**如何使用小根堆：**\n\n库中的实现：\n\n~~~c++\ntemplate<class _Ty,\n\tclass _Container = vector<_Ty>,\n\tclass _Pr = less<typename _Container::value_type> >\n~~~\n\n将 less 改为 greater 即可变为小根堆即可。\n\n~~~c++\nusing MinHeap = priority_queue<int, vector<int>, greater<int>>;\n~~~\n\n**完整代码：**\n\n~~~c++\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nusing MinHeap = priority_queue<int, vector<int>, greater<int>>;\n\nint main()\n{\n\t// 底层vector\n\tMinHeap que;\n\t// 大根堆\n\tint i = 0;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tque.push(rand() % 100 + 1);\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tcout << que.top() << \" \";\n\t\tque.pop();\n\t}\n\tcout << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161528812.png)\n\n2. **set 集合**\n\nset 底层为红黑树，默认底层从小到大进行输出。底层为：\n\n~~~c++\ntemplate<class _Kty,\n\tclass _Pr = less<_Kty>,\n\tclass _Alloc = allocator<_Kty> >\n~~~\n\n~~~c++\nset<int, greater<int>> set;\nfor (int i=0; i<10; ++i)\n{\n\tset.insert(rand() % 100);\n}\n\nfor (int v : set)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n## 10. 泛型算法和绑定器\n\n### 1. 泛型算法\n\n使用 STL 库中提供的泛型算法需要引入：\n\n~~~c++\n#include <algorithm>\n~~~\n\n泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果。\n\n**特点：**\n\n1. 泛型算法的参数接受的都是迭代器。\n2. 泛型算法的参数还可以接受函数对象。\n\n~~~c++\nint arr[] = {12, 4, 78, 9, 21, 43, 56, 52, 42, 31};\nvector<int> vec(arr, arr+sizeof(arr)/sizeof(arr[0]));\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n\nsort(vec.begin(), vec.end());//begin——end之间元素默认小到大排序\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161543085.png)\n\n**在上面有序的容器进行二分查找**\n\n~~~c++\nint arr[] = {12, 4, 78, 9, 21, 43, 56, 52, 42, 31};\nvector<int> vec(arr, arr+sizeof(arr)/sizeof(arr[0]));\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n\nsort(vec.begin(), vec.end());//begin——end之间元素默认小到大排序\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n\nif (binary_search(vec.begin(), vec.end(), 21));\n{\n\tcout << \"21存在\" <<endl;\n}\n~~~\n\n**改变 sort 排序方式**\n\n~~~c++\n// 传入函数对象greater，改变容器元素比较方式\nsort(vec.begin(), vec.end(), greater<int>());\n\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n\n**for_each 将容器中所有偶数打印出来。**\n\n~~~c++\n// for_each可以遍历容器的所有元素，可以自行添加合适的函数对象\n// 对容器的元素进行过滤。\nfor_each(vec.begin(), vec.end(), \n\t[](int val)->void   // 拉姆达表达式\n{\n\tif (val %2 == 0)\n\t{\n\t\tcout << val << \" \";\n\t}\n});\n~~~\n\n### 2. 绑定器\n\n**包含头文件：**\n\n~~~c++\n#include <functional>\n~~~\n\n绑定器：绑定器 + 二元函数对象 = 一元函数对象。\n\n- **bind1st**：把二元函数对象 `operator()(a,b)` 第一个形参绑定起来，绑定为固定的值，只需要传入一个实参。\n- **bind2nd**：把二元函数对象 `operator()(a,b)` 第二个形参绑定起来，绑定为固定的值，只需要传入一个实参。\n\n~~~c++\n//78 56 52 43 42 31 21 12 9 4\n//find_if\n//将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象\n//因此我们需要绑定器\n//greater a > b   less a < b\nauto it2 = find_if(vec.begin(), vec.end(), \n\tbind1st(greater<int>(), 48));\n//bind2nd(less<int>(),48);\n//[](int val)->bool{return val < 48;}); 拉姆达表达式\nvec.insert(it2, 48);\nfor (int v : vec)\n{\n\tcout << v << \" \";\n}\ncout << endl;\n~~~\n","slug":"02.C++ 基础部分/07.C++ STL","published":1,"date":"2023-08-09T00:39:21.411Z","updated":"2023-08-16T08:01:23.087Z","_id":"cll3spnt9000424pkdh9r0wml","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节分为十部分：</p>\n<ol>\n<li>vector 容器</li>\n<li>deque 容器</li>\n<li>list 容器</li>\n<li>vector、deque、list 对比分析</li>\n<li>详解容器适配器</li>\n<li>无序关联容器</li>\n<li>有序关联容器</li>\n<li>迭代器 iterator</li>\n<li>函数对象</li>\n<li>泛型算法和绑定器</li>\n</ol>\n<p><strong>STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。</strong></p>\n<h2 id=\"1-vector-容器\"><a href=\"#1-vector-容器\" class=\"headerlink\" title=\"1. vector 容器\"></a>1. vector 容器</h2><p><strong>vector</strong>：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 </p>\n<p>容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。</p>\n<h3 id=\"1-使用方法合集\"><a href=\"#1-使用方法合集\" class=\"headerlink\" title=\"1. 使用方法合集\"></a>1. 使用方法合集</h3><p><strong>语法结构：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vector&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用方式：</strong> 使用前包含头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>增加：</strong></li>\n</ol>\n<ul>\n<li>**<code>push_back()</code>**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。</li>\n<li>**<code>insert(迭代器，迭代器位置)</code>**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>删除：</strong></li>\n</ol>\n<ul>\n<li>**<code>pop_back()</code>**：在容器末尾删除一个元素，时间复杂度O(1)。</li>\n<li>**<code>erase()</code>**：删除it迭代器指向的元素，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>查询：</strong></li>\n</ol>\n<ul>\n<li>**<code>operator[]</code>**：数据下标的随机访问<code>vec[5]</code>，时间复杂度O(1)。</li>\n<li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li>\n<li>**<code>find()\\for_each</code>**：泛型算法。</li>\n<li>**<code>foreach</code>**：C++11提供的语法糖，通过迭代器iterator来实现的。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用方法：</strong></li>\n</ol>\n<ul>\n<li>**<code>size()</code>**：返回容器底层有效元素的个数。</li>\n<li>**<code>empty()</code>**：判断容器是否为空。</li>\n<li>**<code>reserve()</code>**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</li>\n<li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li>\n<li>**<code>swap()</code>**：两个容器进行元素交换。</li>\n</ul>\n<h3 id=\"2-容器使用\"><a href=\"#2-容器使用\" class=\"headerlink\" title=\"2. 容器使用\"></a>2. 容器使用</h3><ol>\n<li><strong>对 vector 容器中元素遍历。</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义 vector </span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 1. 运算符重载遍历</span><br>\t<span class=\"hljs-type\">int</span> size = vec.<span class=\"hljs-built_in\">size</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t&#123;<br>\t\tcout &lt;&lt; vec[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 2. 迭代器遍历</span><br>\t<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>把 vec 容器中所有偶数全部删除</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义 vector </span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">auto</span> it1 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">while</span> (it1 != vec.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it1 % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <br>\t\t&#123;<br>\t\t\tit1 = vec.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit1++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. 迭代器遍历</span><br>\t<span class=\"hljs-keyword\">auto</span> it2 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it2 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png\" alt=\"image.png\"></p>\n<ol start=\"3\">\n<li><strong>在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义 vector </span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">//vec的operator[]运算符重载函数进行vector遍历</span><br>\t<span class=\"hljs-type\">int</span> size = vec.<span class=\"hljs-built_in\">size</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i)<br>\t&#123;<br>\t\tcout &lt;&lt; vec[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 删除</span><br>\t<span class=\"hljs-keyword\">auto</span> it1 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">while</span> (it1 != vec.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it1 % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <br>\t\t&#123;<br>\t\t\tit1 = vec.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit1++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 迭代器遍历</span><br>\t<span class=\"hljs-keyword\">auto</span> it2 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it2 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 添加</span><br>\t<span class=\"hljs-keyword\">for</span> (it2 = vec.<span class=\"hljs-built_in\">begin</span>(); it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it2 % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tit2 = vec.<span class=\"hljs-built_in\">insert</span>(it2, *it2<span class=\"hljs-number\">-1</span>);<br>\t\t\t++it2;<br>\t\t&#125;<br>\t&#125;<br><br>\tit2 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it2 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png\" alt=\"image.png\"></p>\n<ol start=\"4\">\n<li><strong>reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</strong></li>\n</ol>\n<p>默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<span class=\"hljs-comment\">// 默认定义的 vector 底层为 0</span><br>\tvec.<span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">20</span>);<span class=\"hljs-comment\">// 给 vector 容器预留空间</span><br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果: <code>empty()</code> 是 1 为空，0 为非空。刚开始为空，<code>reserve(20)</code> 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png\" alt=\"image.png\"></p>\n<ol start=\"5\">\n<li><strong>resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。</strong></li>\n</ol>\n<p><code>resize()</code> 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<span class=\"hljs-comment\">//默认定义的vector底层为0</span><br>\tvec.<span class=\"hljs-built_in\">resize</span>(<span class=\"hljs-number\">20</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png\" alt=\"image.png\"></p>\n<h2 id=\"2-deque-容器\"><a href=\"#2-deque-容器\" class=\"headerlink\" title=\"2. deque 容器\"></a>2. deque 容器</h2><p><strong>deque：双端队列容器，底层为动态开辟的二维数组。</strong> **</p>\n<p>一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 <code>oldsize/2</code> 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。</p>\n<h3 id=\"1-容器结构\"><a href=\"#1-容器结构\" class=\"headerlink\" title=\"1. 容器结构\"></a>1. 容器结构</h3><p>其底层为：<strong>动态开辟的二维数组</strong>。</p>\n<p>其有两个宏：<code>MAP_SIZE</code>，为2；<code>QUE_SIZE</code>，为 <code>4096/sizeof(T)</code>，T 为实际的类型。底层有 2 个维度，还有一个 mapper 指针，指向第一维的一维数组，默认大小为<code> MAP_SIZE 2</code>；第二维为动态开辟的 <code>QUE_SIZE</code> 的大小，例如：使用整型时会有1024个元素。</p>\n<p>双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；</p>\n<p>简易的画了一个方向，first 与 last 处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150854875.png\" alt=\"image.png\"></p>\n<h3 id=\"2-扩容方式\"><a href=\"#2-扩容方式\" class=\"headerlink\" title=\"2. 扩容方式\"></a>2. 扩容方式</h3><p>当我们元素的不断增加，相应的指示位置向后移动。</p>\n<ul>\n<li>如图 2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150858867.png\" alt=\"image.png\"></p>\n<ul>\n<li>如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150902713.png\" alt=\"image.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150903312.png\" alt=\"image.png\"></p>\n<ul>\n<li>如图5，6；刚才的第二维移动到第一维中间部分(<code>oldsize/2</code>)，方便任何一边的元素改动。若需再次扩容，同理。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150906687.png\" alt=\"image.png\"><br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150909908.png\" alt=\"image.png\"></p>\n<h3 id=\"3-使用方法合集\"><a href=\"#3-使用方法合集\" class=\"headerlink\" title=\"3. 使用方法合集\"></a>3. 使用方法合集</h3><p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">deque&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>增加：</strong></li>\n</ol>\n<ul>\n<li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li>\n<li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li>\n<li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>删除：</strong></li>\n</ol>\n<ul>\n<li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li>\n<li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li>\n<li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>查询：</strong></li>\n</ol>\n<ul>\n<li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用方法：</strong></li>\n</ol>\n<ul>\n<li>**<code>size()</code>**：返回容器底层有效元素的个数。</li>\n<li>**<code>empty()</code>**：判断容器是否为空。</li>\n<li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li>\n<li>**<code>swap()</code>**：两个容器进行元素交换。</li>\n</ul>\n<h3 id=\"4-使用\"><a href=\"#4-使用\" class=\"headerlink\" title=\"4. 使用\"></a>4. 使用</h3><p>和 vector 实例类似，直接参考 vector 容器实例即可。</p>\n<h2 id=\"3-list-容器\"><a href=\"#3-list-容器\" class=\"headerlink\" title=\"3. list 容器\"></a>3. list 容器</h2><p><strong>list：链表容器，底层数据结构为双向循环链表。</strong></p>\n<h3 id=\"1-使用方法合集-1\"><a href=\"#1-使用方法合集-1\" class=\"headerlink\" title=\"1. 使用方法合集\"></a>1. 使用方法合集</h3><p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">list&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>增加：</strong></li>\n</ol>\n<ul>\n<li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li>\n<li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li>\n<li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行 <code>insert()</code> 时，要先进行 <code>query()</code> 操作，效率就慢了。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>删除：</strong></li>\n</ol>\n<ul>\n<li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li>\n<li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li>\n<li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>查询：</strong></li>\n</ol>\n<ul>\n<li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用方法：</strong></li>\n</ol>\n<ul>\n<li>**<code>size()</code>**：返回容器底层有效元素的个数。</li>\n<li>**<code>empty()</code>**：判断容器是否为空。</li>\n<li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li>\n<li>**<code>swap()</code>**：两个容器进行元素交换。</li>\n</ul>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h3><p>使用实例与vector类似。</p>\n<h2 id=\"4-vector、deque、list-对比分析\"><a href=\"#4-vector、deque、list-对比分析\" class=\"headerlink\" title=\"4. vector、deque、list 对比分析\"></a>4. vector、deque、list 对比分析</h2><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150924833.png\" alt=\"image.png\"></p>\n<ol>\n<li><strong>deque 底层内存是否是连续的？</strong></li>\n</ol>\n<p>不是，deque 底层是动态开辟的二维数组，第二维都是独立开辟的空间，每一个第二维是连续的，但是所有的二维不是连续的。</p>\n<ol start=\"2\">\n<li><strong>vector 与 deque 容器之间的区别：</strong></li>\n</ol>\n<ul>\n<li><strong>vector 特点：</strong> 底层是一个动态开辟数组，内存是连续的，2 倍的方式进行扩容。当默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li>\n<li><strong>deque 特点：</strong> 底层为动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容时候(第一维的数组进行 2 倍扩容，原来的第二维的数组放入新扩容的数组中间)，支持前后插入删除为 O(1) 的操作。</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li><strong>底层数据结构不同</strong>：vector 底层为动态开辟的数组，内存是连续的；deque 底层是动态开辟的二维数组空间，内存不连续。</li>\n<li><strong>前中后删除的时间复杂度不同</strong>：它们中间与末尾插入删除一样为 O(1)，但最前面进行元素添加时候 deque 为 O(1)，vector 为 O(n)。</li>\n<li><strong>内存使用效率不同</strong>：vector 低，需要的内存空间必须是连续的；deque 第二维内存空间不一定连续，可以分块进行数据存储，对内存使用效率会更高。</li>\n<li><strong>在中间进行 insert 或者 erase，vector 与 deque 的效率不同</strong>：它们时间复杂度都为 O(n)，但 vecto r内存完全连续，其他元素容易移动；但 deque 内存不连续，元素移动更加麻烦一些，效率不如 vector。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>vector 与 list 容器之间的区别：</strong></li>\n</ol>\n<ul>\n<li><strong>vector 特点</strong>： 底层是一个动态开辟的数组，内存是连续的，2 倍的方式进行扩容。当我们默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li>\n<li><strong>list 特点</strong>： 底层是一个双向循环链表。</li>\n</ul>\n<p><strong>区别：</strong></p>\n<p><strong>数组与链表区别</strong>：数组增加删除为 O(n)，查询 O(n)，随机访问为 O(1)；链表增加删除一个结点本身为 O(1)，但搜索的时间为 O(n)。如果增加删除使用多，优先使用 list；随机访问使用多，优先使用 vector。</p>\n<h2 id=\"5-详解容器适配器\"><a href=\"#5-详解容器适配器\" class=\"headerlink\" title=\"5. 详解容器适配器\"></a>5. 详解容器适配器</h2><p>容器适配器：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。</p>\n<p><strong>使用容器适配器实现栈</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>, <span class=\"hljs-keyword\">typename</span> Container=deque&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">class</span> Stack<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">push</span>(<span class=\"hljs-type\">const</span> T&amp; val)<br>\t&#123;<br>\t\tcon.<span class=\"hljs-built_in\">push_back</span>(val);<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcon.<span class=\"hljs-built_in\">pop_back</span>();<br>\t&#125;<br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span><span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> con.<span class=\"hljs-built_in\">back</span>();<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tContainer con;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tStack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br>\t<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\ts.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tcout &lt;&lt; s.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\ts.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实现成功，相当于栈将 deque 代理了一下，也成为代理模式。push 将底层容器的 <code>push_back</code> 代理了，pop 将底层 <code>pop_back</code> 代理了，栈的 top 将容器底层的 back 代理了。</p>\n<h3 id=\"1-Stack-栈容器\"><a href=\"#1-Stack-栈容器\" class=\"headerlink\" title=\"1. Stack 栈容器\"></a>1. Stack 栈容器</h3><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151017597.png\" alt=\"image.png\"></p>\n<p><code>stack&lt;T&gt;</code> 容器适配器中的数据是以 LIFO（Last In First Out） 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。</p>\n<p>上图：展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。</p>\n<p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<ul>\n<li>**<code>push()</code>**：入栈  </li>\n<li>**<code>pop()</code>**：  出栈 </li>\n<li>**<code>top()</code>**：查看栈顶元素  </li>\n<li>**<code>empty()</code>**：判断栈空  </li>\n<li>**<code>size()</code>**：返回元素个数</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tstack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\ts.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;栈中元素个数:&quot;</span> &lt;&lt; s.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; s.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\ts.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151023238.png\" alt=\"image.png\"></p>\n<h3 id=\"2-队列\"><a href=\"#2-队列\" class=\"headerlink\" title=\"2. 队列\"></a>2. 队列</h3><p>只能访问 <code>queue&lt;T&gt;</code> 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。  </p>\n<p>许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO（First In First Out） 准则处理的序列来说，使用 queue 容器适配器都是好的选择。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151024083.png\" alt=\"image.png\"></p>\n<p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<ul>\n<li>**<code>push()</code>**：入栈  </li>\n<li>**<code>pop()</code>**：  出栈 </li>\n<li>**<code>front()</code>**：查看对头元素</li>\n<li>**<code>back()</code>**：查看队尾元素</li>\n<li>**<code>empty()</code>**：判断空  </li>\n<li>**<code>size()</code>**：返回元素个数</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tqueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tq.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;队列中元素个数:&quot;</span> &lt;&lt; q.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; q.<span class=\"hljs-built_in\">front</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tq.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151027513.png\" alt=\"image.png\"></p>\n<h3 id=\"3-优先级队列\"><a href=\"#3-优先级队列\" class=\"headerlink\" title=\"3. 优先级队列\"></a>3. 优先级队列</h3><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151036304.png\" alt=\"image.png\"></p>\n<p><strong>优先级队列：底层数据结构为大根堆。</strong> </p>\n<p>使用库中的优先级队列，需要加上头文件<code>&lt;queue&gt;</code>；<strong>优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。</strong></p>\n<p><strong>常用方法：</strong></p>\n<ul>\n<li>**<code>push()</code>**：入栈  </li>\n<li>**<code>pop()</code>**：  出栈 </li>\n<li>**<code>top()</code>**：查看栈顶元素  </li>\n<li>**<code>empty()</code>**：判断栈空  </li>\n<li>**<code>size()</code>**：返回元素个数</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tpriority_queue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tq.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;优先队列中元素个数:&quot;</span> &lt;&lt; q.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; q.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tq.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>数据从大到小依次出队，数据越大优先级越高。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151039915.png\" alt=\"image.png\"></p>\n<p><strong>问题一：stack 与 queue 第二个模板类型参数依赖 deque，为什么不依赖 vector？</strong></p>\n<ol>\n<li>vector 的初始化内存使用效率太低了，没有 deque 好。</li>\n<li>对于 queue 来说，需要支持尾部插入，头部删除，时间复杂度需要为 O(1)，deque 恰好符合条件，若用 vector 其底层效率太低。</li>\n<li>vector 需要大片的连续内存，而 deque 只需要分段的内存，当存储大量数据时，显然 deuqe 对于内存的利用率更高更好一些。</li>\n</ol>\n<p><strong>问题二：优先级队列为什么底层依赖 vector？</strong></p>\n<p>优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为 i，左孩子为 <code>2i+1</code>，右孩子为 <code>2i+2</code>；大根堆为堆顶，其元素最大，结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的，因此底层依赖 vector；而 deque 的第二维不是连续的，不能使用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151042363.png\" alt=\"image.png\"></p>\n<h2 id=\"6-无序关联容器\"><a href=\"#6-无序关联容器\" class=\"headerlink\" title=\"6. 无序关联容器\"></a>6. 无序关联容器</h2><p><strong>关联容器分为：无序关联容器与有序关联容器，简单对比下：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151043482.png\" alt=\"image.png\"></p>\n<p><strong>无序关联容器：底层为哈希表，里面元素无顺序，增删查为O(1)。</strong></p>\n<h3 id=\"1-单重集合与多重集合\"><a href=\"#1-单重集合与多重集合\" class=\"headerlink\" title=\"1. 单重集合与多重集合\"></a>1. 单重集合与多重集合</h3><ul>\n<li><strong>set 集合</strong>：存储的是关键字。<code>[key]</code></li>\n<li><strong>unordered_set</strong>：单重集合；不允许 key 重复。</li>\n<li><strong>unordered_multiset</strong>：多重集合；允许 key 重复。</li>\n</ul>\n<p><strong>包含文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p>\n<p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p>\n<p><strong>使用1：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 不允许存储key值重复的元素</span><br>\tunordered_set&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; ++i)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 与vector/deque/list插入不同</span><br>\t\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br>\t<span class=\"hljs-comment\">// 返回key为15的元素的个数</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">count</span>(<span class=\"hljs-number\">15</span>) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151117267.png\" alt=\"image.png\"></p>\n<p><strong>使用2：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 不允许存储key值重复的元素</span><br>\tunordered_set&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; ++i)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 与vector/deque/list插入不同</span><br>\t\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 迭代器遍历容器</span><br>\t<span class=\"hljs-keyword\">auto</span> it1 = set1.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it1 != set1.<span class=\"hljs-built_in\">end</span>(); ++it1)<br>\t&#123;<br>\t\tcout &lt;&lt; *it1 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 按key值删除元素</span><br>\tset1.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">20</span>);<br>\t<span class=\"hljs-keyword\">for</span> (it1 = set1.<span class=\"hljs-built_in\">begin</span>(); it1 != set1.<span class=\"hljs-built_in\">end</span>();)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it1 == <span class=\"hljs-number\">30</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 迭代器删除元素</span><br>\t\t\tit1 = set1.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\t++it1;<br>\t\t&#125;<br>\t&#125;<br><br>\tit1 = set1.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-number\">20</span>);<br>\t<span class=\"hljs-keyword\">if</span> (it1 != set1.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\tset1.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set1)<br>\t&#123;<br>\t\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151119097.png\" alt=\"image.png\"></p>\n<p><strong>使用3：unordered_multiset</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 允许存储key值重复的元素</span><br>\tunordered_multiset&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; ++i)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 与vector/deque/list插入不同\t</span><br>\t\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br>\t<span class=\"hljs-comment\">// 返回key为15的元素的个数</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">count</span>(<span class=\"hljs-number\">15</span>) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151121798.png\" alt=\"image.png\"></p>\n<h3 id=\"2-单重映射表与多重映射表\"><a href=\"#2-单重映射表与多重映射表\" class=\"headerlink\" title=\"2. 单重映射表与多重映射表\"></a>2. 单重映射表与多重映射表</h3><ul>\n<li><strong>map 集合</strong>：存储的是键值对。<code>[key，value]</code></li>\n<li><strong>unordered_map</strong>：单重映射表；不可重复。</li>\n<li><strong>unordered_multimap</strong>：多重映射表；可重复。</li>\n</ul>\n<p><strong>包含文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p>\n<p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p>\n<p><strong>使用1：unordered_map</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; map1;<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>, <span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; map1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<span class=\"hljs-comment\">//键值对个数</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用2：unordered_multimap</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_multimap&lt;<span class=\"hljs-type\">int</span>,string&gt; map1;<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>,<span class=\"hljs-string\">&quot;张三&quot;</span>));<span class=\"hljs-comment\">//打包成键值对</span><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>,<span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>,<span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>,<span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; map1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<span class=\"hljs-comment\">// 键值对个数</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用3：查询</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//map operator[](key) =&gt;value </span><br>cout &lt;&lt; map1[<span class=\"hljs-number\">1000</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; map1;<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>, <span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">1020</span>);<span class=\"hljs-comment\">//删除</span><br>\tmap1[<span class=\"hljs-number\">2000</span>] = <span class=\"hljs-string\">&quot;刘帅&quot;</span>;<span class=\"hljs-comment\">//相当于插入</span><br>\tmap1[<span class=\"hljs-number\">1000</span>] = <span class=\"hljs-string\">&quot;张三2&quot;</span>;<span class=\"hljs-comment\">//相当于修改操作</span><br><br>\tcout &lt;&lt; map1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<span class=\"hljs-comment\">//键值对个数</span><br>\t<span class=\"hljs-comment\">// map operator[](key) =&gt;value 查询</span><br>\tcout &lt;&lt; map1[<span class=\"hljs-number\">1000</span>] &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用4：iterator 查找</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; map1;<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>, <span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1030</span>, <span class=\"hljs-string\">&quot;赵六&quot;</span>));<br><br>\t<span class=\"hljs-keyword\">auto</span> it1 = map1.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-number\">1030</span>);<br>\t<span class=\"hljs-keyword\">if</span> (it1 != map1.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;key:&quot;</span> &lt;&lt; it1-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot; value:&quot;</span> &lt;&lt; it1-&gt;second &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-海量数据\"><a href=\"#3-海量数据\" class=\"headerlink\" title=\"3. 海量数据\"></a>3. 海量数据</h3><p><strong>案例1：处理海量数据数据查重，经常会使用map。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> ARR_LEN = <span class=\"hljs-number\">1000</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> arr[ARR_LEN] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ARR_LEN; i++)<br>\t&#123;<br>\t\tarr[i] = <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数</span><br><br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; map1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k : arr)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">auto</span> it = map1.<span class=\"hljs-built_in\">find</span>(k);<br>\t\t<span class=\"hljs-keyword\">if</span> (it == map1.<span class=\"hljs-built_in\">end</span>())<span class=\"hljs-comment\">//数字没出现过</span><br>\t\t&#123;<br>\t\t\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(k, <span class=\"hljs-number\">1</span>));<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit-&gt;second++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">auto</span> it = map1.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != map1.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (it-&gt;second &gt; <span class=\"hljs-number\">1</span>)<br>\t\t&#123;<br>\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>案例2：海量数据去重。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> ARR_LEN = <span class=\"hljs-number\">1000</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> arr[ARR_LEN] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ARR_LEN; i++)<br>\t&#123;<br>\t\tarr[i] = <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 上面的整数中，将数字进行去重打印</span><br>\tunordered_set&lt;<span class=\"hljs-type\">int</span>&gt; set;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : arr)<br>\t&#123;<br>\t\tset.<span class=\"hljs-built_in\">insert</span>(v);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set)<br>\t&#123;<br>\t\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-有序关联容器\"><a href=\"#7-有序关联容器\" class=\"headerlink\" title=\"7. 有序关联容器\"></a>7. 有序关联容器</h2><p><strong>有序关联容器：底层为红黑树，里面元素有序，增删查 $O(log^{2n})$。</strong></p>\n<p><strong>包含文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;set&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。</li>\n<li>multiset：多重集合，可以存储重复的元素，从小到大元素有序排列。</li>\n<li>map：单重映射表，重复的只出现一次，从小到大元素有序排列。</li>\n<li>multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。</li>\n</ul>\n<p><strong>实例1：set 实例</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">set&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">20</span>; i++)<br>&#123;<br>\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>()%<span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set1)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<p><strong>实例2：set 存放自定义类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">int</span> id, string name)<br>\t\t: _id(id)<br>\t\t, _name(name)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 舒适化列表</span><br>\t&#125;<br><br>\t<span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> Student&amp; stu) <span class=\"hljs-type\">const</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> _id &lt; stu._id;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _id;<br>\tstring _name;<br>\t<span class=\"hljs-comment\">// 友元</span><br>\t<span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> Student&amp; str);<br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> Student&amp; stu)<br>&#123;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;id: &quot;</span> &lt;&lt; stu._id &lt;&lt; endl;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;name: &quot;</span> &lt;&lt; stu._name;<br><br>\t<span class=\"hljs-keyword\">return</span> out;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tset&lt;Student&gt; set1;<br>\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张文&quot;</span>));<br>\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;李广&quot;</span>));<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = set1.<span class=\"hljs-built_in\">begin</span>(); it != set1.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>实例3：map 实例</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">int</span> id = <span class=\"hljs-number\">0</span>, string name = <span class=\"hljs-string\">&quot;&quot;</span>)<br>\t\t:_id(id), _name(name)&#123;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _id;<br>\tstring _name;<br>\t<span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;out, <span class=\"hljs-type\">const</span> Student &amp;stu);<br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;out, <span class=\"hljs-type\">const</span> Student &amp;stu)<br>&#123;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class=\"hljs-string\">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> out;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmap&lt;<span class=\"hljs-type\">int</span>, Student&gt; stuMap;<br>\tstuMap.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>,<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1010</span>,<span class=\"hljs-string\">&quot;张文&quot;</span>)));<br>\tstuMap.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>,<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1020</span>,<span class=\"hljs-string\">&quot;李广&quot;</span>)));<br>\tstuMap.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1030</span>,<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1030</span>,<span class=\"hljs-string\">&quot;高阳&quot;</span>)));<br><br>\t<span class=\"hljs-comment\">//stuMap.erase(it) stuMap.erase(1020)</span><br>\t<span class=\"hljs-comment\">//cout &lt;&lt; stuMap[1020] &lt;&lt; endl;</span><br>\t<span class=\"hljs-keyword\">auto</span> it = stuMap.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it!=stuMap.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"8-迭代器-iterator\"><a href=\"#8-迭代器-iterator\" class=\"headerlink\" title=\"8. 迭代器 iterator\"></a>8. 迭代器 iterator</h2><ol>\n<li>正向迭代器 <code>iterator</code>：输出元素时从第一个到对后一个，既可以读也可修改。</li>\n<li>常量的正向迭代器 <code>const_iterator</code>：输出元素时从第一个到对后一个，只可以读。</li>\n<li>反向迭代器 <code>reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li>\n<li>常量的反向迭代器 <code>const_reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li>\n</ol>\n<p><strong>顺序容器、关联容器，都支持正向迭代器与反向迭代器。</strong></p>\n<h3 id=\"1-iterator\"><a href=\"#1-iterator\" class=\"headerlink\" title=\"1. iterator\"></a>1. iterator</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t*it = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>\t&#123;<br>\t\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161445442.png\" alt=\"image.png\"></p>\n<h3 id=\"2-const-iterator\"><a href=\"#2-const-iterator\" class=\"headerlink\" title=\"2. const_iterator\"></a>2. const_iterator</h3><p><strong>底层原理：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// const_iterator &lt;= iterator</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">const_iterator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-type\">const</span> T&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t&#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span> : <span class=\"hljs-keyword\">public</span> const_iterator<br>&#123;<br>\tT&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">// class const_iterator&#123;&#125;基类</span><br><span class=\"hljs-comment\">// class iterator : public const_iterator派生类</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// vector&lt;int&gt;::iterator it1 = vec.begin();//可以接受派生类对象</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt;::const_iterator it1 = vec.<span class=\"hljs-built_in\">begin</span>();<br></code></pre></td></tr></table></figure>\n\n<p>将上面普通的正向迭代器换为常量的正向迭代器，编译器报错。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161447974.png\" alt=\"image.png\"></p>\n<h3 id=\"3-reverse-iterator\"><a href=\"#3-reverse-iterator\" class=\"headerlink\" title=\"3. reverse_iterator\"></a>3. reverse_iterator</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::reverse_iterator it = vec.<span class=\"hljs-built_in\">rbegin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">rend</span>(); it++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t*it = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161450170.png\" alt=\"image.png\"></p>\n<h3 id=\"4-const-reverse-iterator\"><a href=\"#4-const-reverse-iterator\" class=\"headerlink\" title=\"4. const_reverse_iterator\"></a>4. const_reverse_iterator</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//vector&lt;int&gt;::reverse_iterator rit = vec.rbegin();</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt;::const_reverse_iterator rit = vec.<span class=\"hljs-built_in\">rbegin</span>();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"9-函数对象\"><a href=\"#9-函数对象\" class=\"headerlink\" title=\"9. 函数对象\"></a>9. 函数对象</h2><p><strong>函数对象</strong>：拥有 <code>()operator</code> 重载函数的对象即函数对象，函数对象类似 C 语言里面的函数指针，但在 C++ 里为函数对象。</p>\n<h3 id=\"1-函数对象解释\"><a href=\"#1-函数对象解释\" class=\"headerlink\" title=\"1. 函数对象解释\"></a>1. 函数对象解释</h3><p>下图为，C 语言进行函数调用与 C++ 中两个函数调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161453547.png\" alt=\"image.png\"></p>\n<p>看起来它们好像一模一样，但是 C 语言中的 <code>sum()</code>，是函数名为一个地址；但 C++ 中的 <code>sum()</code> 为一个对象，sum 调用自己的 <code>( )</code> 重载函数将 10 与 20 传给 sum 调用的 <code>()</code> 运算符重载函数了，它接受两个实参，再执行 a+b。</p>\n<p><strong>这里就把 <code>()</code> 运算符重载函数的对象，称作函数对象，或者称作仿函数。</strong></p>\n<p><strong>好处：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;y&#x27;</span>) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实现了一个比较大于的函数模板，这里编译器会根据实参推导出 T 的类型，再从原模板实例化处理整型与 char 类型的 <code>compare()</code> 函数。  </p>\n<p>但是它不够灵活，有时想比较小于，每次改动符号有些麻烦，C 语言中的函数指针刚好可以很好解决这个问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 使用C的函数指针解决</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">myGreater</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">myLess</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &lt; b;<br>&#125;<br><br><span class=\"hljs-comment\">// compare是C++的库函数模板</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">class</span> Compare&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(T a, T b, Compare comp)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">comp</span>(a, b);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;大于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, myGreater&lt;<span class=\"hljs-type\">int</span>&gt;) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;小于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, myLess&lt;<span class=\"hljs-type\">int</span>&gt;) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161516099.png\" alt=\"image.png\"></p>\n<p>此时，就可以很好的解决这个问题了，当传入不同的函数指针来解决，想比较大就传入 myGreater，想比较小就传入 myLess，通过函数指针间接调用函数。</p>\n<p>这里，使用函数指针虽然解决了问题，但函数指针无法进行内联，有函数的调用开销，效率很低；即使将其能够写为内联函数，编译的时候还是不知道调用时 myGreater，myLess。这里是通过函数指针间接调用的，编译器在编译过程中看到函数指针时候，不知道其调用的哪个函数，只有运行时候才知道。</p>\n<p>因此，C++ 有一个专门的函数对象来解决这个问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// C++ 对象实现</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myGreater</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myLess</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a &lt; b;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// compare 是 C++ 的库函数模板</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">class</span> Compare&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(T a, T b, Compare comp)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 编译过程知道调用对象的函数 operator()(a, b);</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">comp</span>(a, b);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;大于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-built_in\">myGreater</span>&lt;<span class=\"hljs-type\">int</span>&gt;()) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;小于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-built_in\">myLess</span>&lt;<span class=\"hljs-type\">int</span>&gt;()) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>通过函数对象调用 <code>()</code> 运算符重载，可以省略函数的调用开销，比通过函数指针调用函数(不能内联调用)效率高。  </li>\n<li>因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。</li>\n</ol>\n<h3 id=\"2-使用示例\"><a href=\"#2-使用示例\" class=\"headerlink\" title=\"2. 使用示例\"></a>2. 使用示例</h3><ol>\n<li><strong>优先级队列</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 底层vector</span><br>\tpriority_queue&lt;<span class=\"hljs-type\">int</span>&gt; que;<br>\t<span class=\"hljs-comment\">// 大根堆</span><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tque.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; que.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tque.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161525837.png\" alt=\"image.png\"></p>\n<p><strong>如何使用小根堆：</strong></p>\n<p>库中的实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Ty</span>,<br>\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Container</span> = vector&lt;_Ty&gt;,<br>\t<span class=\"hljs-keyword\">class</span> _Pr = less&lt;<span class=\"hljs-keyword\">typename</span> _Container::value_type&gt; &gt;<br></code></pre></td></tr></table></figure>\n\n<p>将 less 改为 greater 即可变为小根堆即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">using</span> MinHeap = priority_queue&lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">using</span> MinHeap = priority_queue&lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 底层vector</span><br>\tMinHeap que;<br>\t<span class=\"hljs-comment\">// 大根堆</span><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tque.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; que.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tque.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161528812.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>set 集合</strong></li>\n</ol>\n<p>set 底层为红黑树，默认底层从小到大进行输出。底层为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Kty</span>,<br>\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Pr</span> = less&lt;_Kty&gt;,<br>\t<span class=\"hljs-keyword\">class</span> _Alloc = allocator&lt;_Kty&gt; &gt;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">set&lt;<span class=\"hljs-type\">int</span>, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; set;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">10</span>; ++i)<br>&#123;<br>\tset.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"10-泛型算法和绑定器\"><a href=\"#10-泛型算法和绑定器\" class=\"headerlink\" title=\"10. 泛型算法和绑定器\"></a>10. 泛型算法和绑定器</h2><h3 id=\"1-泛型算法\"><a href=\"#1-泛型算法\" class=\"headerlink\" title=\"1. 泛型算法\"></a>1. 泛型算法</h3><p>使用 STL 库中提供的泛型算法需要引入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果。</p>\n<p><strong>特点：</strong></p>\n<ol>\n<li>泛型算法的参数接受的都是迭代器。</li>\n<li>泛型算法的参数还可以接受函数对象。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> arr[] = &#123;<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">52</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">31</span>&#125;;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(arr, arr+<span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]))</span></span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>());<span class=\"hljs-comment\">//begin——end之间元素默认小到大排序</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161543085.png\" alt=\"image.png\"></p>\n<p><strong>在上面有序的容器进行二分查找</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> arr[] = &#123;<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">52</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">31</span>&#125;;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(arr, arr+<span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]))</span></span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>());<span class=\"hljs-comment\">//begin——end之间元素默认小到大排序</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">binary_search</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">21</span>));<br>&#123;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;21存在&quot;</span> &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>改变 sort 排序方式</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 传入函数对象greater，改变容器元素比较方式</span><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">greater</span>&lt;<span class=\"hljs-type\">int</span>&gt;());<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<p><strong>for_each 将容器中所有偶数打印出来。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// for_each可以遍历容器的所有元素，可以自行添加合适的函数对象</span><br><span class=\"hljs-comment\">// 对容器的元素进行过滤。</span><br>for_each(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <br>\t[](<span class=\"hljs-type\">int</span> val)-&gt;<span class=\"hljs-type\">void</span>   <span class=\"hljs-comment\">// 拉姆达表达式</span><br>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (val %<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\tcout &lt;&lt; val &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-绑定器\"><a href=\"#2-绑定器\" class=\"headerlink\" title=\"2. 绑定器\"></a>2. 绑定器</h3><p><strong>包含头文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>绑定器：绑定器 + 二元函数对象 &#x3D; 一元函数对象。</p>\n<ul>\n<li><strong>bind1st</strong>：把二元函数对象 <code>operator()(a,b)</code> 第一个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li>\n<li><strong>bind2nd</strong>：把二元函数对象 <code>operator()(a,b)</code> 第二个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//78 56 52 43 42 31 21 12 9 4</span><br><span class=\"hljs-comment\">//find_if</span><br><span class=\"hljs-comment\">//将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象</span><br><span class=\"hljs-comment\">//因此我们需要绑定器</span><br><span class=\"hljs-comment\">//greater a &gt; b   less a &lt; b</span><br><span class=\"hljs-keyword\">auto</span> it2 = <span class=\"hljs-built_in\">find_if</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <br>\t<span class=\"hljs-built_in\">bind1st</span>(<span class=\"hljs-built_in\">greater</span>&lt;<span class=\"hljs-type\">int</span>&gt;(), <span class=\"hljs-number\">48</span>));<br><span class=\"hljs-comment\">//bind2nd(less&lt;int&gt;(),48);</span><br><span class=\"hljs-comment\">//[](int val)-&gt;bool&#123;return val &lt; 48;&#125;); 拉姆达表达式</span><br>vec.<span class=\"hljs-built_in\">insert</span>(it2, <span class=\"hljs-number\">48</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>本节分为十部分：</p>\n<ol>\n<li>vector 容器</li>\n<li>deque 容器</li>\n<li>list 容器</li>\n<li>vector、deque、list 对比分析</li>\n<li>详解容器适配器</li>\n<li>无序关联容器</li>\n<li>有序关联容器</li>\n<li>迭代器 iterator</li>\n<li>函数对象</li>\n<li>泛型算法和绑定器</li>\n</ol>\n<p><strong>STL：其英文全称为：standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。</strong></p>\n<h2 id=\"1-vector-容器\"><a href=\"#1-vector-容器\" class=\"headerlink\" title=\"1. vector 容器\"></a>1. vector 容器</h2><p><strong>vector</strong>：向量容器，底层数据结构是动态开辟的数组，每次以原来空间大小的 2 倍进行扩容。 </p>\n<p>容器中对象的构造析构，内存的开辟释放通过空间配置器 allocator 实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。</p>\n<h3 id=\"1-使用方法合集\"><a href=\"#1-使用方法合集\" class=\"headerlink\" title=\"1. 使用方法合集\"></a>1. 使用方法合集</h3><p><strong>语法结构：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">vector&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用方式：</strong> 使用前包含头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>增加：</strong></li>\n</ol>\n<ul>\n<li>**<code>push_back()</code>**：在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。</li>\n<li>**<code>insert(迭代器，迭代器位置)</code>**：在 it 迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>删除：</strong></li>\n</ol>\n<ul>\n<li>**<code>pop_back()</code>**：在容器末尾删除一个元素，时间复杂度O(1)。</li>\n<li>**<code>erase()</code>**：删除it迭代器指向的元素，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>查询：</strong></li>\n</ol>\n<ul>\n<li>**<code>operator[]</code>**：数据下标的随机访问<code>vec[5]</code>，时间复杂度O(1)。</li>\n<li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li>\n<li>**<code>find()\\for_each</code>**：泛型算法。</li>\n<li>**<code>foreach</code>**：C++11提供的语法糖，通过迭代器iterator来实现的。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用方法：</strong></li>\n</ol>\n<ul>\n<li>**<code>size()</code>**：返回容器底层有效元素的个数。</li>\n<li>**<code>empty()</code>**：判断容器是否为空。</li>\n<li>**<code>reserve()</code>**：为 vector 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</li>\n<li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li>\n<li>**<code>swap()</code>**：两个容器进行元素交换。</li>\n</ul>\n<h3 id=\"2-容器使用\"><a href=\"#2-容器使用\" class=\"headerlink\" title=\"2. 容器使用\"></a>2. 容器使用</h3><ol>\n<li><strong>对 vector 容器中元素遍历。</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义 vector </span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 1. 运算符重载遍历</span><br>\t<span class=\"hljs-type\">int</span> size = vec.<span class=\"hljs-built_in\">size</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>\t&#123;<br>\t\tcout &lt;&lt; vec[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 2. 迭代器遍历</span><br>\t<span class=\"hljs-keyword\">auto</span> it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141548477.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>把 vec 容器中所有偶数全部删除</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义 vector </span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">auto</span> it1 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">while</span> (it1 != vec.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it1 % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <br>\t\t&#123;<br>\t\t\tit1 = vec.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit1++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 2. 迭代器遍历</span><br>\t<span class=\"hljs-keyword\">auto</span> it2 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it2 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141553912.png\" alt=\"image.png\"></p>\n<ol start=\"3\">\n<li><strong>在 2 删除的基础上，给 vector 容器中所有的奇数前面都添加一个小于 1的偶数 例：44 45</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义 vector </span><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">//vec的operator[]运算符重载函数进行vector遍历</span><br>\t<span class=\"hljs-type\">int</span> size = vec.<span class=\"hljs-built_in\">size</span>();<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i)<br>\t&#123;<br>\t\tcout &lt;&lt; vec[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 删除</span><br>\t<span class=\"hljs-keyword\">auto</span> it1 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">while</span> (it1 != vec.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it1 % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <br>\t\t&#123;<br>\t\t\tit1 = vec.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit1++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 迭代器遍历</span><br>\t<span class=\"hljs-keyword\">auto</span> it2 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it2 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 添加</span><br>\t<span class=\"hljs-keyword\">for</span> (it2 = vec.<span class=\"hljs-built_in\">begin</span>(); it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it2 % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tit2 = vec.<span class=\"hljs-built_in\">insert</span>(it2, *it2<span class=\"hljs-number\">-1</span>);<br>\t\t\t++it2;<br>\t\t&#125;<br>\t&#125;<br><br>\tit2 = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it2 != vec.<span class=\"hljs-built_in\">end</span>(); it2++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it2 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141600161.png\" alt=\"image.png\"></p>\n<ol start=\"4\">\n<li><strong>reserve 预留空间，只给容器底层开辟指定大小空间并不添加新的元素。</strong></li>\n</ol>\n<p>默认定义的 vector 底层为 0，第一次插入从 0 变更为 1，再变为 2，4，8… 一直进行扩容，代价十分高，使用初始的内存效率太低，若开始知道问题的数据量大小，即可使用 reserve 预留空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<span class=\"hljs-comment\">// 默认定义的 vector 底层为 0</span><br>\tvec.<span class=\"hljs-built_in\">reserve</span>(<span class=\"hljs-number\">20</span>);<span class=\"hljs-comment\">// 给 vector 容器预留空间</span><br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果: <code>empty()</code> 是 1 为空，0 为非空。刚开始为空，<code>reserve(20)</code> 并没有为容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是 0。再添加 20个 元素的时候，不需要扩容了，效率提高。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141605065.png\" alt=\"image.png\"></p>\n<ol start=\"5\">\n<li><strong>resize 扩容，不仅给容器底层开辟指定大小空间，还会添加新的元素。</strong></li>\n</ol>\n<p><code>resize()</code> 不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为 0。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-comment\">// 使用 vector 库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<span class=\"hljs-comment\">//默认定义的vector底层为0</span><br>\tvec.<span class=\"hljs-built_in\">resize</span>(<span class=\"hljs-number\">20</span>);<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Before，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.empty()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">empty</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;After，vec.size()：&quot;</span> &lt;&lt; vec.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308141606206.png\" alt=\"image.png\"></p>\n<h2 id=\"2-deque-容器\"><a href=\"#2-deque-容器\" class=\"headerlink\" title=\"2. deque 容器\"></a>2. deque 容器</h2><p><strong>deque：双端队列容器，底层为动态开辟的二维数组。</strong> **</p>\n<p>一维数组从 2 开始，以 2 倍的方式进行扩容，每次扩容后，原来第二维的数组，从新的第一维数组的下标 <code>oldsize/2</code> 开始存放，上下都预留相同的空行，方便支持 deque 的首尾元素添加。</p>\n<h3 id=\"1-容器结构\"><a href=\"#1-容器结构\" class=\"headerlink\" title=\"1. 容器结构\"></a>1. 容器结构</h3><p>其底层为：<strong>动态开辟的二维数组</strong>。</p>\n<p>其有两个宏：<code>MAP_SIZE</code>，为2；<code>QUE_SIZE</code>，为 <code>4096/sizeof(T)</code>，T 为实际的类型。底层有 2 个维度，还有一个 mapper 指针，指向第一维的一维数组，默认大小为<code> MAP_SIZE 2</code>；第二维为动态开辟的 <code>QUE_SIZE</code> 的大小，例如：使用整型时会有1024个元素。</p>\n<p>双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；</p>\n<p>简易的画了一个方向，first 与 last 处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150854875.png\" alt=\"image.png\"></p>\n<h3 id=\"2-扩容方式\"><a href=\"#2-扩容方式\" class=\"headerlink\" title=\"2. 扩容方式\"></a>2. 扩容方式</h3><p>当我们元素的不断增加，相应的指示位置向后移动。</p>\n<ul>\n<li>如图 2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150858867.png\" alt=\"image.png\"></p>\n<ul>\n<li>如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150902713.png\" alt=\"image.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150903312.png\" alt=\"image.png\"></p>\n<ul>\n<li>如图5，6；刚才的第二维移动到第一维中间部分(<code>oldsize/2</code>)，方便任何一边的元素改动。若需再次扩容，同理。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150906687.png\" alt=\"image.png\"><br><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150909908.png\" alt=\"image.png\"></p>\n<h3 id=\"3-使用方法合集\"><a href=\"#3-使用方法合集\" class=\"headerlink\" title=\"3. 使用方法合集\"></a>3. 使用方法合集</h3><p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">deque&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>增加：</strong></li>\n</ol>\n<ul>\n<li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li>\n<li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li>\n<li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>删除：</strong></li>\n</ol>\n<ul>\n<li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li>\n<li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li>\n<li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>查询：</strong></li>\n</ol>\n<ul>\n<li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用方法：</strong></li>\n</ol>\n<ul>\n<li>**<code>size()</code>**：返回容器底层有效元素的个数。</li>\n<li>**<code>empty()</code>**：判断容器是否为空。</li>\n<li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li>\n<li>**<code>swap()</code>**：两个容器进行元素交换。</li>\n</ul>\n<h3 id=\"4-使用\"><a href=\"#4-使用\" class=\"headerlink\" title=\"4. 使用\"></a>4. 使用</h3><p>和 vector 实例类似，直接参考 vector 容器实例即可。</p>\n<h2 id=\"3-list-容器\"><a href=\"#3-list-容器\" class=\"headerlink\" title=\"3. list 容器\"></a>3. list 容器</h2><p><strong>list：链表容器，底层数据结构为双向循环链表。</strong></p>\n<h3 id=\"1-使用方法合集-1\"><a href=\"#1-使用方法合集-1\" class=\"headerlink\" title=\"1. 使用方法合集\"></a>1. 使用方法合集</h3><p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">list&lt;type&gt; TypeName;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>增加：</strong></li>\n</ol>\n<ul>\n<li>**<code>push_back()</code>**：从末尾添加元素，时间复杂度O(1)，可能引起扩容。</li>\n<li>**<code>push_front()</code>**：从首部添加元素，时间复杂度O(1)，可能引起扩容。vector 中没有该方法，需要使用 <code>insert()</code>，为O(n)。</li>\n<li>**<code>insert()</code>**：迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行 <code>insert()</code> 时，要先进行 <code>query()</code> 操作，效率就慢了。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>删除：</strong></li>\n</ol>\n<ul>\n<li>**<code>pop_back()</code>**：从末尾删除元素，时间复杂度O(1)。</li>\n<li>**<code>pop_front()</code>**：从首部删除，时间复杂度O(1)。</li>\n<li>**<code>erase()</code>**：迭代器指向的位置进行元素删除，时间复杂度O(n)。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>查询：</strong></li>\n</ol>\n<ul>\n<li>**<code>iterator</code>**：迭代器进行遍历，一定要考虑迭代器失效问题。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>常用方法：</strong></li>\n</ol>\n<ul>\n<li>**<code>size()</code>**：返回容器底层有效元素的个数。</li>\n<li>**<code>empty()</code>**：判断容器是否为空。</li>\n<li>**<code>resize()</code>**：扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。</li>\n<li>**<code>swap()</code>**：两个容器进行元素交换。</li>\n</ul>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2. 使用\"></a>2. 使用</h3><p>使用实例与vector类似。</p>\n<h2 id=\"4-vector、deque、list-对比分析\"><a href=\"#4-vector、deque、list-对比分析\" class=\"headerlink\" title=\"4. vector、deque、list 对比分析\"></a>4. vector、deque、list 对比分析</h2><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308150924833.png\" alt=\"image.png\"></p>\n<ol>\n<li><strong>deque 底层内存是否是连续的？</strong></li>\n</ol>\n<p>不是，deque 底层是动态开辟的二维数组，第二维都是独立开辟的空间，每一个第二维是连续的，但是所有的二维不是连续的。</p>\n<ol start=\"2\">\n<li><strong>vector 与 deque 容器之间的区别：</strong></li>\n</ol>\n<ul>\n<li><strong>vector 特点：</strong> 底层是一个动态开辟数组，内存是连续的，2 倍的方式进行扩容。当默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li>\n<li><strong>deque 特点：</strong> 底层为动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容时候(第一维的数组进行 2 倍扩容，原来的第二维的数组放入新扩容的数组中间)，支持前后插入删除为 O(1) 的操作。</li>\n</ul>\n<p><strong>区别：</strong></p>\n<ul>\n<li><strong>底层数据结构不同</strong>：vector 底层为动态开辟的数组，内存是连续的；deque 底层是动态开辟的二维数组空间，内存不连续。</li>\n<li><strong>前中后删除的时间复杂度不同</strong>：它们中间与末尾插入删除一样为 O(1)，但最前面进行元素添加时候 deque 为 O(1)，vector 为 O(n)。</li>\n<li><strong>内存使用效率不同</strong>：vector 低，需要的内存空间必须是连续的；deque 第二维内存空间不一定连续，可以分块进行数据存储，对内存使用效率会更高。</li>\n<li><strong>在中间进行 insert 或者 erase，vector 与 deque 的效率不同</strong>：它们时间复杂度都为 O(n)，但 vecto r内存完全连续，其他元素容易移动；但 deque 内存不连续，元素移动更加麻烦一些，效率不如 vector。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>vector 与 list 容器之间的区别：</strong></li>\n</ol>\n<ul>\n<li><strong>vector 特点</strong>： 底层是一个动态开辟的数组，内存是连续的，2 倍的方式进行扩容。当我们默认定义一个 vector 时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8… 进行扩容，扩容效率低。reserve 函数可以预留空间，并未添加元素。</li>\n<li><strong>list 特点</strong>： 底层是一个双向循环链表。</li>\n</ul>\n<p><strong>区别：</strong></p>\n<p><strong>数组与链表区别</strong>：数组增加删除为 O(n)，查询 O(n)，随机访问为 O(1)；链表增加删除一个结点本身为 O(1)，但搜索的时间为 O(n)。如果增加删除使用多，优先使用 list；随机访问使用多，优先使用 vector。</p>\n<h2 id=\"5-详解容器适配器\"><a href=\"#5-详解容器适配器\" class=\"headerlink\" title=\"5. 详解容器适配器\"></a>5. 详解容器适配器</h2><p>容器适配器：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。</p>\n<p><strong>使用容器适配器实现栈</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>, <span class=\"hljs-keyword\">typename</span> Container=deque&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">class</span> Stack<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-built_in\">push</span>(<span class=\"hljs-type\">const</span> T&amp; val)<br>\t&#123;<br>\t\tcon.<span class=\"hljs-built_in\">push_back</span>(val);<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcon.<span class=\"hljs-built_in\">pop_back</span>();<br>\t&#125;<br>\t<span class=\"hljs-function\">T <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span><span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> con.<span class=\"hljs-built_in\">back</span>();<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tContainer con;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tStack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br>\t<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\ts.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tcout &lt;&lt; s.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\ts.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实现成功，相当于栈将 deque 代理了一下，也成为代理模式。push 将底层容器的 <code>push_back</code> 代理了，pop 将底层 <code>pop_back</code> 代理了，栈的 top 将容器底层的 back 代理了。</p>\n<h3 id=\"1-Stack-栈容器\"><a href=\"#1-Stack-栈容器\" class=\"headerlink\" title=\"1. Stack 栈容器\"></a>1. Stack 栈容器</h3><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151017597.png\" alt=\"image.png\"></p>\n<p><code>stack&lt;T&gt;</code> 容器适配器中的数据是以 LIFO（Last In First Out） 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。</p>\n<p>上图：展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。</p>\n<p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<ul>\n<li>**<code>push()</code>**：入栈  </li>\n<li>**<code>pop()</code>**：  出栈 </li>\n<li>**<code>top()</code>**：查看栈顶元素  </li>\n<li>**<code>empty()</code>**：判断栈空  </li>\n<li>**<code>size()</code>**：返回元素个数</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tstack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\ts.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;栈中元素个数:&quot;</span> &lt;&lt; s.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; s.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\ts.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151023238.png\" alt=\"image.png\"></p>\n<h3 id=\"2-队列\"><a href=\"#2-队列\" class=\"headerlink\" title=\"2. 队列\"></a>2. 队列</h3><p>只能访问 <code>queue&lt;T&gt;</code> 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。  </p>\n<p>许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO（First In First Out） 准则处理的序列来说，使用 queue 容器适配器都是好的选择。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151024083.png\" alt=\"image.png\"></p>\n<p><strong>使用前提：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<ul>\n<li>**<code>push()</code>**：入栈  </li>\n<li>**<code>pop()</code>**：  出栈 </li>\n<li>**<code>front()</code>**：查看对头元素</li>\n<li>**<code>back()</code>**：查看队尾元素</li>\n<li>**<code>empty()</code>**：判断空  </li>\n<li>**<code>size()</code>**：返回元素个数</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tqueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tq.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;队列中元素个数:&quot;</span> &lt;&lt; q.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; q.<span class=\"hljs-built_in\">front</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tq.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151027513.png\" alt=\"image.png\"></p>\n<h3 id=\"3-优先级队列\"><a href=\"#3-优先级队列\" class=\"headerlink\" title=\"3. 优先级队列\"></a>3. 优先级队列</h3><p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151036304.png\" alt=\"image.png\"></p>\n<p><strong>优先级队列：底层数据结构为大根堆。</strong> </p>\n<p>使用库中的优先级队列，需要加上头文件<code>&lt;queue&gt;</code>；<strong>优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。</strong></p>\n<p><strong>常用方法：</strong></p>\n<ul>\n<li>**<code>push()</code>**：入栈  </li>\n<li>**<code>pop()</code>**：  出栈 </li>\n<li>**<code>top()</code>**：查看栈顶元素  </li>\n<li>**<code>empty()</code>**：判断栈空  </li>\n<li>**<code>size()</code>**：返回元素个数</li>\n</ul>\n<p><strong>使用：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tpriority_queue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tq.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;优先队列中元素个数:&quot;</span> &lt;&lt; q.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; q.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tq.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>数据从大到小依次出队，数据越大优先级越高。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151039915.png\" alt=\"image.png\"></p>\n<p><strong>问题一：stack 与 queue 第二个模板类型参数依赖 deque，为什么不依赖 vector？</strong></p>\n<ol>\n<li>vector 的初始化内存使用效率太低了，没有 deque 好。</li>\n<li>对于 queue 来说，需要支持尾部插入，头部删除，时间复杂度需要为 O(1)，deque 恰好符合条件，若用 vector 其底层效率太低。</li>\n<li>vector 需要大片的连续内存，而 deque 只需要分段的内存，当存储大量数据时，显然 deuqe 对于内存的利用率更高更好一些。</li>\n</ol>\n<p><strong>问题二：优先级队列为什么底层依赖 vector？</strong></p>\n<p>优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为 i，左孩子为 <code>2i+1</code>，右孩子为 <code>2i+2</code>；大根堆为堆顶，其元素最大，结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的，因此底层依赖 vector；而 deque 的第二维不是连续的，不能使用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151042363.png\" alt=\"image.png\"></p>\n<h2 id=\"6-无序关联容器\"><a href=\"#6-无序关联容器\" class=\"headerlink\" title=\"6. 无序关联容器\"></a>6. 无序关联容器</h2><p><strong>关联容器分为：无序关联容器与有序关联容器，简单对比下：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151043482.png\" alt=\"image.png\"></p>\n<p><strong>无序关联容器：底层为哈希表，里面元素无顺序，增删查为O(1)。</strong></p>\n<h3 id=\"1-单重集合与多重集合\"><a href=\"#1-单重集合与多重集合\" class=\"headerlink\" title=\"1. 单重集合与多重集合\"></a>1. 单重集合与多重集合</h3><ul>\n<li><strong>set 集合</strong>：存储的是关键字。<code>[key]</code></li>\n<li><strong>unordered_set</strong>：单重集合；不允许 key 重复。</li>\n<li><strong>unordered_multiset</strong>：多重集合；允许 key 重复。</li>\n</ul>\n<p><strong>包含文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p>\n<p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p>\n<p><strong>使用1：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 不允许存储key值重复的元素</span><br>\tunordered_set&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; ++i)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 与vector/deque/list插入不同</span><br>\t\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br>\t<span class=\"hljs-comment\">// 返回key为15的元素的个数</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">count</span>(<span class=\"hljs-number\">15</span>) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151117267.png\" alt=\"image.png\"></p>\n<p><strong>使用2：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 不允许存储key值重复的元素</span><br>\tunordered_set&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; ++i)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 与vector/deque/list插入不同</span><br>\t\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 迭代器遍历容器</span><br>\t<span class=\"hljs-keyword\">auto</span> it1 = set1.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it1 != set1.<span class=\"hljs-built_in\">end</span>(); ++it1)<br>\t&#123;<br>\t\tcout &lt;&lt; *it1 &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-comment\">// 按key值删除元素</span><br>\tset1.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">20</span>);<br>\t<span class=\"hljs-keyword\">for</span> (it1 = set1.<span class=\"hljs-built_in\">begin</span>(); it1 != set1.<span class=\"hljs-built_in\">end</span>();)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it1 == <span class=\"hljs-number\">30</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 迭代器删除元素</span><br>\t\t\tit1 = set1.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\t++it1;<br>\t\t&#125;<br>\t&#125;<br><br>\tit1 = set1.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-number\">20</span>);<br>\t<span class=\"hljs-keyword\">if</span> (it1 != set1.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\tset1.<span class=\"hljs-built_in\">erase</span>(it1);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set1)<br>\t&#123;<br>\t\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151119097.png\" alt=\"image.png\"></p>\n<p><strong>使用3：unordered_multiset</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 允许存储key值重复的元素</span><br>\tunordered_multiset&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; ++i)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 与vector/deque/list插入不同\t</span><br>\t\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.size() = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<br>\t<span class=\"hljs-comment\">// 返回key为15的元素的个数</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;set1.count(15) = &quot;</span> &lt;&lt; set1.<span class=\"hljs-built_in\">count</span>(<span class=\"hljs-number\">15</span>) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308151121798.png\" alt=\"image.png\"></p>\n<h3 id=\"2-单重映射表与多重映射表\"><a href=\"#2-单重映射表与多重映射表\" class=\"headerlink\" title=\"2. 单重映射表与多重映射表\"></a>2. 单重映射表与多重映射表</h3><ul>\n<li><strong>map 集合</strong>：存储的是键值对。<code>[key，value]</code></li>\n<li><strong>unordered_map</strong>：单重映射表；不可重复。</li>\n<li><strong>unordered_multimap</strong>：多重映射表；可重复。</li>\n</ul>\n<p><strong>包含文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p><strong>常用方法：</strong></p>\n<p>增加：<code>insert(val)</code>;<br>遍历：<code>iterator</code> 自己搜索，调用 <code>find()</code>；<br>删除：<code>erase(key);</code> 或 <code>erase(it);</code></p>\n<p>**<code>size()</code>**：返回容器中元素个数。<br>**<code>count(val)</code>**：返回元素值为val的个数，val不会重复。<br>**<code>find(val)</code>**：在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。</p>\n<p><strong>使用1：unordered_map</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; map1;<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>, <span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; map1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<span class=\"hljs-comment\">//键值对个数</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用2：unordered_multimap</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_multimap&lt;<span class=\"hljs-type\">int</span>,string&gt; map1;<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>,<span class=\"hljs-string\">&quot;张三&quot;</span>));<span class=\"hljs-comment\">//打包成键值对</span><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>,<span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>,<span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>,<span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;size: &quot;</span> &lt;&lt; map1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<span class=\"hljs-comment\">// 键值对个数</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用3：查询</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//map operator[](key) =&gt;value </span><br>cout &lt;&lt; map1[<span class=\"hljs-number\">1000</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; map1;<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>, <span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br><br>\tmap1.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">1020</span>);<span class=\"hljs-comment\">//删除</span><br>\tmap1[<span class=\"hljs-number\">2000</span>] = <span class=\"hljs-string\">&quot;刘帅&quot;</span>;<span class=\"hljs-comment\">//相当于插入</span><br>\tmap1[<span class=\"hljs-number\">1000</span>] = <span class=\"hljs-string\">&quot;张三2&quot;</span>;<span class=\"hljs-comment\">//相当于修改操作</span><br><br>\tcout &lt;&lt; map1.<span class=\"hljs-built_in\">size</span>() &lt;&lt; endl;<span class=\"hljs-comment\">//键值对个数</span><br>\t<span class=\"hljs-comment\">// map operator[](key) =&gt;value 查询</span><br>\tcout &lt;&lt; map1[<span class=\"hljs-number\">1000</span>] &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>使用4：iterator 查找</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; map1;<br><br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张三&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>, <span class=\"hljs-string\">&quot;李四&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;王五&quot;</span>));<br>\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1030</span>, <span class=\"hljs-string\">&quot;赵六&quot;</span>));<br><br>\t<span class=\"hljs-keyword\">auto</span> it1 = map1.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-number\">1030</span>);<br>\t<span class=\"hljs-keyword\">if</span> (it1 != map1.<span class=\"hljs-built_in\">end</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;key:&quot;</span> &lt;&lt; it1-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot; value:&quot;</span> &lt;&lt; it1-&gt;second &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-海量数据\"><a href=\"#3-海量数据\" class=\"headerlink\" title=\"3. 海量数据\"></a>3. 海量数据</h3><p><strong>案例1：处理海量数据数据查重，经常会使用map。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> ARR_LEN = <span class=\"hljs-number\">1000</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> arr[ARR_LEN] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; ARR_LEN; i++)<br>\t&#123;<br>\t\tarr[i] = <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数</span><br><br>\tunordered_map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; map1;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k : arr)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">auto</span> it = map1.<span class=\"hljs-built_in\">find</span>(k);<br>\t\t<span class=\"hljs-keyword\">if</span> (it == map1.<span class=\"hljs-built_in\">end</span>())<span class=\"hljs-comment\">//数字没出现过</span><br>\t\t&#123;<br>\t\t\tmap1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(k, <span class=\"hljs-number\">1</span>));<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\tit-&gt;second++;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">auto</span> it = map1.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != map1.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (it-&gt;second &gt; <span class=\"hljs-number\">1</span>)<br>\t\t&#123;<br>\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>案例2：海量数据去重。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> ARR_LEN = <span class=\"hljs-number\">1000</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span> arr[ARR_LEN] = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; ARR_LEN; i++)<br>\t&#123;<br>\t\tarr[i] = <span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 上面的整数中，将数字进行去重打印</span><br>\tunordered_set&lt;<span class=\"hljs-type\">int</span>&gt; set;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : arr)<br>\t&#123;<br>\t\tset.<span class=\"hljs-built_in\">insert</span>(v);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set)<br>\t&#123;<br>\t\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-有序关联容器\"><a href=\"#7-有序关联容器\" class=\"headerlink\" title=\"7. 有序关联容器\"></a>7. 有序关联容器</h2><p><strong>有序关联容器：底层为红黑树，里面元素有序，增删查 $O(log^{2n})$。</strong></p>\n<p><strong>包含文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;set&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。</li>\n<li>multiset：多重集合，可以存储重复的元素，从小到大元素有序排列。</li>\n<li>map：单重映射表，重复的只出现一次，从小到大元素有序排列。</li>\n<li>multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。</li>\n</ul>\n<p><strong>实例1：set 实例</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">set&lt;<span class=\"hljs-type\">int</span>&gt; set1;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">20</span>; i++)<br>&#123;<br>\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>()%<span class=\"hljs-number\">20</span> + <span class=\"hljs-number\">1</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set1)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<p><strong>实例2：set 存放自定义类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;set&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">int</span> id, string name)<br>\t\t: _id(id)<br>\t\t, _name(name)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 舒适化列表</span><br>\t&#125;<br><br>\t<span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-type\">const</span> Student&amp; stu) <span class=\"hljs-type\">const</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> _id &lt; stu._id;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _id;<br>\tstring _name;<br>\t<span class=\"hljs-comment\">// 友元</span><br>\t<span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> Student&amp; str);<br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream&amp; out, <span class=\"hljs-type\">const</span> Student&amp; stu)<br>&#123;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;id: &quot;</span> &lt;&lt; stu._id &lt;&lt; endl;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;name: &quot;</span> &lt;&lt; stu._name;<br><br>\t<span class=\"hljs-keyword\">return</span> out;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tset&lt;Student&gt; set1;<br>\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1000</span>, <span class=\"hljs-string\">&quot;张文&quot;</span>));<br>\tset1.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1020</span>, <span class=\"hljs-string\">&quot;李广&quot;</span>));<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = set1.<span class=\"hljs-built_in\">begin</span>(); it != set1.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; endl;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>实例3：map 实例</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Student</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-type\">int</span> id = <span class=\"hljs-number\">0</span>, string name = <span class=\"hljs-string\">&quot;&quot;</span>)<br>\t\t:_id(id), _name(name)&#123;&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> _id;<br>\tstring _name;<br>\t<span class=\"hljs-keyword\">friend</span> ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;out, <span class=\"hljs-type\">const</span> Student &amp;stu);<br>&#125;;<br><br>ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;out, <span class=\"hljs-type\">const</span> Student &amp;stu)<br>&#123;<br>\tout &lt;&lt; <span class=\"hljs-string\">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class=\"hljs-string\">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> out;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmap&lt;<span class=\"hljs-type\">int</span>, Student&gt; stuMap;<br>\tstuMap.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1010</span>,<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1010</span>,<span class=\"hljs-string\">&quot;张文&quot;</span>)));<br>\tstuMap.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1020</span>,<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1020</span>,<span class=\"hljs-string\">&quot;李广&quot;</span>)));<br>\tstuMap.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">1030</span>,<span class=\"hljs-built_in\">Student</span>(<span class=\"hljs-number\">1030</span>,<span class=\"hljs-string\">&quot;高阳&quot;</span>)));<br><br>\t<span class=\"hljs-comment\">//stuMap.erase(it) stuMap.erase(1020)</span><br>\t<span class=\"hljs-comment\">//cout &lt;&lt; stuMap[1020] &lt;&lt; endl;</span><br>\t<span class=\"hljs-keyword\">auto</span> it = stuMap.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it!=stuMap.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"8-迭代器-iterator\"><a href=\"#8-迭代器-iterator\" class=\"headerlink\" title=\"8. 迭代器 iterator\"></a>8. 迭代器 iterator</h2><ol>\n<li>正向迭代器 <code>iterator</code>：输出元素时从第一个到对后一个，既可以读也可修改。</li>\n<li>常量的正向迭代器 <code>const_iterator</code>：输出元素时从第一个到对后一个，只可以读。</li>\n<li>反向迭代器 <code>reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li>\n<li>常量的反向迭代器 <code>const_reverse_iterator</code>：输出元素时从最后一个到第一个，既可以读也可修改。</li>\n</ol>\n<p><strong>顺序容器、关联容器，都支持正向迭代器与反向迭代器。</strong></p>\n<h3 id=\"1-iterator\"><a href=\"#1-iterator\" class=\"headerlink\" title=\"1. iterator\"></a>1. iterator</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it = vec.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">end</span>(); it++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t*it = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>\t&#123;<br>\t\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161445442.png\" alt=\"image.png\"></p>\n<h3 id=\"2-const-iterator\"><a href=\"#2-const-iterator\" class=\"headerlink\" title=\"2. const_iterator\"></a>2. const_iterator</h3><p><strong>底层原理：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// const_iterator &lt;= iterator</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">const_iterator</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-type\">const</span> T&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t&#125;<br>&#125;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">iterator</span> : <span class=\"hljs-keyword\">public</span> const_iterator<br>&#123;<br>\tT&amp; <span class=\"hljs-keyword\">operator</span>*()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> *_ptr;<br>\t&#125;<br>&#125;<br><span class=\"hljs-comment\">// class const_iterator&#123;&#125;基类</span><br><span class=\"hljs-comment\">// class iterator : public const_iterator派生类</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// vector&lt;int&gt;::iterator it1 = vec.begin();//可以接受派生类对象</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt;::const_iterator it1 = vec.<span class=\"hljs-built_in\">begin</span>();<br></code></pre></td></tr></table></figure>\n\n<p>将上面普通的正向迭代器换为常量的正向迭代器，编译器报错。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161447974.png\" alt=\"image.png\"></p>\n<h3 id=\"3-reverse-iterator\"><a href=\"#3-reverse-iterator\" class=\"headerlink\" title=\"3. reverse_iterator\"></a>3. reverse_iterator</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">20</span>; i++)<br>\t&#123;<br>\t\tvec.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;::reverse_iterator it = vec.<span class=\"hljs-built_in\">rbegin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != vec.<span class=\"hljs-built_in\">rend</span>(); it++)<br>\t&#123;<br>\t\tcout &lt;&lt; *it &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (*it % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t*it = <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161450170.png\" alt=\"image.png\"></p>\n<h3 id=\"4-const-reverse-iterator\"><a href=\"#4-const-reverse-iterator\" class=\"headerlink\" title=\"4. const_reverse_iterator\"></a>4. const_reverse_iterator</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//vector&lt;int&gt;::reverse_iterator rit = vec.rbegin();</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt;::const_reverse_iterator rit = vec.<span class=\"hljs-built_in\">rbegin</span>();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"9-函数对象\"><a href=\"#9-函数对象\" class=\"headerlink\" title=\"9. 函数对象\"></a>9. 函数对象</h2><p><strong>函数对象</strong>：拥有 <code>()operator</code> 重载函数的对象即函数对象，函数对象类似 C 语言里面的函数指针，但在 C++ 里为函数对象。</p>\n<h3 id=\"1-函数对象解释\"><a href=\"#1-函数对象解释\" class=\"headerlink\" title=\"1. 函数对象解释\"></a>1. 函数对象解释</h3><p>下图为，C 语言进行函数调用与 C++ 中两个函数调用。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161453547.png\" alt=\"image.png\"></p>\n<p>看起来它们好像一模一样，但是 C 语言中的 <code>sum()</code>，是函数名为一个地址；但 C++ 中的 <code>sum()</code> 为一个对象，sum 调用自己的 <code>( )</code> 重载函数将 10 与 20 传给 sum 调用的 <code>()</code> 运算符重载函数了，它接受两个实参，再执行 a+b。</p>\n<p><strong>这里就把 <code>()</code> 运算符重载函数的对象，称作函数对象，或者称作仿函数。</strong></p>\n<p><strong>好处：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;y&#x27;</span>) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>实现了一个比较大于的函数模板，这里编译器会根据实参推导出 T 的类型，再从原模板实例化处理整型与 char 类型的 <code>compare()</code> 函数。  </p>\n<p>但是它不够灵活，有时想比较小于，每次改动符号有些麻烦，C 语言中的函数指针刚好可以很好解决这个问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 使用C的函数指针解决</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">myGreater</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">myLess</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> a &lt; b;<br>&#125;<br><br><span class=\"hljs-comment\">// compare是C++的库函数模板</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">class</span> Compare&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(T a, T b, Compare comp)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">comp</span>(a, b);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;大于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, myGreater&lt;<span class=\"hljs-type\">int</span>&gt;) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;小于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, myLess&lt;<span class=\"hljs-type\">int</span>&gt;) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161516099.png\" alt=\"image.png\"></p>\n<p>此时，就可以很好的解决这个问题了，当传入不同的函数指针来解决，想比较大就传入 myGreater，想比较小就传入 myLess，通过函数指针间接调用函数。</p>\n<p>这里，使用函数指针虽然解决了问题，但函数指针无法进行内联，有函数的调用开销，效率很低；即使将其能够写为内联函数，编译的时候还是不知道调用时 myGreater，myLess。这里是通过函数指针间接调用的，编译器在编译过程中看到函数指针时候，不知道其调用的哪个函数，只有运行时候才知道。</p>\n<p>因此，C++ 有一个专门的函数对象来解决这个问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// C++ 对象实现</span><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myGreater</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a &gt; b;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">T</span>&gt;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myLess</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(T a, T b)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> a &lt; b;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// compare 是 C++ 的库函数模板</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">typename</span> T, <span class=\"hljs-keyword\">class</span> Compare&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(T a, T b, Compare comp)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 编译过程知道调用对象的函数 operator()(a, b);</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">comp</span>(a, b);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;大于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-built_in\">myGreater</span>&lt;<span class=\"hljs-type\">int</span>&gt;()) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;小于：&quot;</span><br>\t\t&lt;&lt; <span class=\"hljs-built_in\">compare</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-built_in\">myLess</span>&lt;<span class=\"hljs-type\">int</span>&gt;()) &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>通过函数对象调用 <code>()</code> 运算符重载，可以省略函数的调用开销，比通过函数指针调用函数(不能内联调用)效率高。  </li>\n<li>因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。</li>\n</ol>\n<h3 id=\"2-使用示例\"><a href=\"#2-使用示例\" class=\"headerlink\" title=\"2. 使用示例\"></a>2. 使用示例</h3><ol>\n<li><strong>优先级队列</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 底层vector</span><br>\tpriority_queue&lt;<span class=\"hljs-type\">int</span>&gt; que;<br>\t<span class=\"hljs-comment\">// 大根堆</span><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tque.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; que.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tque.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161525837.png\" alt=\"image.png\"></p>\n<p><strong>如何使用小根堆：</strong></p>\n<p>库中的实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Ty</span>,<br>\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Container</span> = vector&lt;_Ty&gt;,<br>\t<span class=\"hljs-keyword\">class</span> _Pr = less&lt;<span class=\"hljs-keyword\">typename</span> _Container::value_type&gt; &gt;<br></code></pre></td></tr></table></figure>\n\n<p>将 less 改为 greater 即可变为小根堆即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">using</span> MinHeap = priority_queue&lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">using</span> MinHeap = priority_queue&lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 底层vector</span><br>\tMinHeap que;<br>\t<span class=\"hljs-comment\">// 大根堆</span><br>\t<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tque.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (!que.<span class=\"hljs-built_in\">empty</span>())<br>\t&#123;<br>\t\tcout &lt;&lt; que.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\tque.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\tcout &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161528812.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>set 集合</strong></li>\n</ol>\n<p>set 底层为红黑树，默认底层从小到大进行输出。底层为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Kty</span>,<br>\t<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Pr</span> = less&lt;_Kty&gt;,<br>\t<span class=\"hljs-keyword\">class</span> _Alloc = allocator&lt;_Kty&gt; &gt;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">set&lt;<span class=\"hljs-type\">int</span>, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; set;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">10</span>; ++i)<br>&#123;<br>\tset.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : set)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"10-泛型算法和绑定器\"><a href=\"#10-泛型算法和绑定器\" class=\"headerlink\" title=\"10. 泛型算法和绑定器\"></a>10. 泛型算法和绑定器</h2><h3 id=\"1-泛型算法\"><a href=\"#1-泛型算法\" class=\"headerlink\" title=\"1. 泛型算法\"></a>1. 泛型算法</h3><p>使用 STL 库中提供的泛型算法需要引入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果。</p>\n<p><strong>特点：</strong></p>\n<ol>\n<li>泛型算法的参数接受的都是迭代器。</li>\n<li>泛型算法的参数还可以接受函数对象。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> arr[] = &#123;<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">52</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">31</span>&#125;;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(arr, arr+<span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]))</span></span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>());<span class=\"hljs-comment\">//begin——end之间元素默认小到大排序</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308161543085.png\" alt=\"image.png\"></p>\n<p><strong>在上面有序的容器进行二分查找</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> arr[] = &#123;<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">21</span>, <span class=\"hljs-number\">43</span>, <span class=\"hljs-number\">56</span>, <span class=\"hljs-number\">52</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">31</span>&#125;;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(arr, arr+<span class=\"hljs-keyword\">sizeof</span>(arr)/<span class=\"hljs-keyword\">sizeof</span>(arr[<span class=\"hljs-number\">0</span>]))</span></span>;<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>());<span class=\"hljs-comment\">//begin——end之间元素默认小到大排序</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">binary_search</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">21</span>));<br>&#123;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;21存在&quot;</span> &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>改变 sort 排序方式</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 传入函数对象greater，改变容器元素比较方式</span><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-built_in\">greater</span>&lt;<span class=\"hljs-type\">int</span>&gt;());<br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n\n<p><strong>for_each 将容器中所有偶数打印出来。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// for_each可以遍历容器的所有元素，可以自行添加合适的函数对象</span><br><span class=\"hljs-comment\">// 对容器的元素进行过滤。</span><br>for_each(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <br>\t[](<span class=\"hljs-type\">int</span> val)-&gt;<span class=\"hljs-type\">void</span>   <span class=\"hljs-comment\">// 拉姆达表达式</span><br>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (val %<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\tcout &lt;&lt; val &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-绑定器\"><a href=\"#2-绑定器\" class=\"headerlink\" title=\"2. 绑定器\"></a>2. 绑定器</h3><p><strong>包含头文件：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>绑定器：绑定器 + 二元函数对象 &#x3D; 一元函数对象。</p>\n<ul>\n<li><strong>bind1st</strong>：把二元函数对象 <code>operator()(a,b)</code> 第一个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li>\n<li><strong>bind2nd</strong>：把二元函数对象 <code>operator()(a,b)</code> 第二个形参绑定起来，绑定为固定的值，只需要传入一个实参。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//78 56 52 43 42 31 21 12 9 4</span><br><span class=\"hljs-comment\">//find_if</span><br><span class=\"hljs-comment\">//将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象</span><br><span class=\"hljs-comment\">//因此我们需要绑定器</span><br><span class=\"hljs-comment\">//greater a &gt; b   less a &lt; b</span><br><span class=\"hljs-keyword\">auto</span> it2 = <span class=\"hljs-built_in\">find_if</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>(), <br>\t<span class=\"hljs-built_in\">bind1st</span>(<span class=\"hljs-built_in\">greater</span>&lt;<span class=\"hljs-type\">int</span>&gt;(), <span class=\"hljs-number\">48</span>));<br><span class=\"hljs-comment\">//bind2nd(less&lt;int&gt;(),48);</span><br><span class=\"hljs-comment\">//[](int val)-&gt;bool&#123;return val &lt; 48;&#125;); 拉姆达表达式</span><br>vec.<span class=\"hljs-built_in\">insert</span>(it2, <span class=\"hljs-number\">48</span>);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : vec)<br>&#123;<br>\tcout &lt;&lt; v &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure>\n"},{"title":"06.C++ 继承与多态","index_img":"/img/Blog-Logo/C++_Logo.png","banner_img":"/img/Post-Banner/01.blogs/1316853.jpeg","_content":"\n本节分为十部分：\n\n1. 继承的基本意义\n2. 派生类的构造过程\n3. 重载、覆盖、隐藏\n4. 虚函数、静态绑定和动态绑定\n5. 虚析构函数\n6. 理解多态是什么\n7. 理解抽象类\n8. 理解虚基类和虚继承\n9. 菱形继承问题\n10. C++ 的 四种类型转换\n\n## 1. 继承的基本意义\n\n**继承的本质：**\n\n代码的复用，实现多态的基础。\n\n**关系：**\n\n- 组合：a part of...  一部分的关系\n- 继承：a kind of... 一种的关系\n\n**继承方式和访问限定罗列：**\n\n|   |   |   |   |\n|---|---|---|---|\n|继承方式|基类的访问限定|派生类的访问限定|(main)外部的访问限定|\n|public||||\n||public|public|Y|\n||protected|protected|N|\n||private|不可见的|N|\n|protected||||\n||public|protected|N|\n||protected|protected|N|\n||private|不可见的|N|\n|private||||\n||public|private|N|\n||protected|private|N|\n||private|不可见的|N|\n\n**protected继承方式下：** **基类的成员的访问限定，在派生类里面是不可能超过继承方式的。public降为protected的。**\n\n**private继承方式下：** **public与protected降为private。**\n\n**总结：**\n\n1. 外部只能看到并使用 public 成员，protected 和 private 成员无法直接访问。\n2. 在继承结构中，派生类从基类继承来的 private 成员，然是无法直接访问（派生类中不可见）。\n3. 基类成员访问限定，在派生类里面不能超过继承方式。\n\n**protected 和 private 区别：**\n\n1. 如果只是单纯的一个类，没有继承结构，则二者没有区别，外部都是无法访问的。\n2. 若存在继承关系，在基类中定义的成员，想被派生类访问，但不想被外部访问，那么可以在基类中将该成员定义为保护型。\n3. 若存在继承关系，在基类中定义的成员，不想被派生类访问，也不想被外部访问，则可以在基类中将该成员定义为私有。\n\n**默认继承方式：**\n\n- 要看派生类是用 class 定义的，还是 struct 定义的：\n\t- 若 class 定义派生类，则默认继承方式是私有的。\n\t- 若 struct 定义派生类，则默认继承方式是共有的。\n\n**代码：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcout << \"A()\" << endl;\n\t}\n\tint ma;\n\nprotected:\n\tint mb;\n\nprivate:\n\tint mc;\n};\n\nclass B : public A\n{\npublic:\n\tB(int _md, int _mba, int _maa)\n\t\t: md(_md)\n\t\t, ma(_mba)\n\t{\n\t\tA::ma = _maa;\n\t}\n\tint md;\n\t// 作用域不同：派生类可以定义与基类同名的成员数据\n\tint ma;\n\n\tvoid func()\n\t{\n\t\tcout << md << endl;\n\t\tcout << A::ma << endl;\n\t\tcout << B::ma << endl;\n\t}\n\n\tvoid func1()\n\t{\n\t\t// 公有继承下 ：基类私有的成员在派生类中不可见\n\t\t// cout << mc << endl; \n\t\tcout << \"ok\" << endl;\n\t}\n\nprotected:\n\tint me;\n\nprivate:\n\tint mf;\n\n};\n\nint main()\n{\n\tB b(6, 7, 8);\n\tA a;\n\n\tb.func();\n\tb.func1();\n\n\tcout << \"----------------\" << endl;\n\n\tcout << sizeof(a) << endl;\t// 3 * int(4)\n\tcout << sizeof(b) << endl;\t// (3 + 4) * int(4)\n\n\treturn 0;\n}\n~~~\n\n## 2. 派生类的构造过程\n\n派生类从基类可以继承来所有的成员（成员变量和成员方法）。\n\n**派生类如何初始化基类继承的成员变量：**\n\n通过调用基类相应的构造函数来初始化\n\n- 派生类的构造函数和析构函数，负责初始化和清理派生类部分；\n- 派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数来负责。\n\n**派生类对象构造和析构过程：**\n\n1. 派生类调用基类的构造函数，初始化从基类继承来的成员。\n2. 培生类调用自己的构造函数，初始化自身的成员。\n3. ........... 派生类对象的作用域到期。\n4. 派生类调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存、文件）。\n5. 系统自动调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件）。\n\n**代码：**\n\n~~~c++\n#include<iostream>\nusing namespace std;\n\n\nclass Base\n{\npublic:\n    Base(int data) \n        : ma(data) \n    { \n        cout << \"基类构造函数：Base()\" << endl; \n    }\n\n    ~Base() \n    {\n        cout << \"基类析构函数：~Base()\" << endl; \n    }\n\nprotected:\n    int ma;\n};\n\nclass Derive : public Base\n{\npublic:\n    Derive(int data)\n        : Base(data), mb(data)\n    {\n        cout << \"派生类构造函数：Derive()\" << endl;\n    }\n    ~Derive()\n    {\n        cout << \"派生类析构函数：~Derive()\" << endl;\n    }\nprivate:\n    int mb;\n\n};\n\nint main()\n{\n    Derive d(10);\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110913834.png)\n\n## 3. 重载、覆盖、隐藏\n\n继承结构中，名字相同的成员会产生关系，基类派生类里面相关的成员方法我们经常使用三种关系来描述它们，即：**重载、隐藏、覆盖**关系。\n\n- **重载：**\n\n一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同。\n\n- **隐藏：**\n\n在继承结构当中，派生类的同名成员，把基类的同盟成员给隐藏掉了，即作用域的隐藏。\n\n- **覆盖：**\n\n父子类中的同名、同参数、同返回值的多个成员函数，从子到父形成的关系称为覆盖关系，在虚函数中会详谈它。\n\n### 1. 隐藏关系\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n\tBase(int data = 10)\n\t\t: ma(data) { }\n\n\tvoid show()\n\t{\n\t\tcout << \"Base::show()\" << endl;\n\t}\n\n\tvoid show(int)\n\t{\n\t\tcout << \"Base::show(int)\" << endl;\n\t}\n\nprivate:\n\tint ma;\n};\n\nclass Derive : public Base\n{\npublic:\n\tDerive(int data = 20) \n\t\t:Base(data), mb(data) { }\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\tDerive d;\n\td.show();\n\td.show(10);\n\n\treturn 0;\n}\n~~~\n\n派生类对象调用了不带参数的show方法，派生类本身没有这个方法。  \n执行结果：调用成功，而且**1与2是函数重载关系**。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110931669.png)\n\n我们又给派生类添加了一个不带参数的show方法：\n\n~~~c++\nclass Derive : public Base\n{\npublic:\n\tDerive(int data = 20):Base(data), mb(data){}\n\tvoid show()//3\n\t{\n\t\tcout << \"Derive::show()\" << endl;\n\t}\nprivate:\n\tint mb;\n};\n~~~\n\n派生类调用 show 时优先调用自己的 `show()`，在自己的作用域下找相应的成员名字，若没有才去基类找；当我们调用带整数参数的 `show(int)`，自己并没有，从基类继承来一个带整型参数的 `show(int)`。\n\n执行一下：第二个 `show(int)` 调用执行出错。1 与 3 属于隐藏关系；2 与 3 也属于隐藏关系。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110932089.png)\n\n第二个调用的是派生类的 `show()`，不接受参数。\n\n**为什么不调用基类中的 `show(int)`？**\n\n派生类对象调用派生类与基类同盟成员时，派生类已经有一个名字 show 了，派生类的 `show()` 将基类同盟 `show()`隐藏掉了。\n\n如果想调用基类成员函数，必须指明基类的作用域来调用：\n\n~~~c++\nDerive d;\nd.Base::show();\nd.Base::show(10);\n~~~\n\n指明作用域调用成功。  \n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110934024.png)\n\n### 2. 继承中的类型转换\n\n继承结构，我们也称为从上(基类)到下(派生类)的结构。\n\n**类型转换是否可以？**\n\n1. **基类对象——>派生类对象的转换：类型从上到下的转换(NO)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//基类对象——>派生类对象\nd = b;\n~~~\n\n执行结果：执行失败。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110942832.png)\n\n2. **派生类对象——>基类对象的转换：类型从下到上的转换(YES)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//派生类对象——>基类对象\nb = d;\n~~~\n\n执行结果：成功执行。\n\n3. **基类指针(引用)——>指向派生类对象：类型从下到上的转换(YES)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//基类指针(引用)——>派生类对象\nBase *pb = &d;\npb->show();\npb->show(10);\n~~~\n\n执行结果：成功执行。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110953689.png)\n\n4. **派生类指针(引用)——>指向基类对象：类型从上到下的转换(NO)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//派生类指针(引用)——>指向基类对象\nDerive *pd = &b;\n~~~\n\n执行结果：执行失败。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110954145.png)\n\n**总结：**\n\n在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转不安全会涉及内存的非法访问。\n\n## 4. 虚函数、静态绑定和动态绑定\n\n**覆盖：**\n\n如果派生类中的方法和基类继承的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 **virtual 虚函数** ，那么派生类的这个方法，自动被处理成虚函数，它们之间成为覆盖关系；也就是说派生类会在自己虚函数表中将从基类继承来的虚函数进行替换，替换成派生类自己的。\n\n**静态绑定：**\n\n编译时期的多态，通过函数的重载以及模板来实现，也就是说调用函数的地址在编译时期我们就可以确定，在汇编代码层次，呈现的就是 call 函数名。\n\n**动态绑定：**\n\n动态时期的多态，通过派生类重写基类的虚函数来实现。在汇编代码层次，呈现的就是 call 寄存器，寄存器的值只有运行起来才能确定。\n\n### 1. 不存在的虚函数\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nclass Base\n{\npublic:\n\tBase(int data = 10)\n\t\t: ma(data) { }\n\n\tvoid show() {\n\t\tstd::cout << \"Base::show()\" << std::endl;\n\t}\n\n\tvoid show(int data) {\n\t\tstd::cout << \"Base::show(int): \" << data << std::endl;\n\t}\n\nprivate:\n\tint ma;\n};\n\nclass Derive : public Base\n{\npublic:\n\tDerive(int data) \n\t\t:Base(data)\n\t\t, mb(data) { }\n\n\t~Derive() {}\n\n\tvoid show() {\n\t\tstd::cout << \"Derive::show()\" << std::endl;\n\t}\n\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\t// 创建类\n\tDerive d(50);\n\tBase* pb = &d;\n\n\t// 静态（编译时期）绑定(函数调用) Base::show (06F12E4h)\n\tpb->show();\n\t// Base::show (06F12BCh)\n\tpb->show(10);\n\t\n\tcout << \"---------------------\" << endl;\n\n\tcout << \"Base size:\" << sizeof(Base) << endl;\n\tcout << \"Derive size:\" << sizeof(Derive) << endl;\n\n\tcout << \"---------------------\" << endl;\n\n\tcout << typeid(pb).name() << endl;\n\tcout << typeid(*pb).name() << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111036581.png)\n\n**反汇编查看：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111039623.png)\n\n可以看到调用的都是基类的 `show()`,在编译阶段已经生成指令调用 Base 下的 show。\n\n**结果：**\n\n- 因为 pb 是 Base 类型的指针，所以调用的都是 Base 类的成员方法。  \n- 基类 Base 只有一个数据成员 ma，所以大小只有 4 字节。  \n- 派生类 Derive 继承了 ma，其次还有自己的 mb，所以有 8 字节。  \n- pb 的类型是一个 `class Base *`；  \n- `*pb` 的类型是一个 `class Base`。\n\n**图示:**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111042657.png)\n\n为什么 `Base *` 类型的指针，Derive 类型的对象，调用方法的时候是 Base 而不是 Derive 呢？\n\n原因如上图：\n\nDerive 类继承了 Base 类，导致了派生类的大小要比基类大，而 pb 的类型是基类的指针，所以通过 pb 调用方法时只能访问到 Derive 中从 Base 继承而来的方法，访问不到自己重写的方法（指针的类型限制了指针解引用的能力）。\n\n\n### 2. 基类定义虚函数\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nclass Base\n{\npublic:\n\tBase(int data = 10)\n\t\t: ma(data) { }\n\n\t~Base() {}\n\n\t// 虚基类\n\tvirtual void show() {\n\t\tcout << \"Base::show()\" << endl;\n\t}\n\n\tvoid show(int data) {\n\t\tcout << \"Base::show(int): \" << data << endl;\n\t}\n\nprivate:\n\tint ma;\n};\n\nclass Derive : public Base\n{\npublic:\n\tDerive(int data) \n\t\t:Base(data)\n\t\t, mb(data) { }\n\n\t~Derive() {}\n\n\tvoid show() {\n\t\tcout << \"Derive::show()\" << endl;\n\t}\n\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\t// 创建类\n\tDerive d(50);\n\tBase* pb = &d;\n\n\tpb->show();\n\tpb->show(10);\n\t\n\tcout << \"---------------------\" << endl;\n\n\tcout << \"Base size:\" << sizeof(Base) << endl;\n\tcout << \"Derive size:\" << sizeof(Derive) << endl;\n\n\tcout << \"---------------------\" << endl;\n\n\tcout << typeid(pb).name() << endl;\n\tcout << typeid(*pb).name() << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111047159.png)\n\n**反汇编：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111048405.png)\n\n`pb->show();` 中 pb 指针是 base 类型，如果发现 Base 中的 show 是虚函数，就进行动态绑定。\n\n~~~shell\n|63..32|31..16|15-8|7-0| \n               |AH.|AL.| \n               |AX.....| \n       |EAX............| \n|RAX...................|\n~~~\n\n1. **`mov   rax, qword ptr [pb]`**\n\n将 pb 指向的内存前 4 个字节放入 rax 寄存器，pb指向derive对象，前四个字节即 `vfptr`，将虚函数表地址加载到 rax\n\n2. **`mov   rax, qword ptr [rax]`**\n\n将 rax 的前四个字节 即 `Derive::show` 加载到 rax 中。\n\n3. **`call   qword ptr [rax]`**\n\n虚函数的地址\n\n可以看到这一次，汇编码 call 的就不是确切的函数地址了，而是寄存器 rax。\n\n那么就很好理解了：rax 寄存器里存放的是什么内容，编译阶段根本无从知晓，只能在运行的时候确定； 故为，动态绑定。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111100188.png)\n\npb的类型：Base类型，查看Base中有没有虚函数\n\n（1）Base中没有虚函数 `*pb` 识别的就是编译时期的类型 `*pb` 就是 Base 类型。\n（2） Base中有虚函数，`*pb` 识别的就是运行时期的类型 RTTI 类型为：Derive。\n\n在添加了 virtual 关键字后，对应的函数就变成了虚函数。\n\n**那么，一个类添加了虚函数，对这个类有什么影响呢？**\n\n- 如果类中定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的 `vftable` 虚函数表，虚函数表中主要存储的内容是：RTTI（Run-time Type Information）指针和虚函数的地址；当程序运行时，每一张虚函数表都会加载到内存的 `.rodata` 区（只读数据区）。\n- 一个类中定义了虚函数，那么这个类定义的对象，在运行时，内存中会多存储一个 `vfptr` 虚函数的指针，指向对应类型的虚函数表 `vftable`。\n- 一个类型定义的 n 个对象，它们的 `vfptr` 指向的都是同一张虚函数表。\n- 一个类中的虚函数个数，不影响对象内存的大小（vfptr），影响的是虚函数表 `vftable` 的大小。\n- 如果派生类中的方法和从基类继承的某个方法中返回值、函数名以及参数列表都相同，且基类方法为 virtual ，那么派生类的这个方法自动被处理为虚函数。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111110387.png)\n\n**虚函数表：**\n\n1. RTTI：存放的是类型信息，也就是（Base 或 Derive）。\n2. 偏移地址：虚函数指针相对于对象内存空间的便宜，一般 `vfptr` 都在 0 偏移位置。\n3. 之后是函数时虚函数入口地址。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111112719.png)\n\n在 Derive 类中，由于重写了 `show()`,因此在 Derive 的虚函数表中，是使用子类的 show() 方法代替了 Base 类的 `show()`。\n\n### 3. VS 工具查看虚函数表相关\n\n1. 找到\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111116949.png)\n\n打开后：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111117972.png)\n\n2. 在打开的窗口中切换到当前工程所在目录\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111119264.png)\n\n3. 输入指令\n\n可通过 dir 命令查看当前目录所有文件\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111120593.png)\n\n~~~shell\ncl XXX.cpp /d1reportSingleClassLayoutXX\n~~~\n\n第一个XXX表示源文件的名字，第二个代表你想查看的类类型，我这里就是`Derive`\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111123449.png)\n\n以看到 `class Derived` 的对象的内存布局，在派生类对象的开始包含了基类 Base 的对象，其中有一个虚表指针，指向的就是下面的`Derived::$vftable@ （virtual function table）`，表中包含了 Derived 类中所有的虚函数。\n\n## 5. 虚析构函数\n\n析构函数：可以成为虚函数，调用时候对象存在。\n\n虚析构函数：在析构函数前加上 virtual 关键字。\n\n什么时候需要把基类的析构函数必须实现成虚函数？  \n       \n基类的指针(引用)指向堆上 new 出来的派生类对象的时候，delete 调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n    Base(int data) \n        : ma(data)\n    {\n        cout << \"Base()\" << endl;\n    }\n    ~Base()\n    {\n        cout << \"~Base()\" << endl;\n    }\n\n    virtual void show()\n    {\n        cout << \"call Base::show()\" << endl;\n    }\n\nprotected:\n    int ma;\n};\n\nclass Derive : public Base\n{\npublic:\n    Derive(int data) \n        : Base(data)\n        , mb(data)\n        , ptr(new int(data))\n    {\n        cout << \"Derive()\" << endl;\n    }\n    ~Derive()\n    {\n        delete ptr;\n        cout << \"~Derive() \" << endl;\n    }\n\nprivate:\n    int mb;\n    int* ptr;\n};\n\nint main()\n{\n    Base* pb = new Derive(10);\n    // 静态绑定pb Base*   *pb Derive\n    pb->show();\n\n    delete pb;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111143308.png)\n\n**没有调用派生类的析构函数，造成内存泄漏。**\n\n**问题：**\n\npb 的配型是 Base 类型，因此 delete 调用析构函数先去 Base 找 `Base::~Base()`，对于析构函数的第哦啊用就是静态绑定，之间编译，没有机会调用派生类的析构函数，最后发生内存泄漏。\n\n**解决：**\n\n将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb 的类型是 Base 类型，调用析构时去 Base 中找 `Base::~Base` 发现它为虚函数，发生动态绑定。派生类的虚函数表中：`&Derive:: ~derive`，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。\n\n**注意：**\n\n**构造函数不能为虚函数！！！**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111146816.png)\n\n（1）从存储空间角度：\n\n虚函数对应一个 `vftable` ，这个 `vftable` 其实是存储在内存空间的。问题来了，如果构造函数是虚的，就需要通过 `vtable` 来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找 `vtable` 呢？所以构造函数不能是虚函数。\n\n（2）从使用角度：\n\n虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。\n\n\n（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\n\n\n（4）构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。\n\n（5）从实现上看，`vbtable` 在构造函数调用后才建立，因而构造函数不可能成为虚函数\n\n从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。\n\n## 6. 理解多态是什么\n\n派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。\n\n所谓“虚函数”，就是在声明时前面加了virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。  \n  \n包含虚函数的类称为“**多态类**”。  \n  \n多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。  \n  \n多态在面向对象的程序设计语言中如此重要，以至于有类和对象的概念，但是不支持多态的语言，只能被称作“基于对象的程序设计语言”，而不能被称为“面向对象的程序设计语言”。例如，Visual Basic 就是“基于对象的程序设计语言”。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    virtual void Print() { cout << \"A::Print\" << endl; }\n};\n\nclass B : public A\n{\npublic:\n    virtual void Print() { cout << \"B::Print\" << endl; }\n};\n\nclass D : public A\n{\npublic:\n    virtual void Print() { cout << \"D::Print\" << endl; }\n};\n\nclass E : public B\n{\n    virtual void Print() { cout << \"E::Print\" << endl; }\n};\n\nint main()\n{\n    A a;\n    B b;\n    D d;\n    E e;\n\n    A* pa = &a;\n    B* pb = &b;\n\n    pa->Print();\n    cout << \"-----------------\" << endl;\n\n    pa = pb;\n    pa->Print();\n    cout << \"-----------------\" << endl;\n\n    pa = &d;\n    pa->Print();\n    cout << \"-----------------\" << endl;\n\n    pa = &e;\n    pa->Print();\n\n    return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405480.png)\n\n程序中，四个类之间的派生关系如下所示：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405483.png)\n\n每个类都有同名、同参数表的虚函数 Print（每个 Print 函数声明时都加了 virtual 关键字）。根据多态的规则，对于语句`pa->Print()`，由于 Print 是虚函数，尽管 pa 是基类 A 的指针，编译时也不能确定调用的是哪个类的 Print 函数。当程序运行到该语句时，pa 指向的是哪个类的对象，调用的就是哪个类的 Print 函数。    \n  \n多态的语句调用哪个类的成员函数是在运行时才能确定的，编译时不能确定（具体原理后面会解释）。因此，多态的函数调用语句被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。\n\n### 1.多态起手式以及内存分布\n\n假设有一个基类 ClassA，一个继承了该基类的派生类 ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。\n\n在代码中运用多态这个特性时，通常以两种方式起手：\n(1) `ClassA *a = new ClassB();`\n(2) `ClassB b; ClassA *a = &b;`\n\n以上两种方式都是用基类指针去指向一个派生类实例，区别在于第 1 个用了 new 关键字而分配在堆上，第 2 个分配在栈上：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111411592.png)\n\n请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。\n以左图为例，`ClassA *a` 是一个栈上的指针。\n\n该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向 **该类的虚函数表(这里是类ClassB)** 的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。\n\n### 2. 类的虚函数表与类实例的虚函数指针\n\n首先不考虑继承的情况；如果一个类中有虚函数，那么该类就有一个虚函数表。\n\n这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。\n\n从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111417318.png)\n\n### 3. 多态代码及多重继承情况\n\n讨论了在没有继承的情况下，虚函数表的逻辑结构。\n\n那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass ClassA\n{\npublic:\n    ClassA()\n    {\n        cout << \"ClassA::ClassA();\" << endl;\n    }\n\n    virtual ~ClassA()\n    {\n        cout << \"ClassA::~ClassA();\" << endl;\n    }\n\n    void fn1()\n    {\n        cout << \"ClassA::fn1();\" << endl;\n    }\n\n    void fn2()\n    {\n        cout << \"ClassA::fn2();\" << endl;\n    }\n\n    virtual void vfn1()\n    {\n        cout << \"virtual ClassA::vfn1();\" << endl;\n    }\n\n    virtual void vfn2()\n    {\n        cout << \"virtual ClassA::vfn2();\" << endl;\n    }\n\nprivate:\n    int aData;\n};\n\nclass ClassB : public ClassA\n{\npublic:\n    ClassB()\n    {\n        cout << \"ClassB::ClassB();\" << endl;\n    }\n\n    virtual ~ClassB()\n    {\n        cout << \"ClassB::~ClassB();\" << endl;\n    }\n\n    void fn1()\n    {\n        cout << \"ClassB::fn1();\" << endl;\n    }\n\n    virtual void vfn1()\n    {\n        cout << \"virtual ClassB::vfn1();\" << endl;\n    }\n\nprivate:\n    int bData;\n};\n\nclass ClassC : public ClassA\n{\npublic:\n    ClassC()\n    {\n        cout << \"ClassC::ClassC();\" << endl;\n    }\n\n    virtual ~ClassC()\n    {\n        cout << \"ClassC::~ClassC();\" << endl;\n    }\n\n    void fn2()\n    {\n        cout << \"ClassC::fn2();\" << endl;\n    }\n\n    virtual void vfn2()\n    {\n        cout << \"virtual ClassC::vfn2();\" << endl;\n    }\n\nprivate:\n    int aData;\n};\n\nint main()\n{\n    ClassC c;\n\n    return 0;\n}\n~~~\n\n(1) ClassA 是基类, 有普通函数: `fn1()、fn2()` 。虚函数: `vfn1()、vfn2()、~ClassA()`\n(2) ClassB 继承 ClassA, 有普通函数: `fn1()`。虚函数: `vfn1()、~ClassB()`\n(3) ClassC 继承 ClassB, 有普通函数: `fn2()`。虚函数: `vfn2()、~ClassB()`\n\n基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。\n\nClassB 继承与 ClassA，其虚函数表是在 ClassA 虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的\n\n~~~c++\nClassA* a = new ClassB();\n\na->fn1();\na->fn2();\n\na->vfn1();\na->vfn2();\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111430434.png)\n\n**使用 VS 开发者工具查看：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111432206.png)\n\n这个结果不难想象，看上图，ClassA 类型的指针 a 能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同\n\n这个结果已经说明了 C++ 的隐藏、重写(覆盖)特性。\n\n同理，也就不难推导出 ClassC 的逻辑结构图了\n\n类的继承情况是: ClassC 继承 ClassB，ClassB 继承 ClassA；这是一个多次单继承的情况。(多重继承)。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111435576.png)\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111436071.png)\n\n### 4. 多继承下的虚函数表 (同时继承多个基类)\n\n多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？\n\n~~~c++\n#include <iostream>\n \nusing namespace std;\n \nclass ClassA1\n{\npublic:\n  ClassA1() { cout << \"ClassA1::ClassA1()\" << endl; }\n  virtual ~ClassA1() { cout << \"ClassA1::~ClassA1()\" << endl; }\n \n  void func1() { cout << \"ClassA1::func1()\" << endl; }\n \n  virtual void vfunc1() { cout << \"ClassA1::vfunc1()\" << endl; }\n  virtual void vfunc2() { cout << \"ClassA1::vfunc2()\" << endl; }\nprivate:\n  int a1Data;\n};\n \nclass ClassA2\n{\npublic:\n  ClassA2() { cout << \"ClassA2::ClassA2()\" << endl; }\n  virtual ~ClassA2() { cout << \"ClassA2::~ClassA2()\" << endl; }\n \n  void func1() { cout << \"ClassA2::func1()\" << endl; }\n \n  virtual void vfunc1() { cout << \"ClassA2::vfunc1()\" << endl; }\n  virtual void vfunc2() { cout << \"ClassA2::vfunc2()\" << endl; }\n  virtual void vfunc4() { cout << \"ClassA2::vfunc4()\" << endl; }\nprivate:\n  int a2Data;\n};\n \nclass ClassC : public ClassA1, public ClassA2\n{\npublic:\n  ClassC() { cout << \"ClassC::ClassC()\" << endl; }\n  virtual ~ClassC() { cout << \"ClassC::~ClassC()\" << endl; }\n \n  void func1() { cout << \"ClassC::func1()\" << endl; }\n \n  virtual void vfunc1() { cout << \"ClassC::vfunc1()\" << endl; }\n  virtual void vfunc2() { cout << \"ClassC::vfunc2()\" << endl; }\n  virtual void vfunc3() { cout << \"ClassC::vfunc3()\" << endl; }\n};\n \n \nint main()\n{\n  ClassC c;\n \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111445452.png)\n\n（1）ClassA1 是第一个基类，拥有普通函数 `func1()`，虚函数`vfunc1()、 vfunc2()`。\n（2）ClassA2 是第二个基类，拥有普通函数 `func1()`，虚函数 `vfunc1()、 vfunc2()、vfunc4()`。\n（3）ClassC 依次继承 ClassA1、ClassA2。普通函数 `func1()`,虚函数`vfunc1()、vfunc2()、vfunc3()`。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111442375.png)\n\n在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。\n\n如图，虚函数表指针 01 指向的虚函数表是以 ClassA1 的虚函数表为基础的，子类的 `ClassC::vfunc1()`,和 `vfunc2()` 的函数指针覆盖了虚函数表 01 中的虚函数指针 01 的位置、02 位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。注意：\n\n1. 子类虚函数会覆盖每一个父类的每一个同名虚函数。\n2. 父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。\n3. 父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用\n\n最后给出代码和结果：\n\n~~~c++\n\tClassA1 *a1 = new ClassC;\n\ta1->func1();               // \"ClassA1::func1()\"    隐藏子类同名函数\n\ta1->vfunc1();              // \"ClassC::vfunc1()\"    覆盖父类ClassA1虚函数\n\ta1->vfunc2();              // \"ClassC::vfunc2()\"    覆盖父类ClassA1虚函数\n\t没有a1->vfunc3()，父类没有这个虚函数\n\n\tClassA2 *a2 = new ClassC;\n\ta2->func1();               // \"ClassA2::func1()\"    隐藏子类同名函数\n\ta2->vfunc1();              // \"ClassC::vfunc1()\"    覆盖父类ClassA2虚函数\n\ta2->vfunc2();              // \"ClassC::vfunc2()\"    覆盖父类ClassA2虚函数\n\ta2->vfunc4();              // \"ClassA2::vfunc4()\"   未被子类重写的父类虚函数\n\n\tClassC *c = new ClassC;\n\tc->func1();                // \"ClassC::func1()\"\n\tc->vfunc1();               // \"ClassC::vfunc1()\"\n\tc->vfunc2();               // \"ClassC::vfunc2()\"\n\tc->vfunc3();               // \"ClassC::vfunc3()\"\n\tc->vfunc4();               // \"ClassA2::func4()\"\n~~~\n\n## 7. 理解抽象类\n\n抽象类(接口)：接口描述了类的行为和功能,而无需完成类的特定实现\n\nC++ 接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用\n\n**注意:**\n\n如果试图实例化一个抽象类的对象，会导致编译错误。\n\n因此，如果一个抽象类的派生类需要被实例化(建立对象)，则必须对每个继承来的纯虚函数进行函数体实现。\n如果没有在派生类中重写所有纯虚函数，就尝试实例化派生类的对象，也会导致编译错误，这是因为如果派生类没有实现父类的纯虚函数，则派生类变为抽象类。\n\n抽象类基类为派生自抽象基类的派生类提供了约束条件，即：派生类必须要实现继承自抽象基类中的纯虚函数，否则此派生类不可进行实例化，且派生类将继承为抽象派生类。\n\n### 1. 抽象类与纯虚函数（抽象方法）\n\n**纯虚函数**是一个在 **基类中声明的虚函数**，它在该基类中**没有定义具体的函数体**(操作内容),要求**派生类根据实际需要定义自己的版本**，设计多层次类继承关系时用到。把某个方法声明为一个抽象方法等于告诉编译器,这个方法**必不可少**，但目前在基类中还不能为它提供实现\n\n纯虚函数的标准格式：\n\n~~~c++\nvirtual 函数类型 函数名（参数表）= 0;\n~~~\n\n~~~c++\nclass Pet\n{\npublic:\n\tvirtual void func() = 0;// 声明了一个纯虚函数 也就是在虚函数尾部加上\" = 0 \" 一个虚函数便被声明成为了一个纯虚函数\n\t// 等于 0 表示该函数仅声明而没有函数体\n};\n~~~\n\n**注意：**\n\n一旦类中有了纯虚函数，这个类便被称为：**抽象类**。\n\n> **且此类不能被实例化！！！（不可建立类对象实例！！！）**\n\n例如：\n\n~~~c++\nint main() \n{\n\t// 报错！带有纯虚函数的类称为抽象类，不可实例化\n\tPet pet; \n}\n~~~\n\n**抽象类：**\n\n只能作为积累使用，无法定义抽象类对象实例，这是因为 **抽象类中包含了没有定义的纯虚函数**，在 C++ 中，我们把 **只能由于被继承而不能直接创建对象的类** 称之为：**抽象类**，这种基类不能直接生成对象，而只有被继承后，并重写其虚函数后，才能使用。\n\n当抽象类的派生类实现了继承而来的纯虚函数后，才能实例化对象。\n\n之所以要存在抽象类，最主要是因为它具有不确定因素，我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为虚函数。虚函数是一种特殊的函数，在抽象类中只有声明，没有具体的定义。\n\n**抽象类和纯虚函数的关系**\n\n抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类，存在纯虚函数是成为抽象类的充要条件。\n\n### 2. 为什么需要一个抽象类\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// todonew 与 delete 动态分配内存,与用指针调用对象 通过对象的不同调用不同的同名虚函数\nclass Pet // 声明纯虚函数 sound 后 Pet 类变为抽象类(接口)\n{\npublic:\n    Pet(string thename);\n    void sleep();\n    virtual void sound() = 0;// 声明纯虚函数 sound  (并未进行函数实现 函数实现放在派生类中)\n\n    //注意:\t\t\t\t\t   \n    //todo1.继承自抽象基类 Pet 的子类必须全部实现基类中的所有纯虚函数\n    //todo2.抽象基类 Pet 不可进行实例化\n\nprotected:\n    string name;\n};\n\nclass Cat :public Pet\n{\npublic:\n    Cat(string thename);\n    void climb();\n    void sound();\n};\n\nclass Dog :public Pet\n{\npublic:\n    Dog(string thename);\n    void jump();\n    void sound();\n};\n\n\nPet::Pet(string thename) // todo 基类构造器(抽象类也有构造函数)\n{\n    name = thename;\n}\n\nvoid Pet::sleep()\n{\n    cout << name << \"正在睡大觉\\n\";\n}\n\nvoid Pet::sound()\n{\n    cout << name << \"动物发声\\n\";\n}\n\nCat::Cat(string thename) :Pet(thename) // 派生类 Cat 构造函数\n{\n}\n\nvoid Cat::climb()\n{\n    cout << name << \"正在爬树\\n\";\n}\n\nvoid  Cat::sound() // 派生类虚函数\n{\n\n    //\tPet::sound(); // todo 如果需要调用基类中的 play() 函数  在原本的play()函数的基础上加上覆盖上的子类play()函数\n    cout << name << \"喵喵喵!\\n\";\n}\n\n\nDog::Dog(string thename) :Pet(thename)// 派生类 Dog 构造函数\n{\n}\n\nvoid Dog::jump()\n{\n    cout << name << \"跳过了栅栏\\n\";\n}\n\nvoid Dog::sound() // 派生类虚函数\n{\n    //\tPet::sound();\n    cout << name << \"汪汪汪!\\n\";\n}\n\nvoid func(Pet* x)\n{\n    x->sound();\n}\n\n\nint main()\n{\n    //\tPet pet; // todo 用带有抽象方法(纯虚函数)的抽象类 Pet 无法实例化对象\n\n    // todo 创建指向子类实例的基类指针和引用来调用纯虚函数\n    Pet* cat = new Cat(\"猫\");\n    Pet* dog = new Dog(\"狗\");\n\n    // todo 创建对象实例来调用纯虚函数\n    Cat cat2(\"对象实例调用 猫\");\n    cat2.sound();\n\n    func(cat);\n    func(dog);\n\n    return 0;\n}\n~~~\n\n本例中定义了三个类,它们的继承关系为：`Animal-->Cat`和`Animal-->Dog`\n\nAnimal 是一个抽象类，也是最顶层的基类，在 Animal 类中定义了一个**纯虚函数**`sound()`，在 `Cat` 类中，实现了`sound()`函数。所谓实现，就是定义了纯虚函数的函数体，抽象类 Animal 虽然不能实例化，但它为派生类提供了**约束条件**，派生类必须要实现这个函数，完成动物发声功能，否则就不能对派生类进行实例化。\n\n在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的，虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111557893.png)\n\n**总结：**\n\n1. 任何具有纯虚函数的类都是抽象类。\n2. 抽象类基类不可建立实例。\n3. 抽象类派生出的子类需将继承的纯虚函数全部进行实例化，才能建立其实例。\n4. 抽象类可以有构造函数。\n5. 如果派生类没有实现父类的纯虚函数，则派生类变为抽象类，即不可建立其实例。\n6. 抽象基类除了约束派生类的功能，还可以实现多态，可以创建指向子类的实例的抽象基类的指针和引用。\n7. 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。\n\n## 8. 理解虚基类和虚继承\n\n**virtual作用：**\n\n1. virtual 修饰了成员方法是虚函数。  \n2. 可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。\n\n- **vfptr**：一个类有虚函数，这个类生成的对象就有 vfptr，指向 vftable。  \n- **vbptr**：在派生类中从基类虚继承而来。  \n- **vftable**：第一行为向上偏移量，第二行为虚基类指针离虚基类内存的偏移量。  \n- **vbtable**：存放的 RTTI 指针，指向运行时 RTTI 信息与虚函数地址。\n\n~~~c++\nclass A\n{\npublic:\nprivate:\n\tint ma;\n};\n\nclass B : public A\n{\npublic:\nprivate:\n\tint mb;\n};\n\n//A a; 4个字节\n//B b; 8个字节\n~~~\n\n这里我们的对象 a 占 4 个字节，对象 8 占 8 个字节。但如果我们给 B 的继承方式访问限定符前面加了一个 virtual 关键字。\n\n~~~c++\nclass B : virtual public A\n{\npublic:\nprivate:\n\tint mb;\n};\n~~~\n\n**类 A 被虚继承了，但内存布局没有变化：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111611448.png)\n\n**类 B 在继承普通基类的内存变化：**\n\n![](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111612673.png)\n\n再看一下类 B，不是之前的 8 个字节，变为 12 个字节，多了一个 vbptr 指针。原来最上面应该为 ma 与 mb，但是现在多了一个 `vbptr`(虚基类指针)，ma 跑到派生类最后面去了。`vbptr` 指向的是 `vbtable`，`vbtable` 第一行为 0，第二行为虚基类指针到虚基类数据的偏移量。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111614890.png)\n\n当遇到虚继承时候，要考虑派生类 B 的内存布局时；\n\n首先，先不考虑虚继承，类 B 继承了基类的 ma，还有自己的mb；当基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个 `vbptr`。派生类的内存就由这几部分来构成。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111618147.png)\n\n虚基类指针(`vbptr`)指向虚基类表(`vbtable`)，`vbtable` 第一行为向上的偏移量，因为 `vbptr` 在该派生类内存起始部分，因此向上的偏移量为 0；第二行为向下的偏移量(`vbptr` 离虚基类数据的偏移量)，原来基类的数据放到最后，找 ma 的时候还是在最开始找，但 ma 被移动，根据偏移的字节就可以找到。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111619886.png)\n\n\n### 1. 虚基类和虚继承出错情况分析\n\n**那么当我们虚基类指针与虚函数指针在一起出现的时候会发生什么呢？**\n\n调用是没有问题的，但是 delete 会出错。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tvirtual void func()\n\t{\n\t\tcout << \"call A::func\" << endl;\n\t}\nprivate:\n\tint ma;\n};\n\nclass B : virtual public A\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call B::func()\" << endl;\n\t}\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\t// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。\n\tA* p = new B();// B::vftable\n\tp->func();\n\tdelete p;\n\n\treturn 0;\n}\n~~~\n\n如图：调用成功，但delete时会出错。  \n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111623556.png)\n\n**分析：**\n\nB 的内存布局：\n\nB 首先从 A 中获取 `vfptr` 与 ma， B 中还有自身的 mb；\n此时 A 被虚继承，A 中所有的东西都移动到派生类最后面，最上面补一个`vbptr`，`vbptr` 指向 `vbtable`，`vfptr` 指向 `vftable`；基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。\n\n普通情况下，派生类内存布局先是基类，在是派生类，基类指针指向派生类对象时，基类指针指向的就是派生类内存的起始部分。但是，虚继承下基类称为虚基类，虚基类的数据在派生类最后面，原地方补上 `vbptr`，此时再用基类指针指向派生类对象时候，基类指针永远指向派生类基类部分的起始地址。虚基类一开始就是 `vfptr`，能够用 p 指向的对象访问 `vfptr` 与 `vftable` 的原因。释放内存时候出错，因为对象开辟是在最上面即绿色部分，但是 p 所持有的是虚基类的地址，delete 时从虚基类起始地址 delete，因此出错。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111627334.png)\n\n\n命令验证如下：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111628141.png)\n\n**验证一下内存地址：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tvirtual void func()\n\t{\n\t\tcout << \"call A::func\" << endl;\n\t}\n\tvoid operator delete(void* ptr)\n\t{\n\t\tcout << \"operator delete p:\" << ptr << endl;\n\t\tfree(ptr);\n\t}\nprivate:\n\tint ma;\n};\n\nclass B : virtual public A\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call B::func()\" << endl;\n\t}\n\n\tvoid* operator new(size_t size)\n\t{\n\t\tvoid* p = malloc(size);\n\t\tcout << \"operator new p:\" << p << endl;\n\t\treturn p;\n\t}\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\tA* p = new B(); // B::vftable\n\tcout << \"main p:\" << p << endl;\n\tp->func();\n\tdelete p;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111629072.png)\n\n`00000119E9411CB0` 为分配的内存的起始地址，我们用基类指针指向派生类对象一定是指向派生类内存基类的起始部分：`00000119E9411CC0` 刚好比 `00000119E9411CB0` 多了 16 个字节，是 `vbptr` 与 mb，但是 delete 时候从 `00000119E9411CC0` 开始释放，因此崩溃。\n\nWindows 的 VS 下这样写会出错，但是 Linux 下的 `g++ delete` 时会自动偏移到 new 内存的起始部分，进行内存 `free()`，不会出错。\n\n如果在栈上开辟内存，基类指针指向派生类对象，出了作用域自己进行析构，这样是没有问题的。\n\n~~~c++\nB b;\nA *p = &b; // B::vftable\ncout << \"main p:\" << p << endl;\np->func();\n~~~\n\n## 9. 菱形继承问题\n\n**多重继承：** 一个`派生类`如果只继承一个`基类`，称作单继承； 一个`派生类`如果继承了多个`基类`，称作多继承。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111602992.png)\n\n**优点：**\n\n- 多重继承可以做更多的代码复用！\n- 派生类通过多重继承，可以得到多个基类的数据和方法，更大程度的实现了代码复用。\n\n**问题：**\n\n菱形继承的问题：在于继承时有重复利用的数据。\n\n**会导致派生类有多份间接基类的数据，可以采用虚继承来解决。** **A 为 B、C 的基类，B 从 A 单继承而来，C 从 A 也是单继承而来；D 是 B 和 C 多继承而来，D 有两个基类分别为 B 和 C。A 称为 D 的间接基类，D 也有 A 的数据。**\n\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111637497.png)\n\n当然，多重继承还会出现别的问题：\n\n**半圆形继承问题：** **B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111638517.png)\n\n多重继承虽然可以复用多个基类的代码到派生类中，但是会出现许多问题，因此 C++ 开源代码上很少见到多重继承。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA(int data) : ma(data)\n\t{\n\t\tcout << \"A()\" << endl;\n\t}\n\t~A()\n\t{\n\t\tcout << \"~A()\" << endl;\n\t}\nprotected:\n\tint ma;\n};\n\nclass B : public A\n{\npublic:\n\tB(int data) : A(data), mb(data)\n\t{\n\t\tcout << \"B()\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"~B()\" << endl;\n\t}\nprotected:\n\tint mb;\n};\n\nclass C : public A\n{\npublic:\n\tC(int data) : A(data), mc(data)\n\t{\n\t\tcout << \"C()\" << endl;\n\t}\n\t~C()\n\t{\n\t\tcout << \"~C()\" << endl;\n\t}\nprotected:\n\tint mc;\n};\n\nclass D : public B, public C\n{\npublic:\n\tD(int data) : B(data), C(data), md(data)\n\t{\n\t\tcout << \"D()\" << endl;\n\t}\n\t~D()\n\t{\n\t\tcout << \"~D()\" << endl;\n\t}\nprotected:\n\tint md;\n};\n\nint main()\n{\n\tD d(10);\n\n\treturn 0;\n}\n\n~~~\n\n画一下 d 对象的内存布局：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641312.png)\n\nD 能看见 B，C 与 md，所以 D 在构造时调用 B，C 的构造及 ma 的初始化。 ma 的初始化在 B 与 C 的构造函数中进行，因此 D 内存为 20 个字节。\n\n输出结果：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641957.png)\n\n先是 A 的构造，B 的构造，又是 A 的构造，C 的构造，最后是 D 的构造；析构顺序与其相反。就会发现，D 这个派生类中调用了两次 A 的构造，数据重复，浪费内存，这种情况必须被杜绝。\n\n**如何处理？**\n\n**虚继承来处理，所有从A继承而来的地方都采用虚继承，A 就为虚基类。**\n\n此时：\nB 从 A 虚继承而来，A 为虚基类，`A::ma` 移动到派生类最后面，在 `A::ma` 位置上补一个 `vbptr`；C 也是从 A 虚继承而来，`A::ma` 移动到派生类最后面，但发现已经有一份同样的虚基类的数据，那么 C 的 `A::ma` 丢弃，在 `A::ma` 位置存放 `vbptr`。此时派生类中只有一份基类 `A::ma` 的数据，以后访问都是同一个 ma；同时 ma 的初始化由 D 来负责。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111645047.png)\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA(int data) : ma(data)\n\t{\n\t\tcout << \"A()\" << endl;\n\t}\n\t~A()\n\t{\n\t\tcout << \"~A()\" << endl;\n\t}\nprotected:\n\tint ma;\n};\n\nclass B : virtual public A\n{\npublic:\n\tB(int data) : A(data), mb(data)\n\t{\n\t\tcout << \"B()\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"~B()\" << endl;\n\t}\nprotected:\n\tint mb;\n};\n\nclass C : virtual public A\n{\npublic:\n\tC(int data) : A(data), mc(data)\n\t{\n\t\tcout << \"C()\" << endl;\n\t}\n\t~C()\n\t{\n\t\tcout << \"~C()\" << endl;\n\t}\nprotected:\n\tint mc;\n};\n\nclass D : public B, public C\n{\npublic:\n\tD(int data) : A(data), B(data), C(data), md(data)\n\t{\n\t\tcout << \"D()\" << endl;\n\t}\n\t~D()\n\t{\n\t\tcout << \"~D()\" << endl;\n\t}\nprotected:\n\tint md;\n};\n\nint main()\n{\n\tD d(10);\n\n\treturn 0;\n}\n~~~\n\n打印结果：修改成功；A、B、C、D各初始化与析构一次。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111646462.png)\n\n## 10. C++ 的 四种类型转换\n\n> 1. const_cast\n> 2. static_cast\n> 3. reinterpert_cast\n> 4. dynamic_cast\n\n### 1. const_cast\n\n**const_cast：修改类型的const或volatile属性。** 使用该运算方法可以返回一个指向非常量的指针（或引用）指向，就可以通过该指针（或引用）对它的数据成员任意改变。\n\n**注意：**  \n\n不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。  \n\n**语法：**\n\n~~~c++\nconst_cast<里面必须是指针或引用类型>\n~~~\n\n**实例：**\n\n~~~c++\nconst int a = 10;\nint *p1 = (int*)&a;// C 中类型转换\nint *p2 = const_cast<int*>(&a);// C++ 中类型转换 const_cast\n~~~\n\n转换为相同类型的时候，通过反汇编查看时候，发现 C 中的类型强转与 C++ 中 `const_cast` 所生成的汇编指令底层是一模一样的。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111757973.png)\n\n但是在转换成汇编指令之前，即编译阶段，就有所不同。\n\n**注意：**\n\n1. **不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。**\n\n~~~c++\nconst int a = 10;\n// C 中类型转换，可以\nchar *p1 = (char*)&a;\n// C++ 中类型转换 const_cast，不可以\nchar *p2 = const_cast<char*>(&a);\n~~~\n\n通过 C中类型转换可以将 `int *` 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过 `const_cast` 将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。`const_cast`使用时，地址的类型是与左边类型以及转换的类型需要保持一致。防止了 C 中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。\n\n编译出错：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111806390.png)\n\n2. **`const_cast<里面必须是指针或引用类型>`，否则出错**\n\n~~~c++\nconst int a = 10;\nint b = const_cast<int>(a);\n~~~\n\n编译出错：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111807110.png)\n\n### 2. static_cast\n\n**`static_cast(静态)`：编译时期的类型转换，提供编译器认为安全的类型转换。**\n\n是一个 c++ 运算符，功能是把一个表达式转换为某种类型，使用最多。\n\n**注意：**\n\n1. **有联系的类型之间可以互相转换。**\n2. **没有任何联系的类型之前转换会被否定。**\n3. **基类类型与派生类类型进行转换，可以用 `static_cast`，它们类型之间有关系，但不一定安全。**\n\n**实例：**\n\n1. 有联系的类型之间可以互相转换\n\n~~~c++\nint a = 10;\nchar b = static_cast<int>(a);\n~~~\n\n编译成功，int 与 char 直之间有联系。\n\n2. 有任何联系的类型之间的转换会被否定\n\n~~~c++\nint* p = nullptr;\n// double* = (double*)p; C 可以转换\ndouble* b = static_cast<double*>(p);\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111811911.png)\n\n### 3. reinterpert_cast\n\n**`reinterpret_cast`：类似于 C 风格的强制类型转换，是 C++ 里的强制类型转换符，不安全。**\n\n**注意：**\n\n1. 如果非要进行没有任何联系的类型转换，可以使用 `reinterpret_cast`。\n\n**实例：** \n\n1. 如果非要进行没有任何联系的类型转换，可以使用 `reinterpret_cast`。\n\n~~~c++\nint *p = nullptr;\ndouble* b = reinterpret_cast<double*>(p);\n~~~\n\n`reinterpret_cast` 与 C 中类型转换类似，转换成功，不安全。\n\n### 4. dynamic_cast\n\n**`dynamic_cast`(动态)：运行时期的类型转换，用于继承结构中，可以支持 RTTI 类型识别的上下转换及识别。**\n\n**将一个基类对象指针（或引用）转换到继承类指针，`dynamic_cast` 会根据基类指针是否真正指向继承类指针来做相应处理。**\n\n~~~c++\nclass Base\n{\npublic:\n\tvirtual void func() = 0;\n};\n\nclass Derive1 : public Base\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call Derive1::func\" << endl;\n\t}\n};\n\nclass Derive2 : public Base\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call Derive2::func\" << endl;\n\t}\n};\n\nvoid showFunc(Base* p)\n{\n\tp->func();//动态绑定\n}\n\nint main()\n{\n\tDerive1 d1;\n\tDerive1 d2;\n\t\n\tshowFunc(&d1);\n\tshowFunc(&d2);\n\n\treturn 0;\n}\n~~~\n\n执行结果：执行成功。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111838785.png)\n\n需求改变了，`Derive` 实现了一个新功能的 API 接口函数。\n\n~~~c++\nclass Derive2 : public Base\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call Derive2::func\" << endl;\n\t}\n\t//需求更改 Derive2实现新功能的API接口函数\n\tvoid derive02func()\n\t{\n\t\tcout << \"call derive02func()::func\" << endl;\n\t}\n};\n~~~\n\n`void show()` 应该区分判断一下，如果 `Base* p` 指向了其他的派生类对象，调用 `p->func()` 方法就好。但如果指向 Derive2 对象，不调用 `func()` 方法，而调用 Derive2 的 `derive02 func()`方法。该如何做呢？\n\n这里就要识别 `*p` 的类型，看它指向哪个对象。此时就需要`dynamic_cast()`了。dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象；`p->vfptr->vftable` RTTI 信息 如果是 `dynamic_cast`，转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr。\n\n~~~c++\nvoid showFunc(Base* p)\n{\n\t// dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象\n\t// p->vfptr->vftable RTTI 信息 如果是 dynamic_cast，\n\t// 转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr\n\tDerive2 *pd2 = dynamic_cast<Derive2*>(p);\n\tif (pd2 != nullptr)\n\t{\n\t\tpd2->derive02func();\n\t}\n\telse\n\t{\n\t\tp->func();//动态绑定\n\t}\n}\n~~~\n\n指向结果：调用成功。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111845822.png)\n\n","source":"_posts/02.C++ 基础部分/06.C++ 继承与多态.md","raw":"---\ntitle: 06.C++ 继承与多态\ntags: [C++]\nindex_img: /img/Blog-Logo/C++_Logo.png\nbanner_img: /img/Post-Banner/01.blogs/1316853.jpeg\n---\n\n本节分为十部分：\n\n1. 继承的基本意义\n2. 派生类的构造过程\n3. 重载、覆盖、隐藏\n4. 虚函数、静态绑定和动态绑定\n5. 虚析构函数\n6. 理解多态是什么\n7. 理解抽象类\n8. 理解虚基类和虚继承\n9. 菱形继承问题\n10. C++ 的 四种类型转换\n\n## 1. 继承的基本意义\n\n**继承的本质：**\n\n代码的复用，实现多态的基础。\n\n**关系：**\n\n- 组合：a part of...  一部分的关系\n- 继承：a kind of... 一种的关系\n\n**继承方式和访问限定罗列：**\n\n|   |   |   |   |\n|---|---|---|---|\n|继承方式|基类的访问限定|派生类的访问限定|(main)外部的访问限定|\n|public||||\n||public|public|Y|\n||protected|protected|N|\n||private|不可见的|N|\n|protected||||\n||public|protected|N|\n||protected|protected|N|\n||private|不可见的|N|\n|private||||\n||public|private|N|\n||protected|private|N|\n||private|不可见的|N|\n\n**protected继承方式下：** **基类的成员的访问限定，在派生类里面是不可能超过继承方式的。public降为protected的。**\n\n**private继承方式下：** **public与protected降为private。**\n\n**总结：**\n\n1. 外部只能看到并使用 public 成员，protected 和 private 成员无法直接访问。\n2. 在继承结构中，派生类从基类继承来的 private 成员，然是无法直接访问（派生类中不可见）。\n3. 基类成员访问限定，在派生类里面不能超过继承方式。\n\n**protected 和 private 区别：**\n\n1. 如果只是单纯的一个类，没有继承结构，则二者没有区别，外部都是无法访问的。\n2. 若存在继承关系，在基类中定义的成员，想被派生类访问，但不想被外部访问，那么可以在基类中将该成员定义为保护型。\n3. 若存在继承关系，在基类中定义的成员，不想被派生类访问，也不想被外部访问，则可以在基类中将该成员定义为私有。\n\n**默认继承方式：**\n\n- 要看派生类是用 class 定义的，还是 struct 定义的：\n\t- 若 class 定义派生类，则默认继承方式是私有的。\n\t- 若 struct 定义派生类，则默认继承方式是共有的。\n\n**代码：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA()\n\t{\n\t\tcout << \"A()\" << endl;\n\t}\n\tint ma;\n\nprotected:\n\tint mb;\n\nprivate:\n\tint mc;\n};\n\nclass B : public A\n{\npublic:\n\tB(int _md, int _mba, int _maa)\n\t\t: md(_md)\n\t\t, ma(_mba)\n\t{\n\t\tA::ma = _maa;\n\t}\n\tint md;\n\t// 作用域不同：派生类可以定义与基类同名的成员数据\n\tint ma;\n\n\tvoid func()\n\t{\n\t\tcout << md << endl;\n\t\tcout << A::ma << endl;\n\t\tcout << B::ma << endl;\n\t}\n\n\tvoid func1()\n\t{\n\t\t// 公有继承下 ：基类私有的成员在派生类中不可见\n\t\t// cout << mc << endl; \n\t\tcout << \"ok\" << endl;\n\t}\n\nprotected:\n\tint me;\n\nprivate:\n\tint mf;\n\n};\n\nint main()\n{\n\tB b(6, 7, 8);\n\tA a;\n\n\tb.func();\n\tb.func1();\n\n\tcout << \"----------------\" << endl;\n\n\tcout << sizeof(a) << endl;\t// 3 * int(4)\n\tcout << sizeof(b) << endl;\t// (3 + 4) * int(4)\n\n\treturn 0;\n}\n~~~\n\n## 2. 派生类的构造过程\n\n派生类从基类可以继承来所有的成员（成员变量和成员方法）。\n\n**派生类如何初始化基类继承的成员变量：**\n\n通过调用基类相应的构造函数来初始化\n\n- 派生类的构造函数和析构函数，负责初始化和清理派生类部分；\n- 派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数来负责。\n\n**派生类对象构造和析构过程：**\n\n1. 派生类调用基类的构造函数，初始化从基类继承来的成员。\n2. 培生类调用自己的构造函数，初始化自身的成员。\n3. ........... 派生类对象的作用域到期。\n4. 派生类调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存、文件）。\n5. 系统自动调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件）。\n\n**代码：**\n\n~~~c++\n#include<iostream>\nusing namespace std;\n\n\nclass Base\n{\npublic:\n    Base(int data) \n        : ma(data) \n    { \n        cout << \"基类构造函数：Base()\" << endl; \n    }\n\n    ~Base() \n    {\n        cout << \"基类析构函数：~Base()\" << endl; \n    }\n\nprotected:\n    int ma;\n};\n\nclass Derive : public Base\n{\npublic:\n    Derive(int data)\n        : Base(data), mb(data)\n    {\n        cout << \"派生类构造函数：Derive()\" << endl;\n    }\n    ~Derive()\n    {\n        cout << \"派生类析构函数：~Derive()\" << endl;\n    }\nprivate:\n    int mb;\n\n};\n\nint main()\n{\n    Derive d(10);\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110913834.png)\n\n## 3. 重载、覆盖、隐藏\n\n继承结构中，名字相同的成员会产生关系，基类派生类里面相关的成员方法我们经常使用三种关系来描述它们，即：**重载、隐藏、覆盖**关系。\n\n- **重载：**\n\n一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同。\n\n- **隐藏：**\n\n在继承结构当中，派生类的同名成员，把基类的同盟成员给隐藏掉了，即作用域的隐藏。\n\n- **覆盖：**\n\n父子类中的同名、同参数、同返回值的多个成员函数，从子到父形成的关系称为覆盖关系，在虚函数中会详谈它。\n\n### 1. 隐藏关系\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n\tBase(int data = 10)\n\t\t: ma(data) { }\n\n\tvoid show()\n\t{\n\t\tcout << \"Base::show()\" << endl;\n\t}\n\n\tvoid show(int)\n\t{\n\t\tcout << \"Base::show(int)\" << endl;\n\t}\n\nprivate:\n\tint ma;\n};\n\nclass Derive : public Base\n{\npublic:\n\tDerive(int data = 20) \n\t\t:Base(data), mb(data) { }\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\tDerive d;\n\td.show();\n\td.show(10);\n\n\treturn 0;\n}\n~~~\n\n派生类对象调用了不带参数的show方法，派生类本身没有这个方法。  \n执行结果：调用成功，而且**1与2是函数重载关系**。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110931669.png)\n\n我们又给派生类添加了一个不带参数的show方法：\n\n~~~c++\nclass Derive : public Base\n{\npublic:\n\tDerive(int data = 20):Base(data), mb(data){}\n\tvoid show()//3\n\t{\n\t\tcout << \"Derive::show()\" << endl;\n\t}\nprivate:\n\tint mb;\n};\n~~~\n\n派生类调用 show 时优先调用自己的 `show()`，在自己的作用域下找相应的成员名字，若没有才去基类找；当我们调用带整数参数的 `show(int)`，自己并没有，从基类继承来一个带整型参数的 `show(int)`。\n\n执行一下：第二个 `show(int)` 调用执行出错。1 与 3 属于隐藏关系；2 与 3 也属于隐藏关系。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110932089.png)\n\n第二个调用的是派生类的 `show()`，不接受参数。\n\n**为什么不调用基类中的 `show(int)`？**\n\n派生类对象调用派生类与基类同盟成员时，派生类已经有一个名字 show 了，派生类的 `show()` 将基类同盟 `show()`隐藏掉了。\n\n如果想调用基类成员函数，必须指明基类的作用域来调用：\n\n~~~c++\nDerive d;\nd.Base::show();\nd.Base::show(10);\n~~~\n\n指明作用域调用成功。  \n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110934024.png)\n\n### 2. 继承中的类型转换\n\n继承结构，我们也称为从上(基类)到下(派生类)的结构。\n\n**类型转换是否可以？**\n\n1. **基类对象——>派生类对象的转换：类型从上到下的转换(NO)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//基类对象——>派生类对象\nd = b;\n~~~\n\n执行结果：执行失败。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110942832.png)\n\n2. **派生类对象——>基类对象的转换：类型从下到上的转换(YES)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//派生类对象——>基类对象\nb = d;\n~~~\n\n执行结果：成功执行。\n\n3. **基类指针(引用)——>指向派生类对象：类型从下到上的转换(YES)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//基类指针(引用)——>派生类对象\nBase *pb = &d;\npb->show();\npb->show(10);\n~~~\n\n执行结果：成功执行。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110953689.png)\n\n4. **派生类指针(引用)——>指向基类对象：类型从上到下的转换(NO)**\n\n~~~c++\nBase b(10);\nDerive d(20);\n\n//派生类指针(引用)——>指向基类对象\nDerive *pd = &b;\n~~~\n\n执行结果：执行失败。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110954145.png)\n\n**总结：**\n\n在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转不安全会涉及内存的非法访问。\n\n## 4. 虚函数、静态绑定和动态绑定\n\n**覆盖：**\n\n如果派生类中的方法和基类继承的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 **virtual 虚函数** ，那么派生类的这个方法，自动被处理成虚函数，它们之间成为覆盖关系；也就是说派生类会在自己虚函数表中将从基类继承来的虚函数进行替换，替换成派生类自己的。\n\n**静态绑定：**\n\n编译时期的多态，通过函数的重载以及模板来实现，也就是说调用函数的地址在编译时期我们就可以确定，在汇编代码层次，呈现的就是 call 函数名。\n\n**动态绑定：**\n\n动态时期的多态，通过派生类重写基类的虚函数来实现。在汇编代码层次，呈现的就是 call 寄存器，寄存器的值只有运行起来才能确定。\n\n### 1. 不存在的虚函数\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nclass Base\n{\npublic:\n\tBase(int data = 10)\n\t\t: ma(data) { }\n\n\tvoid show() {\n\t\tstd::cout << \"Base::show()\" << std::endl;\n\t}\n\n\tvoid show(int data) {\n\t\tstd::cout << \"Base::show(int): \" << data << std::endl;\n\t}\n\nprivate:\n\tint ma;\n};\n\nclass Derive : public Base\n{\npublic:\n\tDerive(int data) \n\t\t:Base(data)\n\t\t, mb(data) { }\n\n\t~Derive() {}\n\n\tvoid show() {\n\t\tstd::cout << \"Derive::show()\" << std::endl;\n\t}\n\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\t// 创建类\n\tDerive d(50);\n\tBase* pb = &d;\n\n\t// 静态（编译时期）绑定(函数调用) Base::show (06F12E4h)\n\tpb->show();\n\t// Base::show (06F12BCh)\n\tpb->show(10);\n\t\n\tcout << \"---------------------\" << endl;\n\n\tcout << \"Base size:\" << sizeof(Base) << endl;\n\tcout << \"Derive size:\" << sizeof(Derive) << endl;\n\n\tcout << \"---------------------\" << endl;\n\n\tcout << typeid(pb).name() << endl;\n\tcout << typeid(*pb).name() << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111036581.png)\n\n**反汇编查看：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111039623.png)\n\n可以看到调用的都是基类的 `show()`,在编译阶段已经生成指令调用 Base 下的 show。\n\n**结果：**\n\n- 因为 pb 是 Base 类型的指针，所以调用的都是 Base 类的成员方法。  \n- 基类 Base 只有一个数据成员 ma，所以大小只有 4 字节。  \n- 派生类 Derive 继承了 ma，其次还有自己的 mb，所以有 8 字节。  \n- pb 的类型是一个 `class Base *`；  \n- `*pb` 的类型是一个 `class Base`。\n\n**图示:**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111042657.png)\n\n为什么 `Base *` 类型的指针，Derive 类型的对象，调用方法的时候是 Base 而不是 Derive 呢？\n\n原因如上图：\n\nDerive 类继承了 Base 类，导致了派生类的大小要比基类大，而 pb 的类型是基类的指针，所以通过 pb 调用方法时只能访问到 Derive 中从 Base 继承而来的方法，访问不到自己重写的方法（指针的类型限制了指针解引用的能力）。\n\n\n### 2. 基类定义虚函数\n\n~~~c++\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nclass Base\n{\npublic:\n\tBase(int data = 10)\n\t\t: ma(data) { }\n\n\t~Base() {}\n\n\t// 虚基类\n\tvirtual void show() {\n\t\tcout << \"Base::show()\" << endl;\n\t}\n\n\tvoid show(int data) {\n\t\tcout << \"Base::show(int): \" << data << endl;\n\t}\n\nprivate:\n\tint ma;\n};\n\nclass Derive : public Base\n{\npublic:\n\tDerive(int data) \n\t\t:Base(data)\n\t\t, mb(data) { }\n\n\t~Derive() {}\n\n\tvoid show() {\n\t\tcout << \"Derive::show()\" << endl;\n\t}\n\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\t// 创建类\n\tDerive d(50);\n\tBase* pb = &d;\n\n\tpb->show();\n\tpb->show(10);\n\t\n\tcout << \"---------------------\" << endl;\n\n\tcout << \"Base size:\" << sizeof(Base) << endl;\n\tcout << \"Derive size:\" << sizeof(Derive) << endl;\n\n\tcout << \"---------------------\" << endl;\n\n\tcout << typeid(pb).name() << endl;\n\tcout << typeid(*pb).name() << endl;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111047159.png)\n\n**反汇编：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111048405.png)\n\n`pb->show();` 中 pb 指针是 base 类型，如果发现 Base 中的 show 是虚函数，就进行动态绑定。\n\n~~~shell\n|63..32|31..16|15-8|7-0| \n               |AH.|AL.| \n               |AX.....| \n       |EAX............| \n|RAX...................|\n~~~\n\n1. **`mov   rax, qword ptr [pb]`**\n\n将 pb 指向的内存前 4 个字节放入 rax 寄存器，pb指向derive对象，前四个字节即 `vfptr`，将虚函数表地址加载到 rax\n\n2. **`mov   rax, qword ptr [rax]`**\n\n将 rax 的前四个字节 即 `Derive::show` 加载到 rax 中。\n\n3. **`call   qword ptr [rax]`**\n\n虚函数的地址\n\n可以看到这一次，汇编码 call 的就不是确切的函数地址了，而是寄存器 rax。\n\n那么就很好理解了：rax 寄存器里存放的是什么内容，编译阶段根本无从知晓，只能在运行的时候确定； 故为，动态绑定。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111100188.png)\n\npb的类型：Base类型，查看Base中有没有虚函数\n\n（1）Base中没有虚函数 `*pb` 识别的就是编译时期的类型 `*pb` 就是 Base 类型。\n（2） Base中有虚函数，`*pb` 识别的就是运行时期的类型 RTTI 类型为：Derive。\n\n在添加了 virtual 关键字后，对应的函数就变成了虚函数。\n\n**那么，一个类添加了虚函数，对这个类有什么影响呢？**\n\n- 如果类中定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的 `vftable` 虚函数表，虚函数表中主要存储的内容是：RTTI（Run-time Type Information）指针和虚函数的地址；当程序运行时，每一张虚函数表都会加载到内存的 `.rodata` 区（只读数据区）。\n- 一个类中定义了虚函数，那么这个类定义的对象，在运行时，内存中会多存储一个 `vfptr` 虚函数的指针，指向对应类型的虚函数表 `vftable`。\n- 一个类型定义的 n 个对象，它们的 `vfptr` 指向的都是同一张虚函数表。\n- 一个类中的虚函数个数，不影响对象内存的大小（vfptr），影响的是虚函数表 `vftable` 的大小。\n- 如果派生类中的方法和从基类继承的某个方法中返回值、函数名以及参数列表都相同，且基类方法为 virtual ，那么派生类的这个方法自动被处理为虚函数。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111110387.png)\n\n**虚函数表：**\n\n1. RTTI：存放的是类型信息，也就是（Base 或 Derive）。\n2. 偏移地址：虚函数指针相对于对象内存空间的便宜，一般 `vfptr` 都在 0 偏移位置。\n3. 之后是函数时虚函数入口地址。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111112719.png)\n\n在 Derive 类中，由于重写了 `show()`,因此在 Derive 的虚函数表中，是使用子类的 show() 方法代替了 Base 类的 `show()`。\n\n### 3. VS 工具查看虚函数表相关\n\n1. 找到\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111116949.png)\n\n打开后：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111117972.png)\n\n2. 在打开的窗口中切换到当前工程所在目录\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111119264.png)\n\n3. 输入指令\n\n可通过 dir 命令查看当前目录所有文件\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111120593.png)\n\n~~~shell\ncl XXX.cpp /d1reportSingleClassLayoutXX\n~~~\n\n第一个XXX表示源文件的名字，第二个代表你想查看的类类型，我这里就是`Derive`\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111123449.png)\n\n以看到 `class Derived` 的对象的内存布局，在派生类对象的开始包含了基类 Base 的对象，其中有一个虚表指针，指向的就是下面的`Derived::$vftable@ （virtual function table）`，表中包含了 Derived 类中所有的虚函数。\n\n## 5. 虚析构函数\n\n析构函数：可以成为虚函数，调用时候对象存在。\n\n虚析构函数：在析构函数前加上 virtual 关键字。\n\n什么时候需要把基类的析构函数必须实现成虚函数？  \n       \n基类的指针(引用)指向堆上 new 出来的派生类对象的时候，delete 调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n    Base(int data) \n        : ma(data)\n    {\n        cout << \"Base()\" << endl;\n    }\n    ~Base()\n    {\n        cout << \"~Base()\" << endl;\n    }\n\n    virtual void show()\n    {\n        cout << \"call Base::show()\" << endl;\n    }\n\nprotected:\n    int ma;\n};\n\nclass Derive : public Base\n{\npublic:\n    Derive(int data) \n        : Base(data)\n        , mb(data)\n        , ptr(new int(data))\n    {\n        cout << \"Derive()\" << endl;\n    }\n    ~Derive()\n    {\n        delete ptr;\n        cout << \"~Derive() \" << endl;\n    }\n\nprivate:\n    int mb;\n    int* ptr;\n};\n\nint main()\n{\n    Base* pb = new Derive(10);\n    // 静态绑定pb Base*   *pb Derive\n    pb->show();\n\n    delete pb;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111143308.png)\n\n**没有调用派生类的析构函数，造成内存泄漏。**\n\n**问题：**\n\npb 的配型是 Base 类型，因此 delete 调用析构函数先去 Base 找 `Base::~Base()`，对于析构函数的第哦啊用就是静态绑定，之间编译，没有机会调用派生类的析构函数，最后发生内存泄漏。\n\n**解决：**\n\n将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb 的类型是 Base 类型，调用析构时去 Base 中找 `Base::~Base` 发现它为虚函数，发生动态绑定。派生类的虚函数表中：`&Derive:: ~derive`，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。\n\n**注意：**\n\n**构造函数不能为虚函数！！！**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111146816.png)\n\n（1）从存储空间角度：\n\n虚函数对应一个 `vftable` ，这个 `vftable` 其实是存储在内存空间的。问题来了，如果构造函数是虚的，就需要通过 `vtable` 来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找 `vtable` 呢？所以构造函数不能是虚函数。\n\n（2）从使用角度：\n\n虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。\n\n\n（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。\n\n\n（4）构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。\n\n（5）从实现上看，`vbtable` 在构造函数调用后才建立，因而构造函数不可能成为虚函数\n\n从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。\n\n## 6. 理解多态是什么\n\n派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。\n\n所谓“虚函数”，就是在声明时前面加了virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。  \n  \n包含虚函数的类称为“**多态类**”。  \n  \n多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。  \n  \n多态在面向对象的程序设计语言中如此重要，以至于有类和对象的概念，但是不支持多态的语言，只能被称作“基于对象的程序设计语言”，而不能被称为“面向对象的程序设计语言”。例如，Visual Basic 就是“基于对象的程序设计语言”。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    virtual void Print() { cout << \"A::Print\" << endl; }\n};\n\nclass B : public A\n{\npublic:\n    virtual void Print() { cout << \"B::Print\" << endl; }\n};\n\nclass D : public A\n{\npublic:\n    virtual void Print() { cout << \"D::Print\" << endl; }\n};\n\nclass E : public B\n{\n    virtual void Print() { cout << \"E::Print\" << endl; }\n};\n\nint main()\n{\n    A a;\n    B b;\n    D d;\n    E e;\n\n    A* pa = &a;\n    B* pb = &b;\n\n    pa->Print();\n    cout << \"-----------------\" << endl;\n\n    pa = pb;\n    pa->Print();\n    cout << \"-----------------\" << endl;\n\n    pa = &d;\n    pa->Print();\n    cout << \"-----------------\" << endl;\n\n    pa = &e;\n    pa->Print();\n\n    return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405480.png)\n\n程序中，四个类之间的派生关系如下所示：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405483.png)\n\n每个类都有同名、同参数表的虚函数 Print（每个 Print 函数声明时都加了 virtual 关键字）。根据多态的规则，对于语句`pa->Print()`，由于 Print 是虚函数，尽管 pa 是基类 A 的指针，编译时也不能确定调用的是哪个类的 Print 函数。当程序运行到该语句时，pa 指向的是哪个类的对象，调用的就是哪个类的 Print 函数。    \n  \n多态的语句调用哪个类的成员函数是在运行时才能确定的，编译时不能确定（具体原理后面会解释）。因此，多态的函数调用语句被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。\n\n### 1.多态起手式以及内存分布\n\n假设有一个基类 ClassA，一个继承了该基类的派生类 ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。\n\n在代码中运用多态这个特性时，通常以两种方式起手：\n(1) `ClassA *a = new ClassB();`\n(2) `ClassB b; ClassA *a = &b;`\n\n以上两种方式都是用基类指针去指向一个派生类实例，区别在于第 1 个用了 new 关键字而分配在堆上，第 2 个分配在栈上：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111411592.png)\n\n请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。\n以左图为例，`ClassA *a` 是一个栈上的指针。\n\n该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向 **该类的虚函数表(这里是类ClassB)** 的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。\n\n### 2. 类的虚函数表与类实例的虚函数指针\n\n首先不考虑继承的情况；如果一个类中有虚函数，那么该类就有一个虚函数表。\n\n这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。\n\n从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111417318.png)\n\n### 3. 多态代码及多重继承情况\n\n讨论了在没有继承的情况下，虚函数表的逻辑结构。\n\n那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass ClassA\n{\npublic:\n    ClassA()\n    {\n        cout << \"ClassA::ClassA();\" << endl;\n    }\n\n    virtual ~ClassA()\n    {\n        cout << \"ClassA::~ClassA();\" << endl;\n    }\n\n    void fn1()\n    {\n        cout << \"ClassA::fn1();\" << endl;\n    }\n\n    void fn2()\n    {\n        cout << \"ClassA::fn2();\" << endl;\n    }\n\n    virtual void vfn1()\n    {\n        cout << \"virtual ClassA::vfn1();\" << endl;\n    }\n\n    virtual void vfn2()\n    {\n        cout << \"virtual ClassA::vfn2();\" << endl;\n    }\n\nprivate:\n    int aData;\n};\n\nclass ClassB : public ClassA\n{\npublic:\n    ClassB()\n    {\n        cout << \"ClassB::ClassB();\" << endl;\n    }\n\n    virtual ~ClassB()\n    {\n        cout << \"ClassB::~ClassB();\" << endl;\n    }\n\n    void fn1()\n    {\n        cout << \"ClassB::fn1();\" << endl;\n    }\n\n    virtual void vfn1()\n    {\n        cout << \"virtual ClassB::vfn1();\" << endl;\n    }\n\nprivate:\n    int bData;\n};\n\nclass ClassC : public ClassA\n{\npublic:\n    ClassC()\n    {\n        cout << \"ClassC::ClassC();\" << endl;\n    }\n\n    virtual ~ClassC()\n    {\n        cout << \"ClassC::~ClassC();\" << endl;\n    }\n\n    void fn2()\n    {\n        cout << \"ClassC::fn2();\" << endl;\n    }\n\n    virtual void vfn2()\n    {\n        cout << \"virtual ClassC::vfn2();\" << endl;\n    }\n\nprivate:\n    int aData;\n};\n\nint main()\n{\n    ClassC c;\n\n    return 0;\n}\n~~~\n\n(1) ClassA 是基类, 有普通函数: `fn1()、fn2()` 。虚函数: `vfn1()、vfn2()、~ClassA()`\n(2) ClassB 继承 ClassA, 有普通函数: `fn1()`。虚函数: `vfn1()、~ClassB()`\n(3) ClassC 继承 ClassB, 有普通函数: `fn2()`。虚函数: `vfn2()、~ClassB()`\n\n基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。\n\nClassB 继承与 ClassA，其虚函数表是在 ClassA 虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的\n\n~~~c++\nClassA* a = new ClassB();\n\na->fn1();\na->fn2();\n\na->vfn1();\na->vfn2();\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111430434.png)\n\n**使用 VS 开发者工具查看：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111432206.png)\n\n这个结果不难想象，看上图，ClassA 类型的指针 a 能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同\n\n这个结果已经说明了 C++ 的隐藏、重写(覆盖)特性。\n\n同理，也就不难推导出 ClassC 的逻辑结构图了\n\n类的继承情况是: ClassC 继承 ClassB，ClassB 继承 ClassA；这是一个多次单继承的情况。(多重继承)。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111435576.png)\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111436071.png)\n\n### 4. 多继承下的虚函数表 (同时继承多个基类)\n\n多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？\n\n~~~c++\n#include <iostream>\n \nusing namespace std;\n \nclass ClassA1\n{\npublic:\n  ClassA1() { cout << \"ClassA1::ClassA1()\" << endl; }\n  virtual ~ClassA1() { cout << \"ClassA1::~ClassA1()\" << endl; }\n \n  void func1() { cout << \"ClassA1::func1()\" << endl; }\n \n  virtual void vfunc1() { cout << \"ClassA1::vfunc1()\" << endl; }\n  virtual void vfunc2() { cout << \"ClassA1::vfunc2()\" << endl; }\nprivate:\n  int a1Data;\n};\n \nclass ClassA2\n{\npublic:\n  ClassA2() { cout << \"ClassA2::ClassA2()\" << endl; }\n  virtual ~ClassA2() { cout << \"ClassA2::~ClassA2()\" << endl; }\n \n  void func1() { cout << \"ClassA2::func1()\" << endl; }\n \n  virtual void vfunc1() { cout << \"ClassA2::vfunc1()\" << endl; }\n  virtual void vfunc2() { cout << \"ClassA2::vfunc2()\" << endl; }\n  virtual void vfunc4() { cout << \"ClassA2::vfunc4()\" << endl; }\nprivate:\n  int a2Data;\n};\n \nclass ClassC : public ClassA1, public ClassA2\n{\npublic:\n  ClassC() { cout << \"ClassC::ClassC()\" << endl; }\n  virtual ~ClassC() { cout << \"ClassC::~ClassC()\" << endl; }\n \n  void func1() { cout << \"ClassC::func1()\" << endl; }\n \n  virtual void vfunc1() { cout << \"ClassC::vfunc1()\" << endl; }\n  virtual void vfunc2() { cout << \"ClassC::vfunc2()\" << endl; }\n  virtual void vfunc3() { cout << \"ClassC::vfunc3()\" << endl; }\n};\n \n \nint main()\n{\n  ClassC c;\n \n  return 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111445452.png)\n\n（1）ClassA1 是第一个基类，拥有普通函数 `func1()`，虚函数`vfunc1()、 vfunc2()`。\n（2）ClassA2 是第二个基类，拥有普通函数 `func1()`，虚函数 `vfunc1()、 vfunc2()、vfunc4()`。\n（3）ClassC 依次继承 ClassA1、ClassA2。普通函数 `func1()`,虚函数`vfunc1()、vfunc2()、vfunc3()`。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111442375.png)\n\n在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。\n\n如图，虚函数表指针 01 指向的虚函数表是以 ClassA1 的虚函数表为基础的，子类的 `ClassC::vfunc1()`,和 `vfunc2()` 的函数指针覆盖了虚函数表 01 中的虚函数指针 01 的位置、02 位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。注意：\n\n1. 子类虚函数会覆盖每一个父类的每一个同名虚函数。\n2. 父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。\n3. 父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用\n\n最后给出代码和结果：\n\n~~~c++\n\tClassA1 *a1 = new ClassC;\n\ta1->func1();               // \"ClassA1::func1()\"    隐藏子类同名函数\n\ta1->vfunc1();              // \"ClassC::vfunc1()\"    覆盖父类ClassA1虚函数\n\ta1->vfunc2();              // \"ClassC::vfunc2()\"    覆盖父类ClassA1虚函数\n\t没有a1->vfunc3()，父类没有这个虚函数\n\n\tClassA2 *a2 = new ClassC;\n\ta2->func1();               // \"ClassA2::func1()\"    隐藏子类同名函数\n\ta2->vfunc1();              // \"ClassC::vfunc1()\"    覆盖父类ClassA2虚函数\n\ta2->vfunc2();              // \"ClassC::vfunc2()\"    覆盖父类ClassA2虚函数\n\ta2->vfunc4();              // \"ClassA2::vfunc4()\"   未被子类重写的父类虚函数\n\n\tClassC *c = new ClassC;\n\tc->func1();                // \"ClassC::func1()\"\n\tc->vfunc1();               // \"ClassC::vfunc1()\"\n\tc->vfunc2();               // \"ClassC::vfunc2()\"\n\tc->vfunc3();               // \"ClassC::vfunc3()\"\n\tc->vfunc4();               // \"ClassA2::func4()\"\n~~~\n\n## 7. 理解抽象类\n\n抽象类(接口)：接口描述了类的行为和功能,而无需完成类的特定实现\n\nC++ 接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用\n\n**注意:**\n\n如果试图实例化一个抽象类的对象，会导致编译错误。\n\n因此，如果一个抽象类的派生类需要被实例化(建立对象)，则必须对每个继承来的纯虚函数进行函数体实现。\n如果没有在派生类中重写所有纯虚函数，就尝试实例化派生类的对象，也会导致编译错误，这是因为如果派生类没有实现父类的纯虚函数，则派生类变为抽象类。\n\n抽象类基类为派生自抽象基类的派生类提供了约束条件，即：派生类必须要实现继承自抽象基类中的纯虚函数，否则此派生类不可进行实例化，且派生类将继承为抽象派生类。\n\n### 1. 抽象类与纯虚函数（抽象方法）\n\n**纯虚函数**是一个在 **基类中声明的虚函数**，它在该基类中**没有定义具体的函数体**(操作内容),要求**派生类根据实际需要定义自己的版本**，设计多层次类继承关系时用到。把某个方法声明为一个抽象方法等于告诉编译器,这个方法**必不可少**，但目前在基类中还不能为它提供实现\n\n纯虚函数的标准格式：\n\n~~~c++\nvirtual 函数类型 函数名（参数表）= 0;\n~~~\n\n~~~c++\nclass Pet\n{\npublic:\n\tvirtual void func() = 0;// 声明了一个纯虚函数 也就是在虚函数尾部加上\" = 0 \" 一个虚函数便被声明成为了一个纯虚函数\n\t// 等于 0 表示该函数仅声明而没有函数体\n};\n~~~\n\n**注意：**\n\n一旦类中有了纯虚函数，这个类便被称为：**抽象类**。\n\n> **且此类不能被实例化！！！（不可建立类对象实例！！！）**\n\n例如：\n\n~~~c++\nint main() \n{\n\t// 报错！带有纯虚函数的类称为抽象类，不可实例化\n\tPet pet; \n}\n~~~\n\n**抽象类：**\n\n只能作为积累使用，无法定义抽象类对象实例，这是因为 **抽象类中包含了没有定义的纯虚函数**，在 C++ 中，我们把 **只能由于被继承而不能直接创建对象的类** 称之为：**抽象类**，这种基类不能直接生成对象，而只有被继承后，并重写其虚函数后，才能使用。\n\n当抽象类的派生类实现了继承而来的纯虚函数后，才能实例化对象。\n\n之所以要存在抽象类，最主要是因为它具有不确定因素，我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为虚函数。虚函数是一种特殊的函数，在抽象类中只有声明，没有具体的定义。\n\n**抽象类和纯虚函数的关系**\n\n抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类，存在纯虚函数是成为抽象类的充要条件。\n\n### 2. 为什么需要一个抽象类\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\n// todonew 与 delete 动态分配内存,与用指针调用对象 通过对象的不同调用不同的同名虚函数\nclass Pet // 声明纯虚函数 sound 后 Pet 类变为抽象类(接口)\n{\npublic:\n    Pet(string thename);\n    void sleep();\n    virtual void sound() = 0;// 声明纯虚函数 sound  (并未进行函数实现 函数实现放在派生类中)\n\n    //注意:\t\t\t\t\t   \n    //todo1.继承自抽象基类 Pet 的子类必须全部实现基类中的所有纯虚函数\n    //todo2.抽象基类 Pet 不可进行实例化\n\nprotected:\n    string name;\n};\n\nclass Cat :public Pet\n{\npublic:\n    Cat(string thename);\n    void climb();\n    void sound();\n};\n\nclass Dog :public Pet\n{\npublic:\n    Dog(string thename);\n    void jump();\n    void sound();\n};\n\n\nPet::Pet(string thename) // todo 基类构造器(抽象类也有构造函数)\n{\n    name = thename;\n}\n\nvoid Pet::sleep()\n{\n    cout << name << \"正在睡大觉\\n\";\n}\n\nvoid Pet::sound()\n{\n    cout << name << \"动物发声\\n\";\n}\n\nCat::Cat(string thename) :Pet(thename) // 派生类 Cat 构造函数\n{\n}\n\nvoid Cat::climb()\n{\n    cout << name << \"正在爬树\\n\";\n}\n\nvoid  Cat::sound() // 派生类虚函数\n{\n\n    //\tPet::sound(); // todo 如果需要调用基类中的 play() 函数  在原本的play()函数的基础上加上覆盖上的子类play()函数\n    cout << name << \"喵喵喵!\\n\";\n}\n\n\nDog::Dog(string thename) :Pet(thename)// 派生类 Dog 构造函数\n{\n}\n\nvoid Dog::jump()\n{\n    cout << name << \"跳过了栅栏\\n\";\n}\n\nvoid Dog::sound() // 派生类虚函数\n{\n    //\tPet::sound();\n    cout << name << \"汪汪汪!\\n\";\n}\n\nvoid func(Pet* x)\n{\n    x->sound();\n}\n\n\nint main()\n{\n    //\tPet pet; // todo 用带有抽象方法(纯虚函数)的抽象类 Pet 无法实例化对象\n\n    // todo 创建指向子类实例的基类指针和引用来调用纯虚函数\n    Pet* cat = new Cat(\"猫\");\n    Pet* dog = new Dog(\"狗\");\n\n    // todo 创建对象实例来调用纯虚函数\n    Cat cat2(\"对象实例调用 猫\");\n    cat2.sound();\n\n    func(cat);\n    func(dog);\n\n    return 0;\n}\n~~~\n\n本例中定义了三个类,它们的继承关系为：`Animal-->Cat`和`Animal-->Dog`\n\nAnimal 是一个抽象类，也是最顶层的基类，在 Animal 类中定义了一个**纯虚函数**`sound()`，在 `Cat` 类中，实现了`sound()`函数。所谓实现，就是定义了纯虚函数的函数体，抽象类 Animal 虽然不能实例化，但它为派生类提供了**约束条件**，派生类必须要实现这个函数，完成动物发声功能，否则就不能对派生类进行实例化。\n\n在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的，虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111557893.png)\n\n**总结：**\n\n1. 任何具有纯虚函数的类都是抽象类。\n2. 抽象类基类不可建立实例。\n3. 抽象类派生出的子类需将继承的纯虚函数全部进行实例化，才能建立其实例。\n4. 抽象类可以有构造函数。\n5. 如果派生类没有实现父类的纯虚函数，则派生类变为抽象类，即不可建立其实例。\n6. 抽象基类除了约束派生类的功能，还可以实现多态，可以创建指向子类的实例的抽象基类的指针和引用。\n7. 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。\n\n## 8. 理解虚基类和虚继承\n\n**virtual作用：**\n\n1. virtual 修饰了成员方法是虚函数。  \n2. 可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。\n\n- **vfptr**：一个类有虚函数，这个类生成的对象就有 vfptr，指向 vftable。  \n- **vbptr**：在派生类中从基类虚继承而来。  \n- **vftable**：第一行为向上偏移量，第二行为虚基类指针离虚基类内存的偏移量。  \n- **vbtable**：存放的 RTTI 指针，指向运行时 RTTI 信息与虚函数地址。\n\n~~~c++\nclass A\n{\npublic:\nprivate:\n\tint ma;\n};\n\nclass B : public A\n{\npublic:\nprivate:\n\tint mb;\n};\n\n//A a; 4个字节\n//B b; 8个字节\n~~~\n\n这里我们的对象 a 占 4 个字节，对象 8 占 8 个字节。但如果我们给 B 的继承方式访问限定符前面加了一个 virtual 关键字。\n\n~~~c++\nclass B : virtual public A\n{\npublic:\nprivate:\n\tint mb;\n};\n~~~\n\n**类 A 被虚继承了，但内存布局没有变化：**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111611448.png)\n\n**类 B 在继承普通基类的内存变化：**\n\n![](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111612673.png)\n\n再看一下类 B，不是之前的 8 个字节，变为 12 个字节，多了一个 vbptr 指针。原来最上面应该为 ma 与 mb，但是现在多了一个 `vbptr`(虚基类指针)，ma 跑到派生类最后面去了。`vbptr` 指向的是 `vbtable`，`vbtable` 第一行为 0，第二行为虚基类指针到虚基类数据的偏移量。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111614890.png)\n\n当遇到虚继承时候，要考虑派生类 B 的内存布局时；\n\n首先，先不考虑虚继承，类 B 继承了基类的 ma，还有自己的mb；当基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个 `vbptr`。派生类的内存就由这几部分来构成。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111618147.png)\n\n虚基类指针(`vbptr`)指向虚基类表(`vbtable`)，`vbtable` 第一行为向上的偏移量，因为 `vbptr` 在该派生类内存起始部分，因此向上的偏移量为 0；第二行为向下的偏移量(`vbptr` 离虚基类数据的偏移量)，原来基类的数据放到最后，找 ma 的时候还是在最开始找，但 ma 被移动，根据偏移的字节就可以找到。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111619886.png)\n\n\n### 1. 虚基类和虚继承出错情况分析\n\n**那么当我们虚基类指针与虚函数指针在一起出现的时候会发生什么呢？**\n\n调用是没有问题的，但是 delete 会出错。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tvirtual void func()\n\t{\n\t\tcout << \"call A::func\" << endl;\n\t}\nprivate:\n\tint ma;\n};\n\nclass B : virtual public A\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call B::func()\" << endl;\n\t}\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\t// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。\n\tA* p = new B();// B::vftable\n\tp->func();\n\tdelete p;\n\n\treturn 0;\n}\n~~~\n\n如图：调用成功，但delete时会出错。  \n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111623556.png)\n\n**分析：**\n\nB 的内存布局：\n\nB 首先从 A 中获取 `vfptr` 与 ma， B 中还有自身的 mb；\n此时 A 被虚继承，A 中所有的东西都移动到派生类最后面，最上面补一个`vbptr`，`vbptr` 指向 `vbtable`，`vfptr` 指向 `vftable`；基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。\n\n普通情况下，派生类内存布局先是基类，在是派生类，基类指针指向派生类对象时，基类指针指向的就是派生类内存的起始部分。但是，虚继承下基类称为虚基类，虚基类的数据在派生类最后面，原地方补上 `vbptr`，此时再用基类指针指向派生类对象时候，基类指针永远指向派生类基类部分的起始地址。虚基类一开始就是 `vfptr`，能够用 p 指向的对象访问 `vfptr` 与 `vftable` 的原因。释放内存时候出错，因为对象开辟是在最上面即绿色部分，但是 p 所持有的是虚基类的地址，delete 时从虚基类起始地址 delete，因此出错。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111627334.png)\n\n\n命令验证如下：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111628141.png)\n\n**验证一下内存地址：**\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tvirtual void func()\n\t{\n\t\tcout << \"call A::func\" << endl;\n\t}\n\tvoid operator delete(void* ptr)\n\t{\n\t\tcout << \"operator delete p:\" << ptr << endl;\n\t\tfree(ptr);\n\t}\nprivate:\n\tint ma;\n};\n\nclass B : virtual public A\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call B::func()\" << endl;\n\t}\n\n\tvoid* operator new(size_t size)\n\t{\n\t\tvoid* p = malloc(size);\n\t\tcout << \"operator new p:\" << p << endl;\n\t\treturn p;\n\t}\nprivate:\n\tint mb;\n};\n\nint main()\n{\n\tA* p = new B(); // B::vftable\n\tcout << \"main p:\" << p << endl;\n\tp->func();\n\tdelete p;\n\n\treturn 0;\n}\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111629072.png)\n\n`00000119E9411CB0` 为分配的内存的起始地址，我们用基类指针指向派生类对象一定是指向派生类内存基类的起始部分：`00000119E9411CC0` 刚好比 `00000119E9411CB0` 多了 16 个字节，是 `vbptr` 与 mb，但是 delete 时候从 `00000119E9411CC0` 开始释放，因此崩溃。\n\nWindows 的 VS 下这样写会出错，但是 Linux 下的 `g++ delete` 时会自动偏移到 new 内存的起始部分，进行内存 `free()`，不会出错。\n\n如果在栈上开辟内存，基类指针指向派生类对象，出了作用域自己进行析构，这样是没有问题的。\n\n~~~c++\nB b;\nA *p = &b; // B::vftable\ncout << \"main p:\" << p << endl;\np->func();\n~~~\n\n## 9. 菱形继承问题\n\n**多重继承：** 一个`派生类`如果只继承一个`基类`，称作单继承； 一个`派生类`如果继承了多个`基类`，称作多继承。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111602992.png)\n\n**优点：**\n\n- 多重继承可以做更多的代码复用！\n- 派生类通过多重继承，可以得到多个基类的数据和方法，更大程度的实现了代码复用。\n\n**问题：**\n\n菱形继承的问题：在于继承时有重复利用的数据。\n\n**会导致派生类有多份间接基类的数据，可以采用虚继承来解决。** **A 为 B、C 的基类，B 从 A 单继承而来，C 从 A 也是单继承而来；D 是 B 和 C 多继承而来，D 有两个基类分别为 B 和 C。A 称为 D 的间接基类，D 也有 A 的数据。**\n\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111637497.png)\n\n当然，多重继承还会出现别的问题：\n\n**半圆形继承问题：** **B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。**\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111638517.png)\n\n多重继承虽然可以复用多个基类的代码到派生类中，但是会出现许多问题，因此 C++ 开源代码上很少见到多重继承。\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA(int data) : ma(data)\n\t{\n\t\tcout << \"A()\" << endl;\n\t}\n\t~A()\n\t{\n\t\tcout << \"~A()\" << endl;\n\t}\nprotected:\n\tint ma;\n};\n\nclass B : public A\n{\npublic:\n\tB(int data) : A(data), mb(data)\n\t{\n\t\tcout << \"B()\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"~B()\" << endl;\n\t}\nprotected:\n\tint mb;\n};\n\nclass C : public A\n{\npublic:\n\tC(int data) : A(data), mc(data)\n\t{\n\t\tcout << \"C()\" << endl;\n\t}\n\t~C()\n\t{\n\t\tcout << \"~C()\" << endl;\n\t}\nprotected:\n\tint mc;\n};\n\nclass D : public B, public C\n{\npublic:\n\tD(int data) : B(data), C(data), md(data)\n\t{\n\t\tcout << \"D()\" << endl;\n\t}\n\t~D()\n\t{\n\t\tcout << \"~D()\" << endl;\n\t}\nprotected:\n\tint md;\n};\n\nint main()\n{\n\tD d(10);\n\n\treturn 0;\n}\n\n~~~\n\n画一下 d 对象的内存布局：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641312.png)\n\nD 能看见 B，C 与 md，所以 D 在构造时调用 B，C 的构造及 ma 的初始化。 ma 的初始化在 B 与 C 的构造函数中进行，因此 D 内存为 20 个字节。\n\n输出结果：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641957.png)\n\n先是 A 的构造，B 的构造，又是 A 的构造，C 的构造，最后是 D 的构造；析构顺序与其相反。就会发现，D 这个派生类中调用了两次 A 的构造，数据重复，浪费内存，这种情况必须被杜绝。\n\n**如何处理？**\n\n**虚继承来处理，所有从A继承而来的地方都采用虚继承，A 就为虚基类。**\n\n此时：\nB 从 A 虚继承而来，A 为虚基类，`A::ma` 移动到派生类最后面，在 `A::ma` 位置上补一个 `vbptr`；C 也是从 A 虚继承而来，`A::ma` 移动到派生类最后面，但发现已经有一份同样的虚基类的数据，那么 C 的 `A::ma` 丢弃，在 `A::ma` 位置存放 `vbptr`。此时派生类中只有一份基类 `A::ma` 的数据，以后访问都是同一个 ma；同时 ma 的初始化由 D 来负责。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111645047.png)\n\n~~~c++\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n\tA(int data) : ma(data)\n\t{\n\t\tcout << \"A()\" << endl;\n\t}\n\t~A()\n\t{\n\t\tcout << \"~A()\" << endl;\n\t}\nprotected:\n\tint ma;\n};\n\nclass B : virtual public A\n{\npublic:\n\tB(int data) : A(data), mb(data)\n\t{\n\t\tcout << \"B()\" << endl;\n\t}\n\t~B()\n\t{\n\t\tcout << \"~B()\" << endl;\n\t}\nprotected:\n\tint mb;\n};\n\nclass C : virtual public A\n{\npublic:\n\tC(int data) : A(data), mc(data)\n\t{\n\t\tcout << \"C()\" << endl;\n\t}\n\t~C()\n\t{\n\t\tcout << \"~C()\" << endl;\n\t}\nprotected:\n\tint mc;\n};\n\nclass D : public B, public C\n{\npublic:\n\tD(int data) : A(data), B(data), C(data), md(data)\n\t{\n\t\tcout << \"D()\" << endl;\n\t}\n\t~D()\n\t{\n\t\tcout << \"~D()\" << endl;\n\t}\nprotected:\n\tint md;\n};\n\nint main()\n{\n\tD d(10);\n\n\treturn 0;\n}\n~~~\n\n打印结果：修改成功；A、B、C、D各初始化与析构一次。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111646462.png)\n\n## 10. C++ 的 四种类型转换\n\n> 1. const_cast\n> 2. static_cast\n> 3. reinterpert_cast\n> 4. dynamic_cast\n\n### 1. const_cast\n\n**const_cast：修改类型的const或volatile属性。** 使用该运算方法可以返回一个指向非常量的指针（或引用）指向，就可以通过该指针（或引用）对它的数据成员任意改变。\n\n**注意：**  \n\n不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。  \n\n**语法：**\n\n~~~c++\nconst_cast<里面必须是指针或引用类型>\n~~~\n\n**实例：**\n\n~~~c++\nconst int a = 10;\nint *p1 = (int*)&a;// C 中类型转换\nint *p2 = const_cast<int*>(&a);// C++ 中类型转换 const_cast\n~~~\n\n转换为相同类型的时候，通过反汇编查看时候，发现 C 中的类型强转与 C++ 中 `const_cast` 所生成的汇编指令底层是一模一样的。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111757973.png)\n\n但是在转换成汇编指令之前，即编译阶段，就有所不同。\n\n**注意：**\n\n1. **不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。**\n\n~~~c++\nconst int a = 10;\n// C 中类型转换，可以\nchar *p1 = (char*)&a;\n// C++ 中类型转换 const_cast，不可以\nchar *p2 = const_cast<char*>(&a);\n~~~\n\n通过 C中类型转换可以将 `int *` 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过 `const_cast` 将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。`const_cast`使用时，地址的类型是与左边类型以及转换的类型需要保持一致。防止了 C 中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。\n\n编译出错：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111806390.png)\n\n2. **`const_cast<里面必须是指针或引用类型>`，否则出错**\n\n~~~c++\nconst int a = 10;\nint b = const_cast<int>(a);\n~~~\n\n编译出错：\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111807110.png)\n\n### 2. static_cast\n\n**`static_cast(静态)`：编译时期的类型转换，提供编译器认为安全的类型转换。**\n\n是一个 c++ 运算符，功能是把一个表达式转换为某种类型，使用最多。\n\n**注意：**\n\n1. **有联系的类型之间可以互相转换。**\n2. **没有任何联系的类型之前转换会被否定。**\n3. **基类类型与派生类类型进行转换，可以用 `static_cast`，它们类型之间有关系，但不一定安全。**\n\n**实例：**\n\n1. 有联系的类型之间可以互相转换\n\n~~~c++\nint a = 10;\nchar b = static_cast<int>(a);\n~~~\n\n编译成功，int 与 char 直之间有联系。\n\n2. 有任何联系的类型之间的转换会被否定\n\n~~~c++\nint* p = nullptr;\n// double* = (double*)p; C 可以转换\ndouble* b = static_cast<double*>(p);\n~~~\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111811911.png)\n\n### 3. reinterpert_cast\n\n**`reinterpret_cast`：类似于 C 风格的强制类型转换，是 C++ 里的强制类型转换符，不安全。**\n\n**注意：**\n\n1. 如果非要进行没有任何联系的类型转换，可以使用 `reinterpret_cast`。\n\n**实例：** \n\n1. 如果非要进行没有任何联系的类型转换，可以使用 `reinterpret_cast`。\n\n~~~c++\nint *p = nullptr;\ndouble* b = reinterpret_cast<double*>(p);\n~~~\n\n`reinterpret_cast` 与 C 中类型转换类似，转换成功，不安全。\n\n### 4. dynamic_cast\n\n**`dynamic_cast`(动态)：运行时期的类型转换，用于继承结构中，可以支持 RTTI 类型识别的上下转换及识别。**\n\n**将一个基类对象指针（或引用）转换到继承类指针，`dynamic_cast` 会根据基类指针是否真正指向继承类指针来做相应处理。**\n\n~~~c++\nclass Base\n{\npublic:\n\tvirtual void func() = 0;\n};\n\nclass Derive1 : public Base\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call Derive1::func\" << endl;\n\t}\n};\n\nclass Derive2 : public Base\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call Derive2::func\" << endl;\n\t}\n};\n\nvoid showFunc(Base* p)\n{\n\tp->func();//动态绑定\n}\n\nint main()\n{\n\tDerive1 d1;\n\tDerive1 d2;\n\t\n\tshowFunc(&d1);\n\tshowFunc(&d2);\n\n\treturn 0;\n}\n~~~\n\n执行结果：执行成功。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111838785.png)\n\n需求改变了，`Derive` 实现了一个新功能的 API 接口函数。\n\n~~~c++\nclass Derive2 : public Base\n{\npublic:\n\tvoid func()\n\t{\n\t\tcout << \"call Derive2::func\" << endl;\n\t}\n\t//需求更改 Derive2实现新功能的API接口函数\n\tvoid derive02func()\n\t{\n\t\tcout << \"call derive02func()::func\" << endl;\n\t}\n};\n~~~\n\n`void show()` 应该区分判断一下，如果 `Base* p` 指向了其他的派生类对象，调用 `p->func()` 方法就好。但如果指向 Derive2 对象，不调用 `func()` 方法，而调用 Derive2 的 `derive02 func()`方法。该如何做呢？\n\n这里就要识别 `*p` 的类型，看它指向哪个对象。此时就需要`dynamic_cast()`了。dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象；`p->vfptr->vftable` RTTI 信息 如果是 `dynamic_cast`，转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr。\n\n~~~c++\nvoid showFunc(Base* p)\n{\n\t// dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象\n\t// p->vfptr->vftable RTTI 信息 如果是 dynamic_cast，\n\t// 转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr\n\tDerive2 *pd2 = dynamic_cast<Derive2*>(p);\n\tif (pd2 != nullptr)\n\t{\n\t\tpd2->derive02func();\n\t}\n\telse\n\t{\n\t\tp->func();//动态绑定\n\t}\n}\n~~~\n\n指向结果：调用成功。\n\n![image.png](https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111845822.png)\n\n","slug":"02.C++ 基础部分/06.C++ 继承与多态","published":1,"date":"2023-08-09T00:38:58.469Z","updated":"2023-08-11T13:00:11.193Z","_id":"cll3spntb000624pkdnkicj50","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本节分为十部分：</p>\n<ol>\n<li>继承的基本意义</li>\n<li>派生类的构造过程</li>\n<li>重载、覆盖、隐藏</li>\n<li>虚函数、静态绑定和动态绑定</li>\n<li>虚析构函数</li>\n<li>理解多态是什么</li>\n<li>理解抽象类</li>\n<li>理解虚基类和虚继承</li>\n<li>菱形继承问题</li>\n<li>C++ 的 四种类型转换</li>\n</ol>\n<h2 id=\"1-继承的基本意义\"><a href=\"#1-继承的基本意义\" class=\"headerlink\" title=\"1. 继承的基本意义\"></a>1. 继承的基本意义</h2><p><strong>继承的本质：</strong></p>\n<p>代码的复用，实现多态的基础。</p>\n<p><strong>关系：</strong></p>\n<ul>\n<li>组合：a part of…  一部分的关系</li>\n<li>继承：a kind of… 一种的关系</li>\n</ul>\n<p><strong>继承方式和访问限定罗列：</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>继承方式</td>\n<td>基类的访问限定</td>\n<td>派生类的访问限定</td>\n<td>(main)外部的访问限定</td>\n</tr>\n<tr>\n<td>public</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>public</td>\n<td>public</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>protected</td>\n<td>protected</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>private</td>\n<td>不可见的</td>\n<td>N</td>\n</tr>\n<tr>\n<td>protected</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>public</td>\n<td>protected</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>protected</td>\n<td>protected</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>private</td>\n<td>不可见的</td>\n<td>N</td>\n</tr>\n<tr>\n<td>private</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>public</td>\n<td>private</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>protected</td>\n<td>private</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>private</td>\n<td>不可见的</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p><strong>protected继承方式下：</strong> <strong>基类的成员的访问限定，在派生类里面是不可能超过继承方式的。public降为protected的。</strong></p>\n<p><strong>private继承方式下：</strong> <strong>public与protected降为private。</strong></p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>外部只能看到并使用 public 成员，protected 和 private 成员无法直接访问。</li>\n<li>在继承结构中，派生类从基类继承来的 private 成员，然是无法直接访问（派生类中不可见）。</li>\n<li>基类成员访问限定，在派生类里面不能超过继承方式。</li>\n</ol>\n<p><strong>protected 和 private 区别：</strong></p>\n<ol>\n<li>如果只是单纯的一个类，没有继承结构，则二者没有区别，外部都是无法访问的。</li>\n<li>若存在继承关系，在基类中定义的成员，想被派生类访问，但不想被外部访问，那么可以在基类中将该成员定义为保护型。</li>\n<li>若存在继承关系，在基类中定义的成员，不想被派生类访问，也不想被外部访问，则可以在基类中将该成员定义为私有。</li>\n</ol>\n<p><strong>默认继承方式：</strong></p>\n<ul>\n<li>要看派生类是用 class 定义的，还是 struct 定义的：<ul>\n<li>若 class 定义派生类，则默认继承方式是私有的。</li>\n<li>若 struct 定义派生类，则默认继承方式是共有的。</li>\n</ul>\n</li>\n</ul>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> ma;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mc;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">B</span>(<span class=\"hljs-type\">int</span> _md, <span class=\"hljs-type\">int</span> _mba, <span class=\"hljs-type\">int</span> _maa)<br>\t\t: <span class=\"hljs-built_in\">md</span>(_md)<br>\t\t, <span class=\"hljs-built_in\">ma</span>(_mba)<br>\t&#123;<br>\t\tA::ma = _maa;<br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> md;<br>\t<span class=\"hljs-comment\">// 作用域不同：派生类可以定义与基类同名的成员数据</span><br>\t<span class=\"hljs-type\">int</span> ma;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; md &lt;&lt; endl;<br>\t\tcout &lt;&lt; A::ma &lt;&lt; endl;<br>\t\tcout &lt;&lt; B::ma &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 公有继承下 ：基类私有的成员在派生类中不可见</span><br>\t\t<span class=\"hljs-comment\">// cout &lt;&lt; mc &lt;&lt; endl; </span><br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> me;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mf;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>)</span></span>;<br>\tA a;<br><br>\tb.<span class=\"hljs-built_in\">func</span>();<br>\tb.<span class=\"hljs-built_in\">func1</span>();<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(a) &lt;&lt; endl;\t<span class=\"hljs-comment\">// 3 * int(4)</span><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(b) &lt;&lt; endl;\t<span class=\"hljs-comment\">// (3 + 4) * int(4)</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-派生类的构造过程\"><a href=\"#2-派生类的构造过程\" class=\"headerlink\" title=\"2. 派生类的构造过程\"></a>2. 派生类的构造过程</h2><p>派生类从基类可以继承来所有的成员（成员变量和成员方法）。</p>\n<p><strong>派生类如何初始化基类继承的成员变量：</strong></p>\n<p>通过调用基类相应的构造函数来初始化</p>\n<ul>\n<li>派生类的构造函数和析构函数，负责初始化和清理派生类部分；</li>\n<li>派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数来负责。</li>\n</ul>\n<p><strong>派生类对象构造和析构过程：</strong></p>\n<ol>\n<li>派生类调用基类的构造函数，初始化从基类继承来的成员。</li>\n<li>培生类调用自己的构造函数，初始化自身的成员。</li>\n<li>……….. 派生类对象的作用域到期。</li>\n<li>派生类调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存、文件）。</li>\n<li>系统自动调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件）。</li>\n</ol>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data) <br>        : <span class=\"hljs-built_in\">ma</span>(data) <br>    &#123; <br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;基类构造函数：Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">Base</span>() <br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;基类析构函数：~Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data)<br>        : <span class=\"hljs-built_in\">Base</span>(data), <span class=\"hljs-built_in\">mb</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;派生类构造函数：Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">Derive</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;派生类析构函数：~Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> mb;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110913834.png\" alt=\"image.png\"></p>\n<h2 id=\"3-重载、覆盖、隐藏\"><a href=\"#3-重载、覆盖、隐藏\" class=\"headerlink\" title=\"3. 重载、覆盖、隐藏\"></a>3. 重载、覆盖、隐藏</h2><p>继承结构中，名字相同的成员会产生关系，基类派生类里面相关的成员方法我们经常使用三种关系来描述它们，即：<strong>重载、隐藏、覆盖</strong>关系。</p>\n<ul>\n<li><strong>重载：</strong></li>\n</ul>\n<p>一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同。</p>\n<ul>\n<li><strong>隐藏：</strong></li>\n</ul>\n<p>在继承结构当中，派生类的同名成员，把基类的同盟成员给隐藏掉了，即作用域的隐藏。</p>\n<ul>\n<li><strong>覆盖：</strong></li>\n</ul>\n<p>父子类中的同名、同参数、同返回值的多个成员函数，从子到父形成的关系称为覆盖关系，在虚函数中会详谈它。</p>\n<h3 id=\"1-隐藏关系\"><a href=\"#1-隐藏关系\" class=\"headerlink\" title=\"1. 隐藏关系\"></a>1. 隐藏关系</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">ma</span>(data) &#123; &#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show(int)&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">20</span>) <br>\t\t:<span class=\"hljs-built_in\">Base</span>(data), <span class=\"hljs-built_in\">mb</span>(data) &#123; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tDerive d;<br>\td.<span class=\"hljs-built_in\">show</span>();<br>\td.<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>派生类对象调用了不带参数的show方法，派生类本身没有这个方法。<br>执行结果：调用成功，而且<strong>1与2是函数重载关系</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110931669.png\" alt=\"image.png\"></p>\n<p>我们又给派生类添加了一个不带参数的show方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">20</span>):<span class=\"hljs-built_in\">Base</span>(data), <span class=\"hljs-built_in\">mb</span>(data)&#123;&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//3</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>派生类调用 show 时优先调用自己的 <code>show()</code>，在自己的作用域下找相应的成员名字，若没有才去基类找；当我们调用带整数参数的 <code>show(int)</code>，自己并没有，从基类继承来一个带整型参数的 <code>show(int)</code>。</p>\n<p>执行一下：第二个 <code>show(int)</code> 调用执行出错。1 与 3 属于隐藏关系；2 与 3 也属于隐藏关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110932089.png\" alt=\"image.png\"></p>\n<p>第二个调用的是派生类的 <code>show()</code>，不接受参数。</p>\n<p><strong>为什么不调用基类中的 <code>show(int)</code>？</strong></p>\n<p>派生类对象调用派生类与基类同盟成员时，派生类已经有一个名字 show 了，派生类的 <code>show()</code> 将基类同盟 <code>show()</code>隐藏掉了。</p>\n<p>如果想调用基类成员函数，必须指明基类的作用域来调用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Derive d;<br>d.Base::<span class=\"hljs-built_in\">show</span>();<br>d.Base::<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br></code></pre></td></tr></table></figure>\n\n<p>指明作用域调用成功。  </p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110934024.png\" alt=\"image.png\"></p>\n<h3 id=\"2-继承中的类型转换\"><a href=\"#2-继承中的类型转换\" class=\"headerlink\" title=\"2. 继承中的类型转换\"></a>2. 继承中的类型转换</h3><p>继承结构，我们也称为从上(基类)到下(派生类)的结构。</p>\n<p><strong>类型转换是否可以？</strong></p>\n<ol>\n<li><strong>基类对象——&gt;派生类对象的转换：类型从上到下的转换(NO)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//基类对象——&gt;派生类对象</span><br>d = b;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：执行失败。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110942832.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>派生类对象——&gt;基类对象的转换：类型从下到上的转换(YES)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//派生类对象——&gt;基类对象</span><br>b = d;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：成功执行。</p>\n<ol start=\"3\">\n<li><strong>基类指针(引用)——&gt;指向派生类对象：类型从下到上的转换(YES)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//基类指针(引用)——&gt;派生类对象</span><br>Base *pb = &amp;d;<br>pb-&gt;<span class=\"hljs-built_in\">show</span>();<br>pb-&gt;<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：成功执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110953689.png\" alt=\"image.png\"></p>\n<ol start=\"4\">\n<li><strong>派生类指针(引用)——&gt;指向基类对象：类型从上到下的转换(NO)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//派生类指针(引用)——&gt;指向基类对象</span><br>Derive *pd = &amp;b;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：执行失败。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110954145.png\" alt=\"image.png\"></p>\n<p><strong>总结：</strong></p>\n<p>在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转不安全会涉及内存的非法访问。</p>\n<h2 id=\"4-虚函数、静态绑定和动态绑定\"><a href=\"#4-虚函数、静态绑定和动态绑定\" class=\"headerlink\" title=\"4. 虚函数、静态绑定和动态绑定\"></a>4. 虚函数、静态绑定和动态绑定</h2><p><strong>覆盖：</strong></p>\n<p>如果派生类中的方法和基类继承的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 <strong>virtual 虚函数</strong> ，那么派生类的这个方法，自动被处理成虚函数，它们之间成为覆盖关系；也就是说派生类会在自己虚函数表中将从基类继承来的虚函数进行替换，替换成派生类自己的。</p>\n<p><strong>静态绑定：</strong></p>\n<p>编译时期的多态，通过函数的重载以及模板来实现，也就是说调用函数的地址在编译时期我们就可以确定，在汇编代码层次，呈现的就是 call 函数名。</p>\n<p><strong>动态绑定：</strong></p>\n<p>动态时期的多态，通过派生类重写基类的虚函数来实现。在汇编代码层次，呈现的就是 call 寄存器，寄存器的值只有运行起来才能确定。</p>\n<h3 id=\"1-不存在的虚函数\"><a href=\"#1-不存在的虚函数\" class=\"headerlink\" title=\"1. 不存在的虚函数\"></a>1. 不存在的虚函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">ma</span>(data) &#123; &#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show()&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> </span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data) <br>\t\t:<span class=\"hljs-built_in\">Base</span>(data)<br>\t\t, <span class=\"hljs-built_in\">mb</span>(data) &#123; &#125;<br><br>\t~<span class=\"hljs-built_in\">Derive</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Derive::show()&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建类</span><br>\t<span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">50</span>)</span></span>;<br>\tBase* pb = &amp;d;<br><br>\t<span class=\"hljs-comment\">// 静态（编译时期）绑定(函数调用) Base::show (06F12E4h)</span><br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>();<br>\t<span class=\"hljs-comment\">// Base::show (06F12BCh)</span><br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Base) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Derive) &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(*pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111036581.png\" alt=\"image.png\"></p>\n<p><strong>反汇编查看：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111039623.png\" alt=\"image.png\"></p>\n<p>可以看到调用的都是基类的 <code>show()</code>,在编译阶段已经生成指令调用 Base 下的 show。</p>\n<p><strong>结果：</strong></p>\n<ul>\n<li>因为 pb 是 Base 类型的指针，所以调用的都是 Base 类的成员方法。  </li>\n<li>基类 Base 只有一个数据成员 ma，所以大小只有 4 字节。  </li>\n<li>派生类 Derive 继承了 ma，其次还有自己的 mb，所以有 8 字节。  </li>\n<li>pb 的类型是一个 <code>class Base *</code>；  </li>\n<li><code>*pb</code> 的类型是一个 <code>class Base</code>。</li>\n</ul>\n<p><strong>图示:</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111042657.png\" alt=\"image.png\"></p>\n<p>为什么 <code>Base *</code> 类型的指针，Derive 类型的对象，调用方法的时候是 Base 而不是 Derive 呢？</p>\n<p>原因如上图：</p>\n<p>Derive 类继承了 Base 类，导致了派生类的大小要比基类大，而 pb 的类型是基类的指针，所以通过 pb 调用方法时只能访问到 Derive 中从 Base 继承而来的方法，访问不到自己重写的方法（指针的类型限制了指针解引用的能力）。</p>\n<h3 id=\"2-基类定义虚函数\"><a href=\"#2-基类定义虚函数\" class=\"headerlink\" title=\"2. 基类定义虚函数\"></a>2. 基类定义虚函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">ma</span>(data) &#123; &#125;<br><br>\t~<span class=\"hljs-built_in\">Base</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">// 虚基类</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data) <br>\t\t:<span class=\"hljs-built_in\">Base</span>(data)<br>\t\t, <span class=\"hljs-built_in\">mb</span>(data) &#123; &#125;<br><br>\t~<span class=\"hljs-built_in\">Derive</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建类</span><br>\t<span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">50</span>)</span></span>;<br>\tBase* pb = &amp;d;<br><br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>();<br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Base) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Derive) &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(*pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111047159.png\" alt=\"image.png\"></p>\n<p><strong>反汇编：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111048405.png\" alt=\"image.png\"></p>\n<p><code>pb-&gt;show();</code> 中 pb 指针是 base 类型，如果发现 Base 中的 show 是虚函数，就进行动态绑定。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">|63..32|31..16|15-8|7-0| <br>               |AH.|AL.| <br>               |AX.....| <br>       |EAX............| <br>|RAX...................|<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong><code>mov   rax, qword ptr [pb]</code></strong></li>\n</ol>\n<p>将 pb 指向的内存前 4 个字节放入 rax 寄存器，pb指向derive对象，前四个字节即 <code>vfptr</code>，将虚函数表地址加载到 rax</p>\n<ol start=\"2\">\n<li><strong><code>mov   rax, qword ptr [rax]</code></strong></li>\n</ol>\n<p>将 rax 的前四个字节 即 <code>Derive::show</code> 加载到 rax 中。</p>\n<ol start=\"3\">\n<li><strong><code>call   qword ptr [rax]</code></strong></li>\n</ol>\n<p>虚函数的地址</p>\n<p>可以看到这一次，汇编码 call 的就不是确切的函数地址了，而是寄存器 rax。</p>\n<p>那么就很好理解了：rax 寄存器里存放的是什么内容，编译阶段根本无从知晓，只能在运行的时候确定； 故为，动态绑定。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111100188.png\" alt=\"image.png\"></p>\n<p>pb的类型：Base类型，查看Base中有没有虚函数</p>\n<p>（1）Base中没有虚函数 <code>*pb</code> 识别的就是编译时期的类型 <code>*pb</code> 就是 Base 类型。<br>（2） Base中有虚函数，<code>*pb</code> 识别的就是运行时期的类型 RTTI 类型为：Derive。</p>\n<p>在添加了 virtual 关键字后，对应的函数就变成了虚函数。</p>\n<p><strong>那么，一个类添加了虚函数，对这个类有什么影响呢？</strong></p>\n<ul>\n<li>如果类中定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的 <code>vftable</code> 虚函数表，虚函数表中主要存储的内容是：RTTI（Run-time Type Information）指针和虚函数的地址；当程序运行时，每一张虚函数表都会加载到内存的 <code>.rodata</code> 区（只读数据区）。</li>\n<li>一个类中定义了虚函数，那么这个类定义的对象，在运行时，内存中会多存储一个 <code>vfptr</code> 虚函数的指针，指向对应类型的虚函数表 <code>vftable</code>。</li>\n<li>一个类型定义的 n 个对象，它们的 <code>vfptr</code> 指向的都是同一张虚函数表。</li>\n<li>一个类中的虚函数个数，不影响对象内存的大小（vfptr），影响的是虚函数表 <code>vftable</code> 的大小。</li>\n<li>如果派生类中的方法和从基类继承的某个方法中返回值、函数名以及参数列表都相同，且基类方法为 virtual ，那么派生类的这个方法自动被处理为虚函数。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111110387.png\" alt=\"image.png\"></p>\n<p><strong>虚函数表：</strong></p>\n<ol>\n<li>RTTI：存放的是类型信息，也就是（Base 或 Derive）。</li>\n<li>偏移地址：虚函数指针相对于对象内存空间的便宜，一般 <code>vfptr</code> 都在 0 偏移位置。</li>\n<li>之后是函数时虚函数入口地址。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111112719.png\" alt=\"image.png\"></p>\n<p>在 Derive 类中，由于重写了 <code>show()</code>,因此在 Derive 的虚函数表中，是使用子类的 show() 方法代替了 Base 类的 <code>show()</code>。</p>\n<h3 id=\"3-VS-工具查看虚函数表相关\"><a href=\"#3-VS-工具查看虚函数表相关\" class=\"headerlink\" title=\"3. VS 工具查看虚函数表相关\"></a>3. VS 工具查看虚函数表相关</h3><ol>\n<li>找到</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111116949.png\" alt=\"image.png\"></p>\n<p>打开后：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111117972.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li>在打开的窗口中切换到当前工程所在目录</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111119264.png\" alt=\"image.png\"></p>\n<ol start=\"3\">\n<li>输入指令</li>\n</ol>\n<p>可通过 dir 命令查看当前目录所有文件</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111120593.png\" alt=\"image.png\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cl XXX.cpp /d1reportSingleClassLayoutXX<br></code></pre></td></tr></table></figure>\n\n<p>第一个XXX表示源文件的名字，第二个代表你想查看的类类型，我这里就是<code>Derive</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111123449.png\" alt=\"image.png\"></p>\n<p>以看到 <code>class Derived</code> 的对象的内存布局，在派生类对象的开始包含了基类 Base 的对象，其中有一个虚表指针，指向的就是下面的<code>Derived::$vftable@ （virtual function table）</code>，表中包含了 Derived 类中所有的虚函数。</p>\n<h2 id=\"5-虚析构函数\"><a href=\"#5-虚析构函数\" class=\"headerlink\" title=\"5. 虚析构函数\"></a>5. 虚析构函数</h2><p>析构函数：可以成为虚函数，调用时候对象存在。</p>\n<p>虚析构函数：在析构函数前加上 virtual 关键字。</p>\n<p>什么时候需要把基类的析构函数必须实现成虚函数？<br>       <br>基类的指针(引用)指向堆上 new 出来的派生类对象的时候，delete 调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data) <br>        : <span class=\"hljs-built_in\">ma</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;~Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;call Base::show()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data) <br>        : <span class=\"hljs-built_in\">Base</span>(data)<br>        , <span class=\"hljs-built_in\">mb</span>(data)<br>        , <span class=\"hljs-built_in\">ptr</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(data))<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">Derive</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> ptr;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;~Derive() &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> mb;<br>    <span class=\"hljs-type\">int</span>* ptr;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Base* pb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-number\">10</span>);<br>    <span class=\"hljs-comment\">// 静态绑定pb Base*   *pb Derive</span><br>    pb-&gt;<span class=\"hljs-built_in\">show</span>();<br><br>    <span class=\"hljs-keyword\">delete</span> pb;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111143308.png\" alt=\"image.png\"></p>\n<p><strong>没有调用派生类的析构函数，造成内存泄漏。</strong></p>\n<p><strong>问题：</strong></p>\n<p>pb 的配型是 Base 类型，因此 delete 调用析构函数先去 Base 找 <code>Base::~Base()</code>，对于析构函数的第哦啊用就是静态绑定，之间编译，没有机会调用派生类的析构函数，最后发生内存泄漏。</p>\n<p><strong>解决：</strong></p>\n<p>将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb 的类型是 Base 类型，调用析构时去 Base 中找 <code>Base::~Base</code> 发现它为虚函数，发生动态绑定。派生类的虚函数表中：<code>&amp;Derive:: ~derive</code>，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。</p>\n<p><strong>注意：</strong></p>\n<p><strong>构造函数不能为虚函数！！！</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111146816.png\" alt=\"image.png\"></p>\n<p>（1）从存储空间角度：</p>\n<p>虚函数对应一个 <code>vftable</code> ，这个 <code>vftable</code> 其实是存储在内存空间的。问题来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找 <code>vtable</code> 呢？所以构造函数不能是虚函数。</p>\n<p>（2）从使用角度：</p>\n<p>虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。</p>\n<p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>\n<p>（4）构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p>\n<p>（5）从实现上看，<code>vbtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数</p>\n<p>从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p>\n<h2 id=\"6-理解多态是什么\"><a href=\"#6-理解多态是什么\" class=\"headerlink\" title=\"6. 理解多态是什么\"></a>6. 理解多态是什么</h2><p>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。</p>\n<p>所谓“虚函数”，就是在声明时前面加了virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。  </p>\n<p>包含虚函数的类称为“<strong>多态类</strong>”。  </p>\n<p>多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。  </p>\n<p>多态在面向对象的程序设计语言中如此重要，以至于有类和对象的概念，但是不支持多态的语言，只能被称作“基于对象的程序设计语言”，而不能被称为“面向对象的程序设计语言”。例如，Visual Basic 就是“基于对象的程序设计语言”。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">D</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;D::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">E</span> : <span class=\"hljs-keyword\">public</span> B<br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;E::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    A a;<br>    B b;<br>    D d;<br>    E e;<br><br>    A* pa = &amp;a;<br>    B* pb = &amp;b;<br><br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = pb;<br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;d;<br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;e;<br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405480.png\" alt=\"image.png\"></p>\n<p>程序中，四个类之间的派生关系如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405483.png\" alt=\"image.png\"></p>\n<p>每个类都有同名、同参数表的虚函数 Print（每个 Print 函数声明时都加了 virtual 关键字）。根据多态的规则，对于语句<code>pa-&gt;Print()</code>，由于 Print 是虚函数，尽管 pa 是基类 A 的指针，编译时也不能确定调用的是哪个类的 Print 函数。当程序运行到该语句时，pa 指向的是哪个类的对象，调用的就是哪个类的 Print 函数。    </p>\n<p>多态的语句调用哪个类的成员函数是在运行时才能确定的，编译时不能确定（具体原理后面会解释）。因此，多态的函数调用语句被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。</p>\n<h3 id=\"1-多态起手式以及内存分布\"><a href=\"#1-多态起手式以及内存分布\" class=\"headerlink\" title=\"1.多态起手式以及内存分布\"></a>1.多态起手式以及内存分布</h3><p>假设有一个基类 ClassA，一个继承了该基类的派生类 ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。</p>\n<p>在代码中运用多态这个特性时，通常以两种方式起手：<br>(1) <code>ClassA *a = new ClassB();</code><br>(2) <code>ClassB b; ClassA *a = &amp;b;</code></p>\n<p>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第 1 个用了 new 关键字而分配在堆上，第 2 个分配在栈上：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111411592.png\" alt=\"image.png\"></p>\n<p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，<code>ClassA *a</code> 是一个栈上的指针。</p>\n<p>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向 <strong>该类的虚函数表(这里是类ClassB)</strong> 的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p>\n<h3 id=\"2-类的虚函数表与类实例的虚函数指针\"><a href=\"#2-类的虚函数表与类实例的虚函数指针\" class=\"headerlink\" title=\"2. 类的虚函数表与类实例的虚函数指针\"></a>2. 类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况；如果一个类中有虚函数，那么该类就有一个虚函数表。</p>\n<p>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。</p>\n<p>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111417318.png\" alt=\"image.png\"></p>\n<h3 id=\"3-多态代码及多重继承情况\"><a href=\"#3-多态代码及多重继承情况\" class=\"headerlink\" title=\"3. 多态代码及多重继承情况\"></a>3. 多态代码及多重继承情况</h3><p>讨论了在没有继承的情况下，虚函数表的逻辑结构。</p>\n<p>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassA</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::~ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassA::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassA::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> aData;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassB</span> : <span class=\"hljs-keyword\">public</span> ClassA<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassB::ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassB::~ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassB::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassB::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> bData;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassC</span> : <span class=\"hljs-keyword\">public</span> ClassA<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::~ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassC::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> aData;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    ClassC c;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>(1) ClassA 是基类, 有普通函数: <code>fn1()、fn2()</code> 。虚函数: <code>vfn1()、vfn2()、~ClassA()</code><br>(2) ClassB 继承 ClassA, 有普通函数: <code>fn1()</code>。虚函数: <code>vfn1()、~ClassB()</code><br>(3) ClassC 继承 ClassB, 有普通函数: <code>fn2()</code>。虚函数: <code>vfn2()、~ClassB()</code></p>\n<p>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。</p>\n<p>ClassB 继承与 ClassA，其虚函数表是在 ClassA 虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">ClassA* a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ClassB</span>();<br><br>a-&gt;<span class=\"hljs-built_in\">fn1</span>();<br>a-&gt;<span class=\"hljs-built_in\">fn2</span>();<br><br>a-&gt;<span class=\"hljs-built_in\">vfn1</span>();<br>a-&gt;<span class=\"hljs-built_in\">vfn2</span>();<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111430434.png\" alt=\"image.png\"></p>\n<p><strong>使用 VS 开发者工具查看：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111432206.png\" alt=\"image.png\"></p>\n<p>这个结果不难想象，看上图，ClassA 类型的指针 a 能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同</p>\n<p>这个结果已经说明了 C++ 的隐藏、重写(覆盖)特性。</p>\n<p>同理，也就不难推导出 ClassC 的逻辑结构图了</p>\n<p>类的继承情况是: ClassC 继承 ClassB，ClassB 继承 ClassA；这是一个多次单继承的情况。(多重继承)。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111435576.png\" alt=\"image.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111436071.png\" alt=\"image.png\"></p>\n<h3 id=\"4-多继承下的虚函数表-同时继承多个基类\"><a href=\"#4-多继承下的虚函数表-同时继承多个基类\" class=\"headerlink\" title=\"4. 多继承下的虚函数表 (同时继承多个基类)\"></a>4. 多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br> <br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassA1</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>  <span class=\"hljs-built_in\">ClassA1</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassA1</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::~ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>  <span class=\"hljs-type\">int</span> a1Data;<br>&#125;;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassA2</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>  <span class=\"hljs-built_in\">ClassA2</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassA2</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::~ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc4</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::vfunc4()&quot;</span> &lt;&lt; endl; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>  <span class=\"hljs-type\">int</span> a2Data;<br>&#125;;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassC</span> : <span class=\"hljs-keyword\">public</span> ClassA1, <span class=\"hljs-keyword\">public</span> ClassA2<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>  <span class=\"hljs-built_in\">ClassC</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::ClassC()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassC</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::~ClassC()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc3</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::vfunc3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br> <br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ClassC c;<br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111445452.png\" alt=\"image.png\"></p>\n<p>（1）ClassA1 是第一个基类，拥有普通函数 <code>func1()</code>，虚函数<code>vfunc1()、 vfunc2()</code>。<br>（2）ClassA2 是第二个基类，拥有普通函数 <code>func1()</code>，虚函数 <code>vfunc1()、 vfunc2()、vfunc4()</code>。<br>（3）ClassC 依次继承 ClassA1、ClassA2。普通函数 <code>func1()</code>,虚函数<code>vfunc1()、vfunc2()、vfunc3()</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111442375.png\" alt=\"image.png\"></p>\n<p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。</p>\n<p>如图，虚函数表指针 01 指向的虚函数表是以 ClassA1 的虚函数表为基础的，子类的 <code>ClassC::vfunc1()</code>,和 <code>vfunc2()</code> 的函数指针覆盖了虚函数表 01 中的虚函数指针 01 的位置、02 位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。注意：</p>\n<ol>\n<li>子类虚函数会覆盖每一个父类的每一个同名虚函数。</li>\n<li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li>\n<li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用</li>\n</ol>\n<p>最后给出代码和结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">ClassA1 *a1 = <span class=\"hljs-keyword\">new</span> ClassC;<br>a1-&gt;<span class=\"hljs-built_in\">func1</span>();               <span class=\"hljs-comment\">// &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span><br>a1-&gt;<span class=\"hljs-built_in\">vfunc1</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span><br>a1-&gt;<span class=\"hljs-built_in\">vfunc2</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span><br>没有a1-&gt;<span class=\"hljs-built_in\">vfunc3</span>()，父类没有这个虚函数<br><br>ClassA2 *a2 = <span class=\"hljs-keyword\">new</span> ClassC;<br>a2-&gt;<span class=\"hljs-built_in\">func1</span>();               <span class=\"hljs-comment\">// &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span><br>a2-&gt;<span class=\"hljs-built_in\">vfunc1</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class=\"hljs-built_in\">vfunc2</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class=\"hljs-built_in\">vfunc4</span>();              <span class=\"hljs-comment\">// &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span><br><br>ClassC *c = <span class=\"hljs-keyword\">new</span> ClassC;<br>c-&gt;<span class=\"hljs-built_in\">func1</span>();                <span class=\"hljs-comment\">// &quot;ClassC::func1()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc1</span>();               <span class=\"hljs-comment\">// &quot;ClassC::vfunc1()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc2</span>();               <span class=\"hljs-comment\">// &quot;ClassC::vfunc2()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc3</span>();               <span class=\"hljs-comment\">// &quot;ClassC::vfunc3()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc4</span>();               <span class=\"hljs-comment\">// &quot;ClassA2::func4()&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-理解抽象类\"><a href=\"#7-理解抽象类\" class=\"headerlink\" title=\"7. 理解抽象类\"></a>7. 理解抽象类</h2><p>抽象类(接口)：接口描述了类的行为和功能,而无需完成类的特定实现</p>\n<p>C++ 接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用</p>\n<p><strong>注意:</strong></p>\n<p>如果试图实例化一个抽象类的对象，会导致编译错误。</p>\n<p>因此，如果一个抽象类的派生类需要被实例化(建立对象)，则必须对每个继承来的纯虚函数进行函数体实现。<br>如果没有在派生类中重写所有纯虚函数，就尝试实例化派生类的对象，也会导致编译错误，这是因为如果派生类没有实现父类的纯虚函数，则派生类变为抽象类。</p>\n<p>抽象类基类为派生自抽象基类的派生类提供了约束条件，即：派生类必须要实现继承自抽象基类中的纯虚函数，否则此派生类不可进行实例化，且派生类将继承为抽象派生类。</p>\n<h3 id=\"1-抽象类与纯虚函数（抽象方法）\"><a href=\"#1-抽象类与纯虚函数（抽象方法）\" class=\"headerlink\" title=\"1. 抽象类与纯虚函数（抽象方法）\"></a>1. 抽象类与纯虚函数（抽象方法）</h3><p><strong>纯虚函数</strong>是一个在 <strong>基类中声明的虚函数</strong>，它在该基类中<strong>没有定义具体的函数体</strong>(操作内容),要求<strong>派生类根据实际需要定义自己的版本</strong>，设计多层次类继承关系时用到。把某个方法声明为一个抽象方法等于告诉编译器,这个方法<strong>必不可少</strong>，但目前在基类中还不能为它提供实现</p>\n<p>纯虚函数的标准格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">virtual</span> 函数类型 函数名（参数表）= <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pet</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">// 声明了一个纯虚函数 也就是在虚函数尾部加上&quot; = 0 &quot; 一个虚函数便被声明成为了一个纯虚函数</span><br>\t<span class=\"hljs-comment\">// 等于 0 表示该函数仅声明而没有函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>一旦类中有了纯虚函数，这个类便被称为：<strong>抽象类</strong>。</p>\n<blockquote>\n<p><strong>且此类不能被实例化！！！（不可建立类对象实例！！！）</strong></p>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 报错！带有纯虚函数的类称为抽象类，不可实例化</span><br>\tPet pet; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>抽象类：</strong></p>\n<p>只能作为积累使用，无法定义抽象类对象实例，这是因为 <strong>抽象类中包含了没有定义的纯虚函数</strong>，在 C++ 中，我们把 <strong>只能由于被继承而不能直接创建对象的类</strong> 称之为：<strong>抽象类</strong>，这种基类不能直接生成对象，而只有被继承后，并重写其虚函数后，才能使用。</p>\n<p>当抽象类的派生类实现了继承而来的纯虚函数后，才能实例化对象。</p>\n<p>之所以要存在抽象类，最主要是因为它具有不确定因素，我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为虚函数。虚函数是一种特殊的函数，在抽象类中只有声明，没有具体的定义。</p>\n<p><strong>抽象类和纯虚函数的关系</strong></p>\n<p>抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类，存在纯虚函数是成为抽象类的充要条件。</p>\n<h3 id=\"2-为什么需要一个抽象类\"><a href=\"#2-为什么需要一个抽象类\" class=\"headerlink\" title=\"2. 为什么需要一个抽象类\"></a>2. 为什么需要一个抽象类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// todonew 与 delete 动态分配内存,与用指针调用对象 通过对象的不同调用不同的同名虚函数</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pet</span> <span class=\"hljs-comment\">// 声明纯虚函数 sound 后 Pet 类变为抽象类(接口)</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Pet</span>(string thename);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sleep</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sound</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">// 声明纯虚函数 sound  (并未进行函数实现 函数实现放在派生类中)</span><br><br>    <span class=\"hljs-comment\">//注意:\t\t\t\t\t   </span><br>    <span class=\"hljs-comment\">//todo1.继承自抽象基类 Pet 的子类必须全部实现基类中的所有纯虚函数</span><br>    <span class=\"hljs-comment\">//todo2.抽象基类 Pet 不可进行实例化</span><br><br><span class=\"hljs-keyword\">protected</span>:<br>    string name;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> :<span class=\"hljs-keyword\">public</span> Pet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cat</span>(string thename);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">climb</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sound</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> :<span class=\"hljs-keyword\">public</span> Pet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Dog</span>(string thename);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">jump</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sound</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br><br><br>Pet::<span class=\"hljs-built_in\">Pet</span>(string thename) <span class=\"hljs-comment\">// todo 基类构造器(抽象类也有构造函数)</span><br>&#123;<br>    name = thename;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Pet::sleep</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;正在睡大觉\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Pet::sound</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;动物发声\\n&quot;</span>;<br>&#125;<br><br>Cat::<span class=\"hljs-built_in\">Cat</span>(string thename) :<span class=\"hljs-built_in\">Pet</span>(thename) <span class=\"hljs-comment\">// 派生类 Cat 构造函数</span><br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cat::climb</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;正在爬树\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">Cat::sound</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 派生类虚函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br><br>    <span class=\"hljs-comment\">//\tPet::sound(); // todo 如果需要调用基类中的 play() 函数  在原本的play()函数的基础上加上覆盖上的子类play()函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;喵喵喵!\\n&quot;</span>;<br>&#125;<br><br><br>Dog::<span class=\"hljs-built_in\">Dog</span>(string thename) :<span class=\"hljs-built_in\">Pet</span>(thename)<span class=\"hljs-comment\">// 派生类 Dog 构造函数</span><br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Dog::jump</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;跳过了栅栏\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Dog::sound</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 派生类虚函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//\tPet::sound();</span><br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;汪汪汪!\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(Pet* x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    x-&gt;<span class=\"hljs-built_in\">sound</span>();<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//\tPet pet; // todo 用带有抽象方法(纯虚函数)的抽象类 Pet 无法实例化对象</span><br><br>    <span class=\"hljs-comment\">// todo 创建指向子类实例的基类指针和引用来调用纯虚函数</span><br>    Pet* cat = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Cat</span>(<span class=\"hljs-string\">&quot;猫&quot;</span>);<br>    Pet* dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Dog</span>(<span class=\"hljs-string\">&quot;狗&quot;</span>);<br><br>    <span class=\"hljs-comment\">// todo 创建对象实例来调用纯虚函数</span><br>    <span class=\"hljs-function\">Cat <span class=\"hljs-title\">cat2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;对象实例调用 猫&quot;</span>)</span></span>;<br>    cat2.<span class=\"hljs-built_in\">sound</span>();<br><br>    <span class=\"hljs-built_in\">func</span>(cat);<br>    <span class=\"hljs-built_in\">func</span>(dog);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>本例中定义了三个类,它们的继承关系为：<code>Animal--&gt;Cat</code>和<code>Animal--&gt;Dog</code></p>\n<p>Animal 是一个抽象类，也是最顶层的基类，在 Animal 类中定义了一个<strong>纯虚函数</strong><code>sound()</code>，在 <code>Cat</code> 类中，实现了<code>sound()</code>函数。所谓实现，就是定义了纯虚函数的函数体，抽象类 Animal 虽然不能实例化，但它为派生类提供了<strong>约束条件</strong>，派生类必须要实现这个函数，完成动物发声功能，否则就不能对派生类进行实例化。</p>\n<p>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的，虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111557893.png\" alt=\"image.png\"></p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>任何具有纯虚函数的类都是抽象类。</li>\n<li>抽象类基类不可建立实例。</li>\n<li>抽象类派生出的子类需将继承的纯虚函数全部进行实例化，才能建立其实例。</li>\n<li>抽象类可以有构造函数。</li>\n<li>如果派生类没有实现父类的纯虚函数，则派生类变为抽象类，即不可建立其实例。</li>\n<li>抽象基类除了约束派生类的功能，还可以实现多态，可以创建指向子类的实例的抽象基类的指针和引用。</li>\n<li>只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。</li>\n</ol>\n<h2 id=\"8-理解虚基类和虚继承\"><a href=\"#8-理解虚基类和虚继承\" class=\"headerlink\" title=\"8. 理解虚基类和虚继承\"></a>8. 理解虚基类和虚继承</h2><p><strong>virtual作用：</strong></p>\n<ol>\n<li>virtual 修饰了成员方法是虚函数。  </li>\n<li>可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。</li>\n</ol>\n<ul>\n<li><strong>vfptr</strong>：一个类有虚函数，这个类生成的对象就有 vfptr，指向 vftable。  </li>\n<li><strong>vbptr</strong>：在派生类中从基类虚继承而来。  </li>\n<li><strong>vftable</strong>：第一行为向上偏移量，第二行为虚基类指针离虚基类内存的偏移量。  </li>\n<li><strong>vbtable</strong>：存放的 RTTI 指针，指向运行时 RTTI 信息与虚函数地址。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-comment\">//A a; 4个字节</span><br><span class=\"hljs-comment\">//B b; 8个字节</span><br></code></pre></td></tr></table></figure>\n\n<p>这里我们的对象 a 占 4 个字节，对象 8 占 8 个字节。但如果我们给 B 的继承方式访问限定符前面加了一个 virtual 关键字。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>类 A 被虚继承了，但内存布局没有变化：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111611448.png\" alt=\"image.png\"></p>\n<p><strong>类 B 在继承普通基类的内存变化：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111612673.png\"></p>\n<p>再看一下类 B，不是之前的 8 个字节，变为 12 个字节，多了一个 vbptr 指针。原来最上面应该为 ma 与 mb，但是现在多了一个 <code>vbptr</code>(虚基类指针)，ma 跑到派生类最后面去了。<code>vbptr</code> 指向的是 <code>vbtable</code>，<code>vbtable</code> 第一行为 0，第二行为虚基类指针到虚基类数据的偏移量。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111614890.png\" alt=\"image.png\"></p>\n<p>当遇到虚继承时候，要考虑派生类 B 的内存布局时；</p>\n<p>首先，先不考虑虚继承，类 B 继承了基类的 ma，还有自己的mb；当基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个 <code>vbptr</code>。派生类的内存就由这几部分来构成。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111618147.png\" alt=\"image.png\"></p>\n<p>虚基类指针(<code>vbptr</code>)指向虚基类表(<code>vbtable</code>)，<code>vbtable</code> 第一行为向上的偏移量，因为 <code>vbptr</code> 在该派生类内存起始部分，因此向上的偏移量为 0；第二行为向下的偏移量(<code>vbptr</code> 离虚基类数据的偏移量)，原来基类的数据放到最后，找 ma 的时候还是在最开始找，但 ma 被移动，根据偏移的字节就可以找到。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111619886.png\" alt=\"image.png\"></p>\n<h3 id=\"1-虚基类和虚继承出错情况分析\"><a href=\"#1-虚基类和虚继承出错情况分析\" class=\"headerlink\" title=\"1. 虚基类和虚继承出错情况分析\"></a>1. 虚基类和虚继承出错情况分析</h3><p><strong>那么当我们虚基类指针与虚函数指针在一起出现的时候会发生什么呢？</strong></p>\n<p>调用是没有问题的，但是 delete 会出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</span><br>\tA* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">B</span>();<span class=\"hljs-comment\">// B::vftable</span><br>\tp-&gt;<span class=\"hljs-built_in\">func</span>();<br>\t<span class=\"hljs-keyword\">delete</span> p;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如图：调用成功，但delete时会出错。  </p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111623556.png\" alt=\"image.png\"></p>\n<p><strong>分析：</strong></p>\n<p>B 的内存布局：</p>\n<p>B 首先从 A 中获取 <code>vfptr</code> 与 ma， B 中还有自身的 mb；<br>此时 A 被虚继承，A 中所有的东西都移动到派生类最后面，最上面补一个<code>vbptr</code>，<code>vbptr</code> 指向 <code>vbtable</code>，<code>vfptr</code> 指向 <code>vftable</code>；基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</p>\n<p>普通情况下，派生类内存布局先是基类，在是派生类，基类指针指向派生类对象时，基类指针指向的就是派生类内存的起始部分。但是，虚继承下基类称为虚基类，虚基类的数据在派生类最后面，原地方补上 <code>vbptr</code>，此时再用基类指针指向派生类对象时候，基类指针永远指向派生类基类部分的起始地址。虚基类一开始就是 <code>vfptr</code>，能够用 p 指向的对象访问 <code>vfptr</code> 与 <code>vftable</code> 的原因。释放内存时候出错，因为对象开辟是在最上面即绿色部分，但是 p 所持有的是虚基类的地址，delete 时从虚基类起始地址 delete，因此出错。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111627334.png\" alt=\"image.png\"></p>\n<p>命令验证如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111628141.png\" alt=\"image.png\"></p>\n<p><strong>验证一下内存地址：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ptr)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator delete p:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>\t\t<span class=\"hljs-built_in\">free</span>(ptr);<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">void</span>* p = <span class=\"hljs-built_in\">malloc</span>(size);<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator new p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> p;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">B</span>(); <span class=\"hljs-comment\">// B::vftable</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>\tp-&gt;<span class=\"hljs-built_in\">func</span>();<br>\t<span class=\"hljs-keyword\">delete</span> p;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111629072.png\" alt=\"image.png\"></p>\n<p><code>00000119E9411CB0</code> 为分配的内存的起始地址，我们用基类指针指向派生类对象一定是指向派生类内存基类的起始部分：<code>00000119E9411CC0</code> 刚好比 <code>00000119E9411CB0</code> 多了 16 个字节，是 <code>vbptr</code> 与 mb，但是 delete 时候从 <code>00000119E9411CC0</code> 开始释放，因此崩溃。</p>\n<p>Windows 的 VS 下这样写会出错，但是 Linux 下的 <code>g++ delete</code> 时会自动偏移到 new 内存的起始部分，进行内存 <code>free()</code>，不会出错。</p>\n<p>如果在栈上开辟内存，基类指针指向派生类对象，出了作用域自己进行析构，这样是没有问题的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">B b;<br>A *p = &amp;b; <span class=\"hljs-comment\">// B::vftable</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>p-&gt;<span class=\"hljs-built_in\">func</span>();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"9-菱形继承问题\"><a href=\"#9-菱形继承问题\" class=\"headerlink\" title=\"9. 菱形继承问题\"></a>9. 菱形继承问题</h2><p><strong>多重继承：</strong> 一个<code>派生类</code>如果只继承一个<code>基类</code>，称作单继承； 一个<code>派生类</code>如果继承了多个<code>基类</code>，称作多继承。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111602992.png\" alt=\"image.png\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>多重继承可以做更多的代码复用！</li>\n<li>派生类通过多重继承，可以得到多个基类的数据和方法，更大程度的实现了代码复用。</li>\n</ul>\n<p><strong>问题：</strong></p>\n<p>菱形继承的问题：在于继承时有重复利用的数据。</p>\n<p><strong>会导致派生类有多份间接基类的数据，可以采用虚继承来解决。</strong> <strong>A 为 B、C 的基类，B 从 A 单继承而来，C 从 A 也是单继承而来；D 是 B 和 C 多继承而来，D 有两个基类分别为 B 和 C。A 称为 D 的间接基类，D 也有 A 的数据。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111637497.png\" alt=\"image.png\"></p>\n<p>当然，多重继承还会出现别的问题：</p>\n<p><strong>半圆形继承问题：</strong> <strong>B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111638517.png\" alt=\"image.png\"></p>\n<p>多重继承虽然可以复用多个基类的代码到派生类中，但是会出现许多问题，因此 C++ 开源代码上很少见到多重继承。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">ma</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">A</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">B</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mb</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">B</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">C</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mc</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">C</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mc;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">D</span> : <span class=\"hljs-keyword\">public</span> B, <span class=\"hljs-keyword\">public</span> C<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">D</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">B</span>(data), <span class=\"hljs-built_in\">C</span>(data), <span class=\"hljs-built_in\">md</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">D</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> md;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">D <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>画一下 d 对象的内存布局：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641312.png\" alt=\"image.png\"></p>\n<p>D 能看见 B，C 与 md，所以 D 在构造时调用 B，C 的构造及 ma 的初始化。 ma 的初始化在 B 与 C 的构造函数中进行，因此 D 内存为 20 个字节。</p>\n<p>输出结果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641957.png\" alt=\"image.png\"></p>\n<p>先是 A 的构造，B 的构造，又是 A 的构造，C 的构造，最后是 D 的构造；析构顺序与其相反。就会发现，D 这个派生类中调用了两次 A 的构造，数据重复，浪费内存，这种情况必须被杜绝。</p>\n<p><strong>如何处理？</strong></p>\n<p><strong>虚继承来处理，所有从A继承而来的地方都采用虚继承，A 就为虚基类。</strong></p>\n<p>此时：<br>B 从 A 虚继承而来，A 为虚基类，<code>A::ma</code> 移动到派生类最后面，在 <code>A::ma</code> 位置上补一个 <code>vbptr</code>；C 也是从 A 虚继承而来，<code>A::ma</code> 移动到派生类最后面，但发现已经有一份同样的虚基类的数据，那么 C 的 <code>A::ma</code> 丢弃，在 <code>A::ma</code> 位置存放 <code>vbptr</code>。此时派生类中只有一份基类 <code>A::ma</code> 的数据，以后访问都是同一个 ma；同时 ma 的初始化由 D 来负责。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111645047.png\" alt=\"image.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">ma</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">A</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">B</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mb</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">B</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">C</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mc</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">C</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mc;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">D</span> : <span class=\"hljs-keyword\">public</span> B, <span class=\"hljs-keyword\">public</span> C<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">D</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">B</span>(data), <span class=\"hljs-built_in\">C</span>(data), <span class=\"hljs-built_in\">md</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">D</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> md;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">D <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>打印结果：修改成功；A、B、C、D各初始化与析构一次。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111646462.png\" alt=\"image.png\"></p>\n<h2 id=\"10-C-的-四种类型转换\"><a href=\"#10-C-的-四种类型转换\" class=\"headerlink\" title=\"10. C++ 的 四种类型转换\"></a>10. C++ 的 四种类型转换</h2><blockquote>\n<ol>\n<li>const_cast</li>\n<li>static_cast</li>\n<li>reinterpert_cast</li>\n<li>dynamic_cast</li>\n</ol>\n</blockquote>\n<h3 id=\"1-const-cast\"><a href=\"#1-const-cast\" class=\"headerlink\" title=\"1. const_cast\"></a>1. const_cast</h3><p><strong>const_cast：修改类型的const或volatile属性。</strong> 使用该运算方法可以返回一个指向非常量的指针（或引用）指向，就可以通过该指针（或引用）对它的数据成员任意改变。</p>\n<p><strong>注意：</strong>  </p>\n<p>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。  </p>\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">const_cast</span>&lt;里面必须是指针或引用类型&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>实例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> *p1 = (<span class=\"hljs-type\">int</span>*)&amp;a;<span class=\"hljs-comment\">// C 中类型转换</span><br><span class=\"hljs-type\">int</span> *p2 = <span class=\"hljs-built_in\">const_cast</span>&lt;<span class=\"hljs-type\">int</span>*&gt;(&amp;a);<span class=\"hljs-comment\">// C++ 中类型转换 const_cast</span><br></code></pre></td></tr></table></figure>\n\n<p>转换为相同类型的时候，通过反汇编查看时候，发现 C 中的类型强转与 C++ 中 <code>const_cast</code> 所生成的汇编指令底层是一模一样的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111757973.png\" alt=\"image.png\"></p>\n<p>但是在转换成汇编指令之前，即编译阶段，就有所不同。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><strong>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-comment\">// C 中类型转换，可以</span><br><span class=\"hljs-type\">char</span> *p1 = (<span class=\"hljs-type\">char</span>*)&amp;a;<br><span class=\"hljs-comment\">// C++ 中类型转换 const_cast，不可以</span><br><span class=\"hljs-type\">char</span> *p2 = <span class=\"hljs-built_in\">const_cast</span>&lt;<span class=\"hljs-type\">char</span>*&gt;(&amp;a);<br></code></pre></td></tr></table></figure>\n\n<p>通过 C中类型转换可以将 <code>int *</code> 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过 <code>const_cast</code> 将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。<code>const_cast</code>使用时，地址的类型是与左边类型以及转换的类型需要保持一致。防止了 C 中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。</p>\n<p>编译出错：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111806390.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong><code>const_cast&lt;里面必须是指针或引用类型&gt;</code>，否则出错</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-built_in\">const_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(a);<br></code></pre></td></tr></table></figure>\n\n<p>编译出错：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111807110.png\" alt=\"image.png\"></p>\n<h3 id=\"2-static-cast\"><a href=\"#2-static-cast\" class=\"headerlink\" title=\"2. static_cast\"></a>2. static_cast</h3><p><strong><code>static_cast(静态)</code>：编译时期的类型转换，提供编译器认为安全的类型转换。</strong></p>\n<p>是一个 c++ 运算符，功能是把一个表达式转换为某种类型，使用最多。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><strong>有联系的类型之间可以互相转换。</strong></li>\n<li><strong>没有任何联系的类型之前转换会被否定。</strong></li>\n<li><strong>基类类型与派生类类型进行转换，可以用 <code>static_cast</code>，它们类型之间有关系，但不一定安全。</strong></li>\n</ol>\n<p><strong>实例：</strong></p>\n<ol>\n<li>有联系的类型之间可以互相转换</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">char</span> b = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(a);<br></code></pre></td></tr></table></figure>\n\n<p>编译成功，int 与 char 直之间有联系。</p>\n<ol start=\"2\">\n<li>有任何联系的类型之间的转换会被否定</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span>* p = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-comment\">// double* = (double*)p; C 可以转换</span><br><span class=\"hljs-type\">double</span>* b = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111811911.png\" alt=\"image.png\"></p>\n<h3 id=\"3-reinterpert-cast\"><a href=\"#3-reinterpert-cast\" class=\"headerlink\" title=\"3. reinterpert_cast\"></a>3. reinterpert_cast</h3><p><strong><code>reinterpret_cast</code>：类似于 C 风格的强制类型转换，是 C++ 里的强制类型转换符，不安全。</strong></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li>\n</ol>\n<p><strong>实例：</strong> </p>\n<ol>\n<li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> *p = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-type\">double</span>* b = <span class=\"hljs-built_in\">reinterpret_cast</span>&lt;<span class=\"hljs-type\">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure>\n\n<p><code>reinterpret_cast</code> 与 C 中类型转换类似，转换成功，不安全。</p>\n<h3 id=\"4-dynamic-cast\"><a href=\"#4-dynamic-cast\" class=\"headerlink\" title=\"4. dynamic_cast\"></a>4. dynamic_cast</h3><p><strong><code>dynamic_cast</code>(动态)：运行时期的类型转换，用于继承结构中，可以支持 RTTI 类型识别的上下转换及识别。</strong></p>\n<p><strong>将一个基类对象指针（或引用）转换到继承类指针，<code>dynamic_cast</code> 会根据基类指针是否真正指向继承类指针来做相应处理。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive1</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call Derive1::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive2</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showFunc</span><span class=\"hljs-params\">(Base* p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tp-&gt;<span class=\"hljs-built_in\">func</span>();<span class=\"hljs-comment\">//动态绑定</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tDerive1 d1;<br>\tDerive1 d2;<br>\t<br>\t<span class=\"hljs-built_in\">showFunc</span>(&amp;d1);<br>\t<span class=\"hljs-built_in\">showFunc</span>(&amp;d2);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：执行成功。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111838785.png\" alt=\"image.png\"></p>\n<p>需求改变了，<code>Derive</code> 实现了一个新功能的 API 接口函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive2</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//需求更改 Derive2实现新功能的API接口函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">derive02func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call derive02func()::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>void show()</code> 应该区分判断一下，如果 <code>Base* p</code> 指向了其他的派生类对象，调用 <code>p-&gt;func()</code> 方法就好。但如果指向 Derive2 对象，不调用 <code>func()</code> 方法，而调用 Derive2 的 <code>derive02 func()</code>方法。该如何做呢？</p>\n<p>这里就要识别 <code>*p</code> 的类型，看它指向哪个对象。此时就需要<code>dynamic_cast()</code>了。dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象；<code>p-&gt;vfptr-&gt;vftable</code> RTTI 信息 如果是 <code>dynamic_cast</code>，转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showFunc</span><span class=\"hljs-params\">(Base* p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象</span><br>\t<span class=\"hljs-comment\">// p-&gt;vfptr-&gt;vftable RTTI 信息 如果是 dynamic_cast，</span><br>\t<span class=\"hljs-comment\">// 转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr</span><br>\tDerive2 *pd2 = <span class=\"hljs-built_in\">dynamic_cast</span>&lt;Derive2*&gt;(p);<br>\t<span class=\"hljs-keyword\">if</span> (pd2 != <span class=\"hljs-literal\">nullptr</span>)<br>\t&#123;<br>\t\tpd2-&gt;<span class=\"hljs-built_in\">derive02func</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\tp-&gt;<span class=\"hljs-built_in\">func</span>();<span class=\"hljs-comment\">//动态绑定</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>指向结果：调用成功。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111845822.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本节分为十部分：</p>\n<ol>\n<li>继承的基本意义</li>\n<li>派生类的构造过程</li>\n<li>重载、覆盖、隐藏</li>\n<li>虚函数、静态绑定和动态绑定</li>\n<li>虚析构函数</li>\n<li>理解多态是什么</li>\n<li>理解抽象类</li>\n<li>理解虚基类和虚继承</li>\n<li>菱形继承问题</li>\n<li>C++ 的 四种类型转换</li>\n</ol>\n<h2 id=\"1-继承的基本意义\"><a href=\"#1-继承的基本意义\" class=\"headerlink\" title=\"1. 继承的基本意义\"></a>1. 继承的基本意义</h2><p><strong>继承的本质：</strong></p>\n<p>代码的复用，实现多态的基础。</p>\n<p><strong>关系：</strong></p>\n<ul>\n<li>组合：a part of…  一部分的关系</li>\n<li>继承：a kind of… 一种的关系</li>\n</ul>\n<p><strong>继承方式和访问限定罗列：</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>继承方式</td>\n<td>基类的访问限定</td>\n<td>派生类的访问限定</td>\n<td>(main)外部的访问限定</td>\n</tr>\n<tr>\n<td>public</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>public</td>\n<td>public</td>\n<td>Y</td>\n</tr>\n<tr>\n<td></td>\n<td>protected</td>\n<td>protected</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>private</td>\n<td>不可见的</td>\n<td>N</td>\n</tr>\n<tr>\n<td>protected</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>public</td>\n<td>protected</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>protected</td>\n<td>protected</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>private</td>\n<td>不可见的</td>\n<td>N</td>\n</tr>\n<tr>\n<td>private</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>public</td>\n<td>private</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>protected</td>\n<td>private</td>\n<td>N</td>\n</tr>\n<tr>\n<td></td>\n<td>private</td>\n<td>不可见的</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p><strong>protected继承方式下：</strong> <strong>基类的成员的访问限定，在派生类里面是不可能超过继承方式的。public降为protected的。</strong></p>\n<p><strong>private继承方式下：</strong> <strong>public与protected降为private。</strong></p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>外部只能看到并使用 public 成员，protected 和 private 成员无法直接访问。</li>\n<li>在继承结构中，派生类从基类继承来的 private 成员，然是无法直接访问（派生类中不可见）。</li>\n<li>基类成员访问限定，在派生类里面不能超过继承方式。</li>\n</ol>\n<p><strong>protected 和 private 区别：</strong></p>\n<ol>\n<li>如果只是单纯的一个类，没有继承结构，则二者没有区别，外部都是无法访问的。</li>\n<li>若存在继承关系，在基类中定义的成员，想被派生类访问，但不想被外部访问，那么可以在基类中将该成员定义为保护型。</li>\n<li>若存在继承关系，在基类中定义的成员，不想被派生类访问，也不想被外部访问，则可以在基类中将该成员定义为私有。</li>\n</ol>\n<p><strong>默认继承方式：</strong></p>\n<ul>\n<li>要看派生类是用 class 定义的，还是 struct 定义的：<ul>\n<li>若 class 定义派生类，则默认继承方式是私有的。</li>\n<li>若 struct 定义派生类，则默认继承方式是共有的。</li>\n</ul>\n</li>\n</ul>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> ma;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mc;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">B</span>(<span class=\"hljs-type\">int</span> _md, <span class=\"hljs-type\">int</span> _mba, <span class=\"hljs-type\">int</span> _maa)<br>\t\t: <span class=\"hljs-built_in\">md</span>(_md)<br>\t\t, <span class=\"hljs-built_in\">ma</span>(_mba)<br>\t&#123;<br>\t\tA::ma = _maa;<br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> md;<br>\t<span class=\"hljs-comment\">// 作用域不同：派生类可以定义与基类同名的成员数据</span><br>\t<span class=\"hljs-type\">int</span> ma;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; md &lt;&lt; endl;<br>\t\tcout &lt;&lt; A::ma &lt;&lt; endl;<br>\t\tcout &lt;&lt; B::ma &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 公有继承下 ：基类私有的成员在派生类中不可见</span><br>\t\t<span class=\"hljs-comment\">// cout &lt;&lt; mc &lt;&lt; endl; </span><br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;ok&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> me;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mf;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">B <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>)</span></span>;<br>\tA a;<br><br>\tb.<span class=\"hljs-built_in\">func</span>();<br>\tb.<span class=\"hljs-built_in\">func1</span>();<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;----------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(a) &lt;&lt; endl;\t<span class=\"hljs-comment\">// 3 * int(4)</span><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(b) &lt;&lt; endl;\t<span class=\"hljs-comment\">// (3 + 4) * int(4)</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-派生类的构造过程\"><a href=\"#2-派生类的构造过程\" class=\"headerlink\" title=\"2. 派生类的构造过程\"></a>2. 派生类的构造过程</h2><p>派生类从基类可以继承来所有的成员（成员变量和成员方法）。</p>\n<p><strong>派生类如何初始化基类继承的成员变量：</strong></p>\n<p>通过调用基类相应的构造函数来初始化</p>\n<ul>\n<li>派生类的构造函数和析构函数，负责初始化和清理派生类部分；</li>\n<li>派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数来负责。</li>\n</ul>\n<p><strong>派生类对象构造和析构过程：</strong></p>\n<ol>\n<li>派生类调用基类的构造函数，初始化从基类继承来的成员。</li>\n<li>培生类调用自己的构造函数，初始化自身的成员。</li>\n<li>……….. 派生类对象的作用域到期。</li>\n<li>派生类调用自己的析构函数，释放派生类成员可能占用的外部资源（堆内存、文件）。</li>\n<li>系统自动调用基类的析构函数，释放派生类内存中从基类继承来的成员可能占用的外部资源（堆内存、文件）。</li>\n</ol>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data) <br>        : <span class=\"hljs-built_in\">ma</span>(data) <br>    &#123; <br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;基类构造函数：Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">Base</span>() <br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;基类析构函数：~Base()&quot;</span> &lt;&lt; endl; <br>    &#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data)<br>        : <span class=\"hljs-built_in\">Base</span>(data), <span class=\"hljs-built_in\">mb</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;派生类构造函数：Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">Derive</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;派生类析构函数：~Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> mb;<br><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110913834.png\" alt=\"image.png\"></p>\n<h2 id=\"3-重载、覆盖、隐藏\"><a href=\"#3-重载、覆盖、隐藏\" class=\"headerlink\" title=\"3. 重载、覆盖、隐藏\"></a>3. 重载、覆盖、隐藏</h2><p>继承结构中，名字相同的成员会产生关系，基类派生类里面相关的成员方法我们经常使用三种关系来描述它们，即：<strong>重载、隐藏、覆盖</strong>关系。</p>\n<ul>\n<li><strong>重载：</strong></li>\n</ul>\n<p>一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同。</p>\n<ul>\n<li><strong>隐藏：</strong></li>\n</ul>\n<p>在继承结构当中，派生类的同名成员，把基类的同盟成员给隐藏掉了，即作用域的隐藏。</p>\n<ul>\n<li><strong>覆盖：</strong></li>\n</ul>\n<p>父子类中的同名、同参数、同返回值的多个成员函数，从子到父形成的关系称为覆盖关系，在虚函数中会详谈它。</p>\n<h3 id=\"1-隐藏关系\"><a href=\"#1-隐藏关系\" class=\"headerlink\" title=\"1. 隐藏关系\"></a>1. 隐藏关系</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">ma</span>(data) &#123; &#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show(int)&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">20</span>) <br>\t\t:<span class=\"hljs-built_in\">Base</span>(data), <span class=\"hljs-built_in\">mb</span>(data) &#123; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tDerive d;<br>\td.<span class=\"hljs-built_in\">show</span>();<br>\td.<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>派生类对象调用了不带参数的show方法，派生类本身没有这个方法。<br>执行结果：调用成功，而且<strong>1与2是函数重载关系</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110931669.png\" alt=\"image.png\"></p>\n<p>我们又给派生类添加了一个不带参数的show方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">20</span>):<span class=\"hljs-built_in\">Base</span>(data), <span class=\"hljs-built_in\">mb</span>(data)&#123;&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//3</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>派生类调用 show 时优先调用自己的 <code>show()</code>，在自己的作用域下找相应的成员名字，若没有才去基类找；当我们调用带整数参数的 <code>show(int)</code>，自己并没有，从基类继承来一个带整型参数的 <code>show(int)</code>。</p>\n<p>执行一下：第二个 <code>show(int)</code> 调用执行出错。1 与 3 属于隐藏关系；2 与 3 也属于隐藏关系。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110932089.png\" alt=\"image.png\"></p>\n<p>第二个调用的是派生类的 <code>show()</code>，不接受参数。</p>\n<p><strong>为什么不调用基类中的 <code>show(int)</code>？</strong></p>\n<p>派生类对象调用派生类与基类同盟成员时，派生类已经有一个名字 show 了，派生类的 <code>show()</code> 将基类同盟 <code>show()</code>隐藏掉了。</p>\n<p>如果想调用基类成员函数，必须指明基类的作用域来调用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">Derive d;<br>d.Base::<span class=\"hljs-built_in\">show</span>();<br>d.Base::<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br></code></pre></td></tr></table></figure>\n\n<p>指明作用域调用成功。  </p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110934024.png\" alt=\"image.png\"></p>\n<h3 id=\"2-继承中的类型转换\"><a href=\"#2-继承中的类型转换\" class=\"headerlink\" title=\"2. 继承中的类型转换\"></a>2. 继承中的类型转换</h3><p>继承结构，我们也称为从上(基类)到下(派生类)的结构。</p>\n<p><strong>类型转换是否可以？</strong></p>\n<ol>\n<li><strong>基类对象——&gt;派生类对象的转换：类型从上到下的转换(NO)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//基类对象——&gt;派生类对象</span><br>d = b;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：执行失败。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110942832.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>派生类对象——&gt;基类对象的转换：类型从下到上的转换(YES)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//派生类对象——&gt;基类对象</span><br>b = d;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：成功执行。</p>\n<ol start=\"3\">\n<li><strong>基类指针(引用)——&gt;指向派生类对象：类型从下到上的转换(YES)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//基类指针(引用)——&gt;派生类对象</span><br>Base *pb = &amp;d;<br>pb-&gt;<span class=\"hljs-built_in\">show</span>();<br>pb-&gt;<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：成功执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110953689.png\" alt=\"image.png\"></p>\n<ol start=\"4\">\n<li><strong>派生类指针(引用)——&gt;指向基类对象：类型从上到下的转换(NO)</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">Base <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br><br><span class=\"hljs-comment\">//派生类指针(引用)——&gt;指向基类对象</span><br>Derive *pd = &amp;b;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：执行失败。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308110954145.png\" alt=\"image.png\"></p>\n<p><strong>总结：</strong></p>\n<p>在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转不安全会涉及内存的非法访问。</p>\n<h2 id=\"4-虚函数、静态绑定和动态绑定\"><a href=\"#4-虚函数、静态绑定和动态绑定\" class=\"headerlink\" title=\"4. 虚函数、静态绑定和动态绑定\"></a>4. 虚函数、静态绑定和动态绑定</h2><p><strong>覆盖：</strong></p>\n<p>如果派生类中的方法和基类继承的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是 <strong>virtual 虚函数</strong> ，那么派生类的这个方法，自动被处理成虚函数，它们之间成为覆盖关系；也就是说派生类会在自己虚函数表中将从基类继承来的虚函数进行替换，替换成派生类自己的。</p>\n<p><strong>静态绑定：</strong></p>\n<p>编译时期的多态，通过函数的重载以及模板来实现，也就是说调用函数的地址在编译时期我们就可以确定，在汇编代码层次，呈现的就是 call 函数名。</p>\n<p><strong>动态绑定：</strong></p>\n<p>动态时期的多态，通过派生类重写基类的虚函数来实现。在汇编代码层次，呈现的就是 call 寄存器，寄存器的值只有运行起来才能确定。</p>\n<h3 id=\"1-不存在的虚函数\"><a href=\"#1-不存在的虚函数\" class=\"headerlink\" title=\"1. 不存在的虚函数\"></a>1. 不存在的虚函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">ma</span>(data) &#123; &#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show()&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> </span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; std::endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data) <br>\t\t:<span class=\"hljs-built_in\">Base</span>(data)<br>\t\t, <span class=\"hljs-built_in\">mb</span>(data) &#123; &#125;<br><br>\t~<span class=\"hljs-built_in\">Derive</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Derive::show()&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建类</span><br>\t<span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">50</span>)</span></span>;<br>\tBase* pb = &amp;d;<br><br>\t<span class=\"hljs-comment\">// 静态（编译时期）绑定(函数调用) Base::show (06F12E4h)</span><br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>();<br>\t<span class=\"hljs-comment\">// Base::show (06F12BCh)</span><br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Base) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Derive) &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(*pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111036581.png\" alt=\"image.png\"></p>\n<p><strong>反汇编查看：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111039623.png\" alt=\"image.png\"></p>\n<p>可以看到调用的都是基类的 <code>show()</code>,在编译阶段已经生成指令调用 Base 下的 show。</p>\n<p><strong>结果：</strong></p>\n<ul>\n<li>因为 pb 是 Base 类型的指针，所以调用的都是 Base 类的成员方法。  </li>\n<li>基类 Base 只有一个数据成员 ma，所以大小只有 4 字节。  </li>\n<li>派生类 Derive 继承了 ma，其次还有自己的 mb，所以有 8 字节。  </li>\n<li>pb 的类型是一个 <code>class Base *</code>；  </li>\n<li><code>*pb</code> 的类型是一个 <code>class Base</code>。</li>\n</ul>\n<p><strong>图示:</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111042657.png\" alt=\"image.png\"></p>\n<p>为什么 <code>Base *</code> 类型的指针，Derive 类型的对象，调用方法的时候是 Base 而不是 Derive 呢？</p>\n<p>原因如上图：</p>\n<p>Derive 类继承了 Base 类，导致了派生类的大小要比基类大，而 pb 的类型是基类的指针，所以通过 pb 调用方法时只能访问到 Derive 中从 Base 继承而来的方法，访问不到自己重写的方法（指针的类型限制了指针解引用的能力）。</p>\n<h3 id=\"2-基类定义虚函数\"><a href=\"#2-基类定义虚函数\" class=\"headerlink\" title=\"2. 基类定义虚函数\"></a>2. 基类定义虚函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;typeinfo&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data = <span class=\"hljs-number\">10</span>)<br>\t\t: <span class=\"hljs-built_in\">ma</span>(data) &#123; &#125;<br><br>\t~<span class=\"hljs-built_in\">Base</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">// 虚基类</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> data)</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base::show(int): &quot;</span> &lt;&lt; data &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data) <br>\t\t:<span class=\"hljs-built_in\">Base</span>(data)<br>\t\t, <span class=\"hljs-built_in\">mb</span>(data) &#123; &#125;<br><br>\t~<span class=\"hljs-built_in\">Derive</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive::show()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建类</span><br>\t<span class=\"hljs-function\">Derive <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">50</span>)</span></span>;<br>\tBase* pb = &amp;d;<br><br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>();<br>\tpb-&gt;<span class=\"hljs-built_in\">show</span>(<span class=\"hljs-number\">10</span>);<br>\t<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Base size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Base) &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;Derive size:&quot;</span> &lt;&lt; <span class=\"hljs-built_in\">sizeof</span>(Derive) &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;---------------------&quot;</span> &lt;&lt; endl;<br><br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">typeid</span>(*pb).<span class=\"hljs-built_in\">name</span>() &lt;&lt; endl;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111047159.png\" alt=\"image.png\"></p>\n<p><strong>反汇编：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111048405.png\" alt=\"image.png\"></p>\n<p><code>pb-&gt;show();</code> 中 pb 指针是 base 类型，如果发现 Base 中的 show 是虚函数，就进行动态绑定。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">|63..32|31..16|15-8|7-0| <br>               |AH.|AL.| <br>               |AX.....| <br>       |EAX............| <br>|RAX...................|<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li><strong><code>mov   rax, qword ptr [pb]</code></strong></li>\n</ol>\n<p>将 pb 指向的内存前 4 个字节放入 rax 寄存器，pb指向derive对象，前四个字节即 <code>vfptr</code>，将虚函数表地址加载到 rax</p>\n<ol start=\"2\">\n<li><strong><code>mov   rax, qword ptr [rax]</code></strong></li>\n</ol>\n<p>将 rax 的前四个字节 即 <code>Derive::show</code> 加载到 rax 中。</p>\n<ol start=\"3\">\n<li><strong><code>call   qword ptr [rax]</code></strong></li>\n</ol>\n<p>虚函数的地址</p>\n<p>可以看到这一次，汇编码 call 的就不是确切的函数地址了，而是寄存器 rax。</p>\n<p>那么就很好理解了：rax 寄存器里存放的是什么内容，编译阶段根本无从知晓，只能在运行的时候确定； 故为，动态绑定。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111100188.png\" alt=\"image.png\"></p>\n<p>pb的类型：Base类型，查看Base中有没有虚函数</p>\n<p>（1）Base中没有虚函数 <code>*pb</code> 识别的就是编译时期的类型 <code>*pb</code> 就是 Base 类型。<br>（2） Base中有虚函数，<code>*pb</code> 识别的就是运行时期的类型 RTTI 类型为：Derive。</p>\n<p>在添加了 virtual 关键字后，对应的函数就变成了虚函数。</p>\n<p><strong>那么，一个类添加了虚函数，对这个类有什么影响呢？</strong></p>\n<ul>\n<li>如果类中定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的 <code>vftable</code> 虚函数表，虚函数表中主要存储的内容是：RTTI（Run-time Type Information）指针和虚函数的地址；当程序运行时，每一张虚函数表都会加载到内存的 <code>.rodata</code> 区（只读数据区）。</li>\n<li>一个类中定义了虚函数，那么这个类定义的对象，在运行时，内存中会多存储一个 <code>vfptr</code> 虚函数的指针，指向对应类型的虚函数表 <code>vftable</code>。</li>\n<li>一个类型定义的 n 个对象，它们的 <code>vfptr</code> 指向的都是同一张虚函数表。</li>\n<li>一个类中的虚函数个数，不影响对象内存的大小（vfptr），影响的是虚函数表 <code>vftable</code> 的大小。</li>\n<li>如果派生类中的方法和从基类继承的某个方法中返回值、函数名以及参数列表都相同，且基类方法为 virtual ，那么派生类的这个方法自动被处理为虚函数。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111110387.png\" alt=\"image.png\"></p>\n<p><strong>虚函数表：</strong></p>\n<ol>\n<li>RTTI：存放的是类型信息，也就是（Base 或 Derive）。</li>\n<li>偏移地址：虚函数指针相对于对象内存空间的便宜，一般 <code>vfptr</code> 都在 0 偏移位置。</li>\n<li>之后是函数时虚函数入口地址。</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111112719.png\" alt=\"image.png\"></p>\n<p>在 Derive 类中，由于重写了 <code>show()</code>,因此在 Derive 的虚函数表中，是使用子类的 show() 方法代替了 Base 类的 <code>show()</code>。</p>\n<h3 id=\"3-VS-工具查看虚函数表相关\"><a href=\"#3-VS-工具查看虚函数表相关\" class=\"headerlink\" title=\"3. VS 工具查看虚函数表相关\"></a>3. VS 工具查看虚函数表相关</h3><ol>\n<li>找到</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111116949.png\" alt=\"image.png\"></p>\n<p>打开后：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111117972.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li>在打开的窗口中切换到当前工程所在目录</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111119264.png\" alt=\"image.png\"></p>\n<ol start=\"3\">\n<li>输入指令</li>\n</ol>\n<p>可通过 dir 命令查看当前目录所有文件</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111120593.png\" alt=\"image.png\"></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cl XXX.cpp /d1reportSingleClassLayoutXX<br></code></pre></td></tr></table></figure>\n\n<p>第一个XXX表示源文件的名字，第二个代表你想查看的类类型，我这里就是<code>Derive</code></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111123449.png\" alt=\"image.png\"></p>\n<p>以看到 <code>class Derived</code> 的对象的内存布局，在派生类对象的开始包含了基类 Base 的对象，其中有一个虚表指针，指向的就是下面的<code>Derived::$vftable@ （virtual function table）</code>，表中包含了 Derived 类中所有的虚函数。</p>\n<h2 id=\"5-虚析构函数\"><a href=\"#5-虚析构函数\" class=\"headerlink\" title=\"5. 虚析构函数\"></a>5. 虚析构函数</h2><p>析构函数：可以成为虚函数，调用时候对象存在。</p>\n<p>虚析构函数：在析构函数前加上 virtual 关键字。</p>\n<p>什么时候需要把基类的析构函数必须实现成虚函数？<br>       <br>基类的指针(引用)指向堆上 new 出来的派生类对象的时候，delete 调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Base</span>(<span class=\"hljs-type\">int</span> data) <br>        : <span class=\"hljs-built_in\">ma</span>(data)<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">Base</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;~Base()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;call Base::show()&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-type\">int</span> data) <br>        : <span class=\"hljs-built_in\">Base</span>(data)<br>        , <span class=\"hljs-built_in\">mb</span>(data)<br>        , <span class=\"hljs-built_in\">ptr</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(data))<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;Derive()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class=\"hljs-built_in\">Derive</span>()<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> ptr;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;~Derive() &quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> mb;<br>    <span class=\"hljs-type\">int</span>* ptr;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    Base* pb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Derive</span>(<span class=\"hljs-number\">10</span>);<br>    <span class=\"hljs-comment\">// 静态绑定pb Base*   *pb Derive</span><br>    pb-&gt;<span class=\"hljs-built_in\">show</span>();<br><br>    <span class=\"hljs-keyword\">delete</span> pb;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111143308.png\" alt=\"image.png\"></p>\n<p><strong>没有调用派生类的析构函数，造成内存泄漏。</strong></p>\n<p><strong>问题：</strong></p>\n<p>pb 的配型是 Base 类型，因此 delete 调用析构函数先去 Base 找 <code>Base::~Base()</code>，对于析构函数的第哦啊用就是静态绑定，之间编译，没有机会调用派生类的析构函数，最后发生内存泄漏。</p>\n<p><strong>解决：</strong></p>\n<p>将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb 的类型是 Base 类型，调用析构时去 Base 中找 <code>Base::~Base</code> 发现它为虚函数，发生动态绑定。派生类的虚函数表中：<code>&amp;Derive:: ~derive</code>，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。</p>\n<p><strong>注意：</strong></p>\n<p><strong>构造函数不能为虚函数！！！</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111146816.png\" alt=\"image.png\"></p>\n<p>（1）从存储空间角度：</p>\n<p>虚函数对应一个 <code>vftable</code> ，这个 <code>vftable</code> 其实是存储在内存空间的。问题来了，如果构造函数是虚的，就需要通过 <code>vtable</code> 来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找 <code>vtable</code> 呢？所以构造函数不能是虚函数。</p>\n<p>（2）从使用角度：</p>\n<p>虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。</p>\n<p>（3）虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</p>\n<p>（4）构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它。但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p>\n<p>（5）从实现上看，<code>vbtable</code> 在构造函数调用后才建立，因而构造函数不可能成为虚函数</p>\n<p>从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。</p>\n<h2 id=\"6-理解多态是什么\"><a href=\"#6-理解多态是什么\" class=\"headerlink\" title=\"6. 理解多态是什么\"></a>6. 理解多态是什么</h2><p>派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）”。</p>\n<p>所谓“虚函数”，就是在声明时前面加了virtual 关键字的成员函数。virtual 关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。  </p>\n<p>包含虚函数的类称为“<strong>多态类</strong>”。  </p>\n<p>多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。  </p>\n<p>多态在面向对象的程序设计语言中如此重要，以至于有类和对象的概念，但是不支持多态的语言，只能被称作“基于对象的程序设计语言”，而不能被称为“面向对象的程序设计语言”。例如，Visual Basic 就是“基于对象的程序设计语言”。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;A::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;B::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">D</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;D::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">E</span> : <span class=\"hljs-keyword\">public</span> B<br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;E::Print&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    A a;<br>    B b;<br>    D d;<br>    E e;<br><br>    A* pa = &amp;a;<br>    B* pb = &amp;b;<br><br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = pb;<br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;d;<br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;-----------------&quot;</span> &lt;&lt; endl;<br><br>    pa = &amp;e;<br>    pa-&gt;<span class=\"hljs-built_in\">Print</span>();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405480.png\" alt=\"image.png\"></p>\n<p>程序中，四个类之间的派生关系如下所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111405483.png\" alt=\"image.png\"></p>\n<p>每个类都有同名、同参数表的虚函数 Print（每个 Print 函数声明时都加了 virtual 关键字）。根据多态的规则，对于语句<code>pa-&gt;Print()</code>，由于 Print 是虚函数，尽管 pa 是基类 A 的指针，编译时也不能确定调用的是哪个类的 Print 函数。当程序运行到该语句时，pa 指向的是哪个类的对象，调用的就是哪个类的 Print 函数。    </p>\n<p>多态的语句调用哪个类的成员函数是在运行时才能确定的，编译时不能确定（具体原理后面会解释）。因此，多态的函数调用语句被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。</p>\n<h3 id=\"1-多态起手式以及内存分布\"><a href=\"#1-多态起手式以及内存分布\" class=\"headerlink\" title=\"1.多态起手式以及内存分布\"></a>1.多态起手式以及内存分布</h3><p>假设有一个基类 ClassA，一个继承了该基类的派生类 ClassB，并且基类中有虚函数，派生类实现了基类的虚函数。</p>\n<p>在代码中运用多态这个特性时，通常以两种方式起手：<br>(1) <code>ClassA *a = new ClassB();</code><br>(2) <code>ClassB b; ClassA *a = &amp;b;</code></p>\n<p>以上两种方式都是用基类指针去指向一个派生类实例，区别在于第 1 个用了 new 关键字而分配在堆上，第 2 个分配在栈上：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111411592.png\" alt=\"image.png\"></p>\n<p>请看上图，不同两种方式起手仅仅影响了派生类对象实例存在的位置。<br>以左图为例，<code>ClassA *a</code> 是一个栈上的指针。</p>\n<p>该指针指向一个在堆上实例化的子类对象。基类如果存在虚函数，那么在子类对象中，除了成员函数与成员变量外，编译器会自动生成一个指向 <strong>该类的虚函数表(这里是类ClassB)</strong> 的指针，叫作虚函数表指针。通过虚函数表指针，父类指针即可调用该虚函数表中所有的虚函数。</p>\n<h3 id=\"2-类的虚函数表与类实例的虚函数指针\"><a href=\"#2-类的虚函数表与类实例的虚函数指针\" class=\"headerlink\" title=\"2. 类的虚函数表与类实例的虚函数指针\"></a>2. 类的虚函数表与类实例的虚函数指针</h3><p>首先不考虑继承的情况；如果一个类中有虚函数，那么该类就有一个虚函数表。</p>\n<p>这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表。</p>\n<p>从第一部分的图中我们也能看到，一个类的实例要么在堆上，要么在栈上。也就是说一个类可以有很多很多个实例。但是！一个类只能有一个虚函数表。在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111417318.png\" alt=\"image.png\"></p>\n<h3 id=\"3-多态代码及多重继承情况\"><a href=\"#3-多态代码及多重继承情况\" class=\"headerlink\" title=\"3. 多态代码及多重继承情况\"></a>3. 多态代码及多重继承情况</h3><p>讨论了在没有继承的情况下，虚函数表的逻辑结构。</p>\n<p>那么在有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassA</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassA</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::~ClassA();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassA::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassA::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> aData;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassB</span> : <span class=\"hljs-keyword\">public</span> ClassA<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassB::ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassB</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassB::~ClassB();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassB::fn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassB::vfn1();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> bData;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassC</span> : <span class=\"hljs-keyword\">public</span> ClassA<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassC</span>()<br>    &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::~ClassC();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::fn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfn2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;virtual ClassC::vfn2();&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> aData;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    ClassC c;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>(1) ClassA 是基类, 有普通函数: <code>fn1()、fn2()</code> 。虚函数: <code>vfn1()、vfn2()、~ClassA()</code><br>(2) ClassB 继承 ClassA, 有普通函数: <code>fn1()</code>。虚函数: <code>vfn1()、~ClassB()</code><br>(3) ClassC 继承 ClassB, 有普通函数: <code>fn2()</code>。虚函数: <code>vfn2()、~ClassB()</code></p>\n<p>基类的虚函数表和子类的虚函数表不是同一个表。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。</p>\n<p>ClassB 继承与 ClassA，其虚函数表是在 ClassA 虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">ClassA* a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ClassB</span>();<br><br>a-&gt;<span class=\"hljs-built_in\">fn1</span>();<br>a-&gt;<span class=\"hljs-built_in\">fn2</span>();<br><br>a-&gt;<span class=\"hljs-built_in\">vfn1</span>();<br>a-&gt;<span class=\"hljs-built_in\">vfn2</span>();<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111430434.png\" alt=\"image.png\"></p>\n<p><strong>使用 VS 开发者工具查看：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111432206.png\" alt=\"image.png\"></p>\n<p>这个结果不难想象，看上图，ClassA 类型的指针 a 能操作的范围只能是黑框中的范围，之所以实现了多态完全是因为子类的虚函数表指针与虚函数表的内容与基类不同</p>\n<p>这个结果已经说明了 C++ 的隐藏、重写(覆盖)特性。</p>\n<p>同理，也就不难推导出 ClassC 的逻辑结构图了</p>\n<p>类的继承情况是: ClassC 继承 ClassB，ClassB 继承 ClassA；这是一个多次单继承的情况。(多重继承)。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111435576.png\" alt=\"image.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111436071.png\" alt=\"image.png\"></p>\n<h3 id=\"4-多继承下的虚函数表-同时继承多个基类\"><a href=\"#4-多继承下的虚函数表-同时继承多个基类\" class=\"headerlink\" title=\"4. 多继承下的虚函数表 (同时继承多个基类)\"></a>4. 多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br> <br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassA1</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>  <span class=\"hljs-built_in\">ClassA1</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassA1</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::~ClassA1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA1::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>  <span class=\"hljs-type\">int</span> a1Data;<br>&#125;;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassA2</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>  <span class=\"hljs-built_in\">ClassA2</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassA2</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::~ClassA2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc4</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassA2::vfunc4()&quot;</span> &lt;&lt; endl; &#125;<br><span class=\"hljs-keyword\">private</span>:<br>  <span class=\"hljs-type\">int</span> a2Data;<br>&#125;;<br> <br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ClassC</span> : <span class=\"hljs-keyword\">public</span> ClassA1, <span class=\"hljs-keyword\">public</span> ClassA2<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>  <span class=\"hljs-built_in\">ClassC</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::ClassC()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">ClassC</span>() &#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::~ClassC()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::func1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc1</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::vfunc1()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc2</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::vfunc2()&quot;</span> &lt;&lt; endl; &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">vfunc3</span><span class=\"hljs-params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"hljs-string\">&quot;ClassC::vfunc3()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br> <br> <br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  ClassC c;<br> <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111445452.png\" alt=\"image.png\"></p>\n<p>（1）ClassA1 是第一个基类，拥有普通函数 <code>func1()</code>，虚函数<code>vfunc1()、 vfunc2()</code>。<br>（2）ClassA2 是第二个基类，拥有普通函数 <code>func1()</code>，虚函数 <code>vfunc1()、 vfunc2()、vfunc4()</code>。<br>（3）ClassC 依次继承 ClassA1、ClassA2。普通函数 <code>func1()</code>,虚函数<code>vfunc1()、vfunc2()、vfunc3()</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111442375.png\" alt=\"image.png\"></p>\n<p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。</p>\n<p>如图，虚函数表指针 01 指向的虚函数表是以 ClassA1 的虚函数表为基础的，子类的 <code>ClassC::vfunc1()</code>,和 <code>vfunc2()</code> 的函数指针覆盖了虚函数表 01 中的虚函数指针 01 的位置、02 位置。当子类有多出来的虚函数时，添加在第一个虚函数表中。注意：</p>\n<ol>\n<li>子类虚函数会覆盖每一个父类的每一个同名虚函数。</li>\n<li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li>\n<li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用</li>\n</ol>\n<p>最后给出代码和结果：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">ClassA1 *a1 = <span class=\"hljs-keyword\">new</span> ClassC;<br>a1-&gt;<span class=\"hljs-built_in\">func1</span>();               <span class=\"hljs-comment\">// &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span><br>a1-&gt;<span class=\"hljs-built_in\">vfunc1</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span><br>a1-&gt;<span class=\"hljs-built_in\">vfunc2</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span><br>没有a1-&gt;<span class=\"hljs-built_in\">vfunc3</span>()，父类没有这个虚函数<br><br>ClassA2 *a2 = <span class=\"hljs-keyword\">new</span> ClassC;<br>a2-&gt;<span class=\"hljs-built_in\">func1</span>();               <span class=\"hljs-comment\">// &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span><br>a2-&gt;<span class=\"hljs-built_in\">vfunc1</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class=\"hljs-built_in\">vfunc2</span>();              <span class=\"hljs-comment\">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span><br>a2-&gt;<span class=\"hljs-built_in\">vfunc4</span>();              <span class=\"hljs-comment\">// &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span><br><br>ClassC *c = <span class=\"hljs-keyword\">new</span> ClassC;<br>c-&gt;<span class=\"hljs-built_in\">func1</span>();                <span class=\"hljs-comment\">// &quot;ClassC::func1()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc1</span>();               <span class=\"hljs-comment\">// &quot;ClassC::vfunc1()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc2</span>();               <span class=\"hljs-comment\">// &quot;ClassC::vfunc2()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc3</span>();               <span class=\"hljs-comment\">// &quot;ClassC::vfunc3()&quot;</span><br>c-&gt;<span class=\"hljs-built_in\">vfunc4</span>();               <span class=\"hljs-comment\">// &quot;ClassA2::func4()&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"7-理解抽象类\"><a href=\"#7-理解抽象类\" class=\"headerlink\" title=\"7. 理解抽象类\"></a>7. 理解抽象类</h2><p>抽象类(接口)：接口描述了类的行为和功能,而无需完成类的特定实现</p>\n<p>C++ 接口时通过抽象类实现的,设计抽象类的目的,是为了给其他类提供一个可以继承的适当的基类.抽象类本类不能被用于实例化对象,只能作为接口使用</p>\n<p><strong>注意:</strong></p>\n<p>如果试图实例化一个抽象类的对象，会导致编译错误。</p>\n<p>因此，如果一个抽象类的派生类需要被实例化(建立对象)，则必须对每个继承来的纯虚函数进行函数体实现。<br>如果没有在派生类中重写所有纯虚函数，就尝试实例化派生类的对象，也会导致编译错误，这是因为如果派生类没有实现父类的纯虚函数，则派生类变为抽象类。</p>\n<p>抽象类基类为派生自抽象基类的派生类提供了约束条件，即：派生类必须要实现继承自抽象基类中的纯虚函数，否则此派生类不可进行实例化，且派生类将继承为抽象派生类。</p>\n<h3 id=\"1-抽象类与纯虚函数（抽象方法）\"><a href=\"#1-抽象类与纯虚函数（抽象方法）\" class=\"headerlink\" title=\"1. 抽象类与纯虚函数（抽象方法）\"></a>1. 抽象类与纯虚函数（抽象方法）</h3><p><strong>纯虚函数</strong>是一个在 <strong>基类中声明的虚函数</strong>，它在该基类中<strong>没有定义具体的函数体</strong>(操作内容),要求<strong>派生类根据实际需要定义自己的版本</strong>，设计多层次类继承关系时用到。把某个方法声明为一个抽象方法等于告诉编译器,这个方法<strong>必不可少</strong>，但目前在基类中还不能为它提供实现</p>\n<p>纯虚函数的标准格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">virtual</span> 函数类型 函数名（参数表）= <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pet</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">// 声明了一个纯虚函数 也就是在虚函数尾部加上&quot; = 0 &quot; 一个虚函数便被声明成为了一个纯虚函数</span><br>\t<span class=\"hljs-comment\">// 等于 0 表示该函数仅声明而没有函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<p>一旦类中有了纯虚函数，这个类便被称为：<strong>抽象类</strong>。</p>\n<blockquote>\n<p><strong>且此类不能被实例化！！！（不可建立类对象实例！！！）</strong></p>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 报错！带有纯虚函数的类称为抽象类，不可实例化</span><br>\tPet pet; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>抽象类：</strong></p>\n<p>只能作为积累使用，无法定义抽象类对象实例，这是因为 <strong>抽象类中包含了没有定义的纯虚函数</strong>，在 C++ 中，我们把 <strong>只能由于被继承而不能直接创建对象的类</strong> 称之为：<strong>抽象类</strong>，这种基类不能直接生成对象，而只有被继承后，并重写其虚函数后，才能使用。</p>\n<p>当抽象类的派生类实现了继承而来的纯虚函数后，才能实例化对象。</p>\n<p>之所以要存在抽象类，最主要是因为它具有不确定因素，我们把那些类中的确存在，但是在父类中无法确定具体实现的成员函数称为虚函数。虚函数是一种特殊的函数，在抽象类中只有声明，没有具体的定义。</p>\n<p><strong>抽象类和纯虚函数的关系</strong></p>\n<p>抽象类中至少存在一个纯虚函数，存在纯虚函数的类一定是抽象类，存在纯虚函数是成为抽象类的充要条件。</p>\n<h3 id=\"2-为什么需要一个抽象类\"><a href=\"#2-为什么需要一个抽象类\" class=\"headerlink\" title=\"2. 为什么需要一个抽象类\"></a>2. 为什么需要一个抽象类</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// todonew 与 delete 动态分配内存,与用指针调用对象 通过对象的不同调用不同的同名虚函数</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Pet</span> <span class=\"hljs-comment\">// 声明纯虚函数 sound 后 Pet 类变为抽象类(接口)</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Pet</span>(string thename);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sleep</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sound</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">// 声明纯虚函数 sound  (并未进行函数实现 函数实现放在派生类中)</span><br><br>    <span class=\"hljs-comment\">//注意:\t\t\t\t\t   </span><br>    <span class=\"hljs-comment\">//todo1.继承自抽象基类 Pet 的子类必须全部实现基类中的所有纯虚函数</span><br>    <span class=\"hljs-comment\">//todo2.抽象基类 Pet 不可进行实例化</span><br><br><span class=\"hljs-keyword\">protected</span>:<br>    string name;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> :<span class=\"hljs-keyword\">public</span> Pet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cat</span>(string thename);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">climb</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sound</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> :<span class=\"hljs-keyword\">public</span> Pet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Dog</span>(string thename);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">jump</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sound</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br><br><br>Pet::<span class=\"hljs-built_in\">Pet</span>(string thename) <span class=\"hljs-comment\">// todo 基类构造器(抽象类也有构造函数)</span><br>&#123;<br>    name = thename;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Pet::sleep</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;正在睡大觉\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Pet::sound</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;动物发声\\n&quot;</span>;<br>&#125;<br><br>Cat::<span class=\"hljs-built_in\">Cat</span>(string thename) :<span class=\"hljs-built_in\">Pet</span>(thename) <span class=\"hljs-comment\">// 派生类 Cat 构造函数</span><br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Cat::climb</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;正在爬树\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">Cat::sound</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 派生类虚函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br><br>    <span class=\"hljs-comment\">//\tPet::sound(); // todo 如果需要调用基类中的 play() 函数  在原本的play()函数的基础上加上覆盖上的子类play()函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;喵喵喵!\\n&quot;</span>;<br>&#125;<br><br><br>Dog::<span class=\"hljs-built_in\">Dog</span>(string thename) :<span class=\"hljs-built_in\">Pet</span>(thename)<span class=\"hljs-comment\">// 派生类 Dog 构造函数</span><br>&#123;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Dog::jump</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;跳过了栅栏\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Dog::sound</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// 派生类虚函数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//\tPet::sound();</span><br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot;汪汪汪!\\n&quot;</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(Pet* x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    x-&gt;<span class=\"hljs-built_in\">sound</span>();<br>&#125;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-comment\">//\tPet pet; // todo 用带有抽象方法(纯虚函数)的抽象类 Pet 无法实例化对象</span><br><br>    <span class=\"hljs-comment\">// todo 创建指向子类实例的基类指针和引用来调用纯虚函数</span><br>    Pet* cat = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Cat</span>(<span class=\"hljs-string\">&quot;猫&quot;</span>);<br>    Pet* dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Dog</span>(<span class=\"hljs-string\">&quot;狗&quot;</span>);<br><br>    <span class=\"hljs-comment\">// todo 创建对象实例来调用纯虚函数</span><br>    <span class=\"hljs-function\">Cat <span class=\"hljs-title\">cat2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;对象实例调用 猫&quot;</span>)</span></span>;<br>    cat2.<span class=\"hljs-built_in\">sound</span>();<br><br>    <span class=\"hljs-built_in\">func</span>(cat);<br>    <span class=\"hljs-built_in\">func</span>(dog);<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>本例中定义了三个类,它们的继承关系为：<code>Animal--&gt;Cat</code>和<code>Animal--&gt;Dog</code></p>\n<p>Animal 是一个抽象类，也是最顶层的基类，在 Animal 类中定义了一个<strong>纯虚函数</strong><code>sound()</code>，在 <code>Cat</code> 类中，实现了<code>sound()</code>函数。所谓实现，就是定义了纯虚函数的函数体，抽象类 Animal 虽然不能实例化，但它为派生类提供了<strong>约束条件</strong>，派生类必须要实现这个函数，完成动物发声功能，否则就不能对派生类进行实例化。</p>\n<p>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的，虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111557893.png\" alt=\"image.png\"></p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>任何具有纯虚函数的类都是抽象类。</li>\n<li>抽象类基类不可建立实例。</li>\n<li>抽象类派生出的子类需将继承的纯虚函数全部进行实例化，才能建立其实例。</li>\n<li>抽象类可以有构造函数。</li>\n<li>如果派生类没有实现父类的纯虚函数，则派生类变为抽象类，即不可建立其实例。</li>\n<li>抽象基类除了约束派生类的功能，还可以实现多态，可以创建指向子类的实例的抽象基类的指针和引用。</li>\n<li>只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。</li>\n</ol>\n<h2 id=\"8-理解虚基类和虚继承\"><a href=\"#8-理解虚基类和虚继承\" class=\"headerlink\" title=\"8. 理解虚基类和虚继承\"></a>8. 理解虚基类和虚继承</h2><p><strong>virtual作用：</strong></p>\n<ol>\n<li>virtual 修饰了成员方法是虚函数。  </li>\n<li>可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。</li>\n</ol>\n<ul>\n<li><strong>vfptr</strong>：一个类有虚函数，这个类生成的对象就有 vfptr，指向 vftable。  </li>\n<li><strong>vbptr</strong>：在派生类中从基类虚继承而来。  </li>\n<li><strong>vftable</strong>：第一行为向上偏移量，第二行为虚基类指针离虚基类内存的偏移量。  </li>\n<li><strong>vbtable</strong>：存放的 RTTI 指针，指向运行时 RTTI 信息与虚函数地址。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-comment\">//A a; 4个字节</span><br><span class=\"hljs-comment\">//B b; 8个字节</span><br></code></pre></td></tr></table></figure>\n\n<p>这里我们的对象 a 占 4 个字节，对象 8 占 8 个字节。但如果我们给 B 的继承方式访问限定符前面加了一个 virtual 关键字。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><strong>类 A 被虚继承了，但内存布局没有变化：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111611448.png\" alt=\"image.png\"></p>\n<p><strong>类 B 在继承普通基类的内存变化：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111612673.png\"></p>\n<p>再看一下类 B，不是之前的 8 个字节，变为 12 个字节，多了一个 vbptr 指针。原来最上面应该为 ma 与 mb，但是现在多了一个 <code>vbptr</code>(虚基类指针)，ma 跑到派生类最后面去了。<code>vbptr</code> 指向的是 <code>vbtable</code>，<code>vbtable</code> 第一行为 0，第二行为虚基类指针到虚基类数据的偏移量。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111614890.png\" alt=\"image.png\"></p>\n<p>当遇到虚继承时候，要考虑派生类 B 的内存布局时；</p>\n<p>首先，先不考虑虚继承，类 B 继承了基类的 ma，还有自己的mb；当基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个 <code>vbptr</code>。派生类的内存就由这几部分来构成。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111618147.png\" alt=\"image.png\"></p>\n<p>虚基类指针(<code>vbptr</code>)指向虚基类表(<code>vbtable</code>)，<code>vbtable</code> 第一行为向上的偏移量，因为 <code>vbptr</code> 在该派生类内存起始部分，因此向上的偏移量为 0；第二行为向下的偏移量(<code>vbptr</code> 离虚基类数据的偏移量)，原来基类的数据放到最后，找 ma 的时候还是在最开始找，但 ma 被移动，根据偏移的字节就可以找到。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111619886.png\" alt=\"image.png\"></p>\n<h3 id=\"1-虚基类和虚继承出错情况分析\"><a href=\"#1-虚基类和虚继承出错情况分析\" class=\"headerlink\" title=\"1. 虚基类和虚继承出错情况分析\"></a>1. 虚基类和虚继承出错情况分析</h3><p><strong>那么当我们虚基类指针与虚函数指针在一起出现的时候会发生什么呢？</strong></p>\n<p>调用是没有问题的，但是 delete 会出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</span><br>\tA* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">B</span>();<span class=\"hljs-comment\">// B::vftable</span><br>\tp-&gt;<span class=\"hljs-built_in\">func</span>();<br>\t<span class=\"hljs-keyword\">delete</span> p;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如图：调用成功，但delete时会出错。  </p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111623556.png\" alt=\"image.png\"></p>\n<p><strong>分析：</strong></p>\n<p>B 的内存布局：</p>\n<p>B 首先从 A 中获取 <code>vfptr</code> 与 ma， B 中还有自身的 mb；<br>此时 A 被虚继承，A 中所有的东西都移动到派生类最后面，最上面补一个<code>vbptr</code>，<code>vbptr</code> 指向 <code>vbtable</code>，<code>vfptr</code> 指向 <code>vftable</code>；基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址。</p>\n<p>普通情况下，派生类内存布局先是基类，在是派生类，基类指针指向派生类对象时，基类指针指向的就是派生类内存的起始部分。但是，虚继承下基类称为虚基类，虚基类的数据在派生类最后面，原地方补上 <code>vbptr</code>，此时再用基类指针指向派生类对象时候，基类指针永远指向派生类基类部分的起始地址。虚基类一开始就是 <code>vfptr</code>，能够用 p 指向的对象访问 <code>vfptr</code> 与 <code>vftable</code> 的原因。释放内存时候出错，因为对象开辟是在最上面即绿色部分，但是 p 所持有的是虚基类的地址，delete 时从虚基类起始地址 delete，因此出错。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111627334.png\" alt=\"image.png\"></p>\n<p>命令验证如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111628141.png\" alt=\"image.png\"></p>\n<p><strong>验证一下内存地址：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call A::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ptr)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator delete p:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>\t\t<span class=\"hljs-built_in\">free</span>(ptr);<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call B::func()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">void</span>* p = <span class=\"hljs-built_in\">malloc</span>(size);<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;operator new p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> p;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tA* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">B</span>(); <span class=\"hljs-comment\">// B::vftable</span><br>\tcout &lt;&lt; <span class=\"hljs-string\">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>\tp-&gt;<span class=\"hljs-built_in\">func</span>();<br>\t<span class=\"hljs-keyword\">delete</span> p;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111629072.png\" alt=\"image.png\"></p>\n<p><code>00000119E9411CB0</code> 为分配的内存的起始地址，我们用基类指针指向派生类对象一定是指向派生类内存基类的起始部分：<code>00000119E9411CC0</code> 刚好比 <code>00000119E9411CB0</code> 多了 16 个字节，是 <code>vbptr</code> 与 mb，但是 delete 时候从 <code>00000119E9411CC0</code> 开始释放，因此崩溃。</p>\n<p>Windows 的 VS 下这样写会出错，但是 Linux 下的 <code>g++ delete</code> 时会自动偏移到 new 内存的起始部分，进行内存 <code>free()</code>，不会出错。</p>\n<p>如果在栈上开辟内存，基类指针指向派生类对象，出了作用域自己进行析构，这样是没有问题的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">B b;<br>A *p = &amp;b; <span class=\"hljs-comment\">// B::vftable</span><br>cout &lt;&lt; <span class=\"hljs-string\">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;<br>p-&gt;<span class=\"hljs-built_in\">func</span>();<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"9-菱形继承问题\"><a href=\"#9-菱形继承问题\" class=\"headerlink\" title=\"9. 菱形继承问题\"></a>9. 菱形继承问题</h2><p><strong>多重继承：</strong> 一个<code>派生类</code>如果只继承一个<code>基类</code>，称作单继承； 一个<code>派生类</code>如果继承了多个<code>基类</code>，称作多继承。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111602992.png\" alt=\"image.png\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>多重继承可以做更多的代码复用！</li>\n<li>派生类通过多重继承，可以得到多个基类的数据和方法，更大程度的实现了代码复用。</li>\n</ul>\n<p><strong>问题：</strong></p>\n<p>菱形继承的问题：在于继承时有重复利用的数据。</p>\n<p><strong>会导致派生类有多份间接基类的数据，可以采用虚继承来解决。</strong> <strong>A 为 B、C 的基类，B 从 A 单继承而来，C 从 A 也是单继承而来；D 是 B 和 C 多继承而来，D 有两个基类分别为 B 和 C。A 称为 D 的间接基类，D 也有 A 的数据。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111637497.png\" alt=\"image.png\"></p>\n<p>当然，多重继承还会出现别的问题：</p>\n<p><strong>半圆形继承问题：</strong> <strong>B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111638517.png\" alt=\"image.png\"></p>\n<p>多重继承虽然可以复用多个基类的代码到派生类中，但是会出现许多问题，因此 C++ 开源代码上很少见到多重继承。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">ma</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">A</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">B</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mb</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">B</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">C</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mc</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">C</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mc;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">D</span> : <span class=\"hljs-keyword\">public</span> B, <span class=\"hljs-keyword\">public</span> C<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">D</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">B</span>(data), <span class=\"hljs-built_in\">C</span>(data), <span class=\"hljs-built_in\">md</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">D</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> md;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">D <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>画一下 d 对象的内存布局：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641312.png\" alt=\"image.png\"></p>\n<p>D 能看见 B，C 与 md，所以 D 在构造时调用 B，C 的构造及 ma 的初始化。 ma 的初始化在 B 与 C 的构造函数中进行，因此 D 内存为 20 个字节。</p>\n<p>输出结果：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111641957.png\" alt=\"image.png\"></p>\n<p>先是 A 的构造，B 的构造，又是 A 的构造，C 的构造，最后是 D 的构造；析构顺序与其相反。就会发现，D 这个派生类中调用了两次 A 的构造，数据重复，浪费内存，这种情况必须被杜绝。</p>\n<p><strong>如何处理？</strong></p>\n<p><strong>虚继承来处理，所有从A继承而来的地方都采用虚继承，A 就为虚基类。</strong></p>\n<p>此时：<br>B 从 A 虚继承而来，A 为虚基类，<code>A::ma</code> 移动到派生类最后面，在 <code>A::ma</code> 位置上补一个 <code>vbptr</code>；C 也是从 A 虚继承而来，<code>A::ma</code> 移动到派生类最后面，但发现已经有一份同样的虚基类的数据，那么 C 的 <code>A::ma</code> 丢弃，在 <code>A::ma</code> 位置存放 <code>vbptr</code>。此时派生类中只有一份基类 <code>A::ma</code> 的数据，以后访问都是同一个 ma；同时 ma 的初始化由 D 来负责。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111645047.png\" alt=\"image.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">A</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">ma</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">A</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~A()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> ma;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">B</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mb</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">B</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~B()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mb;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> A<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">C</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">mc</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">C</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~C()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> mc;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">D</span> : <span class=\"hljs-keyword\">public</span> B, <span class=\"hljs-keyword\">public</span> C<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">D</span>(<span class=\"hljs-type\">int</span> data) : <span class=\"hljs-built_in\">A</span>(data), <span class=\"hljs-built_in\">B</span>(data), <span class=\"hljs-built_in\">C</span>(data), <span class=\"hljs-built_in\">md</span>(data)<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t~<span class=\"hljs-built_in\">D</span>()<br>\t&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;~D()&quot;</span> &lt;&lt; endl;<br>\t&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-type\">int</span> md;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">D <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>打印结果：修改成功；A、B、C、D各初始化与析构一次。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111646462.png\" alt=\"image.png\"></p>\n<h2 id=\"10-C-的-四种类型转换\"><a href=\"#10-C-的-四种类型转换\" class=\"headerlink\" title=\"10. C++ 的 四种类型转换\"></a>10. C++ 的 四种类型转换</h2><blockquote>\n<ol>\n<li>const_cast</li>\n<li>static_cast</li>\n<li>reinterpert_cast</li>\n<li>dynamic_cast</li>\n</ol>\n</blockquote>\n<h3 id=\"1-const-cast\"><a href=\"#1-const-cast\" class=\"headerlink\" title=\"1. const_cast\"></a>1. const_cast</h3><p><strong>const_cast：修改类型的const或volatile属性。</strong> 使用该运算方法可以返回一个指向非常量的指针（或引用）指向，就可以通过该指针（或引用）对它的数据成员任意改变。</p>\n<p><strong>注意：</strong>  </p>\n<p>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。  </p>\n<p><strong>语法：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">const_cast</span>&lt;里面必须是指针或引用类型&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>实例：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> *p1 = (<span class=\"hljs-type\">int</span>*)&amp;a;<span class=\"hljs-comment\">// C 中类型转换</span><br><span class=\"hljs-type\">int</span> *p2 = <span class=\"hljs-built_in\">const_cast</span>&lt;<span class=\"hljs-type\">int</span>*&gt;(&amp;a);<span class=\"hljs-comment\">// C++ 中类型转换 const_cast</span><br></code></pre></td></tr></table></figure>\n\n<p>转换为相同类型的时候，通过反汇编查看时候，发现 C 中的类型强转与 C++ 中 <code>const_cast</code> 所生成的汇编指令底层是一模一样的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111757973.png\" alt=\"image.png\"></p>\n<p>但是在转换成汇编指令之前，即编译阶段，就有所不同。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><strong>不考虑 const 或 valatile 后类型保持一致才可以进行合理的类型转换。</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-comment\">// C 中类型转换，可以</span><br><span class=\"hljs-type\">char</span> *p1 = (<span class=\"hljs-type\">char</span>*)&amp;a;<br><span class=\"hljs-comment\">// C++ 中类型转换 const_cast，不可以</span><br><span class=\"hljs-type\">char</span> *p2 = <span class=\"hljs-built_in\">const_cast</span>&lt;<span class=\"hljs-type\">char</span>*&gt;(&amp;a);<br></code></pre></td></tr></table></figure>\n\n<p>通过 C中类型转换可以将 <code>int *</code> 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过 <code>const_cast</code> 将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。<code>const_cast</code>使用时，地址的类型是与左边类型以及转换的类型需要保持一致。防止了 C 中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。</p>\n<p>编译出错：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111806390.png\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong><code>const_cast&lt;里面必须是指针或引用类型&gt;</code>，否则出错</strong></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">int</span> b = <span class=\"hljs-built_in\">const_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(a);<br></code></pre></td></tr></table></figure>\n\n<p>编译出错：</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111807110.png\" alt=\"image.png\"></p>\n<h3 id=\"2-static-cast\"><a href=\"#2-static-cast\" class=\"headerlink\" title=\"2. static_cast\"></a>2. static_cast</h3><p><strong><code>static_cast(静态)</code>：编译时期的类型转换，提供编译器认为安全的类型转换。</strong></p>\n<p>是一个 c++ 运算符，功能是把一个表达式转换为某种类型，使用最多。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li><strong>有联系的类型之间可以互相转换。</strong></li>\n<li><strong>没有任何联系的类型之前转换会被否定。</strong></li>\n<li><strong>基类类型与派生类类型进行转换，可以用 <code>static_cast</code>，它们类型之间有关系，但不一定安全。</strong></li>\n</ol>\n<p><strong>实例：</strong></p>\n<ol>\n<li>有联系的类型之间可以互相转换</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">char</span> b = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(a);<br></code></pre></td></tr></table></figure>\n\n<p>编译成功，int 与 char 直之间有联系。</p>\n<ol start=\"2\">\n<li>有任何联系的类型之间的转换会被否定</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span>* p = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-comment\">// double* = (double*)p; C 可以转换</span><br><span class=\"hljs-type\">double</span>* b = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111811911.png\" alt=\"image.png\"></p>\n<h3 id=\"3-reinterpert-cast\"><a href=\"#3-reinterpert-cast\" class=\"headerlink\" title=\"3. reinterpert_cast\"></a>3. reinterpert_cast</h3><p><strong><code>reinterpret_cast</code>：类似于 C 风格的强制类型转换，是 C++ 里的强制类型转换符，不安全。</strong></p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li>\n</ol>\n<p><strong>实例：</strong> </p>\n<ol>\n<li>如果非要进行没有任何联系的类型转换，可以使用 <code>reinterpret_cast</code>。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> *p = <span class=\"hljs-literal\">nullptr</span>;<br><span class=\"hljs-type\">double</span>* b = <span class=\"hljs-built_in\">reinterpret_cast</span>&lt;<span class=\"hljs-type\">double</span>*&gt;(p);<br></code></pre></td></tr></table></figure>\n\n<p><code>reinterpret_cast</code> 与 C 中类型转换类似，转换成功，不安全。</p>\n<h3 id=\"4-dynamic-cast\"><a href=\"#4-dynamic-cast\" class=\"headerlink\" title=\"4. dynamic_cast\"></a>4. dynamic_cast</h3><p><strong><code>dynamic_cast</code>(动态)：运行时期的类型转换，用于继承结构中，可以支持 RTTI 类型识别的上下转换及识别。</strong></p>\n<p><strong>将一个基类对象指针（或引用）转换到继承类指针，<code>dynamic_cast</code> 会根据基类指针是否真正指向继承类指针来做相应处理。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Base</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive1</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call Derive1::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive2</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showFunc</span><span class=\"hljs-params\">(Base* p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tp-&gt;<span class=\"hljs-built_in\">func</span>();<span class=\"hljs-comment\">//动态绑定</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tDerive1 d1;<br>\tDerive1 d2;<br>\t<br>\t<span class=\"hljs-built_in\">showFunc</span>(&amp;d1);<br>\t<span class=\"hljs-built_in\">showFunc</span>(&amp;d2);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>执行结果：执行成功。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111838785.png\" alt=\"image.png\"></p>\n<p>需求改变了，<code>Derive</code> 实现了一个新功能的 API 接口函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derive2</span> : <span class=\"hljs-keyword\">public</span> Base<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call Derive2::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-comment\">//需求更改 Derive2实现新功能的API接口函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">derive02func</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;call derive02func()::func&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><code>void show()</code> 应该区分判断一下，如果 <code>Base* p</code> 指向了其他的派生类对象，调用 <code>p-&gt;func()</code> 方法就好。但如果指向 Derive2 对象，不调用 <code>func()</code> 方法，而调用 Derive2 的 <code>derive02 func()</code>方法。该如何做呢？</p>\n<p>这里就要识别 <code>*p</code> 的类型，看它指向哪个对象。此时就需要<code>dynamic_cast()</code>了。dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象；<code>p-&gt;vfptr-&gt;vftable</code> RTTI 信息 如果是 <code>dynamic_cast</code>，转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showFunc</span><span class=\"hljs-params\">(Base* p)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// dynamic 会检查 p 指针是否指向的是一个 Derive2 类型的对象</span><br>\t<span class=\"hljs-comment\">// p-&gt;vfptr-&gt;vftable RTTI 信息 如果是 dynamic_cast，</span><br>\t<span class=\"hljs-comment\">// 转换类型成功，返回 Derive2 对象地址；否则，返回 nullptr</span><br>\tDerive2 *pd2 = <span class=\"hljs-built_in\">dynamic_cast</span>&lt;Derive2*&gt;(p);<br>\t<span class=\"hljs-keyword\">if</span> (pd2 != <span class=\"hljs-literal\">nullptr</span>)<br>\t&#123;<br>\t\tpd2-&gt;<span class=\"hljs-built_in\">derive02func</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\tp-&gt;<span class=\"hljs-built_in\">func</span>();<span class=\"hljs-comment\">//动态绑定</span><br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>指向结果：调用成功。</p>\n<p><img src=\"https://raw.githubusercontent.com/Yakumo-Sue/PicGo/main/images202308111845822.png\" alt=\"image.png\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clkrobmbf0001u0pkc6e72u5t","tag_id":"clkrx9my1000188pk03r77a6c","_id":"clkrx9my2000388pkeoylfiwh"},{"post_id":"clkrobmbf0001u0pkc6e72u5t","tag_id":"clkrx9osa000488pk90nigter","_id":"clkrx9osa000588pkdy0w46xg"},{"post_id":"clkrobmbf0001u0pkc6e72u5t","tag_id":"clkrx9my0000088pk9qa334re","_id":"clkrx9vjo000688pkblob304d"},{"post_id":"clkrobmbf0001u0pkc6e72u5t","tag_id":"clkrxabij000988pk2ejf91d2","_id":"clkrxabij000a88pkgz8vbqsd"},{"post_id":"clkrobmbf0001u0pkc6e72u5t","tag_id":"clkrxaf45000d88pk4evxcnph","_id":"clkrxaf45000e88pk7qs9aan9"},{"post_id":"clkufs4140000b0pkgkc45jvo","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"clkufs41b0002b0pk2ckdbh6k"},{"post_id":"clkuty8ua0000ncpkgjf774pk","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"clkuty8uh0002ncpk5cxcdh3r"},{"post_id":"clkw6w7mw0000acpk88orduw7","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"clkw6w7n30001acpkgb2xdi0q"},{"post_id":"cll0x5bxe000074pk90nucv1d","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"cll0x5bxo000374pkbk2t0s6x"},{"post_id":"cll0x5bxe000074pk90nucv1d","tag_id":"cll0x5bxl000174pk2cy274lc","_id":"cll0x5bxo000474pkhj8gc9mb"},{"post_id":"cll0x5bxe000074pk90nucv1d","tag_id":"cll0x5bxn000274pk27g8h0ve","_id":"cll0x5bxo000574pk13zsf6co"},{"post_id":"cll3spnt7000124pk8nok985o","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"cll3spnt9000324pk7pzbfypn"},{"post_id":"cll3spnt8000224pk2oyickm4","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"cll3spnta000524pkhdsxc5yc"},{"post_id":"cll3spntb000624pkdnkicj50","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"cll7nktw900001spk22tp8xfr"},{"post_id":"cll3spnt9000424pkdh9r0wml","tag_id":"clkufs41a0001b0pk3lazgbar","_id":"clldg3ll40000h8pkba2z6lc6"}],"Tag":[{"name":"Hexo","_id":"clkrx9my0000088pk9qa334re"},{"name":"Fluid","_id":"clkrx9my1000188pk03r77a6c"},{"name":"Blog","_id":"clkrx9osa000488pk90nigter"},{"name":"Obdidi","_id":"clkrxa9vs000788pke2prhtx5"},{"name":"Obdidian","_id":"clkrxabij000988pk2ejf91d2"},{"name":"Github","_id":"clkrxade8000b88pk1q1k0kg3"},{"name":"Github Pages","_id":"clkrxaf45000d88pk4evxcnph"},{"name":"C++","_id":"clkufs41a0001b0pk3lazgbar"},{"name":"C++11","_id":"cll0x5bxl000174pk2cy274lc"},{"name":"新特性","_id":"cll0x5bxn000274pk27g8h0ve"},{"name":"biology","_id":"cll3sz1yx0001xgpk1eed0odl"}]}}